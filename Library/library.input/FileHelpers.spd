
/*
	Jeebox internals. By Theodore H. Smith...
*/

	
extend String
	function IsOK (|bool|)
		opt norefcounts
		nil checker
		return self != nil  and  self|object| != string.error|object|
	
	function FileThatExists (|string| operation="access",  |File|)
		|| f = .file
		if f.MustExist(operation)
			return f
		
	function FileExists (|bool|)
		|| f = .file
		return f.exists
	
	
	function FileSize (|int64|)
		|| f = .file
		return f.size
	
	
	function MakeEntirePath (|bool|Last=true, |ErrorInt|)
		visible class~file
		|| p = (self, .parent)(last)
		
		for S.Paths in p
			|| err = S.MakeDir|int|
				rz = err
				exit		
	
	
	function PathDir (|string|) // asdir, todir
		if self and .last != '/'
			return self + "/"
		return self
	
	
	function SyntaxAppend (|string| s, |bool|)
		return .write(s)


	Syntax Append (|messageroot!| msg, |bool|)
		cpp_Part WriteMsg
		msg.render(.out)
		return true


	function Sibling (|string| name, |string|)
		return .ReplacePathComponent(-1, Name)
		
	function file.Sibling (|string| name, |file|)
		return super.sibling(name).file
	
	function Components (|[string]|)
		return .TrimSlashes.Split('/')

	function ReplacePathComponent (|int| num, |string| With, |string|)
		|| R = .components
		if (num < 0)
			num += R.length
		
		R[num] = With
		return r.join("/")

//	function RemoveExt (|string| suff, |string|)
//		if self isa suff
//			return .trimext
//		return self
	
	function TrimSlashes (|string|)
		|| trail = .FindTrailingSlashes
		if trail >= self
			return self							// entire path is '/'
		|| Multi = self contains "//"
		if !multi
			return self[0, trail]
			
		|| fs = FastString()
		|| prev = 0
		for i in trail
			|| c = self[i]
			if (c != '/'  or  prev != '/')
				fs <~ c // remove multiple "/"
			prev = c
		return fs
			
	
	helper FindTrailingSlashes (|int|)
		rz = .Length
		while self[rz-1] == '/'
			rz--

	function Resolve (|bool| AllowMissing = false, |string|) 
		cpp_wrapper JB_Str_ResolvePath

	function IsVolume (|bool|)
		if self == "/"
			return true
		|| p = .parent.pathdir
		rz = p == "/Volumes/" or "/vol/" or "/media/" or "/mnt/"

	function TrimExt (|string|)
		return .TrimExtAndPath(false)
	
	function TrimExtKeepPath (|string|)
		disabled "Just use .trimext"
		return .TrimExtAndPath(false)

	function TrimExtAndPath (|bool| RemovePath=true, |string|)
		Description "already does .name, no need for .name.trimext"
		|| N	 = .FindTrailingSlashes
		|| slash = .find('/', n-1, 0) + 1
		|| dot	 = .find('.', n-1, slash)
		dot ?= n
		if !RemovePath
			slash = 0
		return self[slash, dot]
	
	function ReadFile (|int|lim=16MB, |bool|AllowMissing=true, |stringthatwasreadsafely|)
		return .file.readall(lim, AllowMissing)

	function Write (assigns:|string|, |bool|)
		return .file.data(Value)
		
	function Child (|String| cname, |String|)
		if !self
			Return cname
		|| C = (.last == '/')|int|
		C += (cname[] == '/')
		if (C == 1)
			return self+cname
		if (C == 0)
			Return self + "/" + cname
		Return self + cname[1, int.max]

	syntax access (|string| s, |string|)
		return .child(s)

	function Parent (|string|)
		description "Gets the file path's parent'" 
		if self != "/"
			return .TrimSlashes.BeforeLastByte('/', 1)

	function RegularPath (|string|)
		return .AbsolutePath.TrimSlashes
	
	function AbsolutePath (|StringZeroTerminated|)
		cpp_wrapper JB_File_PathFix
		description `Replaces "~/" with the username.
Relative paths take the current working directory.`

	function MakeDir (|ErrorInt|)
		cpp_wrapper JB_Str_MakeDir

	helper TrimLastSub (|Byte| b, |int|)
		// replace with .outbyte(-1,0,b)?
		|| N = .Length
		while (self[N - 1] == b)
			N--
		return N
	
	function TrimFirst (|Byte| b, |string|)
		|| s = .outbyte(b)
		return self[s...]
	
	function AfterByte (|Byte| b, |int| Last=-1, |string|)
		|| Start = .find( b, Last, 0 )
		return self[Start + 1, Last]

	function BeforeLastByte (|Byte| b, |int| fudge=0, |string|)
		|| Last = .TrimLastSub(b)
		|| Start = .find( b, Last, 0 )
		return self[ 0, Start + fudge ]
		
	function AddExt (|string| ext, |string|)
		if !ext
			return self
		if ext[] != '.'
			ext = "." + ext
		return self + ext
		
	function Ext (|string| ext, |string|)
		disabled "Do you mean .addext or .setext?"

	function SetExt (|string| ext, |string|)
		return .trimext.AddExt(ext)
	
	function Ext (|string|)
		|| i = .find( '.', int.max, 0 ) #require
		|| n = .outbyte('/', int.max, 0) ?? .length
		return self[i + 1, n+1]

	function BackToApp (|string|)
		|| s = .TrimSlashes
		|| Final = ".app/Contents/MacOS/" + .name
		if s endswith final
			rz = s[0, 4+(s-final)]
		  else
			rz = self

	function Name (|string|)
		|| Last  = .TrimLastSub('/')
		return .AfterByte('/', Last)
	

	helper String.FindSlash (|int| from, |ind|)
		if from < .length
			rz = .find('/', from)
			if !rz
				rz = .length		
			
//	function CopyFileTo (|String| Dest, |bool| AttrOnly=false, |ErrorInt|)
//		return .file.copyto(dest.file, attronly)
//	
// "/a/b/c" becomes "/a", "/a/b", "/a/b/c"
// "a/b/c"  becomes "a",  "a/b",  "a/b/c"

	iterator Paths
		|| P = .regularpath
		|| i = p.FindSlash(1)

		while i > 0
			yield P[0, i]
			i = p.FindSlash(i+1)




/// ACTUAL FILE STUFF

	operator isa (|string| s, |bool|)
		if self
			return .ext ~= s
		
	function File (|File!|)
		cpp_part AsFile
		if self isa file
			return self
		return .filesub
	
	helper FileSub (|File|)
		nil self
		cpp_Wrapper JB_Str_File
	
	function FileCh (|string| ch, |File|)
		cpp_Part ChildFile
		return self.Child(ch).file
	
	target !minilib {
	function OpenInEditor (|ExitCode|)
		|| p = .AbsolutePath
			return "/usr/bin/open".SilentExecute([p], NIL, nil)
	
	function Reveal (|bool|)
		if self and platform.osx
			|| p = .AbsolutePath
			require p.fileExists
			|| R = ["-R", p]
			if .last == '/'
				r.remove(0)
			"/usr/bin/open".SilentExecute(R)
			return true
	}

	function TypeContains (|string| s, |bool|)
		for field in StringFields( self, ',' )
			if field ~= s
				return true


		
helper @file.OSXMaxCaseWarnings (|&int|)
	cpp_Wrapper JB_File__Compar


function string.ShellPath (|string|)
	return .replaceall(" ", `\ `)


//target !minilib {
//extend file
//	function UploadTo (|string| url, |ExitCode|) // move to the network module
//		return "/usr/bin/curl".silentexecute([
//			"-T"
//			self
//			url
//		])
//	
//	function ZipTo (|string| zip, |errorint|) //zip -r foo.zip foo
//		|| p = .shellpath // sigh. // zip is so bad.
//		|| dir = p.parent
//		|| name = p[dir.length...]
//		rz = "cd $dir; zip  -r  $zip  $name".system
//		
//	function ZipUpload (|string| url, |ExitCode|)
//		require self
//		|| zip = "/tmp/zipupload/${.name}.zip"
//		if .zipto(zip)
//			return zip.file.uploadto(url)
//}


role StringThatWasReadSafely (string)
	linkage
		cpp_part Safe
	false string.error
	syntax cast (|bool|)
		return .isok


datatype FileSizeInt (int64)
	render
		return .strsize(fs)

