

function Print (|string| data)
	cpp_wrapper JB_Str_Print


function PrintLine (|string| data="")
	strprintline(Data)							// to disambiguate vs macro


macro PrintLine
	StrPrintline(_.render) // not self-referential anymore.

	
function StrPrintLine (|string| data)
	cpp_wrapper JB_Str_PrintLine


function PrintLine (|object| o)
	cpp_name JB_Obj_PrintLine
	printline o.render


function ZalgoLine (|string| data)
	printline data


macro ZalgoLine
	Printline _.render


function Print (|object| o)
	cpp_name JB_Obj_Print
	print o.render


function PrintError (|string| data)
	cpp_wrapper JB_Str_PrintError


function byte.IsConso (|bool|)
	return .isletter and !.isvowel


function byte.IsVowel (|bool|)
	|| b = .lowercase
	return (b == 'a' or 'i' or 'e' or 'o' or 'u') 


function int.operatorpc (|int| x, |string|) 
	return (self|float| / x|float|).pc
	

function string.IsFileLike (|bool|)
	|| c = self[0]
	return (c == '/') or ((c == '.' or c == '~') and ((self[1] == '.') or (self[1] == '/')))
	// so... we want to wrap to w... but prefer to wrap at a SPACE or comma
	
function byte.IsTextLine (|bool|)
	 return self == '\n' or '\r'

function int.TabsWidth (|int|)
	return 4-(self & 3)


function String.UTF16To8 (|faststring|fs=nil, |int|BigEndian=1, |string|)
	cpp_wrapper JB_Str_UTF16To8


function String.UTF8 (|string|)
	if !.isbadutf8(0)
		return self
	return .UTF16To8


/*function string.Appender4 (|string| a, |string| b, |string| c=nil, |string|)
	cpp_wrapper JB_Str_Appender4 // if we wanted 2 params just use "+"

function string.Appender7 (|string| a, |string| b, |string| c, |string| d, |string| e=nil, |string| f=nil, |string|)
	cpp_wrapper JB_Str_Appender7
*/ // do later. compiler can use this :)


function string.operatorplus (|cstring| c, |string|)
	if self
		|| tmp = c.temp
		return self + (&tmp)|string|
	return c.str


function cstring.operatorplus (|string| s, |string|)
	if s
		|| tmp = .temp
		return (&tmp)|string| + s
	return .str

struct FakeJBString
	|int| Refcount
	|int| Length
	|&byte| Addr

function cstring.temp (|fakejbstring|)
	rz.refcount = 0
	rz.length = .length
	rz.addr = self|&byte|


function String.ExtractPathAndLine (|&ivec2| LineAndByte, |string|)
	rz = .TrimStart("line ")
	|| tr = rz.trim
	if tr.isint
		|| v = (tr.int|int|, 0)
		*LineAndByte = v
		return ""
	
	|| parts = rz / ':'
	rz = parts[0].trim
	|| v2 = (parts[1].trim.int|int|, parts[2].trim.int|int|) 
	*LineAndByte = v2
	if rz[0] == '~'
		rz = rz.Resolve(fileResolveMode.allowmissing)


helper string.WrapSub (|int| MaxWidth, |bool| IsInline, |int| p, |int|)
	|| i		= p
	|| ParaMax	= 1K
	MaxWidth	= MaxWidth min Paramax
	|| Orig		= MaxWidth
	paramax += p

	while
		|| c = .byte(i, -1)
		if c < 0
			return i
		if c|byte|.IsTextLine
			return i + 1
		if i >= ParaMax or MaxWidth <= 0
			return i
		
		if c == '\t'
			i++
			maxwidth -= (Orig-MaxWidth).TabsWidth
		  elseif isinline
			i++
		  elseif jeebox.cswrapsplit[c]
			i++
			MaxWidth--
		  else									 // so where does the word end?
			|| WordEnd = .find(jeebox.cswrapsplit, i, ParaMax)
				WordEnd += (self[WordEnd] > 32)
			  else
				WordEnd = .length min paramax
			|| MW2 = MaxWidth - .CharCount(i, WordEnd)
			if MW2 < 0
				if i == p
					i = p + MaxWidth
				return i
			MaxWidth = MW2
			i = WordEnd
			continue

	
function faststring.RenderSpeed (|float| seconds,  |int64| BytesIn, |int64| BytesOut, |string| Name)
	|float| scale = 1MB
	|| speed = ""
	|| s2   = seconds
	|| unit = "s"
	if seconds < 0.01
		unit = "ms"
		s2 *= 1000
	s2 = s2.round(100)
	if name
		self <~ Name
		self <~ ": "
	BytesIn.strsize(self)
	if BytesOut 
		self <~ " to "
		Bytesout.strsize(self)
		self <~ " ("
		self <~ ((Bytesout|float| / Bytesin|float|)*100.0).round(10)
		self <~ "%)"

	self <~ " in $s2$unit" 
	|| rate = BytesIn / (scale*seconds)
	unit = "MB"
	if rate >= 1K
		rate /= 1K
		unit = "GB"
	  elseif rate <= 1
		rate *= 1K
		unit = "KB"
	if rate > 0.01
		rate = rate|float|.round(100)
	if seconds
		self <~ "  ($rate$unit/s)"


	
function string.UnPrintable (|int|)
	if .IsBadUTF8
		return -1
	
	for c in self
		ifn (c >= ' ' or c == 9)
			if c.IsTextLine
				return '\n'
			return -2
