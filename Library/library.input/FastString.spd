
/*
	Jeebox internals. By Theodore H. Smith...
*/


class FastString {
	linkage
		wrapper
		cpp_part FS
		stateful

// Fast appends and tools for building data formats

	|int|			Length
	|int|			Reserved
	|&Byte|			ResultPtr
	|uint16|		Indent
	|Byte|			IndentChar
//	|int64|			WrittenLength // invisible
	
/////

	constructor							{ cpp_wrapper JB_FS_Constructor }
	constructor (|int| BufferSize)		{ cpp_wrapper JB_FS_ConstructorSize }
	destructor							{ cpp_wrapper JB_FS_Destructor }

	setter Length (|int|)				{ cpp_wrapper JB_FS_LengthSet }
	setter Reserved (|int|)				{ disabled }
	setter ResultPtr (|int|)			{ disabled }
	
	function AppendLower (|string| data)
		cpp_wrapper JB_FS_AppendLower
	function FreeSize (|int|):	cpp_wrapper JB_FS_FreeSize
	function FreeSize (assigns:|int|, |&byte|) {cpp_wrapper JB_FS_NeedSpare}

	function StreamLength (|int|)
		cpp_wrapper JB_FS_StreamLength

	function Size (|int|)				{ cpp_wrapper JB_FS_Size }
	function Size (assigns:|int|)		{ cpp_wrapper JB_FS_SizeSet }
	function AppendMultiReplace (|string| s, |dictionary of string| m, |ErrorReceiver| Rec=stderr) { cpp_wrapper JB_FS_AppendMultiReplace }
		
	function AppendHex (|int64| Num, |int|RoundTo=2)
		cpp_wrapper JB_FS_AppendHex
	
	function AppendHexData (|string| Data)
		cpp_part AppendHexStr 
		if data
			.appendhexdata(Data.addr, data.length)
	
	function AppendHexData (|&byte| Data, |int| N, |int| Spaces=0)
		cpp_wrapper JB_FS_AppendHexData

	function AppendRange (|String| Data, |int| Start, |int| After=int.max)
		// would be nice if speedie can optimise
		// fs <~ a[b,c]				// into
		// fs.appendrange(a,b,c)
		// perhaps it could do this for all classes? like Syntax AppendRange
		// i guess only faststring needs it though. perhaps other things want string ranges
		// fastbuff or whatever.
		cpp_wrapper JB_FS_AppendRange

	function AppendSection
		disabled "use .AppendRange"

	autogen AppendHex3 (|int| Num)
		cpp_wrapper JB_FS_AppendHex3 // not really needed. remove this later. Only my obj-saver needs this.
	
	function AppendUTF8 (|codepoint| Num)	{ cpp_wrapper JB_FS_AppendUTF8Char }
	function IndentLine						{ cpp_wrapper JB_FS_LineIndent }
	function AppendIndent					{ cpp_wrapper JB_FS_AppendIndent }
	function Flush	(|bool|)				{ cpp_wrapper JB_FS_Flush }
	function Remove (|Byte| b)				{ cpp_wrapper JB_FS_RemoveByte }
	function GetResult (|string|)
		nil self
		cpp_wrapper JB_FS_GetResult
	function GetResult (|object?| other, |string|)
		nil self
		cpp_wrapper JB_FS_SmartResult
	
	function Reserve (|int| N, |&byte|)
		cpp_wrapper JB_FS_WriteAlloc_

	function AppendLInt (|uint64| n)	// remove this, and replace with appendhint
		while n
			self <~ N|byte|
			n >>= 8

	function AppendHInt (|int| n)
		while n >= 128
			.AppendByte(n ||| 128)
			n >>= 7
		.AppendByte(n)
		
	render
		opt norefcounts
		fs <~ self

	syntax Append (|Byte| data, |int| count)
		cpp_wrapper JB_FS_AppendMultiByte

	syntax Append (|[string]| data, |string| sep)
		cpp_part AppendJoin
		opt norefcounts
		self <~ data[]
		|| i = 0
		while 
			|| s = data[++i]
			loop s != nil
			self <~ sep
			self <~ s

	syntax Append (|string| data, |int| count)
		cpp_part AppendMultiStr
		|| needed = data.Length*count
		if .FreeSize < needed
			.FreeSize = needed
		for count
			self <~ data

	function AppendQuotedEscape (|string| s, |byte| Quote = '"')
		self <~ Quote
		.appendescape(s)
		self <~ Quote
	
	function AppendEscape (|string| s)
		.AppendMultiReplace( s, jeebox.EscapeStr )


	module
		function UseAsOutput (|object| other, |FastString|)
			if !other
				return faststring.new
			if other isa FastString
				return other
			if other isa string
				return other.OutputStream
			error (other, "FastString can't use this object.")
		
		function New (|FastString?| other, |FastString|)
			cpp_wrapper JB_FS__FastNew
		
//		function Append (|file| dest, |FastString|)
//			cpp_wrapper JB_FS__FileAppend


	syntax Access (|int| off, |Byte|)
		cpp_wrapper JB_FS_Byte
	
	syntax Access (|int| off, assigns:|Byte|)
		cpp_wrapper JB_FS_ByteSet
	
	function Last (|int| off=0, |int|)
		cpp_wrapper JB_FS_Last
	
	syntax Append (|string?| data)
		cpp_wrapper JB_FS_AppendString
	
	syntax Append (|FastString| fs)
		cpp_part AppendFastString
		inline
		.Syntaxappend(fs|string|)
		
	function AppendByte (|Byte| data)
		cpp_wrapper JB_FS_AppendByte
	
	syntax Append (|Byte| data)
		cpp_part AppendByte2
		inline
		.appendbyte(data)
		
	syntax Append (|vec3| data)
		cpp_part AppendVec3 // shouldn't be necessay, .render(fs) should be called
		opt norefcounts
		real self
		inline
		data.Render(self)
		
	syntax Append (|vec4| data) // same
		cpp_part AppendVec4
		opt norefcounts
		real self
		inline
		data.Render(self)

	function AppendIntegerAsText (|int64| data, |int| PadTo = 1)
		cpp_wrapper JB_FS_AppendIntegerAsText

	function AppendInteger (|int64| data, |int|RoundTo=1)
		disabled "appendintegerastext or appendint?"
	
	function AppendInt (|int| data)
		cpp_Wrapper JB_FS_AppendInteger
			
	function AppendShort (|uint16| data)
		cpp_wrapper JB_FS_AppendShort

	syntax Append (|int64| data)
		inline // disambiguation
		cpp_part AppendInt64
		.AppendIntegerAsText(data, 1)
	
	syntax Append (|uint64| data)
		inline // disambiguation
		cpp_part AppendUInt64
		.AppendIntegerAsText(data, 1)
	
	syntax Append (|uint| data)
		inline // disambiguation
		cpp_part AppendUint
		.AppendIntegerAsText(data, 1)

	syntax Append (|uint16| data)
		inline // disambiguation
		cpp_part AppendUint16
		.AppendIntegerAsText(data, 1)

	syntax Append (|int| data)
		inline // disambiguation
		cpp_part AppendInt32
		.AppendIntegerAsText(data, 1)
		
//	function AppendFile (|File| f, |int64| N=-1, |bool| LeaveOpen=false,  |ErrorInt|)
//		cpp_wrapper JB_FS_AppendFile
	
	syntax cast (|string|)
		inline
		return .getresult

	
	syntax Append (|cstring| Str)
		cpp_wrapper JB_FS_AppendCString

	
	function Field (|string| name, |string| data)
		cpp_part AppendInfo
		if data
			.fieldstart(name)
			.AppendQuotedEscape(data)
	
	function PadTo (|int| n, |byte| b=' ')
		self <~ (b, n-.length)
	
	function FieldStart (|string| name)
		.IndentLine
		if name
			self <~ name
			self <~ ' '

	function FieldEnter (|string| name)
		.fieldstart(name)
		++.indent

	function FieldFloat (|string| name, |Float64| data)
		cpp_part AppendInfoFloat
		if data
			.fieldstart(name)
			self <~ data

	function Field (|string| name, |int64| data)
		cpp_part AppendInfoNum
		if data
			.fieldstart(name)
			self <~ data

	function AppendMemory (|&byte| Str, |int| N)
		cpp_wrapper JB_FS_AppendMem_
	
	function AppendDurr (|Date| D)
		cpp_wrapper JB_FS_AppendDurr

	function AppendLocalTime (|Date| D)
		cpp_wrapper JB_FS_AppendLocalTime

	syntax Append (|Float| F)
		cpp_name JB_FS_AppendFloatAsText
		inline
		self <~ F|Float64|

	syntax Append (|Float64| D)
		cpp_wrapper JB_FS_AppendDoubleAsText0
	
	function AppendDouble (|Float64| D, |int| dp=1, |bool| CanExp=false)
		cpp_wrapper JB_FS_AppendDoubleAsText
	
	function AppendFloat (|float| D, |int| dp=1, |bool| CanExp=false)
		inline
		.AppendDouble(D|Float64|, dp, canexp)
	
	syntax Append (|bool| B)
		cpp_name JB_FS_AppendBool
		inline
		opt norefcounts
		self <~ b.string
	
	function Mark (|int|)
		description "Returns 'The Mark'. This is the-written-to-disk-length + the-length-current in the faststring. If the faststring did not flush anything to disk (maybe it has no file), then .mark == .length"
		cpp_wrapper
	
	macro SyntaxAppend
		_1.render(_0)
		

	syntax Compare (|int| n, |int|)
		inline
		return .streamlength - n
}


extend FastString
	function File (|File|)
		cpp_wrapper JB_FS_File
	
	function File (assigns:|File|)
		cpp_wrapper JB_FS_FileSet

	// use syntax-append instead? "fs <~ (doubles, n)"
	function AppendFloats (|&float| Data, |int| N)
		self <~ '['
		for (i in N)
			self <~ ", "
			start
			self <~ Data[i]
		self <~ ']'

	function AppendDoubles (|&f64| Data, |int| N)
		self <~ '['
		for (i in N)
			self <~ ", "
			start
			self <~ Data[i]
		self <~ ']'

	function AppendInts (|&int| Data, |int| N)
		self <~ '['
		for (i in N)
			self <~ ", "
			start
			self <~ Data[i]
		self <~ ']'

	function AppendInt64s (|&int64| Data, |int| N)
		self <~ '['
		for (i in N)
			self <~ ", "
			start
			self <~ Data[i]
		self <~ ']'


