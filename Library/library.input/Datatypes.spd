

/*
	Jeebox internals. By Theodore H. Smith...
*/

		
datatype int
	default 0

	module
		function Max (|int|)
			return 0x7FFFffff_
		function Min (|int|)
			return 0x80000000_

	operator Avg (|int| n, |int|)
		return (self+n)/2

	operator In (|ivec2| i, |bool|)
		return self >= i.x and self <= i.y
		
	operator Bits (|int| n, |int|)
		return self & n.bits

	operator DTF (|uint| belf, |bool|)
		return self and ((self&belf) == belf)

	operator FTD (|uint| belf, |bool|)
		return self and ((self&belf) == self)

	function AsFloat (|float|)
		|int[1]| abc = {self}
		|| def = (&abc[0])|&float|
		return def[0]

	function IsKnown (|bool|)
		pragma inline
		return (self & (self - 1)) == 0

	function IsPo2 (|bool|)
		pragma inline
		return (self & (self - 1)) == 0

	function Bits (|int|)
		return (1<<self)-1

	function AlignDown (|int| To, |int64|)
		return self - (self mod to) // ???
		
	syntax compare (|string|s, |bool| aware, |int|)
		return self - s.length
	syntax access (|int| bit, |bool|)
		return self&(1<<bit)
	syntax access (|int| bit, assigns:|bool|, |int|)
		|| mask = 1<<bit
		return (self &~ mask) ||| (value|int| << bit) 
	function Clz (|int|)
		cpp_inbuilt __builtin_clz
	

	operator nobits (|int| n, |int|)
		return self &~ ((1<<n)-1)

	operator isa (|uint| n, |bool|)
		return !(self mod n)

	function Wrap (|int| N, |int|)
		if self < 0 // returns -1 if N ==0
			return N-1
		if self >= N
			return 0
		return self


	syntax cast (|bool|)
		return self|bool|
		// don't put a cast to string here.
		// bytes are for string conversion! not integers.

	render
		cpp_part RenderFS
		fs <~ self
	
	function Render (|&byte| Addr, |int| N, |int|)
		cpp_wrapper JB_int_Render
		
	render StrSize
		cpp_part RenderSize
		return self|int64|.strsize(fs_in)

	render (|int| zeros)
		cpp_part RenderZeros
		fs.appendintegerastext(self, zeros)

	
	operator Min (|int| other, |int|)
		if self < other: return self
		return other


	operator AbsMin (|int| other, |int|)
		if .abs < other.abs: return self
		return other


	operator Max (|int| other, |int|)
		if self > other: return self
		return other


	operator XOR (|int| X, |int|)
		return self ^ X

	
	function CountBits (|int|)
		cpp_wrapper JB_Int_CountBits

	function HighestBit (|int|) // highbit 
		disabled "use .log2"

	function Log2 (|int|)
		cpp_wrapper JB_Int_Log2

	function Ctz (|int|)
		cpp_wrapper JB_Int_CTZ
		
	function Tri (|int|)
		return (self*(self+1))/2

	operator ± (|int|i, |int|)
		cpp_part Shrink
		if self > 0
			return (self-i) max 0
		if self < 0
			return (self+i) min 0
	
	
	operator InRange (|int| d, |bool|)
		pragma inline
		if d > 0 // can fail otherwise
			return (self|uint| < d|uint|)


	function IsPow2 (|bool|)
		disabled ".IsPo2"
	
	operator Align (|int| To, |int|)
		|| Missing = (self mod To)
			return self + (To - Missing)
		return self

	
	iterator
		|| i = 0
		while (i < self)
			yield i (i)
			i++

	iterator down
		|| i = seLf - 1
		while (i >= 0)
			yield i (i)
			i--
	
	iterator bit		// Get 1 bit of the original per loop
		|| curr = self|int|
		while curr
			|| Highest = 1 << curr.log2
			yield highest
			curr = curr &~ Highest
	
	
	operator to (|int| other, |IntRange|)
		// for 5 to 10 // this should be inclusive
		return (self, other+1)

	
	operator downto (|int| other, |IntDownRange|)
		rz.From = self
		rz.To = other


datatype SizeInt (int)
	syntax cast (|string|)
		return .strsize


datatype Ind (int) // an INDex. And an INT.
	default -1
	false -1
	syntax cast (|bool|)
		return self >= 0
	function Exists (|bool|)
		return self >= 0


datatype ErrorInt (int) // useful for unix-functions which has 0 == success
	default 0 // defaults to true... unlike everything else?
	false -1
	syntax cast (|bool|)
		return self == 0

	function SignalName (|stringzeroterminated|)
		cpp_wrapper JB_Err_SignalName

	function Name (|stringzeroterminated|)
		cpp_wrapper JB_Err_Name



struct RetroFloat
// for doing pixel-based animations that move smoothly for retro-games
	|float|		Amount
	|float|		Remain
	
	syntax Append (|float| n)
		.Amount += n
	syntax Access (|int|)
		|| A = .Amount // 1.1... every 10th frame returns 2
		|| rem = A.fract + .remain
		if rem >= 1.0
			rem--
			A++
		.remain = rem
		return A|int|


struct IntDownRange   /// :3
	|int| From
	|int| To
	
	iterator
		|| _c = .from
		while (_c >= .To)
			yield _c (_c)
			_c--


struct FloatRange   /// :3
	|Float| From
	|Float| To
	|float| Step
	
	helper float.LoopOK (|float| Final, |float| Dir, |bool|)
		pragma inline
		// could speed this up using copysign one day
		if dir >= 0.0
			return self < final
		return self > final
		
	iterator
		|| _c = .from
		while (_c.LoopOK(.To, .step))
			yield _c (_c)
			_c += .Step


datatype uint
	default 0

	constants
		|uint|
		max = 0xffffFFFF_
		min = 0
	
	function ClearHigh (|int| p8, |uint|)
		self <<= p8
		self >>= p8
		return self
		
	operator isa (|uint| n, |bool|)
		return !(self mod n)

//	function Crc (|byte| b, |uint|)
//		cpp_inbuilt __builtin_ia32_crc32qi // not on arm?
		
	operator rotl (|int| Amount, |uint64|)
		cpp_wrapper JB_u32_RotL
	
	operator rotr (|int| Amount, |uint64|)
		cpp_wrapper JB_u32_RotR

	operator bits (|uint| n, |uint|)
		return self & ((1<<n)-1)

	operator nobits (|uint| n, |uint|)
		return self &~ ((1<<n)-1)

	function IsPo2 (|bool|)
		pragma inline // as above
		return (self & (self - 1)) == 0
	
	function IsPow2 (|bool|)
		disabled ".IsPo2"
	
	function IsKnown (|bool|)
		return .ispo2

	function Hash (|uint|)
		cpp_wrapper JB_uint_hash
	function Unhash (|uint|)
		cpp_wrapper JB_uint_unhash 
	
	function SwapEndian (|uint|)
		cpp_Wrapper (__builtin_bswap32)
	
	operator tdt (|uint| belf, |bool|)
		|| xelf = self xor belf
		return (self&xelf) and (belf&xelf) 

	operator dtf (|uint| belf, |bool|)
		return self and ((self&belf) == belf)

	operator max (|uint| other, |uint|)
		if (self > other) { return self }
		return other
	

	syntax cast (|bool|)
		return self|bool|

	operator rol (|uint| bits, |uint|)
		bits &= 31
		return ((self << bits) ||| (self >> (32 - bits)))

	operator ror (|uint| bits, |uint|)
		bits &= 31
		return ((self >> bits) ||| (self << (32 - bits)))
		
		
	iterator
		|uint| i = 0
		while i < self
			yield i
			i++
	
	 
	iterator flags
		|| curr = self
		while curr
			|| value = curr & -curr|int|
			yield value
			curr = curr &~ value



datatype U24_8 (uint)
	function Big (|uint|)
		return self >> 8
	function Big (assigns:|uint| v, |U24_8|)
		return (self & 255) ||| (v << 8)
	function Small (|uint|)
		return self & 255
	function Small (assigns:|uint| v, |U24_8|)
		return (self & ~255) ||| (v & 255)


datatype _void
	linkage
		cpp_class void
		noauto				// dont want them to see this.
	size 0
	syntax cast (|bool|)
		disabled "Can't cast void to a bool."




datatype uint16
	linkage
		cpp_class u16

	default 0

	constants
		|uint16|
		max = 0xffff_
		min = 0

	syntax cast (|bool|)
		return self|bool|


datatype int16
	default 0
	
	linkage 
		cpp_class s16

	constants
		|int16|
		max = 32767
		min = -32K

	syntax cast (|bool|)
		return self|bool|



struct uint24
	|byte[3]| Data
	syntax cast	(|uint|)
		return .data[2] ||| .data[1]<<8 ||| .data[0]<<16

function int.SyntaxCast (|uint24|)
	cpp_part U24
	rz.data[0] = self>>16
	rz.data[1] = self>> 8
	rz.data[2] = self



datatype float
	linkage 
		cpp_part f
	default 0.0
		
	module
		function Max (|float|)
			cpp_wrapper JB_f__max
		function Min (|float|)
			return -.max
		function Nan (|float|)
			cpp_wrapper JB_f__nan
	
	render
		fs <~ self

	render PC // operator percent, operator pc 
		if !self
			fs <~ "0"
		  else
			self = (self * 1000.0).floor*0.1
			if !self
				fs <~ "<0.1"
			  else
				fs <~ self
		fs <~ "%"


	syntax cast (|bool|)
		cpp_part AsBool
		return self|bool|
	
	function Floor (|float|)
		cpp_wrapper (floorf)

	function AsInt (|int|)
		cpp_wrapper JB_f_AsInt
	
	function Round (|float|)
		cpp_wrapper (roundf)

	function Date (|date|)
		return (self * 64.0K)|date|
	
	function DecimalPlaces (|int| to=2, |float|)
		cpp_Part RoundTo
		|| v = (10 pow to)|float|
		return (self * v).Round / v
//		std::ceil(value * 100.0) / 100.0

	function SinR (|float|)
		return (self * math.iTau).sin

	function CosR (|float|)
		return (self * math.iTau).cos

	function Length (|float|) // for consistancy
		return .abs

	function Abs (|float|)
		cpp_wrapper (fabsf)
	
	function Sqrt (|float|)
		cpp_wrapper (sqrtf)
	
	function RSqrt (|float|)
		return 1.0 / .sqrt
	
	function Fract (|float|)
		return self - .floor
	
	function Exp (|float|)
		cpp_wrapper (expf)
	
	function Ceil (|float|)
		rz = .floor
		if rz != rz
			rz++

	helper IntegerToMod2 (|float|)
		return (self*0.5).Fract*2.0
		
	operator avg (|float| f, |float|)
		return (f + self) * 0.5
	
	function Bounce (|float|)
		|| f = .fract
		if self|int| isa 2
			return f
		return 1.0-f
	
	operator IsNear (|float|other, |bool|)
		disabled "what usse this even?"
		return (self - other).abs < 0.0001 // seems close enough?
	
	function Mix (|float| y, |float| a, |float|)
		cpp_part FloatMix
		return self * (1.0 - a) + (y * a)

	function SmoothStep (|float|)
		|| x = .clamp-0.5
		return x * x * (3.0 - 2.0 * x)

	operator max (|float| other, |float|)
		cpp_wrapper (fmaxf)

	operator min (|float| other, |float|)
		cpp_wrapper (fminf)

	operator pow (|float| other, |float|)
		cpp_wrapper (powf)
			
	operator ↑↑ (|int| n, |float|)
		rz = self
		for n
			rz = self pow rz

	function vec2.operatorby (|float| step,  |FloatRange|)
		rz.From = .x
		rz.To = .y
		rz.step = step
	
	operator to (|float| To, |floatrange|)
		rz.from = self
		rz.to = to
		rz.step = 1.0

	iterator
		|| i = 0.0
		while (i < self)
			yield i (i)
			i++



datatype f64
	linkage
		cpp_class double
		cpp_part dbl
	
	default 0.0

	syntax cast (|bool|)
		return self|bool|
	
	function AsInt (|int64|)
		|f64[1]| abc = {self}
		|| def = (&abc[0])|&int64|
		return def[0]

	function Floor (|f64|)
		cpp_wrapper (floor)
	
		
	function Fract (|f64|)
		return self - .floor
	
	operator pow (|f64| other, |f64|)
		cpp_wrapper (pow)

	function Abs (|f64|)
		cpp_wrapper (fabs)

	operator max (|f64| other, |f64|)
		cpp_wrapper (fmax)

	operator min (|f64| other, |f64|)
		cpp_wrapper (fmin)

	render (|int|dp=6)
		fs.appenddouble(self, dp, true)

	render RenderFloat
		fs.appenddouble(self, 6, false, true)

	function Date (|date|)
		return (self * 64.0K)|date|


datatype hfloat
	processas float
	default 0.0
	
	linkage
		cpp_class __fp16
		cpp_part f16



datatype int64
	default 0

	constants
		max = 0x7FFFffffFFFFffff_
		min = max+1

	syntax cast (|bool|)
		return self|bool|

	render
		fs <~ self

	function AlignUp (|int64| To, |int64|)
		return self + (-self|uint64| mod to) // ???

	operator InRange (|int64| d, |bool|)
		pragma inline
		return (self|uint64| < d|uint64|)

	operator isa (|uint| n, |bool|)
		return !(self mod n)

	operator max (|int64| d, |int64|)
		if d > self
			return d
		return self
	operator min (|int64| d, |int64|)
		if d < self
			return d
		return self
		
	function Abs (|int64|)
		return (-self,self)(self < 0)

	operator rotl (|int| Amount, |int64|)
		return (self|uint64|) rotl amount

	operator rotr (|int| Amount, |int64|)
		return (self|uint64|) rotr amount

	function Log2 (|int64|) // highestbit, highbit
		return (self|uint64|).log2
	
	function Lowest (|int|)
		return .lowestbit.log2
		
	function Highest (|int|)
		return (self|uint64|).log2

	function LowestBit (|uint64|)
		return self & -self

	operator bits (|int64| n, |int|)
		|int64| one = 1
		return self & ((one<<n)-one)

	operator nobits (|int64| n, |int|)
		|int64| one = 1
		return self & ((one<<n)-one)

	function AsFloat (|f64|)
		|int64[1]| abc = {self}
		|| def = (&abc[0])|&f64|
		return def[0]
	
	render Hex
		fs.appendhex(self)

	helper RenderSizePart (|faststring| fs, |int| Size, |string| Suff)
		|| f = (self|float|/size|float|).DecimalPlaces(1)
		fs <~ f|int|
		if f < 120.0
			|| frac = (f.fract*10.0)|int|
			fs <~ "."
			fs <~ frac
		fs <~ suff
		
	render StrSize
		if self <= 512
			fs <~ self
		  elseif self <= 900KB
			.RenderSizePart(fs, 1KB, "KB")
		  elseif self < 900MB
			.RenderSizePart(fs, 1MB, "MB")
		  elseif self < 900GB
			.RenderSizePart(fs, 1GB, "GB")
		  else
			.RenderSizePart(fs, 1TB, "TB")
	
	
	function IsPo2 (|bool|)
		pragma inline // as above
		return (self & (self - 1)) == 0
	
	function IsPow2 (|bool|)
		disabled ".IsPo2"

	iterator
		|int64| i = 0
		while (i < self)
			yield i (i)
			i++



function _logictest (|uint64| a, |uint64| b, |uint|)
	|| pa = a&~b
	|| pb = b&~a // purely...
	|| ab = a&b
	return (pa.exists << 2) ||| (ab.exists << 1) ||| (pb.exists << 0)



datatype uint64
	default 0

	constants
		|uint64|
		max = -1
	
	operator rotl (|int| Amount, |uint64|)
		cpp_wrapper JB_u64_RotL
	
	operator rotr (|int| Amount, |uint64|)
		cpp_wrapper JB_u64_RotR

	operator isa (|uint| n, |bool|)
		return !(self mod n)
	
	function Exists (|uint|)
		return (self|bool|)|uint|
	
	function High (|uint|)
		return self >> 32
	
	function Low (|uint|)
		return self
	
	syntax cast (|bool|)
		return self|bool|
		
	operator max (|uint64| s, |uint64|)
		if self > s: return self
		return s
	
		
	operator min (|uint64| s, |uint64|)
		if self < s: return self
		return s
	
	function Log2 (|uint64|) // highestbit, highbit
		cpp_wrapper JB_u64_Log2

	function CountBits (|int|)
		cpp_Wrapper (__builtin_popcountll)

	operator rol (|uint| bits, |uint64|)
		bits &= 63
		return ((self << bits) ||| (self >> (64 - bits)))

	operator ror (|uint| bits, |uint64|)
		bits &= 63
		return ((self >> bits) ||| (self << (64 - bits)))

	operator dtf (|uint64| belf, |bool|)
		|| xelf = self xor belf
		return (self&belf) and (!(xelf&belf))
		
	operator inside (|uint64| b, |bool|)
		return _logictest(self, b) == 0b011

	operator contains (|uint64| b, |bool|)
		return _logictest(self, b) == 0b110

	
	operator tdt (|uint64| belf, |bool|)
		|| xelf = self xor belf
		return (self&xelf) and (belf&xelf) 

	function IsPo2 (|bool|)
		pragma inline // as above
		return (self & (SElf - 1)) == 0
	
	function IsPow2 (|bool|)
		disabled ".IsPo2"

//	operator crc (|uint64| Other, |uint64|)
//		cpp_wrapper _mm_crc32_u64 // not on arm
	
	function IsKnown (|bool|)
		return .ispo2
	
	iterator bits				// Get 1 bit of the original per loop
		|| curr = self|uint64|
		while curr
			|uint64| Highest = 1 << curr.log2
			yield highest
			curr = curr &~ Highest
	
	iterator flags
		|| curr = self|uint64|
		while curr
			|| value = curr.lowestbit
			yield value
			curr = curr &~ value

	iterator
		|| i = 0
		while (i < self)
			yield i (i)
			i++



datatype MaybeBool (byte) // could just put these on int? do we need a whole new type?
	linkage
		numeric false
	default 8|MaybeBool|
	function Default (|bool|)
		return self|byte|&1
	function IsKnown (|bool|)
		return self|byte| <= 1
	function IsTrue (|bool|)
		return self|byte| == 1
	function IsFalse (|bool|)
		return self|byte| == 0
	syntax cast (|bool|)
		disabled "Do you mean .istrue? Maybebools can have an unknown state."
	module
		function New (|bool| Default, |Maybebool|)
			return (8+default)|Maybebool|
	
	


datatype bool
	size 1
	default false
	
	operator bitor (|bool| b, |bool|)
		return self or b
	
	operator sign (|int| i, |int|)
		return (i, -i)(self)
	function Bool (|int| i, |int|)
		disabled "use operator sign"
	function Sign
		disabled "use .dir"
	
	syntax cast (|maybebool|)
		return self|maybebool|

	function Set (|int| old, |int| flag, |int|)
		cpp_part setflag
		if self
			return old ||| flag
		return old &~ flag
		
	function Dir (|int|)
		return (self|int|<<1)-1
	
	function Render (|string|)
		cpp_part Render0
		return ("true", "false")(self)

	function Render (|faststring| fs_in, |string|)
		opt norefcounts
		if !fs_in
			return .render
		fs_in <~ .render
	
	iterator
		|| num = 1
		while (num >= 0)
			yield (num == 1)
			num--


datatype MoveCode (byte)
	Flags
		|movecode| 
		Right
		Left
		Up
		Down
		Forward
		Backward
		Open
		Close
		Positive = (Right + Up   + Forward  + Open)
		Negative = (Left  + Down + Backward + Close)
		Top    = Up
		Bottom = Down
		Front  = Forward
		Back   = Backward
		Vertical    = Up + Down
		Horizontal  = Right + Left
		MiddleLeft  = Left + Vertical
		MiddleRight = Right + Vertical
		All = 63
		Center = 63

	syntax is (|movecode| m, |bool|)
		return (self & m) == m
	
	syntax call (|bool| same, |movecode|)
		if same: return self
		return .flip

	function field (|int|)
		if self & Vertical
			rz = 1
		if self & Positive
			rz |= 2
	
	function flip (|movecode|)
		|| m = 0b01010101
		|| m2 = m << 1
		return ((self & m) << 1) ||| ((self & m2) >> 1)
