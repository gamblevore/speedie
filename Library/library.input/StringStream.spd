

class StringStream
	|FastBuff|	Data
	|file|		File
	|int|		Length
	|int|		ChunkSize
	|int| 		StartFrom
	|bool| 		_IsEnded
	|object--|	UserObj // for jbin

	linkage:cpp_Part SS
	
	Flags
		JbinMode = 1
	
	constructor (|string| d)
		d := ""
		.data.readfrom = d
		.length = d.length
	constructor (|file| file, |int| ChunkSize=4MB)
		cpp_part ConstructorStream
		file.close
		.file = file
		.ChunkSize = chunksize
		.length = file.size
		.ReadChunk

	function ReadAll (|string|)
		return .str(.length - .startfrom)
	
	helper ReadChunk (|bool|)
		.data.readfrom = .file.read(.chunksize)		// for now
		if .data.readfrom.length < .chunksize
			._isended = true // not technically true for pipes... but this will do for now!
		return .data.readfrom
	
	function Skip (|int| p = 1)
		if p < 0 // end
			.position = .length
		  else
			.position += p
	syntax cast (|bool|)
		require (self != nil)
		if .data has 1
			return true
		return .NextChunk
	
	helper NextChunk (|bool|)
		opt norefcounts
		if .file
			.startfrom += .data.size
			if .ReadChunk
				return true
			.file = nil // why not
		
		
	function Byte (|byte|)
		ifn .data has 1
			require .NextChunk
		return .data.byte
		
	syntax Compare (|int| n, |bool| aware, |int|)
		return .length - n
	
	function Position (|int64|)
		return .data.position + .StartFrom
	setter Position (|int64|)
		.data.position = value - .StartFrom
	function bint (|int|n=4, |int64|)
		for n
			rz <<= 8
			rz |= .byte
		
	function bint0 (|int|n=3, |int64|)
		// 0-3 works better for bit-math
		return .bint(n+1)

	function lint0 (|int|n=3, |int64|)
		for i in n+1
			rz |= .byte << i << 3

	function CString (|string|)
		// this function doesn't work with streaming...
		// its not ideal. but none of my code needs this streamed!
		// they just read the entire file in. So I don't need it!
		|| p = .position
		|| zpos = .data.find(0|byte|, p, int.max)
			.position = zpos+1
			return .data[p, zpos] // don't call .section, seeing as its not streaming anyhow
	
	function upto (|int| end, |int|)
		return end - .position
	function uint (|int| size, |int| mult=256, |uint64|)
		for size
			rz *= mult
			rz += .Byte
	function Trim (|int| n, |string|)
		return .str(n).trim
	function Remaining (|int|)
		return .length - .position
	
	function StrNoAdvance (|int| n, |int|skip=0, |string|)
		|| p = .Position
		rz = .str(n)
		.Position = p
	
	function IsEnded (|bool|)
		if ._isended
			return true
		if .data.Remaining <= 0
			if !.file
				return true
			if .length <= .startfrom
				return true
				
	function Str (|int| n, |int|skip=0, |string|)
		ifn n > 0 and skip < n
			return ""
		if (.data has n) or (._IsEnded)
			(n min= .Remaining)
			|| pos = .data.position		// no need use the .startfrom
			.data.position = n + pos
			return .data.syntaxaccess(pos + skip, .data.position)

		|| Remaining = n - skip
		|| r = string(Remaining) #require
		|| Dest = r.address
		while
			|| Copied = .data.CopyTo(dest, .data.Remaining min Remaining)
			Remaining -= Copied
			dest += copied
			loop Remaining > 0
			if !.NextChunk
				 r = r[0, r.length - remaining].copy
				 exit
		return r
	
	function utf8 (|int|n, |int|skip=0, |string|)
		return  .str(n,skip).utf16to8(2)
	function test (|string| Header, |bool|)
		if !Header
			return true
		return Header == .str(Header.length)
	function UInt16 (|uint16|)
		disabled "use .uint(2)"

	syntax expect ( |string| Error )
		opt norefcounts
		if !error
			if (.file)	
				error = "Error decoding file: "
			  else
				error = "Error decoding data."
				
		stderr.newError(nil, error, .file)


	
function string.Stream (|string|T="", |StringStream|)
	rz = stringstream(self)
	if !rz.test(t)
		rz = nil

