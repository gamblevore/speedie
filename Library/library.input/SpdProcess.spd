
target !minilib {

class SpdProcess (Process)
	linkage
		cpp_part Proc
	description "SpdProcess is a process, that happens to be made by Speedie. Speedie processes come with a pico (message-passer), so they can be talked to, if you want.

We also make it easier to send and receive message objects, instead of pure strings.

SpdProcess handles your subprocess dying, or needing resetting.

The DebugName is normally a file-path, but might not be, for example you are in fact running a function in a thread and using that function as a subprocess.

(This is possible if the function is an entire speedie program, complete with 'main', loaded from a library.)
"
	contains SpdProcess
	|jbin|						Writer
	|?ThreadAsProcess|			SubProcess
	|int| 						DeathLimit
	|bool|						AlreadyWarnedDied

	constructor	(|string| path, |?ThreadAsProcess| fn, |pico| pico, |[string]| params=nil,  |ProcessMode| Mode=ProcessMode.stderrpassthru)
		mode |= ProcessMode.MsgPassing
		super.constructor(path, mode, params, pico)
		.deathlimit = 12
		.SubProcess = fn
		.writer = FastString()

			
	destructor
		pico.destroy(.pico, "destructor")
			
	function CommsOpen (|bool|)
		if self
			return .pico.MessageStatus == 0

	helper Alive (|bool|)
		disabled "use .CommsOpen"
		// todo: why isn't this just .CommsOpen? 
//		if self != nil
//			rz = (.ChildAlive, .ParentAlive)(.isParent)
	
	helper ParentAlive (|bool|)
		return app.ParentID > 1

	helper ChildAlive (|bool|)
		if .SubProcess
			return .CommsOpen
		return .status.isrunning


	syntax append (|string| str, |bool|)
		cpp_Part SendStr
		return self <~ @sstr.msg(str)


	syntax append (|message| msg, |bool|)
		cpp_part Send 
		opt norefcounts			
		if .status == -2
			.start
		if .pico.MessageStatus == 0
			msg.RenderJbin(.writer)
			.pico <~ .writer

 
	function Get (|float| T=0, |message|)
		opt norefcounts
		if self
			if .status == -2
				.start
			|| str = .pico.get(T)
				rz = str.parse
	

	function LastSend (|date|)
		|| p = .pico
		return p.config.lastsend
	
	
	function TimeWaitingForReply (|date|)
		|| c = .pico.config
		|| last = c.lastsend
		if c.lastread < last
			return last.ago

	function process.DiedCount (|int|)
		return .pico.config.deathcount
		

	function CanActivate (|bool|)
		if !.Deathlimit or .Diedcount < .Deathlimit
			.alreadywarneddied = false
			return true
		if !.AlreadyWarnedDied
			.AlreadyWarnedDied = true
			error (.path, "Too many disconnections, blocking reconnection.")
	
	
	helper Kill
		disabled "Explain why"


	syntax expect (|string| err)
		cpp_part Fail
		if .CommsOpen
			printline err
			errorreceiver.NewError(nil, err, .path)
		.Disconnect(err)


	function Disconnect (|string| why="")
		.pico.close(why.cstr)

	
	function SpawnAsChild (|bool|)
		if !.pico.isok
			require pico.replace(.pico)
		return .Start.successful


	function TimedOut (|date| Durr, |bool|)
		if (.TimeWaitingForReply > durr)
			error (self, "child timed out.")
			return true
	
	
	function process.IsParent (|bool|)
		return .pico.config.IsParent
	
	
	function IsOpen (|bool|)
		nil checker // shouldn't be necessary
		return .CommsOpen and .status.isrunning
	
	
	function ActivateChild (|bool|)
		if .isopen
			return true
		.Kill(0)
		if .CanActivate
			expect (.path) (self, "Can't re-activate process without a path.")
			return .SpawnAsChild


	iterator
		while .pico.Canget
			|| msg = .get(10.0)
			if !msg
				continue
			yield msg


	module
		|bool|		 CheckedParent
		|SpdProcess| _Parent
		
		function pico.UseAsParent (|spdprocess|)
			if !app.IsThreadedAsLib
				require .CompleteExec
			|| p = SpdProcess("", nil, self)
			SpdProcess._parent = p
			return p
		
		function app.Parent (|bool| Expect=false, |spdprocess|)
			opt norefcounts
			if spdprocess.CheckedParent
				return spdprocess._parent
			spdprocess.CheckedParent = true
			if pico.HasParentSocket
				|| comms = pico.new
					return comms.UseAsParent
			if expect
				error "Parent lost connection"


		helper CreateArgs (|string| path, |[string]!| Args, |&cstring|)
			cpp_wrapper


		function string.Spawn (|string| Name, |[string]| Params=nil, |spdprocess|)
			return SpdProcess.Spawn(self, name, params)		
		
		
		function Spawn (|string| app_path, |string| Name, |[string]| params=[], |ProcessMode| Mode=ProcessMode.CaptureAll, |SpdProcess|)
			require app_path.file.mustexist
			|| pico = pico.new(name)
				rz = SpdProcess(app_path, nil, pico, params, Mode)
				if !rz.SpawnAsChild()
					rz = nil


		function SpawnFork (|ProcessMode| Mode=ProcessMode.CaptureAll, |SpdProcess|)
			disabled "use pico properly"
//			|| p = pico.new$
//			|| id = p.spawnfork
//			if id < 0
//				pico.destroy(p, "fork failed")
//				return nil
//
//			if id == 0 // we are child
//				id = app.parentid
//				mode = ProcessMode.PassThru
//			rz = spdprocess(app.path, nil, p, nil, mode)
//			rz.pid = id

	
	prototype ThreadAsProcess (|&pico| Comms, |int64| Data, |&cstring| args, |bool|)
		function Spawn (|string| ThreadName,  |[string]!| R = [],  |SpdProcess|)
			description `This is meant to run a "main-function" from a lib, as if it were a subprocess. Its usually a wrapper around main(). Just needed this to debug speedie from within Perry.`
			
			|| c_args = SpdProcess.CreateArgs("", r)
			|| pico_fn = pico.new(threadname)
				|| proc = SpdProcess(threadname, self, pico_fn, r)
				if proc.pico.SpawnThread(self|picothreadfn|, 7, c_args)
					return proc
			// its the called-threads responsibility to free the std-args received. Or not!
			// at least we don't crash this way.
			memory.free(c_args)



prototype Thread (|pico| Comms, |uint16| Data, |&nil| Argument, |bool|)
	function Spawn (|pico| Comms, |uint16| Data, |&nil| Argument,  |int| BuffBits=0, |&pico|)
		description "Just a wrapper around pico.thread" 
		|| name = (&comms.config.name[0])|cstring|
		|| pico_out = pico.new(name.wrap, -1)
			if BuffBits
				pico_out.config.Bits = BuffBits
			if comms.SpawnThread(self|picothreadfn|, Data, Argument|&cstring|)
				return pico_out
			pico_out.Close("")


prototype SpdDeathActionFn

}

