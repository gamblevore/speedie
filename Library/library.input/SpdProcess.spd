
target !minilib {

class SpdProcess (UnixProcess)
	linkage
		cpp_part Proc
	description "SpdProcess is a process, that happens to be made by Speedie. Speedie processes come with a pico (message-passer), so they can be talked to, if you want.

We also make it easier to send and receive message objects, instead of pure strings.

SpdProcess handles your subprocess dying, or needing resetting.

The DebugName is normally a file-path, but might not be, for example you are in fact running a function in a thread and using that function as a subprocess.

(This is possible if the function is an entire speedie program, complete with 'main', loaded from a library.)
"
	contains SpdProcess
	|jbin|						Writer
	|?spdprocess.Thread|		SubProcess
	|int| 						DeathLimit
	|bool|						AlreadyWarnedDied

	constructor	(|string| path, |?spdprocess.Thread| fn, |pico| pico, |[string]| params=nil,  |ProcessMode| Mode=ProcessMode.stderrpassthru)
		mode |= ProcessMode.MsgPassing
		super.constructor(path, mode, params, pico)
		.deathlimit = 12
		.SubProcess = fn
		.writer = FastString()

			
	destructor
		pico.destroy(.pico, "destructor")
			
	function CommsOpen (|bool|)
		if self
			return .pico.MessageStatus == 0

	libinternal Alive (|bool|)
		disabled "use .CommsOpen"
		// todo: why isn't this just .CommsOpen? 
//		if self != nil
//			rz = (.ChildAlive, .ParentAlive)(.isParent)
	
	libinternal ParentAlive (|bool|)
		return app.ParentID > 1

	libinternal ChildAlive (|bool|)
		if .SubProcess
			return .CommsOpen
		return .status.isrunning


	syntax append (|string| str, |bool|)
		cpp_Part SendStr
		return self <~ @sstr.msg(str)


	syntax append (|message| msg, |bool|)
		cpp_part Send 
		opt norefcounts			
		if .status.NotStarted
			.start
		if .pico.MessageStatus == 0
			msg.RenderJbin(.writer)
			.pico <~ .writer|string|
			.writer.length = 0

 
	function Get (|float| T=0, |message|)
		// this should take a Date. seems easier?
		// pico could use dates internally... at least for this?
		// that, or we do the conversion in here.
		opt norefcounts
		if self
			if .status.NotStarted
				.start
			|| str = .pico.get(T)
				rz = str.parse
	

	function LastSend (|date|)
		|| p = .pico
		return p.config.lastsend
	
	
	function TimeWaitingForReply (|date|)
		|| c = .pico.config
		|| last = c.lastsend
		if c.lastread < last
			return last.ago


	function CanActivate (|bool|)
		if !.Deathlimit or .Diedcount < .Deathlimit
			.alreadywarneddied = false
			return true
		if !.AlreadyWarnedDied
			.AlreadyWarnedDied = true
			error (.path, "Too many disconnections, blocking reconnection.")
	
	
	libinternal Kill
		disabled "Explain why"


	syntax expect (|string| err)
		cpp_part Fail
		if .CommsOpen
			printline err
			errorreceiver.NewError(nil, err, .path)
		.Disconnect(err)


	function Disconnect (|string| why="")
		.pico.close(why.cstr)

	
	function SpawnAsChild (|bool|)
		if !.pico.isok
			require pico.replace(.pico)
		return .Start.successful


	function TimedOut (|date| Durr, |bool|)
		if (.TimeWaitingForReply > durr)
			error (self, "child timed out.")
			return true
	
		
	function IsOpen (|bool|)
		nil checker // shouldn't be necessary
		return .CommsOpen and .status.isrunning
	
	
	function ActivateChild (|bool|)
		if .isopen
			return true
		.Kill(0)
		if .CanActivate
			expect (.path) (self, "Can't re-activate process without a path.")
			return .SpawnAsChild


	iterator
		while .pico.Canget
			|| msg = .get(10.0)
			if !msg
				continue
			yield msg


	module
		|bool|		 CheckedParent
		|SpdProcess| _Parent
		
		function pico.UseAsParent (|spdprocess?|)
			if !app.IsThreadedAsLib
				require .CompleteExec
			|| p = SpdProcess("", nil, self)
			SpdProcess._parent = p
			return p
		
		function app.Parent (|bool| Expect=false, |spdprocess?|)
			opt norefcounts
			if spdprocess.CheckedParent
				return spdprocess._parent
			spdprocess.CheckedParent = true
			if pico.HasParentSocket
				|| comms = pico.new
					return comms.UseAsParent
			if expect
				error "Parent lost connection"


		libinternal CreateArgs (|string| path, |[string]!| Args, |&cstring|)
			cpp_wrapper


		function string.Spawn (|string| Name, |[string]| Params=nil, |spdprocess|)
			return SpdProcess.Spawn(self, params, name)		
		
		
		function Spawn (|string| app_path, |[string]| params=[], |ProcessMode| Mode=ProcessMode.CaptureAll, |string| Name, |SpdProcess|)
			require app_path.file.mustexist
			|| pico = pico.new(name)
				rz = SpdProcess(app_path, nil, pico, params, Mode)
				if !rz.SpawnAsChild
					rz = nil


		function SpawnFork (|ProcessMode| Mode=ProcessMode.CaptureAll, |SpdProcess|)
			disabled "This function needs rework. Feel free to fix it"
//			|| p = pico.new$
//			|| id = p.spawnfork
//			if id < 0
//				pico.destroy(p, "fork failed")
//				return nil
//
//			if id == 0 // we are child
//				id = app.parentid
//				mode = ProcessMode.PassThru
//			rz = spdprocess(app.path, nil, p, nil, mode)
//			rz.pid = id

	
	prototype Thread (|&pico| Comms, |int64| Data, |&cstring| args, |bool|)
		function Spawn (|string| ThreadName,  |[string]!| R = [],  |SpdProcess|)
			description `This is meant to run a "main-function" from a lib, as if it were a subprocess. Its usually a wrapper around main(). Just needed this to debug speedie from within Perry.`
			
			|| c_args = SpdProcess.CreateArgs("", r)
			|| pico_fn = pico.new(threadname)
				|| proc = SpdProcess(threadname, self, pico_fn, r)
				if proc.pico.SpawnThread(self|picothreadfn|, 7, c_args)
					return proc
			// its the called-threads responsibility to free the std-args received. Or not!
			// at least we don't crash this way.
			memory.free(c_args)



prototype SpdDeathActionFn

}

