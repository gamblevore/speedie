
target !minilib {

class SpdProcess (Process)
	linkage
		cpp_part Proc
	description "SpdProcess is a process, that happens to be made by Speedie. Speedie processes come with a pico (message-passer), so they can be talked to, if you want.

We also make it easier to send and receive message objects, instead of pure strings.

SpdProcess handles your subprocess dying, or needing resetting.

The DebugName is normally a file-path, but might not be, for example you are in fact running a function in a thread and using that function as a subprocess.

(This is possible if the function is an entire speedie program, complete with 'main', loaded from a library.)
"
	contains SpdProcess
	|jbin|						Writer
	|?ThreadAsProcess|			SubProcess
	|int| 						DeathLimit
	|bool|						AlreadyWarnedDied

	constructor	(|string| path, |?ThreadAsProcess| fn, |pico| pico, |[string]| params=nil,  |ProcessMode| Mode=ProcessMode.stderrpassthru)
		super.constructor(path, mode, params, pico)
		
		.deathlimit = 12
		//.IsParent = path != "" or fn != nil
		.SubProcess = fn
		.writer = FastString()

			
	destructor
		pico.destroy(.pico, "destructor")
			
	function CommsOpen (|bool|)
		if self
			return .pico.MessageStatus == 0

	helper Alive (|bool|)
		// todo: why isn't this just .CommsOpen? 
		if self != nil
			rz = (.ChildAlive, .ParentAlive)(.isParent)
	
	helper ParentAlive (|bool|)
		return app.ParentID > 1

	helper ChildAlive (|bool|)
		if .SubProcess
			return .CommsOpen
		return .status.isrunning


	syntax append (|string| str, |bool|)
		cpp_Part SendStr
		return self <~ @sstr.msg(str)


	syntax append (|message| msg, |bool|)
		cpp_part Send 
		opt norefcounts			
		if .status == -2
			.start_
		if .pico.MessageStatus == 0
			msg.RenderJbin(.writer)
			.pico <~ .writer

 
	function Get (|float| T=0, |message|)
		opt norefcounts
		if self
			if .status == -2
				.start_
			|| str = .pico.get(T)
				rz = str.parse
	

	function LastSend (|date|)
		|| p = .pico
		return p.config.lastsend
	
	
	function TimeWaitingForReply (|date|)
		|| c = .pico.config
		|| last = c.lastsend
		if c.lastread < last
			return last.ago

	function process.DiedCount (|int|)
		return .pico.config.deathcount
		
	helper HandleDied 
		|| Bad = !.Status.crashed
		.Disconnect(.status.name) // removes us from the check-list


	function CanActivate (|bool|)
		if !.Deathlimit or .Diedcount < .Deathlimit
			.alreadywarneddied = false
			return true
		if !.AlreadyWarnedDied
			.AlreadyWarnedDied = true
			error (.path, "Too many disconnections, blocking reconnection.")
	
	
	helper Kill
		disabled "Explain why"

		
	helper Kill (|int| ExitCode, |stringzeroterminated| why)
		super.kill(ExitCode)
		.Disconnect(why)


	syntax expect (|string| err)
		cpp_part Fail
		if .CommsOpen
			printline err
			errorreceiver.NewError(nil, err, .path)
		.Disconnect(err)


	function Disconnect (|string| why="")
		opt norefcounts
		// all this can be moved into pico!!! very easy.
		.ClosePipes
//		if .alive and !why and .CommsOpen
//			why = "UnknownReason"
//		.pico!.close(Why)


	helper StartProcess (|ExitCode|)
		cpp_Wrapper JB_Sh_StartProcess

	
	function SpawnAsChild (|duration| delay=0, |bool|)
		if !.pico.isok
			require pico.replace(.pico)
		
//		if delay > 0
//			.DelaySpawnTill = date.now + delay
//			return true
		return .Start_
	
	
	helper Start_ (|bool|)
		return .StartProcess.successful


	function TimedOut (|date| Durr, |bool|)
		if (.TimeWaitingForReply > durr)
			error (self, "child timed out.")
			return true
	
	
	function process.IsParent (|bool|)
		return .pico.config.IsParent
	
	
	function IsOpen (|bool|)
		nil checker // shouldn't be necessary
		return .CommsOpen and .status.isrunning
	
	
	function Deactivate (|int| ExitCode)
		|| running = .status.isrunning
			.Kill(ExitCode)			// kill child
		  elseif .CommsOpen			// inconsistant...
			.handledied				// disconnect comms
	
	
	function ActivateChild (|bool|)
		if .isopen
			return true
		.Deactivate(0)
		if .CanActivate
			expect (.path) (self, "Can't re-activate process without a path.")
			return .SpawnAsChild


	iterator
		while .pico.Canget
			|| msg = .get(10.0)
			if !msg
				continue
			yield msg


	module
		|bool|		 CheckedParent
		|SpdProcess| _Parent
		
		helper app.UsePico (|&pico| Comms, |spdprocess|)
			if !app.IsThreadedAsLib
				require comms.CompleteExec
			|| p = SpdProcess("", nil, comms)
			SpdProcess._parent = p
			return p
		
		function app.Parent (|bool| Expect=false, |spdprocess|)
			opt norefcounts
			if spdprocess.CheckedParent
				return spdprocess._parent
			spdprocess.CheckedParent = true
			if pico.HasParentSocket
				|| comms = pico.new
					return .UsePico(comms)
			if expect
				error "Parent lost connection"


		helper CreateArgs (|string| path, |[string]!| Args, |&cstring|)
			cpp_wrapper


		function string.Spawn (|string| Name, |[string]| Params=nil, |spdprocess|)
			return SpdProcess.Spawn(self, name, params)		
		
		
		function Spawn (|string| app_path, |string| Name, |[string]| params=[], |ProcessMode| Mode=ProcessMode.CaptureAll, |duration| Delay=0, |SpdProcess|)
			require app_path.file.mustexist
			|| pico = pico.new(name)
				rz = SpdProcess(app_path, nil, pico, params, Mode)
				if !rz.SpawnAsChild(delay)
					rz = nil


		function SpawnFork (|ProcessMode| Mode=ProcessMode.CaptureAll, |SpdProcess|)
			disabled "use pico properly"
//			|| p = pico.new$
//			|| id = p.spawnfork
//			if id < 0
//				pico.destroy(p, "fork failed")
//				return nil
//
//			if id == 0 // we are child
//				id = app.parentid
//				mode = ProcessMode.PassThru
//			rz = spdprocess(app.path, nil, p, nil, mode)
//			rz.pid = id

	
	prototype ThreadAsProcess (|&pico| Comms, |int64| Data, |&cstring| args, |bool|)
		function Spawn (|string| ThreadName,  |[string]!| R = [],  |SpdProcess|)
			description `This is meant to run a "main-function" from a lib, as if it were a subprocess. Its usually a wrapper around main(). Just needed this to debug speedie from within Perry.`
			
			|| c_args = SpdProcess.CreateArgs("", r)
			|| pico_fn = pico.new(threadname)
				|| proc = SpdProcess(threadname, self, pico_fn, r)
				if proc.pico.SpawnThread(self|picothreadfn|, 7, c_args)
					return proc
			// its the called-threads responsibility to free the std-args received. Or not!
			// at least we don't crash this way.
			memory.free(c_args)



prototype Thread (|pico| Comms, |uint16| Data, |&nil| Argument, |bool|)
	function Spawn (|pico| Comms, |uint16| Data, |&nil| Argument,  |int| BuffBits=0, |&pico|)
		description "Just a wrapper around pico.thread" 
		|| name = (&comms.config.name[0])|cstring|
		|| pico_out = pico.new(name.wrap, -1)
			if BuffBits
				pico_out.config.Bits = BuffBits
			if comms.SpawnThread(self|picothreadfn|, Data, Argument|&cstring|)
				return pico_out
			pico_out.Close("")



function app.fork (|PID_Int|)
	cpp_wrapper fork
	description "Calls unix's `fork()`. Does nothing else.

To fork and communicate with speedie apps using messages, use spdprocess.spawnfork()

To fork and talk to PicoMsg-based apps that aren't speedie, use pico.spawnfork()"


prototype SpdDeathActionFn

}

