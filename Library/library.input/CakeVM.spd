


struct CakeVM {
linkage: cpp_class CakeVM, wrapper

constants
	TrapTooFar		= 1
	WantProtect		= 2
	CanDebug		= 4

target cpp or vm {
	function Load		(|&uint| Code, |int| CodeLength, |&uint|)
		cpp_wrapper JB_ASM_Code
	function Run		(|int| StartAt, |&ivec4|)
		cpp_wrapper JB_ASM_Run
			
	function Registers	(|bool| Clear=true, |&ivec4|)
		cpp_wrapper JB_ASM_Registers
	function TestInit	(|int| n, |int| g, |&&nil|)
		cpp_wrapper JB_ASM_InitTable
	function ExecInit	(|&byte| LibGlobs, |&byte| PackGlobs, |&&nil| CppFuncs)
		cpp_wrapper JB_ASM_FillTable
	function IsDebugging (assigns:|CakeChef?| Value, |&int|)
		cpp_wrapper JB_ASM_SetDebug
	function Pause
		cpp_wrapper JB_ASM_Pause

	function IsDebugging (assigns:|bool| Value, |&int|)
		|| v = (dummychef, nil)(value)
		return .IsDebugging(v)

	function Index (|&uint| Code,  |int|)
		cpp_wrapper JB_ASM_Index
	
	function DummyChef (CakeChef)

	module
		function New	(|int| StackSize = 1MB, |int| Flags = cakevm.WantProtect ||| cakevm.candebug, |&CakeVM|)
			cpp_wrapper JB_ASM__VM
	
	prototype CakeChef (|&uint| Code,  |int| BreakValue, |bool|)
		// returns false to continue breaking back into here.
		// If you return true, make sure to sleep a little to avoid a hot-loop.
}
}
