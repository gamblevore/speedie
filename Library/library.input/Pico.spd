

prototype PicoThreadFn (|pico| Comms, |uint| Mode, |&cstring| Args=nil)
// todo: pico could use shared memory, instead of pipes. This actually reduces memory use!
// To under half the memory.


struct PicoMessage
	linkage: wrapper, cpp_part Pico
	|int|			Length
	|?&int8|		Data
	
	syntax cast (|bool|)
		inline
		if self
			return .data
	
	module
		function From (|string| s, |PicoMessage|)
			rz.length = s.length
			rz.data = s.addr|&int8|


function @string.FromPico (|picomessage| M, |string|)
	|| x = m.data|&byte|
		return string.own(x, M.length)


struct PicoConfig
	linkage: wrapper, cpp_part PCF
	|int8[16]| 				Name
	|Date|					LastRead
	|Date|					LastSend
	|int|					QueueSize
	|uint16|				DeathCount
	|uint16|				SendFailCount
	|uint16|				ReadFailCount
	|byte|					Noise
	|byte|					SendTimeOut
	|int16|					PIDStatus
	|byte|					SocketStatus
	|bool|					LeaveOrphaned
	|byte|					Bits
	|bool|					IsParent


struct Pico
	linkage: wrapper, cpp_part Pico, cpp_class PicoComms

	function IsParent (|bool|)
		cpp_wrapper PicoIsParent
		
	function CanGet (|bool|)
		nil self
		cpp_wrapper PicoCanGet
		
	libinternal SpawnFork (|cstring| Name=nil, |PID_Int|)
		nil self
		cpp_wrapper PicoStartFork

	function SpawnThread (|PicoThreadFn| fn, |uint16| Mode, |?&cstring| Args = nil, |bool|)
		cpp_wrapper PicoStartThread

	function CompleteExec (|bool|)
		cpp_wrapper PicoRestoreExec
	
	syntax append (|string| str, |bool| Wait=false, |bool|)
		cpp_part SendString
		return ._send(str.addr|&int8|, str.length, wait)
		
	libinternal _Send (|?&int8| msg, |int| Length, |bool| Wait=false, |bool|)
		cpp_wrapper PicoSend

//	libinternal Send (|picomessage| A, |bool| Wait=false, |bool|)
//		cpp_Part SendMsg
//		return ._send(A.data, a.length, wait)
		
	function Tickle (|bool|)
		return self <~ ""
	
	libinternal __Get (|PicoMessage| Msg, |float| T)
		nil checker
		cpp_wrapper PicoGet

	function Get (|float| T, |string|)
		nil checker
		if .canget
			|picomessage| msg
			.__get(msg, T)
			return string.FromPico(msg)
		
	function Close (|cstring| Why)
		cpp_wrapper PicoClose
	
	function MessageStatus (|ErrorInt|)
		nil checker
		cpp_wrapper PicoError
	
	function IsOK (|bool|)
		nil checker
		|| s = .MessageStatus
		return s == 0 or 255

	function IsSending (|bool|)
		cpp_wrapper PicoStillSending

	function Config (|&PicoConfig|)
		inline
		return self|&PicoConfig|
	
	function Name (assigns:|string|)
		|| x = &.config.name[0]
		|| n = value.length min 15
		x[n] = 0
		memory.copy(x|&nil|, value.addr|&nil|, n)
	
	function Name (|string|)
		|| x = &.config.name[0]
		return string.copy(x|cstring|)
	
		
	

	module
		function GlobalConfig (|&PicoGlobalConfig|)
			cpp_wrapper PicoGlobalConf
			
		function SleepForSend (|float| During=5.0, |float| After = 0.5)
			cpp_wrapper PicoSleepForSend
		
		function Start (|int| ThreadCount = 0)
			cpp_wrapper PicoInit

		function Destroy (|?&pico| Where, |Cstring| Why, |?&pico|)
			cpp_wrapper PicoDestroy
			
		function Replace (|&&pico| Where, |bool|)
			|| New = pico.new #require
			.destroy(where, "replace")
			where[0] = new
			return true

		function HasParentSocket (|bool|)
			cpp_wrapper PicoHasParentSocket
			
		function Create (|cstring| Name, |int| ByteBufferSize = 0, |?&pico|)
			cpp_wrapper PicoCreate

		function Fork (|stringzeroterminated| name="", |int| Noise=piconoise.events,   |&pico|)
			|| p = .new(name, noise)
				|| pid = p.spawnfork
				if pid >= 0
					return p
				p.close(nil)
		
		function New (|stringzeroterminated| name="", |int| Noise=piconoise.events,   |&pico|)
			|| p = pico.Create(name)
				p.config.Noise = noise
				return p
			|PicoGlobalStats| St
			St.Read
			error ("Couldn't create a pico object. Too many picos: " + St.OpenPicos)
	
		prototype Thread (|pico| Comms, |uint16| Data, |&nil| Argument, |bool|)
			function Spawn (|pico| Comms, |uint16| Data, |&nil| Argument,  |int| BuffBits=0, |&pico|)
				description "Just a wrapper around pico.thread" 
				|| name = (&comms.config.name[0])|cstring|
				|| pico_out = pico.new(name.wrap, -1)
					if BuffBits
						pico_out.config.Bits = BuffBits
					if comms.SpawnThread(self|picothreadfn|, Data, Argument|&cstring|)
						return pico_out
					pico_out.Close("")

module PicoNoise
	constants
		DebugChild	= 1
		DebugParent	= 2
		Debug		= 3
		EventsChild	= 4
		EventsParent= 8
		Events		= 12
		All			= 15



struct PicoGlobalConfig
	linkage: wrapper
	|Date|						LastActivity
	|Date|						TimeOut
	|int|						ExitCode
	

struct PicoGlobalStats
	linkage: wrapper
	|int|						TimeOutCount
	|int|						OpenSockets
	|int|						OpenPicos

	autogen Read
		cpp_wrapper PicoGlobals
	module
		function New (|PicoGlobalStats|)
			inline
			rz.read



// could be useful for threads :]
struct AtomicLock
	linkage
		cpp_part LOK
	
	|bool| Locked
	function Lock
		cpp_wrapper PicoLock

	function Enter (|bool|)
		cpp_wrapper PicoEnter
	
	function Leave
		.Locked = false

	syntax Using (|&AtomicLock|) // I don't like how this works... I wnt to return nothing.
		.Enter
		return self

	syntax UsingComplete (|&AtomicLock| idk=nil)
		// param order should be reversed! sigh...
		.locked = false

//	module
//		function Test
//			visible
//			|AtomicLock| Lock
//			using Lock
//				"hello"
//			
