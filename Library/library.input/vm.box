


// vm.box
forms
	U0:
	U1:		r1 R
	U2:		r1 R,  r2 r
	U3:		r1 R,  r2 r,  r3 r
	U4:		r1 R,  r2 r,  r3 r,  r4 r


	Func	// func: fnc:
		SaveRegs 5 // should this be R?
		JUMP	j
		Prm1	x // use const instead?
		Prm2	x // maybe just leave it for now...
				  // besides fncx might need some types.
	
	Tail
		JUMP	j
		Prm1	x // also
		
	Alloc
		r1		R
		Align	3 // 1 << align
		Amount	l
	
	Jump
		l0		l
		
	
	Cmp		// cmp:
		r1		R
		r2		r
		r3		r
		Cmp		4
	
	Const	// const:
		r1		R
		Rot		6
		Inv		1
		Value	12

	JCmpEq	// cmpeq:
		r1		r
		r2		r
		Jmp		j

	JCmp	// cmp:
		r1		r
		r2		r
		Cmp		4
		Jmp		j

	Bra		// bra:
		r1		r
		jmp		j
	
	Table
		r1		R
		Mode	2
		Add		l
	
	Read			// mem:
		r1		R	// dest
		r2		r	// Base
		r3		r	// VarAdd
		L		7	// Const A
		move	2

	Write		// mem:
		r1		r	// Src
		r2		r	// Base
		r3		r	// VarAdd
		L		7	// Const A
		move	2
	
	MemUtil
		r1		R
		r2		r
		Op		3
		N		l
		
		
	CNTC
		r1		R
		r2		R
		offset	5
		cnst	7
		size	2 // 1, 2, 4, 8
		// *p1[offset] += cnst
	
	BFLD
		r1		R
		r2		r
		up		6
		down	6
		sign	1
	
	CmpB	// cmpb:
		r1		R
		r2		r
		r3		r
		Shift	6
		Inv		3

	BClear
		r1		R
		r2		R
		Shift1	6
		Shift2	6
		Sign	2
	
	Convert
		r1		R
		r2		r
		Mode	4
		
		
	RET
		r1		r
		r2		r
		Count	3
		Exists	1
	
	Div
		r1		R
		r2		R
		r3		r
		r4		r
		Kind	2
	
	Trap
		r1		 r
		Continue 1		// trap or halt
		Mode	 2		// 1 = trap on function-count,  2 = trap-always

	Float
		r1		R
		r2		r
		r3		r
		r4		r
		D		1

	FloatConst
		r1		R
		r2		r
		High	14

/*
	FloatAddExp
// Can (should?) we reduce this down to 5 lines? // perhaps merge shifts?
		r1		R
		r2		r
		r3		r
		Sh2		4
		Sh3		4
		D		1
*/

	ConstStretchy
		r1		R
		Cond	1	// 0 == always, 1 = only if dest == 0
		Inv		1
		Value	17
//		Prm1	x  // unused!
//		Prm2	x
		
	AddK
		r1		R
		r2		r
		K		l
	
	Shift
		r1		R
		r2		r
		r3		r
		Sh		l
	
	Loop
		r1		r
		r2		r
		Jump	j
	
	Swap
		r1		R
		r2		R
		r3		R
		r4		R

	RefSet
		r1		R
		r2		r
		r3		R
		r4		r


// this file:
// 1) builds the c++ codes, and the jump-table, and the ASM accessor functions
// 2) builds the instruction-info speedie uses exec can just include this file too.
// 3) builds the Âµforms



#!						 (((((STOP)))))
/**/ EROR (U1)
		return u1+U1_Lu

/**/ NOOP (U0):
		i1 = i1
		#!NOOP

	// does nothing


/**/ TRAP (Trap)
		if (Trap_Continueu)
			JB_App__SelfSignal(Trap_Lu)
		else
			return u1


// needs ASM-text: rare, RSDE, RALO, RSET, MEMM



#!						 (((((FUNC)))))

/**/ RET (Ret)	// ret: 
		__ 
		Code = Return(r, Code, Op)
		___

/**/ FUNC (Func, 2,3) // func: 
		__
		Code = BumpStack(r, Code, Op)
		___

/**/ FNCX (Func, 2,3)
		__
		vm.CurrRegs = r // to make this recursive
		ForeignFuncSimple(r, Code, Op)
		___

/**/ TAIL (Tail, 2)
		__
		Code = TailStack(r, Code, Op)
		___

/**/ ALLO (Alloc)
		AllocStack(vm, r, Op)
	


#!						 (((((Utils)))))

/**/ SWAP (Swap)
		std_swap(r[n1], r[n2])
		std_swap(r[n3], r[n4])

/**/ PRNT (U1)
		printf("%lli\n", i1)
		#!better to print this also as float/double/signed/unsigned...
/**/ RARE (U2)
		if_rare (Rare(r, Op)) return n3
/**/ CONV (Convert)
		Conv(r, Convert_Modeu, Op)



#!						 (((((Consts)))))
/**/ KNSR (Const)
		RotateConst(r, Op)
/**/ KNST (ConstStretchy, 1, 2, 3)
		Code = LoadConst(r, Op, Code)



#!						 (((((Math)))))
/**/ ADDK (AddK)
		i1 = i2 + U2_Li
/**/ ADPK (AddK)
		i1 = i2
		i2 = i2 + U2_Li
/**/ ADD  (Shift)
		i1 = i2 + (i3 << Shift_Shu) // only need 6 bits for shift! can we save 3 conditional add?
/**/ SUBB  (Shift)              	// must come after ADD
		i1 = (i2 - i3) >> Shift_Shu
/**/ MULT  (U4)
		i1 = (i2 * i3) + i4
/**/ DIVV (Div)
		DivMath(r, Op)
/**/ MAX (Cmp)
		if Cmp_Cmpu
			i1 = std_max(i2, i3)
		else
			u1 = std_max(u2, u3)
/**/ MIN (Cmp)
		if Cmp_Cmpu
			i1 = std_min(i2, i3)
		else
			u1 = std_min(u2, u3)



#!						 (((((Bitops)))))
/**/ BRUS  (Shift) // technically we could only use 6 bits for the shift, and keep the last 3 for adding
		i1 = (((i2<<Shift_Shu)>>Shift_Shu) >> i3) // its too fiddly though.
/**/ BRUU  (Shift)
		u1 = (u2 >> (u3+Shift_Shu))
/**/ BLUE  (Shift) 
		u1 = (u2 << (u3+Shift_Shu))
/**/ BAND  (Shift)
		u1 = u2 &  (u3|||Shift_Shu)
/**/ BOAR  (U4) // maybe << k is better? idk that bfls is very useful...
		u1  = (u2|||u3)&~u4
/**/ BXOR  (U3)
		u1 = u2 ^ u3
/**/ BNOT  (U2)
		u1 = ~u2 & ~u3
/**/ BFLG  (BFLD) // perhaps sign can allow for SIMD opts?
		if (BFLD_signu)
			i1 = ((i2 << BFLD_upu) >> BFLD_downu)
		else
			u1 = ((u2 << BFLD_upu) >> BFLD_downu)
/**/ BFLS  (BFLD)
		BFLS(r, Op)

	
///**/ BSTT  (U4)
//		i1 = 0//bitstats(u2, u3, u4)
/**/ BROL  (U3)
		i1 = JB_u64_RotL(u2, u3 + L3)
/**/ BROR  (U3)
		i1 = JB_u64_RotR(u2, u3 + L3)
/**/ BCLR  (BClear)
		BitClear(r, Op)


#!						 (((((MiniCompare)))))
/**/ CMPB  (CmpB)
		u1 = BitComp(r, Op)

/**/ TERN  (U4)
	if (u2)
		u1 = u3
	else
		u1 = u4


/**/ CMPI  (Cmp)
	CompI(r, Op)


/**/ CMPF  (Cmp)
	CompF(r, Op)


#!						 (((((Branches)))))
/**/ JUMP (jump)
		Code += l0

/**/ JMPI  (JCmp)
		__
		Code = JompI(r, Op, Code)
		___
/**/ JMPF  (JCmp)
		__
		Code = JompF(r, Op, Code)
		___
/**/ JMPE  (JCmpEq)
		__
		Code = JompEq(r, Op, Code)
		___
/**/ JMPN  (JCmpEq)
		__
		Code = JompNeq(r, Op, Code)
		___
/**/ JBRA  (Bra)
		__
		if (i1)
			Code += Bra_jmpi
		___

/**/ JBRN  (Bra)					
		__
		if (!i1)
			Code += Bra_jmpi
		___

/**/ LUPD  (Loop)			 	// same
		__
		if (i1-- > i2)
			Code -= Loop_Jumpu
		___

/**/ LUPU  (Loop)				// assume uint64
		__
		if (i1++ < i2)
			Code -= Loop_Jumpu
		___



#!						 (((((Refs)))))
///**/ RSDE  (`rrrj`) // do this later... too much work for now.
//		__
//		Code += U3_Li
//		___
//		decr(o3)
//		decr(o2)
//		safedecr(o1)
//		#!jump too? for branches...

/**/ RSET  (refset)
		setref(n1, o1, o2)
		setref(n3, o3, o4)
/**/ RMEM  (U4)		// we need some way to also refcount objs in memory! not just in registers
		i1 = i1
		#!Do later
//		setref(n1, o1, o2)

/**/ RALO  (U2)
		o1 = alloc(o2)
		#!should call constructor too.



#!						(((((Memory)))))
/**/ TABL  (table)
		u1 = table(n2)
/**/ RD1U  (Read)
		u1 = mem(uint8)
		mem2(uint8)
/**/ RD1S  (Read)
		u1 = mem(char)
		mem2(char)
/**/ RD2U  (Read)
		u1 = mem(u16)
		mem2(u16)
/**/ RD2S  (Read)
		u1 = mem(s16)
		mem2(s16)
/**/ RD4U  (Read)
		u1 = mem(u32)
		mem2(u32)
/**/ RD4S  (Read)
		u1 = mem(int)
		mem2(int)
/**/ RD8U  (Read)
		u1 = mem(u64)
		mem2(u64)
/**/ RD16  (Read)
		((ivec4*)r)[n1] = mem(ivec4)
		mem2(ivec4)
/**/ WR1U  (Write)
		mem(uint8) = u1
		mem2(uint8)
/**/ WR2U  (Write)
		mem(u16) = u1
		mem2(u16)
/**/ WR4U  (Write)
		#! xcode only complains about this one? ?
		mem(u32) = (u32)u1
		mem2(u32)
/**/ WR8U  (Write)
		mem(u64) = u1
		mem2(u64)
/**/ WR16  (Write)
		mem(ivec4) = (ivec4)(((ivec4*)r)[n1])
		mem2(ivec4)

/**/ CNTC  (CNTC) // negation bound CNTC and CNTD. CNTD must always be following.
		CountConst(r, Op, 1) // same with a few others actually

/**/ CNTD  (CNTC)
		CountConst(r, Op, 0)

/**/ MEMU  (MemUtil)
		#! copy/fill/endian/xor
		MemStuff((u32*)u1, (u32*)u2, n3, L3)


#!						(((((Float)))))

/*
/**/ FEXK  (FloatAddExp)
		if FloatAddExp_Du
			f1 = FloatSh2(u2, FloatAddExp_Sh2i) + FloatSh2(u3, FloatAddExp_Sh3i)
		else
			f1 = FloatSh1(u2, FloatAddExp_Sh2i) + FloatSh1(u3, FloatAddExp_Sh3i)
*/		

/**/ FADD  (Float)
		if (Float_Du)
			d1 = d2 + d3 - d4
		else
			f1 = f2 + f3 - f4

/**/ FADK (FloatConst)
		// we just want simple things like MyFloat += 2.0
		f1 += f2 + FloatIncr1(Op)

/**/ FMUL  (Float)
		if (Float_Du)
			d1 = (d2 * d3)+d4
		else
			f1 = (f2 * f3)+f4

/**/ FMLK  (FloatConst)
		f1 = f2 * FloatIncr1(Op)

/**/ FDIV  (float)
		if (Float_Du)
			d1 = d2 / d3
		else
			f1 = f2 / f3

/**/ FFRC  (Float)
		if (Float_Du)
			d1 = (d2 - floor(d2)) * d3
		else
			f1 = (f2 - floor(f2)) * f3

/**/ FMAX  (Float)
		if (Float_Du)
			d1 = std_max(d2, d3)
		else
			f1 = std_max(f2, f3)

/**/ FMIN  (Float)
		if (Float_Du)
			d1 = std_min(d2, d3)
		else
			f1 = std_min(f2, f3)
