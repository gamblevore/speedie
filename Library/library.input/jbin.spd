
// jbin: streamable, binary jeebox


extend message
	render RenderJbin (|string| shell_path = "")
		opt norefcounts
		require self
		|| js = fs|jbin|
		if shell_path
			js.sheb(shell_path)
		js <~ Jbin.Header
		.render_jbin_sub(js)
	
	helper render_jbin_sub (|jbin| js)
		opt norefcounts
		|| ch	 = self
		|| after = .FlatAfter
		while ch and ch != after
			|| Depth	= 0
			|| curr		= ch
			ch			= curr.FlatNextDepth(depth)
			js.Add(curr.func, curr.name, depth > 0)
			js.exit(-depth)



role JBin (Faststring)
	module
		|| Header     = "\01\10\EA\E2"

	linkage: cpp_part bin

	constructor         	(|syntax| type=@arg, |string| name="")
		cpp_part Constructor
		self <~ Jbin.Header
		.enter(type, name)
	
	constructor (|int| n)
		cpp_part Constructor0
		if n // what?

	function Enter			(|syntax| type=@arg, |string| name="", |jbinleaver|)
		return .add(type, name, true)

	function ExitAll
		cpp_Part Exit0
		.Exit(.indent)
	
	function Exit			(|int| Amount=1, |int|)
		.Indent = (.Indent - amount) max 0
		|| Add = 239
		while amount > 0
			rz++
			|| B  = (add + amount)  min  (255)
			self    <~ B|byte|
			amount  -= (B-add)

	function Tmp			(|string| name, |jbinLeaver|)
		.Enter(@tmp, name)
		.Enter(@arg)
		return 2

	function Sheb			(|string| name)
		self <~ '#'
		self <~ '!'
		self <~ name
		self <~ '\n' // noice
	
			
	function AddStr			(|string| name)
		.add(@str, name)
	
	function AddInt			(|int64| name)
		.add(@num, name.render)
	
	function Add			(|syntax| type, |string| name="", |bool|into = false, |jbinleaver|)
		return .AddMemory(type, name.length, into, name.addr)
	
	function Add			(|syntax| type, |faststring| fs, |bool|into = false, |jbinleaver|)
		cpp_part AddFS
		return .AddMemory(Type, fs.length, into, fs.Resultptr)

	function AddCString		(|syntax| type=@str, |cstring| name)
		.AddMemory(type, name.length, false, name|&byte|)

	function AddMemory		(|syntax| type, |int| L, |bool| GoIn, |&byte| data, |jbinleaver|)
		|| T = (type|int|<<1) ||| (goin)
		self <~ T|byte|
		.AppendStrLength(L)
		.AppendMemory(data, L)
		if goin
			.Indent++
			return 1
		
	helper AppendStrLength (|int| n)
		while n >= 128
			.appendbyte(n ||| 128)
			n >>= 7
		.AppendByte(n)
			

	function ReserveMemory	(|syntax| type, |int| L, |bool| GoIn=false, |&byte|)
		|| T = (type|int|<<1) ||| (goin)
		self <~ T|byte|
		.AppendStrLength(L)
		.Indent += goin
		return .Reserve(L)
		




datatype jbinLeaver (int)
	// need some nice syntax so we can do: using j.enter
	// not finished

	syntax UsingComplete (|jbin| jb)
		StdErr.LowerErrorsTo = self
		
	module
		function Test
			|| j = jbin()
			j.Enter	// Sigh... syntaxusing is called upon the leaver, and not the jbin!
					// how to make it work on j rather than on j.enter?
					// we could do it.
					// so... we call j.enter
					// i mean we can just make it work on the thing inside the dot instead of the overall
					// but that affects a lot of things. its not very reliable.
						  
	

function StringReader.NextMsg (|message| parent=nil, |syntax| fn=@nil, |string| name=nil,  |Message|)
	cpp_part NextMsgExpect
	opt norefcounts
	rz = .NextMsg #require
	expect (rz.expect(fn, name) and (rz in parent)) (rz)


helper StringReader.NextMsg (|message|)
	return .nextmsginfo|message|


helper StringReader.NextMsgInfo (|uint64|)
	opt norefcounts
	|| Msg = ._Object|message|
	|int| info
	while 
		info = .NonZeroByte
		loop info > 239
		msg = Msg.upward(info - 239)
		._Object = msg, require msg

	|| T = (info >> 1)|syntax|
	if (t < @max and T > @nil) // 01 --> T=@nil
		msg = msg.msg(t, .str(.strlength))			
		if info & 1
			._Object = msg
		|| cb = .CallBack
			(cb)(msg)
		return msg|uint64|

	._Object = nil
	if info >= 0
		expect (T > @nil) (self, "StringReader.IsJBin was not called.")
		error (self, "Corrupted jbin")


function StringReader.IsJBin (|bool|)
	return .str(4).IsJbin
	
	
function StringReader.ExpectJbin (|bool|)	
	if .IsJBin
		return true
	error (Self, "Not jbin")


function StringReader.ParseJbin (|int64| Remain=1G, |MessageRoot|)	
	require .ExpectJbin
	._Object = nil
	rz = .NextMsg
	while --Remain > 0
		loop .NextMsginfo
	
	if .Data.WentBad
		rz = nil // be consistant with .parse!
	

function string.ParseJbin (|int64| max=1G, |messageroot|)
	|| s = .stream
	|messageroot--| msg = s.ParseJbin(max)
	return msg


function string.Digest (|string|)
	if .IsJbin
		return self
	return .parse$.renderjbin


/* 
	Ideas
	
	Rework (good):
		* Length high-bit means 31-bits remain. If false, next bit means 14 or 6 bits remain.
			* More reliable! matches speedie's string max length!! 
	
	Speedups (annoying):
		* Node-info can't cross 16MB boundary (name can tho). Then can keep ptrs in regs.
		  (will need work on faststring, I think.)  Needs end with three zeros, also.
		* Allocate one block at a time! Call constructors. Just need Curr+Last ptr.

	Language level additions (meh):
		* Allow MessageID during parse. Could save on RAM+CPU, if done properly, say only on @tmp, or
		  done on a per-document-basis that knows what types to use.

	Jbin level additions: (probably bad)
		* A back-ref mode? Some objects can store their name+type in a cache for reuse.	
			* Some unused @syx could represent backrefs.
*/




