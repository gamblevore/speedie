
// jbin: streamable, binary jeebox

|| _JbinHeader = "\10\03" // ugh 
/// can't put a constant in a role? 


extend message
	render render_jbin (|string| execute = "")
		opt norefcounts
		require self
		|| js = fs|jbin|
		if execute
			js.sheb(execute)
		js.jinit
		|| ch	 = self
		|| after = .FlatAfter
		while ch != after
			|| Depth	= 0
			|| curr		= ch
			ch			= ch.FlatNextDepth(depth)
			js.Add(curr.func, curr.name, depth > 0)
			js.up(-depth)


role JBin (Faststring)
	linkage: cpp_part bin
	constructor         (|syntax| type=@arg, |string| data="")
		cpp_part Constructor
		.jinit
		.enter(type, data)
	constructor (|int| n)
		cpp_part Constructor0
		if n // what?
	function enter		(|syntax| type=@arg, |string| data="")
		.add(type, data, true)
	function addstr		(|string| data)
		.add(@str, data)
	function addint		(|int64| data)
		.add(@num, data.render)
	function add		(|syntax| type, |string| data="", |bool|into = false)
		|| L = data.length
		|| addr = (data.addr, nil)(L)
		.addmemory(type, into, addr, L)

	function sheb		(|string| data)
		self <~ '#'
		self <~ '!'
		self <~ data
		self <~ '\n' // noice

	function jinit
		self <~ _JbinHeader

	function up (|int| amount = 1)
		while amount > 0
			|| less  = amount min 63
			self    <~ (less(|)192)|byte|
			amount  -= less

	function AddCstring	(|cstring| data, |syntax| type=@str)
		.addmemory(type, false, data|&byte|, data.length)
	
	function AddMemory	(|syntax| type, |bool| GoIn, |&byte| data, |uint64| L)
		|uint| info = 128 >> goin
		|| L2 = (L|int|, 60+L.lelength)(L < 60)
		self <~ (info (|) L2)|byte|
		if L >= 60
			.lint(L)
		self <~ type|byte|
		if data // so .openstream can stream unknown data-length  
			.AppendMemory(data, L|int|)

	function OpenStream	(|int|)
		.AddMemory(@bin, false, nil, 1GB)
		return .length

	function CloseStream (|int| c)
		|| nwe = .length
		.length = c - 6
		self <~ 191|byte|
		.AppendInt(nwe - c)
		self <~ (@bin)|byte|
		.length = nwe


helper stringstream.Parse_Jbin (|MessageRoot|)	
	expect .test(_JbinHeader)  (self, "Not jbin")
	|message|	Curr
	||			Type = 0
	while (self)
		|| name = .NextJbin(type)
		if type < 0 // go up
			curr = curr.upward(-type)					#loop
		  else
			|| msg = curr.msg((type>>1)|syntax|, name)
			rz := msg
			if !curr or Type & 1
				curr = msg


helper stringstream.NextJbin (|&int| type, |string|)	
	|uint| info = .Byte
	|| L	= info & 63
	|| Dir	= info >> 6						// 3 = up,  2 = same,  1 = down :)
	if Dir == 3
		*type = -L
		return nil
	if L >= 60
		L = .lint0(L-60)
	|| t = .byte
	if t > @bin|int|						// need @max
		if !.ErrorReported
			error (self, "Corrupted jbin")
			.ErrorReported = true
		t = @tmp
	*type = (t<<1)+(2-Dir)
	return .str(L)


function string.parse_jbin (|message|)
	return .Stream.Parse_Jbin

function string.IsJbin (|bool|)
	return self starts _JbinHeader

function string.digest (|string|)
	if .IsJbin
		return self
	return .parse$.render_jbin


