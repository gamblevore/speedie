
// jbin: streamable, binary jeebox
// offers a compacted version too!

|| _JbinHeader     = "\01\10\EA\E2"     /// can't put a constant in a role? 
|| _JbinHeaderComp = "\01\11\EA\E2"
|| _jBinNotJbin    = "Not jbin"


extend message
	render render_jbin (|string| shell_path = "", |bool| Compact=false)
		opt norefcounts
		require self
		|| js = fs|jbin|
		if shell_path
			js.sheb(shell_path)
		js.jinit
		|| ch	 = self
		|| after = .FlatAfter
		while ch != after
			|| Depth	= 0
			|| curr		= ch
			ch			= curr.FlatNextDepth(depth)
			js.Add(curr.func, curr.name, depth > 0)
			js.up(-depth)


role JBin (Faststring)
	linkage: cpp_part bin
	constructor         (|syntax| type=@arg, |string| data="")
		cpp_part Constructor
		.jinit
		.enter(type, data)
	constructor (|int| n)
		cpp_part Constructor0
		if n // what?
	function enter		(|syntax| type=@arg, |string| data="")
		.add(type, data, true)
	function addstr		(|string| data)
		.add(@str, data)
	function addint		(|int64| data)
		.add(@num, data.render)
	function add		(|syntax| type, |string| data="", |bool|into = false)
		|| L = data.length
		|| addr = (data.addr, nil)(L)
		.addmemory(type, addr, into, L)
	function add		(|syntax| type, |faststring| fs, |bool|into = false)
		cpp_part AddFS
		.addmemory(Type, fs.resultptr, into, fs.length)

	function addcomp (|faststring| fs, |int| strength=mzlab.strongest)
		if strength > 0
			|| Place = .OpenSection
			fs.compressinto(self, strength)
			.CloseSection(Place)
		  else
			.add(@str, fs)
		
	function sheb		(|string| data)
		self <~ '#'
		self <~ '!'
		self <~ data
		self <~ '\n' // noice

	function jinit
		self <~ _JbinHeader

	function up (|int| amount = 1) // we encode the upness in the range of syntax values that have no children
		|| add = (@cnj|int|)-1
		while amount > 0
			|| expr  = (add + amount)  min  (@bin|int|)
			self    <~ ((expr<<1) (|) 1)|byte|
			amount  -= (expr-add)

	function AddCstring	(|cstring| data, |syntax| type=@str)
		.addmemory(type, data|&byte|, false, data.length)
	
	function AddMemory	(|syntax| type, |&byte| data, |bool| GoIn, |uint64| L)
		|uint| T = (type|uint|<<1) (|) (goin)
		self <~ T|byte|
		.hint(L)
		.AppendMemory(data, L|int|)


	function OpenSection  (|int|)				// openstream 
		.NoFlush ++
		.length += 6
		return .length

	function CloseSection (|uint| c)			// closestream
		|| CurrLen = .length
		expect (CurrLen >= c) (self, "Unable to close section")
		.length = c - 6
		|| blen = 5
		c = CurrLen - c
		|| Actual = c
		while {
			Actual >>= 7
			blen--
		} (Actual)

		self <~ (0|byte|, blen) 
		self <~ (@bin|int|<<1)|byte|
		.hint(c)
		.length = CurrLen
		.NoFlush--


function stringstream.NextMsg (|Message|)
	return .NextMsgInfo|message|


function stringstream.NextMsg (|message| parent=nil, |syntax| fn, |string| name=nil,  |Message|)
	cpp_part NextMsgExpect
	rz = .NextMsg #require
	if (rz.expect(fn, name)) and (parent) and (rz.parent != parent)
		error rz
		rz = nil


helper stringstream.NextMsgInfo (|uint64|)
	opt norefcounts
	while (self)
		|uint| info = .Byte
		if info & 128
			expect (.UserTable) (self, "Can't stream compacted jbin. Use .parse instead")
			return info
		if info == 0 :   continue
		|| T = (info >> 1)|syntax|
		expect (t < @max and T > @nil) (self, "Corrupted jbin")

		ifn (info & 1) and t.NoChildren
			|| msg = .UserObj|message|.msg(t, .str(.hInt))|uint64|
			if info & 1
				.userobj = msg|object|
			return msg
		  else
			.UserObj = .UserObj|message|.upward(t|int|-7)			#require


helper stringstream.NextMsgAllocate (|&message|)
	require !.Data.ErrorReported
	
	|| pos = .UserTableCurr - .UserTable
	|| Amount = (pos*2) max 4K
	rz = Memory.realloc(.usertable, Amount * platform.PointerBytes)|&message|
		
	expect rz (self, "jbin can't allocate")
	.UserTable = rz
	.UserTableCurr = rz + pos
	.UserTableEnd = rz + Amount


helper stringstream.NextMsgAdd (|Message| New)
	|| c = .UserTableCurr
	if c >= .UserTableEnd
		c = .NextMsgAllocate #require
	*c++ = New
	.UserTableCurr = c
	
	
helper stringstream.NextMsgLZ (|uint| Info)
	opt norefcounts
	if Info < 16
		Info |= .hInt << 4
	  else
		Info -= 15
	|| Index  = Info >> 1
	|| Ref    = .UserTableEnd[-Index]
	|| Msg    = .UserObj|message|.msg(ref.func, ref.name)
	if Info & 1
		.UserObj = msg


helper stringstream.Parse_Jbliz (|MessageRoot|)
	// compacted jbin, using lz-like scheme
	rz = .NextMsginfo|messageroot|
	.NextMsgAllocate
	while
		|| lz = .NextMsginfo #loop
		if lz < 256
			.NextMsgLZ(lz & 127)
		  else
			.NextMsgAdd(lz|message|)
			
	memory.Free(.UserTable)
	.UserTableEnd = nil
	.UserTable = nil
	.UserTableCurr = nil



helper stringstream.ExpectJbin (|bool|)
	// remove this func :) only decompressinto needs it!
	|| Header = .str(4)
	if header == _JbinHeader
		rz = true
	  else
		error (self, _jBinNotJbin)


function stringstream.Parse_Jbin (|MessageRoot|)	
	.UserObj = nil
	|| Header = .str(4)
	
	if header == _JbinHeader
		rz = .NextMsginfo|messageroot|
		while .NextMsginfo
	  elseif Header == _JbinHeaderComp
		rz = .parse_jbliz
	  else
		error (self, _jBinNotJbin)

	.UserObj = nil
	

function string.parse_jbin (|message|)
	return .Stream.Parse_Jbin

function string.IsJbin (|bool|)
	return self starts _JbinHeader

function string.digest (|string|)
	if .IsJbin
		return self
	return .parse$.render_jbin

