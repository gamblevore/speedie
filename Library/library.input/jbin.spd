
// jbin: streamable, binary jeebox


extend message
	render RenderJbin (|string| shell_path = "")
		opt norefcounts
		require self
		|| js = fs|jbin|
		js.RunHeader(shell_path)
		.render_jbin_sub(js)
	
	libinternal render_jbin_sub (|jbin| js)
		opt norefcounts
		|| ch	 = self
		|| after = .FlatAfter
		while ch and ch != after
			|| Depth	= 0
			|| curr		= ch
			ch			= curr.FlatNextDepth(depth)
			js.Add(curr.func, curr.name, depth > 0)
			js.exit(-depth)



role JBin (Faststring)
	module
		|| Header     = "\01\10\EA\E2"

	linkage: cpp_part bin

	constructor         	(|syntax| type=@arg, |string| name="")
		cpp_part Constructor
		self <~ Jbin.Header
		.enter(type, name)
	
	constructor (|int| n)
		disabled `Use jbin(@syx, "name")`
		cpp_part Constructor0

	function Enter			(|syntax| type=@arg, |string| name="", |jbinleaver|)
		return .add(type, name, true)

	function ExitAll
		cpp_Part Exit0
		.Exit(.indent)
	
	function Exit			(|int| Amount=1, |int|)
		.Indent = (.Indent - amount) max 0
		|| Add = 239
		while amount > 0
			rz++
			|| B  = (add + amount)  min  (255)
			self    <~ B|byte|
			amount  -= (B-add)

	function TmpArg			(|string| name, |jbinLeaver|)
		.Enter(@tmp, name)
		.Enter(@arg)
		return 2

	function RunHeader     (|string| name)
		if name
			self <~ '#'
			self <~ '!'
			self <~ name
			self <~ '\n' // noice
		self <~ Jbin.Header
	
	function AddStr			(|string| name)
		.add(@str, name)
	
	function AddInt			(|int64| name)
		.add(@num, name.render)
	
	function Add			(|syntax| type, |string| name="", |bool|into = false, |jbinleaver|)
		return .AddMemory(type, name.length, into, name.addr)
	
	function Add			(|syntax| type, |faststring| fs, |bool|into = false, |jbinleaver|)
		cpp_part AddFS
		return .add(Type, fs|string|, into)

	function AddCString		(|syntax| type=@str, |cstring| name)
		.AddMemory(type, name.length, false, name|&byte|)

	function AddMemory		(|syntax| type, |int| L, |bool| GoIn, |&byte| data, |jbinleaver|)
		.WriteType(type, goin)
		.AppendHInt(L)
		.AppendMemory(data, L)
		return goin|int|

	function WriteType	(|syntax| type, |bool| GoIn=false)
		|| T = (type|int|<<1) ||| (goin)
		self <~ T|byte|
		.Indent += goin

	function ReserveMemory	(|syntax| type, |int| L, |int| AlignTo=0, |bool| GoIn=false, |&byte|)
		if (AlignTo >= 2)
			|| Header = (L.Log2/7)+2
			|| NewStart = Header + .streamlength
			|| extra = NewStart mod AlignTo
				self <~ (0, AlignTo-extra)
		.WriteType(type, goin)
		.AppendHInt(L)
		return .Reserve(L)	




datatype jbinLeaver (int)
	// need some nice syntax so we can do: using j.enter
	// not finished

	syntax UsingComplete (|jbin| jb)
		StdErr.LowerErrorsTo = self
		
	module
		target debug
			inline Test
				|| j = jbin()
				j.Enter	// Sigh... syntaxusing is called upon the leaver, and not the jbin!
						// how to make it work on j rather than on j.enter?
						// we could do it.
						// so... we call j.enter
						// i mean we can just make it work on the thing inside the dot instead of the overall
						// but that affects a lot of things. its not very reliable.
						  
	
/*
function InputStream.NextMsg (|message| parent=nil, |syntax| fn=@nil, |string?| name=nil,  |Message|)
	cpp_part NextMsgExpect
	opt norefcounts
	rz = .nextmsginfo|message| #require
	expect (rz.expect(fn, name) and (rz in parent)) (rz)
	// A good concept, but untested and unused. So its not a real function unless I can see a real use.
*/

libinternal InputStream.NextMsgInfo (|uint64|)
	opt norefcounts
	|| Msg = ._Object|message|
	|int| info
	while 
		info = .NonZeroByte
		loop info > 239
		msg = Msg.upward(info - 239)
		._Object = msg, require msg

	|| T = (info >> 1)|syntax|
	if (t < @max  and  T > @nil)					// 01 --> T=@nil
		msg = msg.msg(t, .str(.HInt))			
		msg.Position = .data.position - msg.name.Length
				
		if info & 1
			._Object = msg
		|| cb = .CallBack
		if !cb // common case
			return msg|uint64|
		(cb)(msg)
		return msg|uint64|

	._Object = nil
	if info >= 0
		expect (T > @nil) (self, "InputStream.IsJBin was not called.")
		error (self, "Corrupted jbin")


function InputStream.StreamJbin (|int64| Remain=1G, |MessageRoot|)	
	if .Eat("#!") == 2				 // shebang
		.Find('\n')
	expect (.HasHeader(Jbin.Header))  (Self, "Parsed data lacks jbin header.")

	._Object = nil
	|| Root = .NextMsgInfo|message|
	while --Remain > 0
		loop .NextMsginfo
	
	if .Data.WentBad and !.TryRecoverBadData
		Root = nil // be consistant with .parse!
	return Root
	

function string.ParseJbin (|int64| max=1G, |messageroot|)
	|| s = .stream
	|messageroot--| msg = s.StreamJbin(max)
	return msg


function string.Digest (|string|)
	if .IsJbin
		return self
	return .parse$.renderjbin


/* 
	Ideas
	
	Rework (good):
		* Length high-bit means 31-bits remain. If false, next bit means 14 or 6 bits remain.
			* More reliable! matches speedie's string max length!! 
	
	Speedups (annoying):
		* Node-info can't cross 16MB boundary (name can tho). Then can keep ptrs in regs.
		  (will need work on faststring, I think.)  Needs end with three zeros, also.
		* Allocate one block at a time! Call constructors. Just need Curr+Last ptr.

	Language level additions (meh):
		* Allow MessageID during parse. Could save on RAM+CPU, if done properly, say only on @tmp, or
		  done on a per-document-basis that knows what types to use.

	Jbin level additions: (probably bad)
		* A back-ref mode? Some objects can store their name+type in a cache for reuse.	
			* Some unused @syx could represent backrefs.
*/




