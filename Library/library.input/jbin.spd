
// jbin: streamable, binary jeebox

|| _JbinHeader     = "\01\10\EA\E2"     /// can't put a constant in a role? 
|| _JbinHeaderComp = "\01\11\EA\E2"
|| _jBinNotJbin    = "Not jbin"


extend message
	render render_jbin (|string| shell_path = "")
		opt norefcounts
		require self
		|| js = fs|jbin|
		if shell_path
			js.sheb(shell_path)
		js.jinit
		|| ch	 = self
		|| after = .FlatAfter
		while ch != after
			|| Depth	= 0
			|| curr		= ch
			ch			= curr.FlatNextDepth(depth)
			js.Add(curr.func, curr.name, depth > 0)
			js.up(-depth)


role JBin (Faststring)
	linkage: cpp_part bin
	constructor         (|syntax| type=@arg, |string| data="")
		cpp_part Constructor
		.jinit
		.enter(type, data)
	constructor (|int| n)
		cpp_part Constructor0
		if n // what?
	function enter		(|syntax| type=@arg, |string| data="")
		.add(type, data, true)
	function addstr		(|string| data)
		.add(@str, data)
	function addint		(|int64| data)
		.add(@num, data.render)
	function add		(|syntax| type, |string| data="", |bool|into = false)
		|| L = data.length
		|| addr = (data.addr, nil)(L)
		.addmemory(type, addr, into, L)

	function add		(|syntax| type, |faststring| fs, |bool|into = false)
		cpp_part AddFS
		.addmemory(Type, fs.resultptr, into, fs.length)

	function addcomp (|faststring| fs, |int| strength=mzlab.strongest)
		if strength > 0
			|| Place = .OpenSection
			fs.compressinto(self, strength)
			.CloseSection(Place)
		  else
			.add(@str, fs)
		
	function sheb		(|string| data)
		self <~ '#'
		self <~ '!'
		self <~ data
		self <~ '\n' // noice

	function jinit
		self <~ _JbinHeader

	function up (|int| amount = 1)
		while amount > 0
			|| curr  = amount min 16
			self    <~ (256-curr)|byte|
			amount  -= curr

	function AddCstring	(|cstring| data, |syntax| type=@str)
		.addmemory(type, data|&byte|, false, data.length)
	
	function AddMemory	(|syntax| type, |&byte| data, |bool| GoIn, |uint64| L)
		if type|int| >= 120
		|uint| T = (type|uint|<<1) (|) (goin)
		self <~ T|byte|
		.hint(L)
		.AppendMemory(data, L|int|)

	function OpenSection  (|int|)				// openstream 
		.NoFlush ++
		.length += 6
		return .length

	function CloseSection (|uint| c)			// closestream
		|| CurrLen = .length
		expect (CurrLen >= c) (self, "Unable to close section")
		.length = c - 6
		|| blen = 5
		c = CurrLen - c
		|| Actual = c
		while {
			Actual >>= 7
			blen--
		} (Actual)

		self <~ (0|byte|, blen) 
		self <~ (@bin|int|<<1)|byte|
		.hint(c)
		.length = CurrLen
		.NoFlush--


function @string.int32 (|int| n, |string|)
	return string.Copy((&n)|&byte|, 4)


function @jbin.JoinParseTest (|string|)
    || bin = â€“digest "@mary had a~little~lamb whose fleece was white as snow"
	|| out = faststring()
	for 5
		out <~ bin
	|| In = out.getresult.stream

	|| result = Message()
	while !in.NoMoreChunks
		result <~ in.Parse_Jbin
	return result.render


function stringstream.NextMsg (|Message|)
	return .NextMsgInfo|message|


function stringstream.NextMsg (|message| parent=nil, |syntax| fn, |string| name=nil,  |Message|)
	cpp_part NextMsgExpect
	rz = .NextMsg #require
	if (rz.expect(fn, name)) and (parent) and (rz.parent != parent)
		error rz
		rz = nil


helper stringstream.NextMsgInfo (|uint64|)
	opt norefcounts
	|| parent = .UserObj|message|
	while (self)
		|uint| info = .Byte
		if info < 160
			if info <= 1
				if (info == 1)
					error (self, "Corrupted jbin")
					exit
				continue
			|| T = (info >> 1)|syntax|
			if t >= @max
				error (self, "Corrupted jbin" )
				t = @arg
			|| msg = parent.msg(t, .str(.hInt))
			if info & 1							// better to not check !parent
				.userobj = msg
			return msg|uint64|
		parent = parent.upward(256-info)		// go up
		.userobj = parent
		require parent
	.UserObj = nil


helper stringstream.NextMsgAllocate (|&message|)
	require !.Data.ErrorReported
	
	|| pos = .UserTableCurr - .UserTable
	|| Amount = (pos*2) max 4K
	rz = Memory.realloc(.usertable, Amount * platform.PointerBytes)|&message|
		
	expect rz (self, "jbin can't allocate")
	.UserTable = rz
	.UserTableCurr = rz + pos
	.UserTableEnd = rz + Amount


helper stringstream.NextMsgAdd (|Message| New)
	|| c = .UserTableCurr
	if c >= .UserTableEnd
		c = .NextMsgAllocate #require
	*c++ = New
	.UserTableCurr = c
	
	
helper stringstream.NextMsgLZ (|uint| Info)
	opt norefcounts
	if Info < 16
		Info |= .hInt << 4
	  else
		Info -= 15
	|| Index  = Info >> 1
	|| Ref    = .UserTableEnd[-Index]
	|| Msg    = .UserObj|message|.msg(ref.func, ref.name)
	if Info & 1
		.UserObj = msg
	

function stringstream.Parse_Jbin2 (|MessageRoot|)	
	.UserObj = nil
	|| Header = .str(4)
	
	if header == _JbinHeader
		rz = .NextMsginfo2|messageroot|
		while .NextMsginfo2
	
	  elseif Header == _JbinHeaderComp
		rz = .NextMsginfo2|messageroot|
		.NextMsgAllocate
		while
			|| lz = .NextMsginfo2 #loop
			if lz < 256
				.NextMsgLZ(lz&127)
			  else
				.NextMsgAdd(lz|message|)
				
		memory.Free(.UserTable)
		.UserTableEnd = nil
		.UserTable = nil
		.UserTableCurr = nil
	
	  else
		error (self, _jBinNotJbin)

	.UserObj = nil


helper stringstream.NextMsgInfo2 (|uint64|)
	opt norefcounts
	while (self)
		|uint| info = .Byte
		if info & 128
			expect (.UserTable) (self, "Can't stream compacted jbin. Use .parse instead")
			return info
		if info == 0 :   continue
		|| T = (info >> 1)|syntax|
		expect (t < @max and T > @nil) (self, "Corrupted jbin")

		ifn (info & 1) and t.NoChildren
			|| msg = .UserObj|message|.msg(t, .str(.hInt))|uint64|
			if info & 1
				.userobj = msg|object|
			return msg
		  else
			.UserObj = .UserObj|message|.upward(t|int|-7)			#require



helper stringstream.ExpectJbin (|bool|)
	// remove this func :) only decompressinto needs it!
	|| Header = .str(4)
	if header == _JbinHeader
		rz = true
	  else
		error (self, _jBinNotJbin)


helper stringstream.Parse_Jbin (|bool| Burst = false, |MessageRoot|)	
	require .expectjbin
	
	.UserObj = nil
	|| root = .NextMsginfo				// just avoid refcounting
	while .NextMsginfo
	.UserObj = nil

	return root|messageroot|
	

function string.parse_jbin (|message|)
	return .Stream.Parse_Jbin

function string.IsJbin (|bool|)
	return self starts _JbinHeader

function string.digest (|string|)
	if .IsJbin
		return self
	return .parse$.render_jbin

