
// jbin: streamable, binary jeebox

/* 
	Future improvement... allocate one block at a time! Can call constructor on each object
	Just need a Curr+Last pointer.
*/


|| _JbinHeader     = "\01\10\EA\E2"     /// can't put a constant in a role? 
|| _jBinNotJbin    = "Not jbin"


extend message
	render RenderJbin (|string| shell_path = "")
		opt norefcounts
		require self
		|| js = fs|jbin|
		if shell_path
			js.sheb(shell_path)
		js <~ _JbinHeader
		.render_jbin_sub(js)
	
	
	helper render_jbin_sub (|jbin| js)
		opt norefcounts
		|| ch	 = self
		|| after = .FlatAfter
		while ch and ch != after
			|| Depth	= 0
			|| curr		= ch
			ch			= curr.FlatNextDepth(depth)
			js.Add(curr.func, curr.name, depth > 0)
			js.up(-depth)
	

role JBin (Faststring)
	linkage: cpp_part bin
	constructor         (|syntax| type=@arg, |string| data="")
		cpp_part Constructor
		 self <~ _JbinHeader
		.enter(type, data)
	constructor (|int| n)
		cpp_part Constructor0
		if n // what?
	function Enter		(|syntax| type=@arg, |string| data="")
		.add(type, data, true)
	function AddStr		(|string| data)
		.add(@str, data)
	function AddInt		(|int64| data)
		.add(@num, data.render)
	function Add		(|syntax| type, |string| data="", |bool|into = false)
		|| L = data.length
		|| addr = (data.addr, nil)(L)
		.addmemory(type, addr, into, L)
	function Add		(|syntax| type, |faststring| fs, |bool|into = false)
		cpp_part AddFS
		.addmemory(Type, fs.resultptr, into, fs.length)


	function AddComp (|faststring| fs, |int| strength=mzlab.strongest)
		if strength > 0
			|| Place = .OpenSection
			fs.compressinto(self, strength)
			.CloseSection(Place)
		  else
			.add(@str, fs)
		
	function Sheb		(|string| data)
		self <~ '#'
		self <~ '!'
		self <~ data
		self <~ '\n' // noice

	function Up (|int| amount = 1)
		|| add = 239
		while amount > 0
			|| B  = (add + amount)  min  (255)
			self    <~ B|byte|
			amount  -= (B-add)

	function AddCstring (|syntax| type=@str, |cstring| data)
		.addmemory(type, data|&byte|, false, data.length)
	
	function AddMemory (|syntax| type, |&byte| data, |bool| GoIn, |uint64| L)
		|uint| T = (type|uint|<<1) ||| (goin)
		self <~ T|byte|
		.hint(L)
		if data
			.AppendMemory(data, L|int|)


	function OpenSection  (|int|)				// openstream 
		.NoFlush ++
		.length += 6
		return .length

	function CloseSection (|uint| c)			// closestream
		|| CurrLen = .length
		expect (CurrLen >= c) (self, "Unable to close section")
		.length = c - 6
		|| blen = 5
		c = CurrLen - c
		|| Actual = c
		while {
			Actual >>= 7
			blen--
		} (Actual)

		self <~ (0|byte|, blen) 
		self <~ (@bin|int|<<1)|byte|
		.hint(c)
		.length = CurrLen
		.NoFlush--


function StringReader.NextMsg (|message| parent=nil, |syntax| fn, |string| name=nil,  |Message|)
	cpp_part NextMsgExpect
	opt norefcounts
	rz = .NextMsg #require
	expect (rz.expect(fn, name) and (rz.parent == parent)) (rz)


helper StringReader.NextMsg (|message|)
	return .nextmsginfo|message|


helper StringReader.NextMsgInfo (|uint64|)
	opt norefcounts
	|| Msg = .UserObj|message|
	|int| info
	while 
		info = .NonZeroByte
		loop info > 239
		msg = Msg.upward(info - 239)
		.userobj = msg, require msg

	|| T = (info >> 1)|syntax|
	if (t < @max and T > @nil) // 01 --> T=@nil
		msg = msg.msg(t, .str(.hInt))			
		if info & 1
			.userobj = msg
		return msg|uint64|
	
	expect (T > @nil) (self, "StringReader.IsJBin was not called.")
	error (self, "Corrupted jbin")


function StringReader.IsJBin (|bool|)
	return .str(4).IsJbin
	
	
function StringReader.ParseJbin (|int64| Remain=int64.max, |MessageRoot|)	
	expect .IsJBin (Self, _jBinNotJbin )
	.UserObj = nil
	rz = .NextMsg
	while --Remain > 0
		loop .NextMsginfo
	
	if .Data.ErrorReported
		rz = nil // be consistant with .parse!
	

function string.ParseJbin (|int64| max=int64.max, |messageroot|)
	return .Stream.ParseJbin(max)

function string.IsJbin (|bool|)
	if self starts _JbinHeader
		return true

function string.Digest (|string|)
	if .IsJbin
		return self
	return .parse$.renderjbin

