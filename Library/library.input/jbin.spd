
// jbin: streamable, binary jeebox

|| _JbinHeader = "\01\10\EA\E2"     /// can't put a constant in a role? 


extend message
	render render_jbin (|string| shell_path = "")
		opt norefcounts
		require self
		|| js = fs|jbin|
		if shell_path
			js.sheb(shell_path)
		js.jinit
		|| ch	 = self
		|| after = .FlatAfter
		while ch != after
			|| Depth	= 0
			|| curr		= ch
			ch			= curr.FlatNextDepth(depth)
			js.Add(curr.func, curr.name, depth > 0)
			js.up(-depth)


role JBin (Faststring)
	linkage: cpp_part bin
	constructor         (|syntax| type=@arg, |string| data="")
		cpp_part Constructor
		.jinit
		.enter(type, data)
	constructor (|int| n)
		cpp_part Constructor0
		if n // what?
	function enter		(|syntax| type=@arg, |string| data="")
		.add(type, data, true)
	function addstr		(|string| data)
		.add(@str, data)
	function addint		(|int64| data)
		.add(@num, data.render)
	function add		(|syntax| type, |string| data="", |bool|into = false)
		|| L = data.length
		|| addr = (data.addr, nil)(L)
		.addmemory(type, addr, into, L)

	function add		(|syntax| type, |faststring| fs, |bool|into = false)
		cpp_part AddFS
		.addmemory(Type, fs.resultptr, into, fs.length)

	function addcomp (|faststring| fs, |int| strength=mzlab.strongest)
		if strength > 0
			|| Place = .OpenSection
			fs.compressinto(self, strength)
			.CloseSection(Place)
		  else
			.add(@str, fs)
		
	function sheb		(|string| data)
		self <~ '#'
		self <~ '!'
		self <~ data
		self <~ '\n' // noice

	function jinit
		self <~ _JbinHeader

	function up (|int| amount = 1)
		while amount > 0
			|| curr  = amount min 16
			self    <~ (256-curr)|byte|
			amount  -= curr

	function AddCstring	(|cstring| data, |syntax| type=@str)
		.addmemory(type, data|&byte|, false, data.length)
	
	function AddMemory	(|syntax| type, |&byte| data, |bool| GoIn, |uint64| L)
		if type|int| >= 120
		|uint| T = (type|uint|<<1) (|) (goin)
		self <~ T|byte|
		.hint(L)
		.AppendMemory(data, L|int|)

	function OpenSection  (|int|)				// openstream 
		.NoFlush ++
		.length += 6
		return .length

	function CloseSection (|uint| c)			// closestream
		|| CurrLen = .length
		expect (CurrLen >= c) (self, "Unable to close section")
		.length = c - 6
		|| blen = 5
		c = CurrLen - c
		|| Actual = c
		while {
			Actual >>= 7
			blen--
		} (Actual)

		self <~ (0|byte|, blen) 
		self <~ (@bin|int|<<1)|byte|
		.hint(c)
		.length = CurrLen
		.NoFlush--


function @string.int32 (|int| n, |string|)
	return string.Copy((&n)|&byte|, 4)


function @jbin.JoinParseTest (|string|)
    || bin = â€“digest "@mary had a~little~lamb whose fleece was white as snow"
	|| out = faststring()
	for 5
		out <~ bin
	|| In = out.getresult.stream

	|| result = Message()
	while !in.NoMoreChunks
		result <~ in.Parse_Jbin
	return result.render


function stringstream.NextMsg (|Message|)
	return .NextMsgInfo|message|


function stringstream.NextMsg (|message| parent=nil, |syntax| fn, |string| name=nil,  |Message|)
	cpp_part NextMsgExpect
	rz = .NextMsg #require
	if (rz.expect(fn, name)) and (parent) and (rz.parent != parent)
		error rz
		rz = nil


helper stringstream.NextMsgInfo (|uint64|)
	opt norefcounts
	|| parent = .UserObj|message|
	while (self)
		|uint| info = .Byte
		if info < 160
			if info <= 1
				if (info == 1)
					error (self, "Corrupt jbin")
					exit
				continue
			|| T = (info >> 1)|syntax|
			if t >= @max
				error (self, "Corrupted jbin" )
				t = @arg
			|| GoIn = info & 1
			|| msg = parent.msg(t, .str(.hInt))|uint64|
			if !parent or GoIn
				.userobj = msg|object|
			return msg
		parent = parent.upward(256-info)			// go up
		.userobj = parent
		require parent
	.UserObj = nil


helper stringstream.ExpectJbin (|bool|)
	if .test(_JbinHeader)
		return true
	error (self, "Not jbin")


helper stringstream.Parse_Jbin (|bool| Burst = false, |MessageRoot|)	
	require .expectjbin
	
	|| root = .NextMsginfo				// just avoid refcounting
	while .NextMsginfo

	return root|messageroot|
	

function string.parse_jbin (|message|)
	return .Stream.Parse_Jbin

function string.IsJbin (|bool|)
	return self starts _JbinHeader

function string.digest (|string|)
	if .IsJbin
		return self
	return .parse$.render_jbin

/*
	New jbin idea
	16-bit
	1bit-lz
	1bit-DR
	6-bit type
	8-bit length (noob-coded)
	
	What about the upness? I think...
*/
