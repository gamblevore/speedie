
// jbin: streamable, binary jeebox


extend message
	render RenderJbin (|string| shell_path = "")
		opt norefcounts
		require self
		|| js = fs|jbin|
		js.RunHeader(shell_path)
		.render_jbin_sub(js)
	
	libinternal render_jbin_sub (|jbin| js)
		opt norefcounts
		|| ch	 = self
		|| after = .FlatAfter
		while ch and ch != after
			|| Depth	= 0
			|| curr		= ch
			ch			= curr.FlatNextDepth(depth)
			js.Add(curr.func, curr.name, depth > 0)
			js.exit(-depth)



role JBin (Faststring)
	module
		|| Header     = "\01\10\EA\E2"

	linkage: cpp_part bin

	constructor         	(|syntax| type=@arg, |string| name="")
		cpp_part Constructor
		self <~ Jbin.Header
		.enter(type, name)
	
	constructor (|int| n)
		disabled `Use jbin(@syx, "name")`
		cpp_part Constructor0

	function Enter			(|syntax| type=@arg, |string| name="", |jbinleaver|)
		return .add(type, name, true)

	function ExitAll
		cpp_Part Exit0
		.Exit(.indent)
	
	function Exit			(|int| Amount=1, |int|)
		.Indent = (.Indent - amount) max 0
		|| Add = 239
		while amount > 0
			rz++
			|| B  = (add + amount)  min  (255)
			self    <~ B|byte|
			amount  -= (B-add)

	function TmpArg			(|string| name, |jbinLeaver|)
		.Enter(@tmp, name)
		.Enter(@arg)
		return 2

	function RunHeader     (|string| name)
		if name
			self <~ '#'
			self <~ '!'
			self <~ name
			self <~ '\n' // noice
		self <~ Jbin.Header
	
	function AddStr			(|string| name)
		.add(@str, name)
	
	function AddInt			(|int64| name)
		.add(@num, name.render)

	function AddRow			(|string| Row, |syntax| type, |string| Value)
		.enter(@msg, row)
		.AddMemory(type, value.length, false, value.addr)
		.exit
	
	function Add			(|syntax| type, |string| name="", |bool|into = false, |jbinleaver|)
		return .AddMemory(type, name.length, into, name.addr)
	
	function Add			(|syntax| type, |faststring| fs, |bool|into = false, |jbinleaver|)
		cpp_part AddFS
		return .add(Type, fs|string|, into)

	function AddCString		(|syntax| type=@str, |cstring| name)
		.AddMemory(type, name.length, false, name|&byte|)

	function AddMemory		(|syntax| type, |int| L, |bool| GoIn, |&byte| data, |jbinleaver|)
		.WriteType(type, goin)
		.AppendHInt(L)
		.AppendMemory(data, L)
		return goin|int|

	function WriteType	(|syntax| type, |bool| GoIn=false)
		|| T = (type|int|<<1) ||| (goin)
		self <~ T|byte|
		.Indent += goin

//	function ReserveMemory (|syntax| type, |int| L, |bool| GoIn=false, |&byte|)
//		.WriteType(type, goin)
//		.AppendHInt(L)
//		return .Reserve(L)	

	function StartAdd (|int|)
		self <~ (0|byte|, 5)
		return .Length
		
	function FinishAdd (|syntax| Ty, |int| Start, |int|)
		|| NewLength = .Length
		|| Gained = NewLength - Start
		|| HLength = Gained|uint64|.hintlength
		.Length = Start-5
		self <~ (0|byte|, 5-(hlength+1))
		self <~ (ty|int|<<1)|byte|
		.AppendHInt(Gained)
		self|faststring|.Length = NewLength // shouldn't be necessary
		return Gained
	
	function uint64.HintLength (|int|)
		rz = 1
		while self >= 128
			self = self >> 7
			rz++


libinternal InputStream.NextMsgInfo (|uint64|)
	opt norefcounts
	|| Msg = ._Object|message|
	|int| info
	while 
		info = .NonZeroByte
		loop info > 239
		msg = Msg.upward(info - 239)
		._Object = msg, require msg

	|| T = (info >> 1)|syntax|
	if (t < @max  and  T > @nil)					// 01 --> T=@nil
		msg = msg.msg(t, .str(.HInt))			
				
		if info & 1
			._Object = msg
		|| cb = .CallBack
		if !cb // common case
			return msg|uint64|
		(cb)(msg)
		return msg|uint64|

	._Object = nil
	if info >= 0
		expect (T > @nil) (self, "InputStream.IsJBin was not called.")
		error (self, "Corrupted jbin")


function InputStream.StreamJbin (|int64| Remain=1G, |MessageRoot|)	
	if .Eat("#!") == 2				 // shebang
		.Find('\n')
	expect (.HasHeader(Jbin.Header))  (Self, "Parsed data lacks jbin header.")

	._Object = nil
	|| Root = .NextMsgInfo|message|
	while --Remain > 0
		loop .NextMsginfo
	
	if .Data.WentBad and !.TryRecoverBadData
		Root = nil // be consistant with .parse!
	return Root
	

function string.ParseJbin (|int64| max=1G, |messageroot|)
	|| s = .stream
	|messageroot--| msg = s.StreamJbin(max)
	return msg


function string.Digest (|string|)
	if .IsJbin
		return self
	return .parse$.renderjbin



