
// jbin: streamable, binary jeebox

/* 
	Leave this as it is right now.
	One day hol can be used instead of the compressed jbin.
	Just keep this for reference... like "hol should parse just as fast"
	No reason it shouldn't!
	
	For now, don't consider jbin a storage format! Its just a speed-increasing format.
	Like a cache...
	
	Because the format will probably change.
	
	Future improvement... allocate one block at a time! Can call constructor on each object
	Just need a Curr+Last pointer.
	
	
*/


|| _JbinHeader     = "\01\10\EA\E2"     /// can't put a constant in a role? 
|| _jBinNotJbin    = "Not jbin"


extend message
	render RenderJbin (|string| shell_path = "")
		opt norefcounts
		require self
		|| js = fs|jbin|
		if shell_path
			js.sheb(shell_path)
		js <~ _JbinHeader
		.render_jbin_sub(js)
			
	helper render_jbin_sub (|jbin| js)
		opt norefcounts
		|| ch	 = self
		|| after = .FlatAfter
		while ch != after
			|| Depth	= 0
			|| curr		= ch
			ch			= curr.FlatNextDepth(depth)
			js.Add(curr.func, curr.name, depth > 0)
			js.up(-depth)

// this will do.
/*
	helper jbin.AddCompressed (|message| Curr, |&MessageCompressor| D, |bool| Down, |bool|)
		opt norefcounts  // now what? detect
		|| back = d.Find(curr)								#require
		|| info = ((d.position - back.Tag)-1 << 1) (|) Down
		if info < 112
			self <~ ((info+15)(|)128)|byte|
		  else
			self <~ ((info&15)(|)128)|byte|
			.hint(info>>4)
		return true
*/
	

role JBin (Faststring)
	linkage: cpp_part bin
	constructor         (|syntax| type=@arg, |string| data="")
		cpp_part Constructor
		 self <~ _JbinHeader
		.enter(type, data)
	constructor (|int| n)
		cpp_part Constructor0
		if n // what?
	function Enter		(|syntax| type=@arg, |string| data="")
		.add(type, data, true)
	function AddStr		(|string| data)
		.add(@str, data)
	function AddInt		(|int64| data)
		.add(@num, data.render)
	function Add		(|syntax| type, |string| data="", |bool|into = false)
		|| L = data.length
		|| addr = (data.addr, nil)(L)
		.addmemory(type, addr, into, L)
	function Add		(|syntax| type, |faststring| fs, |bool|into = false)
		cpp_part AddFS
		.addmemory(Type, fs.resultptr, into, fs.length)


	function AddComp (|faststring| fs, |int| strength=mzlab.strongest)
		if strength > 0
			|| Place = .OpenSection
			fs.compressinto(self, strength)
			.CloseSection(Place)
		  else
			.add(@str, fs)
		
	function Sheb		(|string| data)
		self <~ '#'
		self <~ '!'
		self <~ data
		self <~ '\n' // noice

	function Up (|int| amount = 1) // we encode the upness in the range of syntax values that have no children
		|| add = (@cnj|int|)-1
		while amount > 0
			|| expr  = (add + amount)  min  (@bin|int|)
			self    <~ ((expr<<1) (|) 1)|byte|
			amount  -= (expr-add)

	function AddCstring	(|cstring| data, |syntax| type=@str)
		.addmemory(type, data|&byte|, false, data.length)
	
	function AddMemory	(|syntax| type, |&byte| data, |bool| GoIn, |uint64| L)
		|uint| T = (type|uint|<<1) (|) (goin)
		self <~ T|byte|
		.hint(L)
		.AppendMemory(data, L|int|)


	function OpenSection  (|int|)				// openstream 
		.NoFlush ++
		.length += 6
		return .length

	function CloseSection (|uint| c)			// closestream
		|| CurrLen = .length
		expect (CurrLen >= c) (self, "Unable to close section")
		.length = c - 6
		|| blen = 5
		c = CurrLen - c
		|| Actual = c
		while {
			Actual >>= 7
			blen--
		} (Actual)

		self <~ (0|byte|, blen) 
		self <~ (@bin|int|<<1)|byte|
		.hint(c)
		.length = CurrLen
		.NoFlush--


function StringReader.NextMsg (|Message|)
	return .NextMsgInfo|message|


function StringReader.NextMsg (|message| parent=nil, |syntax| fn, |string| name=nil,  |Message|)
	cpp_part NextMsgExpect
	opt norefcounts
	rz = .NextMsg #require
	expect (rz.expect(fn, name) and (rz.parent == parent)) (rz)


helper StringReader.NextMsgInfo (|bool| CanDecomp=false, |uint64|)
	opt norefcounts
	while
		|uint| info = .Byte
//		if info & 128
//			expect (CanDecomp) (self, "Can't stream compacted jbin. Use .parse instead")
//			return info
		if info == 0 :   continue
		|| T = (info >> 1)|syntax|
		if (t >= @max or T <= @nil)
			expect (T > @nil) (self, "jbin header was not pre-loaded.")
			expect (false)	  (self, "Corrupted jbin")

		ifn (info & 1) and t.NoChildren
			|| msg = .UserObj|message|.msg(t, .str(.hInt))|uint64|
			if info & 1
				.userobj = msg|object|
			return msg
		  else
			.UserObj = .UserObj|message|.upward(t|int|-7)
			require .userobj

/*
helper StringReader.NextMsgLZ (|&messagedecompressor| D, |uint| Info)
	opt norefcounts
	if Info < 16
		Info |= .hInt << 4
	  else
		Info -= 15
	|| Index  = Info >> 1
	|| Ref    = D.curr-(Index+1)
	expect (ref >= D.Table and ref < d.curr) (self, "Corrupted jbin")
	|| r      = *ref
	|| p      = .userobj|message|
	|| Msg    = p.msg(r.func, r.name)
	if Info & 1
		.UserObj = msg
*/


function StringReader.IsJBin (|bool|)
	return .str(4).IsJbin
	
	
function StringReader.Parse_Jbin (|MessageRoot|)	
	expect .IsJBin (Self, _jBinNotJbin )
	.UserObj = nil
	rz = .NextMsginfo|messageroot|
	while .NextMsginfo
	.UserObj = nil
	

function string.ParseJbin (|messageroot|)
	return .Stream.Parse_Jbin

function string.IsJbin (|bool|)
	if self starts _JbinHeader
		return true

function string.Digest (|string|)
	if .IsJbin
		return self
	return .parse$.renderjbin

