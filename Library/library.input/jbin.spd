
// jbin: streamable, binary jeebox

|| _JbinHeader = "\10\03" // ugh 
/// can't put a constant in a role? 


extend message
	render render_jbin (|string| execute = "")
		opt norefcounts
		require self
		|| js = fs|jbin|
		if execute
			js.sheb(execute)
		js.jinit
		|| ch	 = self
		|| after = .FlatAfter
		while ch != after
			|| Depth	= 0
			|| curr		= ch
			ch			= ch.FlatNextDepth(depth)
			js.Add(curr.func, curr.name, depth > 0)
			js.up(-depth)


role JBin (Faststring)
	linkage: cpp_part bin
	constructor         (|syntax| type=@arg, |string| data="")
		cpp_part Constructor
		.jinit
		.enter(type, data)
	constructor (|int| n)
		cpp_part Constructor0
		if n // what?
	function enter		(|syntax| type=@arg, |string| data="")
		.add(type, data, true)
	function addstr		(|string| data)
		.add(@str, data)
	function addint		(|int64| data)
		.add(@num, data.render)
	function add		(|syntax| type, |string| data="", |bool|into = false)
		|| L = data.length
		|| addr = (data.addr, nil)(L)
		.addmemory(type, into, addr, L)

	function sheb		(|string| data)
		self <~ '#'
		self <~ '!'
		self <~ data
		self <~ '\n' // noice

	function jinit
		self <~ _JbinHeader

	function up (|int| amount = 1)
		while amount > 0
			|| less  = amount min 63
			self    <~ (less(|)192)|byte|
			amount  -= less

	function AddCstring	(|cstring| data, |syntax| type=@str)
		.addmemory(type, false, data|&byte|, data.length)
	
	function AddMemory	(|syntax| type, |bool| GoIn, |&byte| data, |uint64| L)
		|uint| info = 128 >> goin
		|| L2 = (L|int|, 60+L.lelength)(L < 60)
		self <~ (info (|) L2)|byte|
		if L >= 60
			.lint(L)
		self <~ type|byte|
		if data // so .openstream can stream unknown data-length  
			.AppendMemory(data, L|int|)

	function OpenStream	(|int|)
		.AddMemory(@bin, false, nil, 1GB)
		return .length

	function CloseStream (|int| c)
		|| nwe = .length
		.length = c - 6
		self <~ 191|byte|
		.AppendInt(nwe - c)
		self <~ (@bin)|byte|
		.length = nwe


function stringstream.NextMsg (|Message|)
	return .NextMsgInfo|message|

helper stringstream.NextMsgInfo (|uint64|)
	opt norefcounts
	|| parent = .UserObj|message|
	while (self)
		|uint| info = .Byte
		|| L	= info & 63
		|| Dir	= info >> 6							// 3 = up,  2 = same,  1 = down :)
		if Dir != 3
			if L >= 60
				L = .lint0(L - 60)|uint|
			|| t = .byte
			if t > @bin|int|						// need @max
				error (.data, "Corrupted jbin" )
				t = @arg
			|| msg = parent.msg(t|syntax|, .str(L))|uint64|
			if !parent or dir == 1
				.userobj = msg|object|
			return msg
		parent = parent.upward(L) // go up
		.userobj = parent
		require parent
	.UserObj = nil


helper stringstream.Parse_Jbin (|MessageRoot|)	
	expect .test(_JbinHeader)  (self, "Not jbin")
	
	(message).BoostMode = true
	|| root = .NextMsginfo				// just avoid refcounting
	while (.NextMsginfo)
	(message).BoostMode = false

	return root|messageroot|
	

function string.parse_jbin (|message|)
	return .Stream.Parse_Jbin

function string.IsJbin (|bool|)
	return self starts _JbinHeader

function string.digest (|string|)
	if .IsJbin
		return self
	return .parse$.render_jbin

