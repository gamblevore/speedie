
// jbin: streamable, binary jeebox

|| _JbinHeader = "\10\03" // ugh 
/// can't put a constant in a role? 


extend message
	render render_jbin (|string| shell_path = "")
		opt norefcounts
		require self
		|| js = fs|jbin|
		if shell_path
			js.sheb(shell_path)
		js.jinit
		|| ch	 = self
		|| after = .FlatAfter
		while ch != after
			|| Depth	= 0
			|| curr		= ch
			ch			= curr.FlatNextDepth(depth)
			js.Add(curr.func, curr.name, depth > 0)
			js.up(-depth)


role JBin (Faststring)
	linkage: cpp_part bin
	constructor         (|syntax| type=@arg, |string| data="")
		cpp_part Constructor
		.jinit
		.enter(type, data)
	constructor (|int| n)
		cpp_part Constructor0
		if n // what?
	function enter		(|syntax| type=@arg, |string| data="")
		.add(type, data, true)
	function addstr		(|string| data)
		.add(@str, data)
	function addint		(|int64| data)
		.add(@num, data.render)
	function add		(|syntax| type, |string| data="", |bool|into = false)
		|| L = data.length
		|| addr = (data.addr, nil)(L)
		.addmemory(type, addr, into, L)

	function add		(|syntax| type, |faststring| fs, |bool|into = false)
		cpp_part AddFS
		.addmemory(Type, fs.resultptr, into, fs.length)

	function sheb		(|string| data)
		self <~ '#'
		self <~ '!'
		self <~ data
		self <~ '\n' // noice

	function jinit
		self <~ _JbinHeader

	function up (|int| amount = 1)
		while amount > 0
			|| less  = amount min 63
			self    <~ (less(|)192)|byte|
			amount  -= less

	function AddCstring	(|cstring| data, |syntax| type=@str)
		.addmemory(type, data|&byte|, false, data.length)
	
	function AddMemory	(|syntax| type, |&byte| data, |bool| GoIn, |uint64| L)
		|uint| info = 128 >> goin
		|| L2 = (L|int|, 60+L.lelength)(L < 60)
		self <~ (info (|) L2)|byte|
		if L >= 60
			.lint(L)
		self <~ type|byte|
		if data // so .opensection can stream unknown data-length  
			.AppendMemory(data, L|int|)

	function OpenSection	(|int|)			// openstream 
		.NoFlush ++
		.AddMemory(@bin, nil, false, 1GB)
		return .length

	function CloseSection (|int| c)			// closestream
		|| nwe = .length
		expect (nwe >= c) (self, "Unable to close section")
		.length = c - 6
		self <~ 191|byte|
		.AppendInt(nwe - c)
		self <~ (@bin)|byte|
		.length = nwe
		.NoFlush--


function @string.int32 (|int| n, |string|)
	return string.Copy((&n)|&byte|, 4)


function @jbin.JoinParseTest (|string|)
    || bin = â€“digest "@mary had a~little~lamb whose fleece was white as snow"
	|| out = faststring()
	for 5
		out <~ bin
	|| In = out.getresult.stream

	|| result = Message()
	while !in.NoMoreChunks
		result <~ in.Parse_Jbin
	return result.render


function @jbin.ParseSpeedTest (|int| Count=10000000) 
	.JoinParseTest
    
    || p = "/tmp/jbin_demo.jbin"
	|jbin| out = p.out 
	out.jinit
	out.enter
	
    "Creating $Count nodes at '$p'"
	for n in Count
		if n isa 2
			out.add(@str, string.int32(n))
		  else
			out.add(@str, "") // half the nodes usually have no name
	out = nil

	|int| sz = p.file.size
	|| strsize = sz.strsize
	"Size: $strsize"
	
	|| In = p.in

	|| start = date.now
	|| result = in.Parse_Jbin	#require
	|| t = (date.now - start).seconds
	|| node_rate = (1000000000.0 * t)/Count|f64|
	|| size_rate = (sz|f64|/1MB|f64|)/t
	"parsed_in: ${t}s
duration: ${node_rate}ns / node
parse_rate: ${size_rate}MB / s
"
	 

function stringstream.NextMsg (|Message|)
	return .NextMsgInfo|message|


function stringstream.NextMsg (|message| parent=nil, |syntax| fn, |string| name=nil,  |Message|)
	cpp_part NextMsgExpect
	rz = .NextMsg #require
	if (rz.expect(fn, name)) and (parent) and (rz.parent != parent)
		error rz
		rz = nil


helper stringstream.NextMsgInfo (|uint64|)
	opt norefcounts
	|| parent = .UserObj|message|
	while (self)
		|uint| info = .Byte
		|| L	= info & 63
		|| Dir	= info >> 6							// 3 = up,  2 = same,  1 = down :)
		if Dir != 3
			if L >= 60
				L = .lint0(L - 60)|uint|
			|| t = .byte
			if t > @bin|int|						// need @max
				error (.data, "Corrupted jbin" )
				t = @arg
			|| msg = parent.msg(t|syntax|, .str(L))|uint64|
			if !parent or dir == 1
				.userobj = msg|object|
			return msg
		parent = parent.upward(L) // go up
		.userobj = parent
		require parent
	.UserObj = nil


helper stringstream.ExpectJbin (|bool|)
	if .test(_JbinHeader)
		return true
	error (self, "Not jbin")


helper stringstream.Parse_Jbin (|bool| Burst = false, |MessageRoot|)	
	require .expectjbin
	
	|| root = .NextMsginfo				// just avoid refcounting
	while .NextMsginfo

	return root|messageroot|
	

function string.parse_jbin (|message|)
	return .Stream.Parse_Jbin

function string.IsJbin (|bool|)
	return self starts _JbinHeader

function string.digest (|string|)
	if .IsJbin
		return self
	return .parse$.render_jbin

