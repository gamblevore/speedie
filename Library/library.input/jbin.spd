
// jbin: streamable, binary jeebox

/* 
	Leave this as it is right now.
	One day hol can be used instead of the compressed jbin.
	Just keep this for reference... like "hol should parse just as fast"
	No reason it shouldn't!
	
	For now, don't consider jbin a storage format! Its just a speed-increasing format.
	Like a cache...
	
	Because the format will probably change.
	
	Future improvement... allocate one block at a time! Can call constructor on each object
	Just need a Curr+Last pointer.
	
	
*/


|| _JbinHeader     = "\01\10\EA\E2"     /// can't put a constant in a role? 
|| _JbinHeaderComp = "\01\11\EA\E2"
|| _jBinNotJbin    = "Not jbin"


extend message
	render render_jbin (|bool| Compress=false, |string| shell_path = "")
		opt norefcounts
		require self
		|| js = fs|jbin|
		if shell_path
			js.sheb(shell_path)
		if Compress
			|MessageCompressor| D
			js <~ _JbinHeaderComp
			.render_jbin_sub(js,   d)
		  else
			js <~ _JbinHeader
			.render_jbin_sub(js, nil)
			
	helper render_jbin_sub (|jbin| js, |&MessageCompressor| D)
		opt norefcounts
		|| ch	 = self
		|| after = .FlatAfter
		while ch != after
			|| Depth	= 0
			|| curr		= ch
			ch			= curr.FlatNextDepth(depth)
			if !D or !js.AddCompressed(curr, D, depth > 0)
				js.Add(curr.func, curr.name, depth > 0)
			js.up(-depth)

// this will do.

	helper jbin.AddCompressed (|message| Curr, |&MessageCompressor| D, |bool| Down, |bool|)
		opt norefcounts  // now what? detect
		|| back = d.Find(curr)								#require
		|| info = ((d.position - back.Tag)-1 << 1) (|) Down
		if info < 112
			self <~ ((info+15)(|)128)|byte|
		  else
			self <~ ((info&15)(|)128)|byte|
			.hint(info>>4)
		return true
		

role JBin (Faststring)
	linkage: cpp_part bin
	constructor         (|syntax| type=@arg, |string| data="")
		cpp_part Constructor
		 self <~ _JbinHeader
		.enter(type, data)
	constructor (|int| n)
		cpp_part Constructor0
		if n // what?
	function enter		(|syntax| type=@arg, |string| data="")
		.add(type, data, true)
	function addstr		(|string| data)
		.add(@str, data)
	function addint		(|int64| data)
		.add(@num, data.render)
	function add		(|syntax| type, |string| data="", |bool|into = false)
		|| L = data.length
		|| addr = (data.addr, nil)(L)
		.addmemory(type, addr, into, L)
	function add		(|syntax| type, |faststring| fs, |bool|into = false)
		cpp_part AddFS
		.addmemory(Type, fs.resultptr, into, fs.length)

	function addcomp (|faststring| fs, |int| strength=mzlab.strongest)
		if strength > 0
			|| Place = .OpenSection
			fs.compressinto(self, strength)
			.CloseSection(Place)
		  else
			.add(@str, fs)
		
	function sheb		(|string| data)
		self <~ '#'
		self <~ '!'
		self <~ data
		self <~ '\n' // noice

	function up (|int| amount = 1) // we encode the upness in the range of syntax values that have no children
		|| add = (@cnj|int|)-1
		while amount > 0
			|| expr  = (add + amount)  min  (@bin|int|)
			self    <~ ((expr<<1) (|) 1)|byte|
			amount  -= (expr-add)

	function AddCstring	(|cstring| data, |syntax| type=@str)
		.addmemory(type, data|&byte|, false, data.length)
	
	function AddMemory	(|syntax| type, |&byte| data, |bool| GoIn, |uint64| L)
		|uint| T = (type|uint|<<1) (|) (goin)
		self <~ T|byte|
		.hint(L)
		.AppendMemory(data, L|int|)


	function OpenSection  (|int|)				// openstream 
		.NoFlush ++
		.length += 6
		return .length

	function CloseSection (|uint| c)			// closestream
		|| CurrLen = .length
		expect (CurrLen >= c) (self, "Unable to close section")
		.length = c - 6
		|| blen = 5
		c = CurrLen - c
		|| Actual = c
		while {
			Actual >>= 7
			blen--
		} (Actual)

		self <~ (0|byte|, blen) 
		self <~ (@bin|int|<<1)|byte|
		.hint(c)
		.length = CurrLen
		.NoFlush--


function stringstream.NextMsg (|Message|)
	return .NextMsgInfo|message|


function stringstream.NextMsg (|message| parent=nil, |syntax| fn, |string| name=nil,  |Message|)
	cpp_part NextMsgExpect
	rz = .NextMsg #require
	if (rz.expect(fn, name)) and (parent) and (rz.parent != parent)
		error rz
		rz = nil


helper stringstream.NextMsgInfo (|bool| CanDecomp=false, |uint64|)
	opt norefcounts
	while .hasany
		|uint| info = .Byte
		if info & 128
			expect (CanDecomp) (self, "Can't stream compacted jbin. Use .parse instead")
			return info
		if info == 0 :   continue
		|| T = (info >> 1)|syntax|
		if (t >= @max or T <= @nil)
			expect (T > @nil) (self, "jbin header was not pre-loaded.")
			expect (false)	  (self, "Corrupted jbin")

		ifn (info & 1) and t.NoChildren
			|| msg = .UserObj|message|.msg(t, .str(.hInt))|uint64|
			if info & 1
				.userobj = msg|object|
			return msg
		  else
			.UserObj = .UserObj|message|.upward(t|int|-7)			#require

	
helper stringstream.NextMsgLZ (|&messagedecompressor| D, |uint| Info)
	opt norefcounts
	if Info < 16
		Info |= .hInt << 4
	  else
		Info -= 15
	|| Index  = Info >> 1
	|| Ref    = D.curr-(Index+1)
	expect (ref >= D.Table and ref < d.curr) (self, "Corrupted jbin")
	|| r      = *ref
	|| p      = .userobj|message|
	|| Msg    = p.msg(r.func, r.name)
	if Info & 1
		.UserObj = msg


helper stringstream.Parse_Jbliz (|MessageRoot|)
	|MessageDecompressor| Decomp
	rz = .NextMsginfo|messageroot|
	Decomp <~ rz|message|
	while
		|| msg = .NextMsginfo(true) #loop
		if msg < 256
			.NextMsgLZ(decomp, msg & 127)
		  else
			loop Decomp <~ msg|message|


function stringstream.DetectJBinType (|int|)
	return .str(4).IsJbin
	
	
function stringstream.Parse_Jbin (|MessageRoot|)	
	.UserObj = nil
	|| T = .DetectJBinType
	if T == 1
		rz = .NextMsginfo|messageroot|
		while .NextMsginfo
	  elseif T == 2
		rz = .parse_jbliz
	  else
		error (self, _jBinNotJbin)

	.UserObj = nil
	

function string.parse_jbin (|message|)
	return .Stream.Parse_Jbin

function string.IsJbin (|int|)
	if self starts _JbinHeader
		return 1
	if self starts _JbinHeaderComp
		return 2

function string.digest (|string|)
	if .IsJbin
		return self
	return .parse$.render_jbin

