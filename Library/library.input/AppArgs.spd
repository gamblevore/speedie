

function string.ArgName (|string|)
	// "--Name=Value" --> "Name"
	// "--Name" --> "Name"
	if (self and self[] == '-') 
		|| i = .find( '=' ) ?? int.max
		|| S = self[ 0, i ]
		S = S.TrimFirst('-')
		return S.lowercase


function string.ArgValue (|string|)
	// "--Name=Value" --> "Value"
	// "--Name" --> ""
	// "Value" --> "Value"
	if self
		if (self[0] != '-')
			return self
	
		|| it = .find( '=' )
			return self[it + 1...]
		return "true"


function String.ArgSwitch (|string| name, |bool|)
	if .argName ~= name
		rz = .argvalue.yes

// The idea is... we want to have an array of arguments... that can be messages or strings:
	// * (name:)	  for switches:  --nocolor
	// * (name:value) for switches:  --level=3
	// * (value)	  for paths:	 "/usr/dir/filexx"



autogen @int.MainArg         (|int| Pos, |string| name, |int|)
	|| big = int64.mainarg(pos, name)
	expect (big <= int.max and big >= int.min) ("Int out of range")
	return big


autogen @int64.MainArg       (|int| Pos, |string| name,  |int64|)
	return string.MainArgSub(Pos, name, "integer")$.int


autogen @bool.MainArg        (|int| Pos, |string| name,  |bool|)
	return string.MainArgSub(Pos, name, "boolean")$.Yes


autogen @string.MainArg      (|int| Pos, |string| name, |string|)
	return string.MainArgSub(Pos, name, "string")


autogen @message.MainArg     (|int| Pos, |string| name, |message|)
	|| str = string.MainArgSub(Pos, name, "jeebox")
	ifn str contains '\n' // a file-path?
		|| s0 = str[]
		if (s0 == '/') or (s0 == '.' and str[1] == '/')
			return str.file.parse
	return str.parse


autogen @float.MainArg       (|int| Pos, |string| name, |Float64|)
	return string.MainArgSub(Pos, name, "float")$.float


autogen @file.MainArg		(|int| Pos, |string| name, |file|)
	|| str = string.MainArgSub(Pos, name, "file-path")
		if str == "-"
			rz = app.StdOut
		  else
			rz = str.file
	

autogen @FileSizeInt.MainArg (|int| Pos, |string| name,  |FileSizeInt|)
	return string.MainArgSub(Pos, name, "file-size")$.float(true)|FileSizeInt|


autogen @string.MainArgSub (|int| Pos,  |string| name,  |string| type,  |stringthatwasreadsafely|)
	// could remove "pos", and use array.mark?
	opt norefcounts
	|| str = app.args[pos.abs-1]
	if str != nil
		return str
	if (pos >= 0) and StdErr.ok
		|| usage = app.Usage
		error "Missing $name ($type).\n\n$usage"
	return string.Error

