

function string.ArgName (|string|)
	// "--Name=Value" --> "Name"
	// "--Name" --> "Name"
	if (self[] == '-') 
		|| i = .find( '=' ) ?? int.max
		|| S = self[ 0, i ]
		S = S.TrimFirst('-')
		return S.lowercase


function string.ArgValue (|string|)
	// "--Name=Value" --> "Value"
	// "--Name" --> ""
	// "Value" --> "Value"
	if (self[0] != '-')
		return self

	|| it = .find( '=' )
		return self[it + 1...]
	return "true"



role AppArgument (object)
	function Value (|String|)
		if (self isa string):  return .argValue
		if (self isa message): return .argValue
	
	function Name (|string|)
		if (self isa string):  return .argName
		if (self isa message): return .argName


// The idea is... we want to have an array of arguments... that can be messages or strings:
	// * (name:)	  for switches:  --nocolor
	// * (name:value) for switches:  --level=3
	// * (value)	  for paths:	 "/usr/dir/filexx"


function Message.ArgName (|string|)
	opt norefcounts
	require self == @item
	return .firstname.lowercase


function Message.ArgValue (|string|)
	opt norefcounts
	if (self == @item)
		return .second.name ?? "true"
	return .name



helper @int.MainArg         (|int| Pos, |string| name, |int|)
	|| big = int64.mainarg(pos, name)
	expect (big <= int.max and big >= int.min) ("Int out of range")
	return big

helper @int64.MainArg         (|int| Pos, |string| name,  |int64|)
	return string.MainArgSub(Pos, name, "integer")$.int

helper @bool.MainArg        (|int| Pos, |string| name,  |bool|)
	return string.MainArgSub(Pos, name, "boolean")$.Yes

helper @string.MainArg      (|int| Pos, |string| name, |string|)
	return string.MainArgSub(Pos, name, "string")

helper @message.MainArg     (|int| Pos, |string| name, |message|)
	return string.MainArgSub(Pos, name, "jeebox")$.parse

helper @float.MainArg       (|int| Pos, |string| name, |Float64|)
	return string.MainArgSub(Pos, name, "float")$.float

helper @file.MainArg		(|int| Pos, |string| name, |file|)
	return string.MainArgSub(Pos, name, "file-path")$.file

//extend_module File
// should be possible.
//	module Existing
//		helper MainArg (|int| Pos, |string| name, |file|)
//			return string.MainArgSub(Pos, name, "file-path")$.FileThatExists
//	module Jeebox
//		helper MainArg (|int| Pos, |string| name, |messageroot|)
//			return File.existing.MainArg(pos, name)$.parse
//	module Output
//		helper MainArg   (|int| Pos, |string| name, |faststring|)
//			return file.MainArg(pos, name)$.Out

helper @string.MainArgSub (|int| Pos,  |string| name,  |string| type,  |stringthatwasreadsafely|)
	// could remove "pos", and use array.mark?
	opt norefcounts
	|| str = app.args[pos.abs-1]
	if str != nil
		return str
	if (pos >= 0) and StdErr.ok
		|| usage = app.Usage
		error "Missing $name ($type).\n\n$usage"
	return string.Error


helper @FileSizeInt.MainArg (|int| Pos, |string| name,  |FileSizeInt|)
	|| size = string.MainArgSub(Pos, name, "file-size")$
	|Float64| Mul = 1.0
	|| T = size.length-2
	if size endswith "kb"
		mul = 1.0KB
	  elseif size endswith "mb"
		mul = 1.0MB
	  elseif size endswith "gb"
		mul = 1.0GB
	  else
		T+=2
	
	|| f = size[0, T].float
	return (f*mul)|FileSizeInt|

