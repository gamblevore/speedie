
/*
	Jeebox internals. By Theodore H. Smith...
*/


class Error (Message)
	linkage
		cpp_part	Err
		cpp_class	JB_Error
	
	contains	Error
	
	|String|				Path
	|String|				OriginalData
	|String|				StackTrace
	|message?|				Node
	|date|					When
	|ErrorSeverity|			Severity
	|ErrorFlags|			ErrorFlags

	constructor (|message?| node, |string| desc = "", |errorseverity| level=errorseverity.error, |string| path="" )
		visible
		super.constructor
		.position = -1
		.node = node
		.severity = level
		.name = desc // sigh
		.path = path
		.when = date.now
		.func = @sstr // whatever
		.UpgradeWithNode
	
	
	constructor
		cpp_part Nothing // Not an error actually.
		super.constructor
		.position = -1
		.severity = ErrorSeverity.ok
		.when = date.now
		.func = @arg


	constructor (|error| orig) 
		description "Error Copier" 
		cpp_Part Copy
		super.constructor
		.position = orig.position
		.node = orig.node
		.severity = orig.severity
		.name = orig.name // sigh
		.path = orig.path
		.OriginalData = orig.OriginalData
		.when = orig.when
		.func = @sstr // whatever
	
	
	function UpgradeWithNode
		opt norefcounts
		|| node = .node
		if !node
			node = BackupErrorSource
			require node
		.position = node.position

		if !.path
			.path = node.originalfilepath
		.OriginalData = node.OriginalParseData
		
		
	syntax is (|ErrorFlags| F, |bool|)
		return self and .ErrorFlags&F
		
	syntax is (|ErrorFlags|F, assigns:|bool|)
		if Value
			.ErrorFlags |= f
		  else
			.ErrorFlags &= ~F
	
	function LinePos (|string| data, |int|)
		if (.HasPosition)
			return data[ 0, .Position ].LineCount

	function HasPosition (|bool|)
		return .Position >= 0 
		
	function ShiftPosition (|int| i)
		opt norefcounts
		.position += i
		|| node = .node
			node.position += i
	
	
	function IsWarning (|bool|)
		return (.severity <= errorseverity.Warning)

	function IsBad (|bool|)
		return (.severity >= errorseverity.problem)

	function IsError (|bool|)
		return (.severity >= errorseverity.error)

	
	function Fill (|string| path, |string| desc)
		visible					// for lib
		.Path = path
		(self is PreferNoRenderPath) = desc contains path
		.name = desc 
	
	
	function GrabLine (|faststring| fs, |bool| Usecolor=false)
		if Usecolor
			fs <~ TerminalColor.Normal

		|| d = .OriginalData
		require d and .HasPosition

		fs <~ "\n"
		|| Start  = d.find( CharSet.Line, .Position, 0  ) + 1
		|| Finish = d.find( CharSet.Line, .Position...  )
		if (Finish == -1)
			Finish = D.Length + 1
		
		fs <~ d[Start, Finish].ReplaceAll("\t", " ")

		|| Spaces = (.Position - Start)
		if spaces > 200: spaces = 0 // stop bugs.
		
		fs <~ '\n'
		if Usecolor: fs <~ TerminalColor.Underline
		fs <~ (' ', Spaces)
		fs <~ '^'


	function WorseThan (|error| Other, |bool|)
		if !other
			return true
		return .severity > other.severity
	
	function LineIdentifiers (|faststring| fs, |string| path, |bool|)
		require (.HasPosition)
		|| d = .OriginalData #require

		if !path: fs <~ "line "
		fs <~ .LinePos( d )
		fs <~ ':'

		|| Start = d.find( CharSet.Line, .Position, 0 )
		fs <~ .Position - Start
		fs <~ ':'
		return true


	render Render
		fs <~ "error"
		++fs.indent
		fs.field( "", .name )
		if .position >= 0
			fs.field( "pos", .position )
		fs.field( "file", .path )
		fs.field( "severity", .severity )
		if .StackTrace
			fs.field( "stack", "" )
			++fs.indent
			for fn.lines in .stacktrace
				fs.field( "fn", fn )
			--fs.indent
		fs <~ "\n"
		--fs.indent


	render RenderUnix
		|| M = fs.mark
		|| p = .path
			if self isnt PreferNoRenderPath
				fs <~ .path
				fs <~ ":"
		
		if (!.LineIdentifiers(fs, P) and .node)
			.node.render(fs)
		
		if fs.mark > m
			fs <~ " "
		.severity.render(fs)
		fs <~ ": "
		fs <~ .name
		.GrabLine(fs)


	module
			
		|message|		BackupErrorSource
		|byte|			AutoPrint = 0 // errorflags.PrintAndRemove
		|bool|			KeepStackTrace = false



datatype ErrorFlags (Byte)
	flags
		|ErrorFlags|
		DontStrip
		PreferNoRenderPath
		Parse
	constants
		Keep = 0
		PrintAndKeep = 1
		PrintAndRemove = 2



datatype ErrorSeverity (Byte)
	render
		if (self < MaxError)
			|| name = errorseverity.InitNames[self|int|]
			if !fs_in
				if name != nil
					return name
				return ""
			if name
				fs_in <~ name
	
	syntax is (|errorseverity| e, |bool|)
		return self == e
		
	syntax Using (|errorseverity|)
		rz = StdErr.LowerErrorsTo
		StdErr.LowerErrorsTo = self

	syntax UsingComplete (|object| idk=nil)
		StdErr.LowerErrorsTo = self


	constants // Severity
		|ErrorSeverity|
		MaxError	= 6	    // dont use this!
		Critical	= 5		// Unrecoverable "OutOfMemory / signals / etc"  need to quit.
		Error		= 4		// parse errors, file not exists, etc.
		Problem		= 3		// always print these, but still continue
		Warning		= 2		// Its probably bad, and probably better corrected. 
		Hint		= 1		// We canâ€™t tell if its wrong, just letting you know if you want it fixed
		OK			= 0
	
	module
		|[string]| _ErrorNames = nil
	
		function InitNames (|[string]|)
			opt norefcounts
			return ._ErrorNames init "OK note warning problem error critical".words
		
		function Find (|string| name, |message| err=nil, |errorseverity|)
			opt norefcounts
			for (n in .InitNames) (i)
				if n ~= name
					return i
			if err
				error err

