

/*
	FlowControl system.
	Makes sure your code is rock solid, and works identical when porting from one system to another!
	Smash all bugs!
*/

		
class FlowControl 
	linkage:cpp_part Flow
	|FastBuff|				Buff
	|StringReader?|			ReadInput
	|faststring?| 			Write
	|bool| 					CanDoErrors

	constructor (|string| path)
		flow off
		.CanDoErrors = true
		.buff.needAlloc(1MB)
		.write = nil
		if .LoadPath(path)
			flowcontrol.Disabled = 0
		  else
			print "Cant load flow "
		printline path


	helper LoadPath	(|string| path, |bool|)
		flow off
		if (FlowControl.Active < FlowControl.Validate)
			print "Logging flow to "
			.write = path.out
			return true

		.ReadInput = path.ReadFile(16MB, false).Decompress.stream
		if .ReadInput.HasAny
			print "Validating flow against "
			return true
	
	
	helper Flush
		flow off
		if .write
			.buff.tmpstr.CompressInto(.write, stats)
		.buff.Curr = .buff.start
			 

	destructor
		flow off
		FlowControl.Disabled = int.max
		
		.flush
		if .ReadInput!=nil
			"Flow: Occurred equally."

	
	helper AddByte (|byte| value)
		flow off
		if .buff <~ value
			.Flush
		
	helper TestByte (|byte| value, |bool|)
		flow off, opt norefcounts, visible

		.AddByte(value)
		|| r = .ReadInput
		if r == nil
			return true
		|| b = r.byte
		if b == value
			return true
		.fail(string.byte(value), string.byte(b), "")


	function Fail (|string| found, |string| expected, |string| InputName)
		flow off
		.readinput = .readinput
		require .CanDoErrors
		|| fs = FastString()
		if InputName 
			fs <~ "Different input for: ${InputName}. "			
		if !.ReadInput.HasAny
			fs <~ "New-stream longer than old-stream."
		  else
			fs <~ "Expected: "
			fs.printnicely(expected)
			fs <~ " but found: "
			fs.printnicely(found)
		fs <~ "\n"
		
		app.StackTrace(3, fs)
		printline fs.GetResult
		.CanDoErrors = false
		.ReadInput = nil
		if FlowControl.BreakOnFail
			debugger


	function faststring.PrintNicely (|string| s)
		|| Cause = s.UnPrintable
		if cause < 0
			self <~ "#(${s.hex})#"
		  elseif cause == '\n'
			s.ReplaceAll("\n", `\n`, self)
		  else
			self <~ s
	
	
	module
		|flowcontrol|			Flow			// DONT directly alter this 
		|CompressionStats| 		Stats
		|int| 					Disabled		= int.max
		|bool|					AlwaysMove		= true
		|bool|					BreakOnFail
		|byte|					Active
		.GetActiveFlow
		
		constants
			Validate			= 2
			Log					= 1
			Off					= 0
		
		function GetActiveFlow
			|| str = app["flowmode"]
			if str ~= "validate"
				.Active = Validate
			  elseif str ~= "log"
				.Active = log
			
		syntax append (|bool| value, |bool|)
			cpp_name JB_Flow__Cond,  visible,  flow off
			self <~ ('T', 'F')(value)
			return value
		
		syntax append (|byte| value)
			visible,  flow off
			if !.disabled
				.disabled = 1
				.flow!.TestByte(('T', 'F')(value))
				.disabled = 0

		function Input (|[string]| lines, |string| name,  |bool|)
			cpp_part InputStrings
			flow off
			.Input(lines.join("\n"), name)

		function Input (|string| data, |string| name)
			visible
			flow off
			require !.disabled

			.disabled = 1
			|flowcontrol--| f = .flow!
			|StringReader--| r = f.ReadInput
			if r != nil
				|| str = r.str(data.length)
				if str != data
					f.Fail(str, data, name)
				
			for c in data
				f.addbyte(c)
			.disabled = 0
		
		function Stop
			flow off
			.Disabled = int.max
			.Flow = nil

		function Activate (|string| name,  |FlowControlStopper|)
			flow off
			if !.Active
				"#!Use --flowmode=log or --flowmode=validate to activate FlowControl"
				return nil

			|| path = "/tmp/Speedie/FlowControl".child( name + ".txt.mz" )
			print "#!FlowControl "
			if .Active >= Validate
				print "validation at: "
			  else
				print "logging at: "
			printline path
			.Disabled = int.max			// in case its set badly
			.flow = FlowControl(path)


		function Attempt (|string| name,  |FlowControlStopper|)
			flow off
			target flow
				return .Activate(name)



datatype FlowControlStopper (int)
	syntax UsingComplete (|object| dummy=nil)
		flow off
		flowcontrol.stop
	
	syntax Using (|FlowControlStopper|)
		flow off

