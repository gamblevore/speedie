

/*
	API to check if something different happened to the flow control from one platform to another
	only call: flowcontrol.Cond
*/

		
class FlowControl
	linkage:cpp_part Flow
	|FastBuff|				Buff
	|stringstream|			ReadInput
	|faststring| 			Write
	|bool| 					OK

	constructor
		flow off
		.ok = .buff.Alloc(1MB)

	helper Init (|string| path)
		flow off
		|| Compare = ""
		if FlowControl.FlowMode >= FlowControl.Validate
			|| prev = path.AddExt(".expected")
			if AlwaysMove or (!prev.filesize and path.filesize)
				|| f = path.file
				if f.exists
					require f.MoveTo(prev)
			if prev.FileSize
				|| S = prev.ReadFile
					Compare = prev
					.ReadInput = S.decompress.stream
		print "Capturing flow: "
		printline path
		if .ReadInput != nil
			print "Comparing flow: "
			printline compare
		.write = path.out
	
	helper Flush
		flow off
		if .write
			.buff.tmpstr.CompressInto(.write, stats)
		.buff.Curr = .buff.start
			 

	destructor
		flow off
		FlowControl.Disabled = int.max
		.flush
		printline stats.render
		stats.clear

	
	helper AddByte (|byte| value)
		if .buff <~ value
			.Flush
		
	helper Cond (|byte| value, |bool|)
		flow off, opt norefcounts, visible

		.AddByte(value)
		|| r = .ReadInput
		if r == nil
			return true
		|| b = r.byte
		if b == value
			return true
		.fail(string.byte(value), string.byte(b), "")


	function Fail (|string| found, |string| expected, |string| name)
		opt norefcounts, flow off
		if !.readinput.HasAny
			"New-stream longer than old-stream."
		  else
			if name
				print "with "
				print name
			print " expected: "
			print expected
			print "\nbut found: "
			printline found
		printline app.StackTrace("JB_Flow_")
		.ReadInput = nil
		if BreakOnFail
			debugger

	
	module
		|flowcontrol|			Flow // DONT directly alter this 
		||						FlowDiff		= "Flow differs here:"

		|CompressionStats| 		Stats
		|uint| 					Disabled		= int.max
		|byte|					FlowMode		= FlowControl.Validate
		|bool|					AlwaysMove		= true
		|bool|					BreakOnFail
		
		constants
			Validate			= 2
			Log					= 1
			Off					= 0
			
		syntax append (|bool| value, |bool|)
			visible,  flow off,  cpp_name JB_Flow__Cond
			if .disabled
				return value
			.disabled = 1
			.flow.cond(('T', 'F')(value))
			.disabled = 0
			return value

		function Input (|[string]| lines, |string| name,  |bool|)
			cpp_part InputStrings
			.Input(join2(lines, "\n"), name)

		function Input (|string| data, |string| name)
			visible
			flow off
			require !.disabled

			.disabled = 1
			|flowcontrol--| f = .flow
			|stringstream--| r = f.ReadInput
			if r != nil
				|| str = r.str(data.length)
				if str != data
					f.Fail(data, str, name)
				
			for c in data
				f.addbyte(c)
			.disabled = 0
		
		function Stop
			flow off
			.Disabled = int.max
			.Flow = nil
		
		function New (|string| name, |FlowControlStopper|)
			cpp_part FlowStarter
			flow off
			require FlowMode
			.Disabled = int.max			// in case its set badly
			.flow = FlowControl()
			.flow.init("/tmp/FlowControl/" + name + ".txt.mz")



datatype FlowControlStopper (uint)
	syntax UsingComplete
		flowcontrol.stop

	syntax Using (|FlowControlStopper|)
		flow off
		opt norefcounts
		if FlowControl.FlowMode
			flowcontrol.Disabled = 0

