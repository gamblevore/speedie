

/*
	Jeebox internals. By Theodore H. Smith...
*/



//role DataObject (DataTypeWrapper)


class DataObject
	linkage
		cpp_part Wrap
		cpp_class DTWrap
	contains int64
	constants
		kNothing = 0
		kFree    = 1
		kDelete  = 2
	
	|DataTypeCode|		DataType
	|byte|				DeathAction
	|int64|				PrivValue
	
	destructor
		if .deathaction == DataObject.kfree
			Memory.free(.privvalue|&nil|)

	
	constructor (|int64| v)
		cpp_part ConstructorInt
		.datatype = datatypecode.s64
		.PrivValue = v

	
	constructor (|bool| b)  // could be an issue as most things convert to a bool...
		cpp_part ConstructorBool
		.datatype = datatypecode.bool
		.PrivValue = b|int|

	
	constructor (|&nil| p)
		cpp_part ConstructorVoidPtr
		.datatype = datatypecode.unusedtype
		.PrivValue = p|int64|


	function First (||) // for floats... perhaps use this?    macro first: .privvalue|...(samebits)|
		return .privvalue

	
	function Value (|int64|)
		if (self) {return .privvalue}
	
	
	function FloatValue (|f64|)
		if (self) {return .privvalue.asfloat}


	function Value (assigns:|int64|)
		disabled "This property is immutable"


	render
		visible// remove this, once we fix the dtwrap bug
		if .datatype.isfloat
			fs <~ .FloatValue
		  elseif .datatype == datatypecode.unusedtype
			fs <~ "0x"
			fs.appendhex(.privvalue)
		  elseif .datatype == datatypecode.bool	
			fs <~ ("true", "false")(.privvalue)
		  else
			fs <~ .PrivValue

	module
		function NewFloat (|f64| v, |Dataobject|)
			rz = DataObject(true) 
			rz.datatype = datatypecode.f64
			rz.PrivValue = v.AsInt



// probably the capcity should just be raw byte capacity.
// seems to make more sense... right? 
class Memory
	linkage
		cpp_part Mrap
		cpp_class MWrap
		pragma noearlyfree
	
	|int|				Capacity
	|&byte|				_Ptr
	|int|				Length
	|uint16|			ItemSize
	|DataTypeCode|		DataType
	|byte|				DeathAction
	contains byte // should be byte?
	

	constructor (|int| ItemCount, |uint| ItemSize, |&byte| ptr, |byte| DeathAction=DataObject.kfree)
		cpp_part ConstructorPtr
		.ItemSize = ItemSize
		.length = 0
		.Capacity = itemcount
		._ptr = ptr
	
	function Ptr (|&...|)
		return ._ptr|&...|
		
	function After (|&...|)
		return (._ptr + .BytesUsed)|&...|
		
	setter Length (|int|)
		if Value > .Capacity
			.Capacity = Value
		  elseif Value == 0
			.Capacity = 0
		.length = Value
	
	operator plus (|int|n, |&...|)
		return (._ptr + .itemsize*n)|&...|
	
	function Place (|&...|)
		return .operatorplus(.length)
	
	function Copy (|string| Src, |int|)
		|| cap = .ByteCapacity min src.Length
			memory.Copy(.ptr, src.Addr, cap)
			return cap


	function DiffAt (|memory| other, |ind|) // seems unused
		disabled  "Unused? Also seems bad design."
		|| n = other.length
		if .length != n
			return .length min n
		|| p1 = ._ptr
		|| pz = p1 + n
		|| pc = other._ptr
		
		while p1 < pz
			if *pc++ != *p1++
				return (p1-1) - ._ptr
		
	
	function CopyTo (|memory| other, |bool|)
		|| A1 = .ByteCapacity
		|| A2 = other.ByteCapacity
		|| A3 = A1 min A2
			memory.copy(other.ptr, .ptr, A3)
		return A3 == A1
		
		
	function AppendPlace (|&...|)
		|| L = .length
		if (L >= .Capacity)
			// try grow
			|| NewSize = (.itemsize*L*2)
			|| P2 = Memory.realloc(._ptr, NewSize)
			if (!P2) // fail
				return (&Memory.MDummy)|&...|
			|| OldSize = .ByteCapacity
			Memory.zero((p2 + OldSize), NewSize - OldSize) 
			._ptr = p2
	
		.length = l + 1
		return (._ptr + (.itemsize*L))|&...|
	
	
	function Temporal
		random.shared.temporal(self)
	
		
	setter Capacity	(|int|)
		.setcap(value) // shouldn't be necesary!!
		// image(class) is setting .capacity but not coming here, even when called like: .capacity(n)

	
	function SetCap (|int| value, |bool|)
		require .deathaction == DataObject.kfree
		|| S = .itemsize|int|
		|| old = S * .capacity
		|| New = S * value
		|| Mem = Memory.realloc(._ptr, New)
			._ptr = mem
			.Capacity = Value 
			if New > Old
				memory.Zero((mem+old), New-Old)
			return true
		error (self, "Can't allocate enough bytes: " + new.render)

	
	function ByteCapacity (|int|)
		return .ItemSize|int|*.Capacity|int|
	
	
	function BytesUsed (|int|)
		return .ItemSize|int|*.Length|int|
	
	
	function Clear
		disabled "Do you mean .Free or .Zero?"
	
	
	function Zero
		zero(._ptr, .length * .itemsize)
	

	render Dump (|int| row, |int| cn=4)
		|| p = ._ptr
		|| p2 = p + .length*.itemsize 
		|| i = 0
		|| com = 0
		fs <~ "dumping memory:\n"
		
		while (p < p2)
			|| c = *p++
			fs.appendhex(c, 2)
			if (++i >= row)
				i = 0
				com = 0
				fs <~ "\n"
			  elseif ++com >= cn
				com = 0
				fs <~ ", "

	
	destructor
		if (.deathaction == DataObject.kfree)
			Memory.free(._ptr)
		

	iterator safe
		|| i = 0
		while (i < .length)
			yield self[i] (i)
			i++


	iterator
		|| FFFirst = .ptr 
		|| Curr = FFFirst  
		|| After = curr + .length
		while (Curr < after)
			yield Curr[0] (curr - FFFirst)
			Curr++

		
	macro SyntaxAccess
		(_0.ptr|&...|)[_1]
	
	macro SyntaxAppend
		(_0.appendplace|&...|)[0] = _1

	syntax cast (|&...|)
		return .ptr

	module
		|uint64[2]| MDummy
		function Object (|int| Count, |int| ItemSize, |Memory|)
			visible 
			|| p = byte.zalloc(Count * ItemSize)
				return .new(Count, ItemSize, p)

		function Random  (|int| n, |memory|)
			rz = byte[n]
			if rz
				random.shared.temporal(rz)
		
		function FillInt (|&int| p, |int| n, |int| Pattern):			cpp_wrapper JB_FillInts
		function Unmap	 (|&nil| p, |int| n):							cpp_wrapper JB_munmap
		function UsedString	 (|int64|):									cpp_wrapper JB_MemUsedString
		function UsedOther	 (|int64|):									cpp_wrapper JB_MemUsedOther
		function Zalloc  (|int| n, |?&byte|)
			return byte.zalloc(n)
		function Realloc (|&nil| b, |int| n, |?&byte|):				cpp_wrapper JB_realloc
		function Free	 (|?(&nil)| b):								cpp_wrapper JB_free
		function Zero	 (|&nil| addr, |int| n):						cpp_wrapper memzero (||)
		function Copy	 (|&nil| dest, |&nil| src, |int| N):		cpp_wrapper memcpy

