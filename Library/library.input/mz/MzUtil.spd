

extend string
	function Compress (|int|Strength=mzlab.default, |&compressionstats| st = nil, |string|) 
		|| j = jbin(0)
		.CompressInto(j, Strength, st)
		return j
	
	function CompressInto (|file| file, |int|Strength=mzlab.default, |&compressionstats| st=nil)
		cpp_part CompressFileInto
		.CompressInto(file.out, Strength, st)
	
	function IsCompressed (|bool|)
		// remove the arg version (longer string). when i feel like testing all my files that is.
		return .isjbin and self[2, "C\06µz"] or self[2, "@\01C\06µz"]
		
	function DecompressInto (|faststring| fs, |&compressionstats| st=nil, |bool|)
		return .stream.Decompressinto(fs, 256MB, st)
		
	function Decompress (|int|lim=256MB, |&compressionstats| st=nil,  |StringThatWasReadSafely|)
		return .stream.Decompress(lim, st)


function stringstream.Decompress (|int|lim=256MB, |&compressionstats| st=nil,   |StringThatWasReadSafely|)
	rz = string.error
	|| fs = faststring()
	if .Decompressinto(fs, lim, st)
		rz = fs


function Stringstream.IsCompressed (|bool|)
	|| str = .StrNoAdvance(16)
	return str.IsCompressed	


function FastString.CompressInto (|faststring| fs, |int|Strength=mzlab.default, |&compressionstats| st=nil)
	|| str = string.fromptr(.resultptr, .length)
	str.CompressInto(fs, Strength, st)


function FastBuff.CompressInto (|faststring| fs, |int|Strength=mzlab.default, |&compressionstats| st=nil)
	.tmpstr.CompressInto(fs, Strength, st)

	

Module MZLab 
	constants
		Fastest = -4		// lz
		Fast = 0			// lz harder
		Strong = 1			// rolz
		Strongest = 2   	// rolz harder
		Default = strong	// its good enough!
		
	function TestMz (|string| path, |bool|)
		if path
			|| f = path.ReadFile.decompress(int.max)
			return f.CompressTest(true) and .ManyTests
		
	helper string.CompressTest (|bool| report, |int| which=3, |bool|)
		if which & 1
			require .compresstestsub(mzlab.strong, report)
		if which & 2
			require .compresstestsub(mzlab.fast, report)
		return true
	
	
	helper string.CompressTestSub (|int| Strength, |bool| report, |bool|)
		|compressionstats| stats
		|| c = .compress(Strength, stats)
		if report
			printline stats.Render
		stats = nil
		|| decomp = c.Decompress(int.max, stats)
		rz = self == decomp
		if !rz
			error "Decompression failed when compressing: " + self
			debugger
			decomp = c.Decompress(int.max)
		  elseif report
			printline stats.Render
		
	
	helper TestSub (|[string]| items, |FastString| FS, |int|i) 
		for j in 4 
			if i & (1<<j)
				fs <~ items[j]

	helper ManyTests (|bool|) // mztest
		|| Items = "abcd efgh ijkl mnop".words
		|| fs = faststring()
		
		for i in 1024*64
			if i  and  i isa 16K
				printline i.render
			for sh in 0 to 4
				.TestSub(items, fs, i>>(sh*4))
			|| str = fs.getresult
			require str.CompressTest(false, (i&1)+1)
		"Compression Test: OK"
		return true
	
	
	helper BalzTest (|string| path)
		|| in = path.file
		|| indata = in.Readall						#require
		|| out = in.setext("jalz").out
		out.BALZCompressChunk(indata)
		out.Flush
		"Compression done"
		
		|| fs = faststring()
		|| sigh = out.file.readfile
		fs.BalzDecompressChunk(sigh, indata.length)
		|| back = fs.getresult
		require in.compare(back, true)
		"Decompressed OK!"
		mzlab.TestMz(in)


	function TestCompression
		|| d = "/usr/local/speedie/Speedie.scproj/speedie.input/ASMBuilder/".file
		require d.exists
		|[string]| Inputs
		for ch.files in d
			if ch.visible
				inputs <~ ch.readall
	
		|| total = 0
		|| fs = FastString()
		for str in inputs
			total += str.length
			str.CompressInto(fs)
		
		|| back = fs.GetResult.stream
		for orig in inputs
			expect orig == back.decompress
		expect (back.IsEnded) and !back.Decompress.length
		"TestCompression passed."


target minilib {
struct CompressionStats
	linkage:cpp_part MzSt
	function start
	function end
	function len (|int| n)
	function liveupdate (|string| s, |int| outt)
	function durr (|float|)
	function render (|string|)
	module
		function all (|&compressionstats|)
		function New (|compressionstats|)

} else {
struct CompressionStats
	linkage:cpp_part MzSt
	|date| Duration
	|int|  In
	|int|  LastOut
	|int|  Out
	|bool| Live
	
	function start
		.Duration = -date()
	function end
		.Duration += date()
	function len (|int| n)
		.Duration := -date()
		.LastOut = n

	function LiveUpdate (|string| s, |int| outt)
		.in += s.length
		.out += outt - .LastOut
		.LastOut = .out
		|| d = .durr
		if .live and d > 1
			printline .render
	function durr (|float|)
		|| d = .duration
		if d < 0
			d += date()
		return d.seconds
	render
		|| durr = .durr
		|int64| spd = (.in max .out)/durr
		|| pc = .out pc .in
		fs <~ "${.in.strsize} to ${.out.strsize} ($pc) in at ${spd.strsize}/s (${durr}s)"
	module
		|compressionstats| All // noice
		function New (|compressionstats|)
			rz.live = true
}


helper BTWSorter_64K (|string| text, |&int| ap, |&int| bp, |int|)
	|| a		= *ap
	|| b		= *bp
	|| txt		= text.addr
	for text.length
		|int| ac = txt[64KB&a++]
		|int| bc = txt[64KB&b++]
		|| d = ac - bc
			return d.SignBit
