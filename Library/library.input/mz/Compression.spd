

/*
* OK... so lets go with an array of compressed strings. As long as .need works... the rest will work
	* just nede to modify compression so that an array of strings is possible!
	* also decompression... works directly from message, meaning we need the entire jbin in memory.
		* We could alter that? Just... turn my jbin parser into some kind of generator? A func that "Gives the next string/func"
		
* I guess decompress can just fall off the last position...

*/

	
function stringstream.CompressInto (|object| dest, |int|Strength=mzlab.default, |&compressionstats| st=nil) 
	expect (self!=nil) ("Nil object given to CompressInto")
	|jbin| j = faststring.use(dest)				#require
	st := CompressionStats.All
	|| Mode = ("ro", "")(strength >= mzlab.strong)
	|| ChunkSize = (4MB, 1MB)(mode)				// don't change these! compression will fail.
	st.len(j.length) 
	j.jinit
	j.enter(@tmp, "Âµz")
	j.addint(.length)
	j.enter(@arg, Mode)
	while self
		|| str = .str(Chunksize)
		|| Place = j.OpenSection
		if Mode
			j.BalzCompressChunk(str, strength > mzlab.strong)
		  else
			j.CompressChunk(str)
		
		j.CloseSection(Place)
		st.LiveUpdate(str, j.length)
		if !.nomorechunks
			j.flush // we are calling it after anyhow	
	j.up(2)
	j.flush			// we definitely need to flush it. -- genius theo 2023, no humour.
	j.CompressChunk(nil)						// cleanup


helper stringstream.DecompressInto (|object| dest, |int| lim=int.max, |&compressionstats| st=nil, |bool|)
	expect (self!=nil) ("Nil object given to CompressInto")
	|| fs = faststring.use(dest) #require
	if !.IsCompressed
		fs <~ .readall
		return true
	st := compressionstats.all
	require .ExpectJbin
	
	|| mz = .NextMsg				#require
	if mz == @arg // remove this later
		mz = .NextMsg(@tmp)
	  else
		require mz.expect(@tmp)

	|| size = .NextMsg(mz, @num)
	|| arg = .NextMsg(mz, @arg)
	|| Remaining = size.int
	|| OK = StdErr.Mark
	mz.name = nil
	size.name = nil
	ifn size and arg and Remaining <= lim
		if (Remaining > lim)
			error (self, "mz would decompress too large")
		  else
			error (self, "Invalid mz header")
	  else
		st.len(fs.StreamLength)
		|| Mode = arg.name
		|| ChunkMax = (4MB, 1MB)(mode) 
		while
			|| c = .NextMsg(arg, @bin) #loop
			|| s = c.name
			|| Expected = Remaining min ChunkMax
			if Mode
				loop fs.BalzDecompressChunk(c.name, Expected)
			  else
				loop fs.DecompressChunk(c.name, Expected)
			Remaining -= Expected
			fs.Flush
			st.LiveUpdate(c.name, fs.StreamLength)
			c.remove
			
	return OK

		
helper faststring.CompressChunk (|string| str) 
	cpp_wrapper JB_Str_CompressChunk

helper faststring.DecompressChunk (|string| str, |int| Expected, |int|) 
	cpp_wrapper JB_Str_DecompressChunk

helper faststring.BalzCompressChunk (|string| str, |bool| Strong = false) 
	cpp_wrapper JB_BALZ_CompressChunk

helper faststring.BalzDecompressChunk (|string| str, |int| Expected, |int|) 
	cpp_wrapper JB_BALZ_DecompressChunk


