

/*
* OK... so lets go with an array of compressed strings. As long as .need works... the rest will work
	* just nede to modify compression so that an array of strings is possible!
	* also decompression... works directly from message, meaning we need the entire jbin in memory.
		* We could alter that? Just... turn my jbin parser into some kind of generator? A func that "Gives the next string/func"
		
* I guess decompress can just fall off the last position...

*/


extend String 		
	helper CompressIntoSub (|jbin| j, |&compressionstats| st) 
		st := CompressionStats.All
		st.len(j.length)
		if !j.Length
			j.jinit
			j.enter(@arg)
		j.enter(@tmp, "Âµz")
		j.addint(.length)
		j.enter(@arg)
		for s in .chunk(1MB)
			|| Place = j.OpenStream
			j.CompressChunk(s)
			j.CloseStream(Place)
			st.LiveUpdate(s, j.length)
		j.up(2)
		j.CompressChunk(nil) // cleanup

	helper DecompressSub (|&compressionstats| st, |int| lim, |string| input, |faststring| fs, |bool|)
		opt norefcounts
		st := compressionstats.all
		|| mz = .parse_jbin				#require
		|| size_node = mz.first
		|| arg = mz.second
		|| total_size = size_node.int
		expect (size_node == @num and arg == @arg)  (self, "Invalid mz header")
		expect (total_size <= lim)					(self, "Oversized mz")
		st.len(mz.length)
		for C in arg
			require fs.DecompressChunk(c.name, total_size)
			st.liveupdate(c.name, fs.length)
		return true

		
helper faststring.CompressChunk (|string| str) 
	cpp_wrapper JB_Str_CompressChunk


helper faststring.DecompressChunk (|string| str, |int| total_length, |int|) 
	cpp_wrapper JB_Str_DecompressChunk

