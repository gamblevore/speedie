

/*
* OK... so lets go with an array of compressed strings. As long as .need works... the rest will work
	* just nede to modify compression so that an array of strings is possible!
	* also decompression... works directly from message, meaning we need the entire jbin in memory.
		* We could alter that? Just... turn my jbin parser into some kind of generator? A func that "Gives the next string/func"
		
* I guess decompress can just fall off the last position...

*/


function string.CompressInto (|jbin| j, |&compressionstats| st=nil) 
	st := CompressionStats.All
	st.len(j.length)
	j.jinit
	j.enter(@arg)
	j.enter(@tmp, "Âµz")
	j.addint(.length)
	j.enter(@arg)
	for s in .chunk(1MB)
		|| Place = j.OpenStream
		j.CompressChunk(s)
		j.CloseStream(Place)
		st.LiveUpdate(s, j.length)
	j.up(3)
	j.CompressChunk(nil) // cleanup


helper stringstream.DecompressInto (|&compressionstats| st, |int| lim, |faststring| fs, |bool|)
	if !.IsCompressed
		fs <~ .readall
		return true
	st := compressionstats.all
	require .ExpectJbin
	
	|| mz = .NextMsg				#require
	if mz == @arg
		mz = .NextMsg(@tmp)
	  elseif !mz.expect(@tmp)
		mz = nil
	|| size = .NextMsg(mz, @num)
	|| arg = .NextMsg(mz, @arg)
	|| total_size = size.int
	|| ErrorCount = StdErr.ErrorCount
	mz.name = nil
	size.name = nil
	ifn size and arg and total_size <= lim
		if (total_size > lim)
			error (self, "mz would decompress too large")
		  else
			error (self, "Invalid mz header")
	  else
		st.len(fs.StreamLength)
		|| Continue = true
		while Continue
			|| c = .NextMsg(arg, @bin)
			Continue = c and fs.DecompressChunk(c.name, total_size)
			if Continue
				st.LiveUpdate(c.name, fs.StreamLength)
			c.remove
			
	return stderr.ErrorCount == ErrorCount

		
helper faststring.CompressChunk (|string| str) 
	cpp_wrapper JB_Str_CompressChunk


helper faststring.DecompressChunk (|string| str, |int| total_length, |int|) 
	cpp_wrapper JB_Str_DecompressChunk

