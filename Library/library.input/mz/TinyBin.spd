
struct unklinker
	linkage
		cpp_part ubs
	|stringstream|	Input 
	|stringstream|	SubParser 
	|message|		Name
	|message|		strings
	|message|		BitSize
	|message|		IDTable
	|message|		Tree
	|[messageid]|	IDs

	function Collect (|int|)
		.name    = .input.nextmsg(@tmp, "Ĵµ")
		.strings = .input.nextmsg(.name, @str)
		.BitSize = .input.nextmsg(.name, @bin)
		.IDTable = .input.nextmsg(.name, @bin)
		.Tree    = .input.nextmsg(.name, @bin)				#require
		
		.SubParser = stringstream(.IDTable.name)
		rz = .SubParser.hInt
		expect (rz < 512K) (.input, "IDCount too large") 
	
		.IDS <~ (messageID(), rz)


	function IDGen (|int| IDCount)
		opt norefcounts
		|| n   = 0
		|| pos = 0
		|| ids = .ids
		|| Str = .strings.name.decompress(int.max)
		while .SubParser
			|| fn = .subparser.byte|syntax| #expect (.input)
			|| length = .subparser.hint 
			expect (n < idcount) (.input, "Too many IDs found")
			ids[n] = MessageID(str[pos, length], fn)
			pos += length
			n++ 
		expect (n == IDCount) (.input, "Too few IDs found")
	

	function MakeTree
		opt norefcounts
		|message| Parent
		|| Table = .ids
		while .input
			|| ID = .input.byte
			|| Dir	= ID >> 6							// 0 = up,  2 = same,  1 = down :)
				ID = (ID << 8) (|) .input.byte
				if ID >= 14K
					ID = ((ID-14K)<<8) (|) .input.byte
				|| MID = table[ID]							#expect (.input, "Bad ID")
				|| msg = mid.msg(parent)
				if !parent
					parent = msg
					.tree = msg
				  elseif dir == 1
					parent = msg
			  else
				parent = parent.upward(ID) // go up


	function Decode
		|| OK = stderr.mark 
		|| N = .collect
		if OK //      :3
			.IDGen(n)
		if OK //hehe
			.MakeTree
	
	
	function stringstream.UnsquashJbin (|message|)
		|unklinker| sq
		sq.input = self
		sq.decode
		rz = sq.Tree
			
	
	
struct KlinkIt
	linkage
		cpp_part sbs
	|faststring|					Strings
	|faststring|					IDTable
	|string|						Tree
	|faststring| 					Out
	
	function BuildTable (|message| root, |[messageid]|)
		|dictionary of messageid| d = Dictionary()
		|| Length = root.identify(d, rz)
		rz.sort(&messageid.IDSorter)
		|| fs_str = FastString(length)
		.strings = fs_Str
		|| fs_id = FastString()
		.IDTable = fs_id
		for id in rz
			fs_str <~ id.Name
			fs_id  <~ id.Func|byte|
			fs_id.hint(id.name.length)
		

	helper GoUp (|int| Depth)
		while depth
			|| amount = depth min 16
			.out <~ (amount-1)|byte|
			depth -= amount

	
	function NextIDs
			
			
	function Run (|message| root, |bool|)
		visible
		opt NoRefCounts
		
		|| table = .BuildTable(root)
		|| curr = root
		|| depth = 0
		|| Count = 0
		while curr
			Count++
			if count >= 30K
				.NextIDs
				Count = 0
			
			curr = curr.FlatNextDepth(depth)
			if depth < 0 
				.GoUp(-depth)
			  else // 0 or 1
				|| ID = curr.name|messageid|.decodeid
				
	
	function stringstream.CompressJbin (|jbin| fs)
		|KlinkIt| Stuff
		stuff.out = fs
		require Stuff.Run(.parse_jbin)
		fs.enter(@tmp, "Ĵµ")
		fs.add(@str, stuff.strings)
		fs.add(@bin, "\08")
		fs.add(@bin, stuff.IDTable)
		fs.add(@bin, stuff.Tree)
	
	
	
/*
	We need any possible integer value. But want smaller values to take less.

	Encoding approaches:
	
	8-bit, 12-bit, 16-bit
	
	i think lets noobcode 32-values, then hint the rest. Perhaps with a callback
	
	
*/


