

// remove charset...?
// could just try replacing one or two calls with this... see how we get on
// if it works... then replace more.

datatype CharPropList (uint)
	linkage
		numeric false
	
	operator contains (|byte| b, |bool|)
		inline
		return (1<<b.Property|uint|) & self|uint|
		
	operator contains (|charprop| b, |bool|)
		inline
		cpp_part ContainsProp
		return (1<<b|uint|) & self|uint|
		
	operator contains (|string| s, |bool|)
		cpp_Part ContainsStr
		return s.OutCharSet(self) == -1
		
	operator Plus (|charproplist| p, |charproplist|)
		inline
		return (self|uint| ||| p|uint|)|charproplist|

	operator Plus (|charprop| p, |charproplist|)
		inline
		cpp_Part Add1
		return (self|uint| ||| (1<<p|uint|))|charproplist|

	syntax Access (|byte| b, |bool|)
		inline
		return self contains b


function byte.SyntaxIs (|CharProp| s, |bool|)
	inline
	return .Property == s


function Byte.Property (|CharProp|)
	inline
	return CharProp.Props[self]

	
function string.Find (|CharProp| Find, |int| From=0, |int| After=int.max, |ind|)
	cpp_part FindProp
	return .find(find.list, from, after)

// needs to be able to go backwards... to replace charset
function string.Find (|CharPropList| Find, |int| From=0, |int| After=int.max, |ind|)
	cpp_part FindPropList
	if from < 0 or after < 0 // i don't think its such a good API to take negative numbers...
							 // makes for confusing code. it WOULD have been good... if this were 1-based
							 // because -1 is also the return value of a missing value.
							 // nicer to make an explicit function that to handle end-relative searches
	|| p = &CharProp.Props[0]
	|| addr = .addr
	if from < After
		from = from max 0
		After = After min .Length
		while From < After
			if find contains p[addr[from++]]
				return from-1
	  else // oof
		from = from min .length
		After = After max 0
		while From > After
			if find contains p[addr[--from]]
				return from

/*
    || SelfAfter = self->Length
    if (StartOff < 0)
        StartOff = SelfAfter + 1 + StartOff
      else if (StartOff > SelfAfter)
        StartOff = SelfAfter

    if (AfterOff > SelfAfter)
        AfterOff = SelfAfter
      else if (AfterOff < 0)
        AfterOff = SelfAfter + 1 + AfterOff

    return {AfterOff - StartOff, self->Addr + StartOff}  
*/

function string.OutCharSet (|CharPropList| Find, |int| From=0, |int| After=int.max, |ind|)
	cpp_part OutPropList
	if from < 0 or after < 0 // i don't think its such a good API to take negative numbers...
							 // makes for confusing code. it WOULD have been good... if this were 1-based
							 // because -1 is also the return value of a missing value.
							 // nicer to make an explicit function that to handle end-relative searches
	|| p = &CharProp.Props[0]
	|| addr = .addr
	if from < After
		from = from max 0
		After = After min .Length
		while From < After
			ifn find contains p[addr[from++]]
				return from-1
	  else // oof
		from = from min .length
		After = After max 0
		while From > After
			ifn find contains p[addr[--from]]
				return from
	

datatype CharProp (uint16)
	linkage
		numeric false
	constants
		|CharProp| 
		Invalid
		Null				// 0
		Unprintable 		// 1-8, 11, 12, 14-30
		Line				// nl, rt
		HSpace				// space, tab
		Punct1				// &|~@!()[]}?\
		Punct2				// space   '`\"{#\$%		// csafterstatement
		Punct3				// -^+/*;<>= // 
		Punct4				// white, "\\,:"			// csafterdot
		PunctXML			// .-:
		Number				// 0123456789
		Underscore			// _
		Upper				// A-Z
		Lower				// a-z
		UnicodeByte			// 128+


		|CharPropList| 
		NumMid			= (1<<Upper) + (1<<Lower) + (1<<UnderScore) + (1<<Number)
		Unicode			= (1<<UnicodeByte)
		LettersOnly 	= Unicode + (1<<Upper) + (1<<Lower) 
		LettersUnderScore= LettersOnly+ (1<<Underscore) 
		NameMid			= LettersUnderScore + (1<<Number)
		XMLNameMid		= NameMid + (1<<PunctXML)
		White			= (1<<Line) + (1<<HSpace)
		Punct			= (1<<Punct1) + (1<<PunctXML)

	operator Plus (|charprop| p, |charproplist|)
		inline
		cpp_part Add1
		return ((1<<self|uint|) ||| (1<<p|uint|))|charproplist|

	operator Plus (|charproplist| p, |charproplist|)
		inline
		return ((1<<self|uint|) ||| p|uint|)|charproplist|
		
	inline List (|charproplist|)
		return (1<<self|uint|)|charproplist|
	
	syntax cast (|charproplist|)
		inline
		return (1<<self|uint|)|charproplist|
		
	module
		|CharProp[256]| Props
		charprop.MakeDefault
//		charprop.test
//		
//	
//		inline Test
//			expect 'a' is lower and 'b' is lower and 'C' is upper and 'D' is upper and '5' is number
//			expect Letters contains 'C' and 'c'
//			|| fs = FastString()
//			for c in "We ate some cheese for 5Â£."
//				|| p = lower+Number
//				if p contains c 
//					fs <~ c
//			printline fs

	
		function MakeDefault
			|| item = &.Props[0]
			for s in 32
				item[s] = Unprintable
			for s in 33 to 126
				item[s] = punct1
			for s in 128 to 253
				item[s] = UnicodeByte
			for s in '0'|int| to '9'|int|
				item[s] = charprop.number
			for s in 'A'|int| to 'Z'|int|
				item[s] = charprop.upper
				item[s+32] = charprop.lower

			item[0] = null
			item[9] = HSpace
			item[10] = line
			item[13] = line
			item[32] = HSpace

			item['_'] = charprop.Underscore
			item['-'] = PunctXML
			item[':'] = PunctXML
			item['.'] = PunctXML

///			item[0x7f] = Invalid // not set above
			item[0xC0] = Invalid
//			item[0xFE] = Invalid // also
//			item[0xFF] = Invalid
			
	

