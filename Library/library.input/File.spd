
/*
	Jeebox internals. By Theodore H. Smith...
*/

// how to say that we are in JBLib?
// via a conf, right? where is conf read from?

class File (String)
	linkage
		cpp_class JB_File
		wrapper
	default			nil
	|int|		Descriptor

	constants
		IgnoreErrors = true
		O_CREAT	 = 0x200			/* create if nonexistant */
		O_TRUNC	 = 0x400			/* truncate to zero length */
		O_EXCL   = 0x800			/* error if already exists */
		O_APPEND = 0x008			/* set append mode */
		O_RDONLY = 0x000			/* open for reading only */
		O_WRONLY = 0x001			/* open for writing only */
		O_RDWR   = 0x002			/* open for reading and writing */

////////////////////////////////////////////////////////////////////////////

	constructor ( |string| path = "" )
		cpp_wrapper JB_File_Constructor
	
	destructor
		cpp_wrapper JB_File_Destructor

	function Mode (|FileMode|)
		cpp_Wrapper JB_File_Mode
	
	function path (|string|)
		cpp_Wrapper JB_File_Path

	function Mode (assigns:|FileMode|)
		cpp_Wrapper JB_File_ModeSet

	function LinksTo (|string|)
		cpp_wrapper JB_File_LinkToGet

	function StringZeroTerminated.SymLink (assigns:|file|, |errorint|)
		cpp_wrapper JB_Str_SymLink

	function LinkTo (assigns:|string|, |errorint|)
		// This API confuses me... not sure if it's me or unix right now. 
		return Value.cstr.SymLink(self)

	function HardLinkTo (assigns:|stringzeroterminated|, |bool|)
		cpp_wrapper JB_File_HardLinkTo 

	function IsOpen (|bool|)
		disabled "use .opened"
	function Opened (|bool|) // isopen
		return .descriptor >= 0

	function Name (assigns:|string|Name, |errorint|)
		return .MoveTo( super.Parent[Name] )
	
	syntax cast (|bool|)
		return self!=nil

	syntax cast (|faststring|)
		cpp_part CastToStream
		return .out

	syntax equals (|string|s, |bool| aware, |bool|)
		if self != nil
			return super.syntaxequals(s, aware)
			
	function Length (|int|)
		disabled "Do you mean the file's size or the file's path length?" 
	
	function Size (|int64|) // actually ints are less buggy. Like "|| NewSize = oldsize-1" with uint is bad.
		cpp_wrapper JB_File_Size

	function Size (assigns:|int|N)
		cpp_wrapper JB_File_SizeSet

	function Created (|Date|)
		cpp_wrapper JB_File_Created

	function Close
		cpp_wrapper JB_File_Close
	
	function Write (|string| Data, |ind|)
		cpp_wrapper JB_File_Write
	
	Syntax Append (|string| data)
		.write(Data)
	
	function string.visible (|bool|)
		return .name[0] != '.'
		
	function hidden (|bool|)
		return !.visible

	function SmartData (assigns:|String| nieu, |bool|)
		if (.size != nieu.length) or (.readall(true) != nieu)
			return .data(Nieu)
	
	operator plus (|string|s, |file|)
		return (super+S).file
	
	
	function Data (assigns:|String|Data, |bool|)
		cpp_wrapper JB_File_DataSet
	
	
	function ReadSafely (|int| lim = 128MB, |bool| AllowMissing = false, |StringThatWasReadSafely|)
		// normally allowmissing is good, but here it is bad.
		return .readall(lim, allowmissing)
	
	
	function Parse (|int| lim = 16MB, |bool| AllowMissing=false, |messageroot|)
		// file.parse keeps track of the source+path
		|| f = .Resolve(allowmissing).file
//			if f.peek(16).IsJbin and !f.peek(16).IsCompressed
// 			    return .in.parse_jbin // soemthing like that
			|| S = f.readsafely(lim, allowmissing)
			if s.IsCompressed
				s = s.Decompress(lim, nil)
			if s
				|memorylayer--| L = (Message).CreateLayer(f) // these 3 lines should be one
				L.use      // 2
				L.obj2 = S // 3 // data set here, path set in createlayer 
				rz = S.parse(@arg, false) // already decompressed.
				(message).restore

	
	function Modified (|Date|)
		cpp_wrapper JB_File_Modified
			
	function IsPipe (|bool|)
		cpp_wrapper JB_File_IsPipe

	function Peek (|int| n, |string|)
		|| i = .offset
		rz = .read(n)
		.offset = i
	
	function Section (|int| a, |int| b, |string|)
		cpp_part AccessPeek
		|| WasClosed = .descriptor < 0
		if .open(File.O_RDONLY)
			.offset = a
			rz = .read(b-a)
			if WasClosed
				.close
		
	function IsCompressed (|bool|)
		return .section(0,16).iscompressed


	function RelFile (|file|)
		|| cd = app.cwd.pathdir
		return .trimstart(cd).File

	render 
		cpp_wrapper


	function Child (|string| name, |bool| errs=false, |File|)
		if name
			|| f = File( .PathDir + Name.trimstart("/", true) )
			if (!errs or f.exists)
				return f
			error (Self, "Can't find file/folder: '$name' in '${super}'." )
		error (Self, "No name specified for sub-file of directory: " + self)
	
	
	function Parent (|File|)
		return File.new( super.Parent )
	
	function Touch (|errorint|)
		return "/usr/bin/touch".SilentExecute([self])

	
	function CompareFile (|File| A, |string| Error="", |bool|)
		cpp_part FileCompare
		FlowControl.Disabled++
		|| code = .CompareSub(a)
		.Close
		A.Close
		rz = .CompareMsg(code, Error)
		FlowControl.Disabled--
	
	
	helper CompareMsg (|errorint| code, |string| Error, |bool|)
		flow off
		if (code==0) or !error
			return code == 0

		|string| msg = self
		if code == 1
			msg += " has different length to "
		  else
			msg += " has different contents to "
		msg += Error
		error msg
		
		
	helper CompareSub (|File| A, |ErrorInt|)
		cpp_part FileCompareSub
		flow off
		if (.Size != A.Size)
			return 1
		A.close
		.close
		.Open(O_RDONLY)
		A.Open(O_RDONLY)
		
		while {
			|| S_ = .Read(64K)
			|| SA = A.Read(64K)
			if S_ != SA
				rz = 2
				exit
		} (S_)

	
	function CompareData (|String| A, |string| Error="", |bool|)
		flow off
		|| code = 0
		if (.Size != A.length)
			code = 1
		  elseif (.ReadAll(true) != A)
			code = 2
		return .CompareMsg(code, error)

	
	function ReadAll (|int| lim = 128MB, |bool| AllowMissing = true, |stringthatwasreadsafely|)
		cpp_wrapper JB_File_ReadAll
	
	
	function MustExist (|string| operation = "", |bool|)
		if .exists
			return true
		|| eerr = "File does not exist"
		if self and super[0] != '/'
			eerr += " at "
			eerr += app.cwd
		if operation
			eerr += ", trying to "
			eerr += operation
		error (self, eerr)

	
	function Exists (|bool|TestLinkExists=false, |bool|)
		cpp_wrapper JB_File_Exists
	
	syntax access (|string| name, |bool| Errs=false, |File|)
		return .Child(name, errs)

	function ListStart (|bool|)
		cpp_wrapper

	function ListActive (|bool|)
		cpp_wrapper

	function ListEnd
		cpp_wrapper

	function MoveNext (|bool|)
		cpp_wrapper JB_File_MoveNext

	function CurrChild (|String|)
		cpp_wrapper
	
	function Open (|int| Flags = File.O_RDWR (|) File.O_CREAT, |bool|AllowMissing=false, |int|)
		cpp_wrapper

	function OpenForRead (|bool| AllowMissing = false, |int|)
		return .open(0, AllowMissing)
	
	function OpenDes (|int|)
		.openempty
		return .descriptor
	
	
	function OpenBlank (|int|)
		cpp_wrapper JB_File_Open____
		disabled "Use OpenEmpty instead"

	function OpenEmpty (|ind|)
		cpp_wrapper JB_File_OpenBlank
	
	function EOF (|bool|)
		cpp_wrapper JB_File_EOF
	
	function IsDir (|bool|)
		cpp_wrapper JB_File_IsDir

	function IsLink (|bool|)
		cpp_wrapper JB_File_IsLink

	function IsTerminal (|bool|)
		return pipe.IsTerminal(.descriptor)
		
	function Offset (|int64|)
		cpp_wrapper JB_File_Offset
	
	function Offset (assigns:|int64|)
		cpp_wrapper JB_File_OffsetSet
	
	function Delete (|ErrorInt|)
		cpp_wrapper JB_File_Delete
		
	function MoveToTrash (|ErrorInt|)
		|| tttt = (file)
		|| ch = file.trash(.name)
			.moveto(ch)
	
	function string.UniqueFile (|file|)
		|| f = .file
		if !f.exists
			return f
		return f.Parent.UniqueChild(.name)
			
		
	function UniqueChild (|string| name, |file|)
		|| test = name
		for 1000
			|| ch = .child(test)
			if !ch.exists
				return ch
			test = name + (random.shared.int&0xFFFFFF).render
			
	function Relax (|bool| NeedsMode=true, |errorint|)
		cpp_Wrapper JB_File_RelaxPath
	
	function DeleteAll (|ErrorInt|)
		if super == "/" or ""
			return -1
		if .IsDir
			for C.Files in self
				|| tmp = C.DeleteAll
				if rz == 0
					rz = tmp
		if rz == 0
			rz = .Delete


	operator isfile (|string| ext, |bool|)
		return !.isdir and self isa ext

	operator isdir (|string| ext, |bool|)
		return .isdir and self isa ext
		
	function DirectoryContains (|string| path, |bool|)
		return path.pathfix starts .PathDir
	
	operator IsNewerThan (|File| F, |bool|)
		cpp_Part NewerThanFile
		return self isnewerthan f.modified
	operator IsNewerThan (|date| F, |bool|)
		return (.Modified > F)
	
	
	operator IsOlderThan (|File| F, |bool|)
		return (.Modified < F.Modified)
	
	
	function Writer (|FastString|) // streamout
		disabled "Use .out"
	
	
	function string.Out (|bool| Clear=true, |Faststring|)
		|| f = .file						#require
		if Clear and !f.ispipe // we don't close pipes!
			f.close
			require f.openempty
				
		rz = FastString()
		rz.file = f

	
	function string.In (|string|Header="", |int| ChunkSize=4MB, |StringStream|)
		|| f = .file
		if f.mustexist("stream")
			rz = stringstream(f, chunkSize)
			if !rz.test(Header)
				rz = nil
	
	function Copy (|File| Dest, |bool|AttrOnly=false, |ErrorInt|)
		disabled "Use .Copyto"
	
	function CopyTo (|File| Dest, |bool|AttrOnly=false, |ErrorInt|)
		cpp_wrapper JB_File_Copy
	
	function CopyAll (|string| Dest, |bool| AttrOnly=false, |ErrorInt|)
		if !.isdir
			return .copyto(dest.file, AttrOnly)

		for f in self
			rz = .child(f).copyall(dest[f]) 
			if !rz
				exit
	
	function List (|bool|invis = false, |[string]|)
		flow off
		for name in self
			if (invis) or (name[0] != '.')
				rz <~ name
		rz.sort(stringsorter)
		if !flowcontrol.disabled
			flowcontrol.input(rz, self)
	
	function MoveTo (|string| Path, |ErrorInt|)
		cpp_wrapper JB_File_MoveTo
		
	operator inside (|file|f, |bool|)
		|| fp = f.pathdir
		return super[0, fp.length] == fp
			
	function Read (|int| Length, |bool|AllowMissing=true, |string|)
		cpp_wrapper JB_File_Read

	function skip (|int| n=1)
		.offset += n

	iterator
		.ListStart
		while ( .MoveNext )
			yield .CurrChild
		.listend

	iterator Files
		.ListStart
		while ( .MoveNext )
			yield self.child(.CurrChild)
		.listend
		
	iterator flat // i don't like this...
		|[file]| dir_chain
		|| Curr		 = self
		.liststart
		while .MoveNextChain(dir_chain, Curr)
			yield curr
		.listend
	
	function MoveNextChain (|[file]| dir_chain, |&File| Curr, |bool|)
		if !.listactive
			dir_chain <~ self
			*curr = self
			return true
		while dir_chain
			|| last = dir_chain.Last
			if last.movenext // OK... we went in. now we can find a child
				|| ch = last.currchild.file
				*curr = ch
				if ch.isdir
					dir_chain <~ ch
				return true
			dir_chain.pop
		
	function SyntaxExpect (|string| Error)
		opt norefcounts
		cpp_part Fail
		StdErr.NewError( nil, Error, (.path, "")(self) )

	module
		|| DebugExecute = false
		
		helper ComparisonsAllowed (|&int|)
			cpp_Wrapper JB_File__Compar

		helper RelaxSudo (|int| Amount = 0, |int|)
			cpp_wrapper
				
		function SizeSorter (SorterComparer)
			|| aa = a|file|.size
			|| bb = b|file|.size
			return aa > bb
			
		function string.NeatenPath (|string|)
			if self starts file.HomePath
				return "~" + self[file.HomePath.length ...]

		function string.IdealApp (|string|)
			if platform.OSX
				return ("/Applications/" + .name)

		function file.IdealApp (|file|)
			return .path.idealapp.file


		function NewPipe (|int| Pipe, |file|)
			cpp_wrapper JB_File__NewPipe
		
// can rename these from path into files :)
		function TrashPath (|string|)
			if platform.OSX
				return "~/.Trash/"
			if platform.win
				return `C:\$Recycle.Bin`
			if platform.lin
				return "~/.local/share/Trash"

		function AppPrefs (|string|name = "", |string|)
			if !name
				name = app.FileName.lowercase
				name := app.conf("name")
				name += ".pref"
			return .preferencespath.child(name)		

		function Preferences (|file|)
			return .PreferencesPath.resolve.file 
		
		function HomePath (|string|)
			cpp_wrapper JB_File__Home

		function PreferencesPath (|string|)
			if platform.osx
				return "~/Library/Preferences"
			if platform.win
				return "~\AppData\Roaming" // whatever
			if platform.lin
				return "~/.config"
			
		function Trash (|string|name="", |file|)
			rz = .TrashPath.Resolve.file
			if name
				rz = rz.uniquechild(name)

		function ReadCPath (|cstring| path, |bool| AllowMissingFile, |int| MaxSize = 100000000, |string|)
			cpp_wrapper JB_cPath_ReadAll


		function DocumentsFolder (|file|)
			return "~/Documents/".file			// .file calls pathfix already

		function PrefsFolder (|file|)
			if platform.osx
				return "~/Library/Preferences".file

		function Logs (|file|)
			return "/tmp/logs/".file

	function AppDate (|date|)
		if self
			ifn self isa "app"
				return .anydate
			|| n = "/Contents/MacOS/" + .trimextandpath
			return .child(n).anydate


	function anydate (|date|)
		return .created ?? .modified



role StringThatWasReadSafely (string)
	linkage
		cpp_part Safe
	syntax cast (|bool|)
		opt norefcounts
		|| o = self|object|
		return o != string.error and nil



datatype FileMode (int)
	constants
		|FileMode|
		Owner   = 7<<6
		Group   = 7<<3
		Other   = 7<<0
		CanExec = 1<<6  + 1<<3 + 1<<0
		Process = Owner + 5<<3 + 5<<0
		Data    = 6<<6  + 4<<2 + 4<<2

