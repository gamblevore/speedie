

struct FastBuff
	|&byte|		Curr
	|&byte|		Start
	|&byte|		End
	|string|	ReadFrom
	|bool| 		ErrorReported
	
	function TmpStr (|string|)
		return string.FromPtr(.start, .length)
	function String (|string|)
		if .ReadFrom!=nil
			return .ReadFrom
		return string.copy(.start, .length)
	
	syntax Compare (|int| n, |bool| aware,  |int|)
		return .Length - n
	syntax Append (|byte| v, |bool|)
		cpp_part AppendByte
		pragma inline
		*.curr++ = v
		return .curr >= .end
	syntax Append (|uint16| v, |bool|)
		cpp_part AppendU16
		pragma inline
		|| c = .curr|&uint16|,  *c++ = v,  .curr = c|&byte|
		return c|&byte| >= .end
	syntax access (|int| pos, |byte|)
		cpp_part AccessByte
		return .start[pos]
	syntax access (|int| pos, |int| after,  |string|)
		cpp_part AccessStr
		if .readfrom != nil
			return .readfrom[pos, after] // better
		|| A = .clip(pos)
		|| B = .clip(after, 0)
		if B >= A
			return string.Copy(A, B-A)
	function Clip (|int| v, |int| reduce=1, |&byte|)
		if v <= 0
			return .start
		v = v min (.size-reduce)
		return .start + v
	function CopyTo (|&byte| Dest, |int| Length, |uint|)
		|| A = .curr
		require (A < .end and length > 0)
		|| B = A + Length
		if b > .end
			b = .end
		rz = B - A
		.curr = b
		Memory.Copy(Dest, A, rz)
		
	function Remaining (|int64|)
		return .end - .curr

	function Position (|int64|)
		return .curr - .start
		
	setter Position (|int64|)
		|| c = .start + value
		if c < .start or c > .end
			error (self, "Stream read too far")
			c = .end
		.curr = c
		
	function Byte (|byte|)
		return *.curr++
	
	syntax Expect (|string| s)
		if !.ErrorReported
			.ErrorReported = true
			error s
		
	function UInt16 (|uint16|)
		|| c = .curr|&uint16|,  rz = *c++,  .curr = c|&byte|
		
	function Find (|byte| b, |int| from, |int| After, |ind|)
		|| Pos = .clip(from)
		|| End = .clip(after, 0)
		while Pos < End
			if *Pos == b
				return pos - .Start
			Pos++
		
	operator has (|int| n, |bool|)
		return .end - .curr >= n
	
	setter ReadFrom (|string|)
		.ReadFrom = Value
		.start = Value.Address
		.end = .start + Value.length
		.curr = .start
	function NeedAlloc (|int| n, |bool|)
		if .Alloc(n)
			return true
		error ("Can't allocate memory.")
	function Alloc (|int| n, |bool|)
		.start = Memory.Zalloc(n)
		.curr = .start
		.end = (.start+n, nil)(.start)
		.readfrom = nil
		return .start
	function Length (|int|)
		if self
			return .curr - .start
	function Size (|int|)
		if self
			return .end - .start
	function jbin.add		(|syntax| type, |&FastBuff| data, |bool|into = false)
		cpp_part AddBuff
		|| L = data.length
		|| addr = (data.start, nil)(L)
		.addmemory(type, addr, into, L)

