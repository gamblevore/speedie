

role Macro (Message)
	// made into a role... one less class bloating Speedie up!
	constructor (|message| s)
		disabled "Use Macro.build"
		super.constructor
	
	function Cleaned (|bool|)
		inline
		return self is MacroMade
	
	function Cleaned (assigns:|bool|)
		inline
		(self is MacroMade) = value
		
	function Source (|message|) // can't I use a getter?
		opt norefcounts
		rz = .first
		if !rz
			rz = .name.parse
			if rz
				for v.flat in rz
					v.position = -1
				.first = rz
	
	inline Run (|[message]| prms=nil, |message|)
		rz = message()
		rz.BecomeMacro(self, prms)
	
	function Run (|message| prm1=nil, |message| prm2=nil, |message|)
		cpp_part CallFast
		rz = message()
		TmpPrms_ <~ prm1
		TmpPrms_ <~ prm2
		rz.BecomeMacro(self, TmpPrms_)
		TmpPrms_.clear
	
	module
		|[message]| TmpPrms_
		// can't call this "New" for some reason?
		function Build (|message| s, |Macro!|)
			rz = Message()
			rz <~ s
		


macro string.Macro
	macro.build((â€“digest "_0").parsejbin)
	

extend message
	helper MacroAvoidCopy (|message|)
		if self isnt MacroMade
			is Macromade
			return self
		return  .copy


	helper MacroSame (|message| prm, |message|)
		rz = .copy
		(prm is Macromade)
		rz.name = prm.name // why?
	
	
	helper MacroPrm (|message| root,  |array? of message| prms,  |message| dest,  |Message|)
		opt norefcounts
		|| n = .name
		|| c = n[]
		if (c == '*') and (self == @brel)
			|| f = .first
			if f == "_" and @thg
				for p in prms
					if p isnt MacroMade
						dest <~ p.MacroAvoidCopy
				return nil
				// (first, secnd, A, B, C, D, E)
		
		if (c == '_'  and  n > 1) and n.IsInt(1) 
			|| oop = prms[n.int|int|]		#expect (root, "Not enough params.")
			|| f = .func
			if f == @dot or @sdot or @str or @sstr or @char // anything except @thg?
				return .MacroSame(oop)
			return oop.MacroAvoidCopy
		rz = Message(self)
		rz.position = root.position
		.MacroCopy(root, prms, rz)


	helper MacroCopy (|Message| root,  |array? of message| prms,  |Message| dest)
		opt norefcounts
		for v in self
			dest <~ v.MacroPrm(root, prms, dest)


	function BecomeMacro (|Macro| M,  |array? of message| prms=nil)
		opt norefcounts
		|| s = m.source
			.clear
			.func = s.func
			.name = s.name
			.appendmacro(m, prms)
	
		
	function AppendMacro (|Macro| M,  |array? of message| prms=nil)
		using self,  opt norefcounts
		for r in prms
			(r isnt MacroMade) // in case it was passed in
//		debugat 0
		m.Source.MacroCopy(self, prms, self)
		for r in prms
			check (r is MacroMade)  (r, "Unused parameter to macro")


