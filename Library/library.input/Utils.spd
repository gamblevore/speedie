
// allow the short sort of one-liners that other languages have...
// good for demos and language-tests

function dictionary.Sort (|SorterComparer| fn, |int| count, |[...]|)
	rz = .values // a more efficient sorter could extract only needed
	rz.sort(fn)
	rz.Length = count
	
	
function message.AllNames (|[string]|)
	opt norefcounts
	for s in self
		|| i = s.GoodName
		if i != string.error
			rz <~ i


 // we want something that looks like it could have a name
function message.GoodName (|bool| NeedName=false, |string|)
	|| name = .GoodNamesub
		return name
	if name.isok and needname
		error (self, "No name found")
		return string.Error
	return name
	
	
helper message.GoodNameSub (|bool| NeedName=false, |string|)
	opt norefcounts
	|| f = .func
	if .IsString or f == @thg or @num
		return .name
	if f == @tmp
		|| c = .first
		if !c
			return .name
	error (self, "Make sure this item is a string or a proper-name.")
	return string.Error


function ivec4.List (|message|)
	rz = @list.msg
	for i in 4
		rz <~ self[i]

function message.Dict (|dictionary of message|)
	opt norefcounts
	rz = Dictionary()
	for s in self
		rz[s.name] = s

function @file.Dictionary (|file|)
	disabled "Use .words"
	
function @file.Words (|file|)
	return "/usr/share/dict/words".file
		
function string.Dict (|byte|zep='\n', |dictionary|)
	rz = Dictionary()
	if self
		for l in StringFields( self, zep )
			rz[l] = "x"

function string.Sort (|byte| sep = '\n', |string|)
	|| x = .split(sep)
	x.Sort(StringSorter)
	return x.Join(string.byte(sep))


function message.LOC (|int|)
	description "Calculate Lines of content" 
	opt norefcounts
	for s.flat in self
		|| p = s.parent
			|| pf = p.func
			rz += (pf == @arg) or (pf == @tmp  and  s == @tmp)


function int.Msg (|message|)
	return @num + .render

function string.Msg (|message|)
	return @str + self
	
function int64.Msg (|message|)
	return @num + .Render

function bool.Msg (|message|)
	return @thg + .Render

