
// allow the short sort of one-liners that other languages have...
// good for demos and language-tests

function dictionary.Sort (|SorterComparer| fn, |int| count, |[...]|)
	rz = .values // a more efficient sorter could extract only needed
	rz.sort(fn)
	rz.Length = count


function string.Sort (|byte| sep = '\n', |string|)
	|| x = .split(sep)
	x.Sort
	return x.join_sub(string.byte(sep), .length)


role MessageTable (Dictionary)
	contains Message
	syntax Access (|string| Key, assigns:||)
		super.valuelower(key) = value
	syntax Access (|string| Key, ||)
		return super.valuelower(key)
	syntax Access (|message| Key, assigns:||)
		cpp_part GetMsg
		super.valuelower(key.name) = value
	syntax Access (|message| Key, ||)
		cpp_part SetMsg
		return super.valuelower(key.name)
	syntax append (|message| Msg)
		cpp_part AppendMsg
		super.valuelower(msg.name) = msg
	

function message.List (|[Message]|)
	disabled "Use .array if you want an array of all the children. Message is already a 'list'."

function message.Array (|[Message]|)
	opt norefcounts
	for s in self
		rz <~ s


function @message.Sorter (SorterComparer of list)
	return .position < b.position


function message.Dict (|bool| DoLower=false, |bool| DoCount=false,   |dictionary of message|)
	// cheese.spd uses this
	opt norefcounts
	rz = Dictionary()
	|| i = 0
	for s in self
		if DoLower
			rz.Valuelower(s.name) = s
		  else
			rz[s.name] = s
		if DoCount
			s.Position = i++


function @file.Dictionary (|file|)
	disabled "Use File.Words() instead"

	
inline @file.Words (|file|)
	return "/usr/share/dict/words".file


autogen String.NextField (|byte| Sep, |$int| Begin, |string?|)
	opt norefcounts
	|| B = begin
	|| N = .Length
	if B >= N
		return nil
	|| After = .find(Sep, B)
	if After < 0
		after = N
	rz = self[B, After]
	Begin = After + 1
	
	
function string.Dict (|byte| sep='\n', |dictionary of string|)
	opt norefcounts
	if self
		// many speedie example projects rely on nil meaning "wildcard"
		// so we have to return nil if self==""
		rz = Dictionary()
		|| Last = 0
		while
			|| Word = .NextField(sep, Last)
			if Word == nil
				exit
			rz[Word] = "true"


autogen Message.FindNotInserted (|message|)
	opt norefcounts
	nil self
	for c.up in self
		if c.position > -1
			return c
	return self


function message.IsTypeOfDecl (|bool|)
	return .WithinType(1)


function message.WithinType (|int| Allowed=3, |bool|)
	opt norefcounts
	|| p = .parent
	|| msg = self
	while p and p != @arg
		if (allowed&1) and (p == @decl)
			return msg.isfirst
		if (allowed&2) and (p == @type)
			return msg.islast
		msg = p
		p = p.parent	


inline Message.At (|int| pos, |message|)
	return .FindTightest(pos, false, false)


function message.FindTightest (|int| pos, |bool| Named=false, |bool| SamePosition=false, |message|) // findpos, findat
	opt norefcounts
	nil checker
	|| size = int.max
	for ch.flat in self
		|| r = ch.rangelength
		if !r
			0
		  elseif (ch.contains(pos, true)) and (!named or ch.name or (ch == @dot or @sdot))
			if sameposition and ch.position != pos
				0// fail
			
			  elseif (r < size) or ((rz!=nil) and (pos == rz.position and pos == ch.after)) // smallest
				rz = ch
				size = r


function message.LOC (|ivec2|)
	description "Calculate Lines of content" 
	opt norefcounts
	for s.flat in self
		++(rz[1])
		|| p = s.parent
			|| pf = p.func
			rz[0] += (pf == @arg) or (pf == @tmp  and  s == @tmp)


// maybe the compiler should have some kind of "Cleanlyness" feature.
// that marks certain functions as "not worth" being in the lib... that inlining is better.

inline int.Msg (|message|)
	return @num + .render

inline string.Msg (|message|)
	return @str + self
	
inline int64.Msg (|message|)
	return @num + .Render

inline bool.Msg (|message|)
	return @thg + .string


datatype HumanDate (date)
	inline Render (|faststring| fs_in, |string|)
		|| fs = FastString(fs_in)
		fs.AppendLocalTime(self)
		return fs.GetResult(fs)

	inline Faststring.syntaxappend (|humandate| d)
		.appendlocaltime(d)
	
	inline message.date (|humanDate|)
		return .int


insertion
	parse (â€“digest _0).ParseJbin! // could possibly compress large files too?


target debug and !cake
	function list.JDB2 // makes it easier to debug from xcode
		cpp_name jdb2
		visible
		if Self
			printline self|message|.RenderAST
		  else
			"(nil)"
	function object.DebugPrint  // more for use in XCode, than anything else.
		cpp_name jdb
		visible true
		if self
			print string.new(.class.name)
			print ": "
		printline .render
  else
	function message.JDB2
		cpp_name jdb2
		visible
		if Self
			printline .RenderAST
		  else
			"(nil)"


datatype FailableInt (int) // useful when you want most numbers, even negatives, and zero but still want AN error code
	constants
		|int| 
		Fail = 0x8000_0000
	default FailableInt.fail
	false   FailableInt.fail
	syntax cast (|bool|)
		inline
		return self != fail|int|

