


struct ImagePixel
	|byte| R
	|byte| G
	|byte| B
	|byte| A
	linkage
		datatype true
		cpp_part pix
		opt min 3

	constructor
		.a = 255
		

	render
		fs <~ "0c"
		fs.appendhex(.r)
		fs.appendhex(.g)
		fs.appendhex(.b)
		fs.appendhex(.a)
	
	
	function Load (|message| f)
		opt norefcounts
		cpp_Part LoadMsg
		if f
			.load(f.value)
	
	function Load (|string| s)
		if s[0, "0c"]
			s = s[2...]
		for i in 4
			|| v = 0
			|| c = s[i*2, i*2+2]
				v = c.parsehex|int|
			  elseif i == 3
				v = 255
			.parts[i] = v
	
	function Lum (|float|)
		return .color.lum
	
	function HasColor (|bool|)
		return .r or .g or .b

	function HasAny (|bool|)
		return *(self|&int|)
			
	syntax cast (|bool|)
		cpp_part Exists
		return self and .a

	syntax cast (|vec4|)
		cpp_part CastVec4
		return .color

	syntax cast (|PremultipliedColor|)
		cpp_part CastPremul
		return .PreMul

	function Equals (|imagepixel|p, |bool|)
		return .uint == p.uint
		
	function Alpha (assigns:|float| a)
		a = (a * 255.0) + 0.25
		.a = a.clamp(255.0)|int|
		
	function Alpha (|float|)
		return .a|float| * 255th
	
	function AddAlpha (|float| v)
		.Alpha = .Alpha + v
		
	syntax append (|&imagepixel| r)
		*self = *r

	syntax append (|vec4| V)
		cpp_part AppendVec
		v = (v.clamp * 255.0) + 0.25
		|| b = v.iVec4
		.r = b.r
		.g = b.g
		.b = b.b
		.a = b.a
	
	syntax append (|int| r, |int| g, |int| b, |int| a=255)
		cpp_part AppendInts
		.R=r.clamp(255)
		.g=g.clamp(255)
		.b=b.clamp(255)
		.a=a.clamp(255)
		
	syntax append (|float| v)
		disabled "Use a vector?"
		cpp_part AppendFloat
		self <~ ((v,v,v,1.0))
		
	syntax append (|float| r, |float| g, |float| b, |float| a=255)
		cpp_part AppendFloats
		disabled "Just make a vector out of this and pass that instead"


	function AddInt (|int| i)
		// remove this func, only one thing needs it
		.r += i
		.g += i
		.b += i
		
	function Add (|vec4| c)
		cpp_part AddVec
		self <~ (c + .Color)
		
	function Overlay (|vec4| T)
		disabled "Call .Premul on this first for great speed boost!"

		
	function Overlay (|PreMultipliedColor| T)
		|| R = .raw
		|| D = ((R * t.a)>>16)+T
		D.a = r.a
		.raw = D
		

	function Underlay (|vec4| b) 
		|| Old = .color
		|| C = mix(b, Old, Old.a)
		C.a = old.a
		self <~ C 
	
	function Color (|vec4|)
		rz = vec4.load(self|&byte|)
		rz *= (1.0/254.99)
		
	function Raw (|ivec4|)
		return ivec4.load(self|&byte|)

	function Raw (assigns:|ivec4|)
		.r = value.r
		.g = value.g
		.b = value.b
		.a = value.a
	
	function Uint (|uint|)
		return *(self|&uint|)
		
	function Parts (|&byte|)
		return &.r
	
	function vec4.Px (|imagepixel|)
		rz <~ self
	function vec3.Px (|imagepixel|)
		rz <~ ((self,1.0))
	function ivec4.Px (|imagepixel|)
		rz <~ (.r, .g, .b, .a)
	
	module 
		|ImagePixel| Bad
		|ImagePixel| White
		|ImagePixel| Clear
		init()
		function Init
			white <~ vec4(1.0)
		function Char (|codepoint| c, |&imagepixel|)
			if c&1
				return .white
			return .clear


extend vec3
	syntax cast (|imagepixel|)
		cpp_part AsPixel
		return .px
extend vec4
	syntax cast (|imagepixel|)
		cpp_part AsPixel
		return .px
extend ivec4
	syntax cast (|imagepixel|)
		cpp_part AsPixel
		return .px
		
