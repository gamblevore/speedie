

struct ImagePixelStruct
	linkage
		cpp_part Pxst
	|byte| R
	|byte| G
	|byte| B
	|byte| A

	function AppendVec4 (|vec4| V)
		v = (v * 255.0) + 0.5
		|| iv = v.iVec4
		iv = iv.clamp(0,255)
		.r = iv.r
		.g = iv.g
		.b = iv.b
		.a = iv.a

	helper AppendVec3 (|vec3| V)
		v = (v * 255.0) + 0.5
		|| iv = v|vec4|.iVec4.clamp(0,255)
		.r = iv.r
		.g = iv.g
		.b = iv.b
	
	inline Px (|ImagePixel|)
		return self|&ImagePixel|[]
				
//	helper ivec4._CB (|ivec4|)
//		// test if this is faster.
//		description "A secret ClampByte"
//		|| L = ivec4((.x<0)|int|,   (.y<0)|int|,   (.z<0)|int|,   (.w<0)|int|)
//		|| H = ivec4((.x>255)|int|, (.y>255)|int|, (.z>255)|int|, (.w>255)|int|)
//	    self &= L-1			// clamp < 0
//	    self |= -H			// clamp > 255
//	    return self


datatype ImagePixel (uint)
//	|byte| R
//	|byte| G
//	|byte| B
//	|byte| A
//  We should be able to define rgba like this... and have all these accessor functions auto-created.

	linkage
//		datatype true
		cpp_part Pxl
		opt min 3

	inline a (|int|):							return (self >> 24)
	function a (assigns:|int|, |imagepixel|): 	return ((self << 8) >> 8) ||| (value << 24)
	inline a (|&imagepixel| self, assigns:|int|)
		cpp_part A2
		self|&ImagePixelStruct|.a = value

	inline b (|int|):							return (self >> 16) & 255
	function b (assigns:|int|, |imagepixel|):	return (self &~ 0x00FF0000) ||| ((value&255) << 16)
	inline b (|&imagepixel| self, assigns:|int|)
		cpp_part B2
		self|&ImagePixelStruct|.b = value
		
	inline g (|int|):							return (self >> 8) & 255
	function g (assigns:|int|, |imagepixel|):	return (self &~ 0x0000FF00) ||| ((value&255) << 8)
	inline g (|&imagepixel| self, assigns:|int|)
		cpp_part G2
		self|&ImagePixelStruct|.g = value
	
	inline r (|int|):							return (self >> 0) & 255
	function r (assigns:|int|, |imagepixel|): 	return (self &~ 0x000000ff) ||| ((value&255) << 0)
	inline r (|&imagepixel| self, assigns:|int|)
		cpp_part R2
		self|&ImagePixelStruct|.r = value
		
	function Alpha (|&imagepixel| self, assigns:|float| a)
		cpp_part Alpha2
		a = (a * 255.0) + 0.25
		.a = a.clamp(255.0)|int|
		
	function Alpha (assigns:|float| a, |imagepixel|)
		a = (a * 255.0) + 0.25
		.a = a.clamp(255.0)|int|
		return self
		
	inline Alpha (|float|)
		return .a|float| * 255th
	
	render
		fs <~ "0c"
		fs.appendhex(.r)
		fs.appendhex(.g)
		fs.appendhex(.b)
		fs.appendhex(.a)
	
	
	function Load (|&imagepixel| self, |message| f)
		opt norefcounts
		cpp_Part LoadMsg
		if f
			.load(f.value)
	
	function Load (|&imagepixel| self, |string| s)
		if s[0, "0c"]
			s = s[2...]
		|| parts = self|&byte|
		for i in 4
			|| v = 0
			|| c = s[i*2, i*2+2]
				v = c.parsehex|int|
			  elseif i == 3
				v = 255
			parts[i] = v
	
//	function Lum (|float|)
//		return .color.lum
	
	function HasColor (|bool|)
		inline
		return (self << 8) != 0

	function HasAny (|bool|)
		inline
		return (self != 0)
		
	operator in (|&imagepixel| self, |image| src, |bool|)
		disabled "Use: image contains pixel"

	syntax cast (|vec4|)
		cpp_part CastVec4
		inline
		return .color

	syntax cast (|PremultipliedColor|)
		cpp_part CastPremul
		inline
		return .PreMul

	function AddAlpha (|&imagepixel| self, |float| v)
		v += .Alpha
		.Alpha = v
		
	syntax append (|&imagepixel| self, |imagepixel| r)
		inline
		self[] = r
		
	syntax append (|&imagepixel| self, |vec4| V)
		cpp_part AppendVec
		inline
		self|&imagepixelstruct|.AppendVec4(v)

	function AppendRGB (|&imagepixel| self, |vec3| V)
		self|&imagepixelstruct|.AppendVec3(v)
	
	syntax append (|&imagepixel| self, |int| r, |int| g, |int| b, |int| a=255)
		cpp_part AppendInts
		.R = r.clamp(255)
		.g = g.clamp(255)
		.b = b.clamp(255)
		.a = a.clamp(255)
	
	function CopyFrom (|&imagepixel| self, |&imagepixel| src, |int| N)
		Memory.Copy(self, src, N*4)
		
	function Add (|&imagepixel| self, |vec4| c)
		cpp_part AddVec
		self <~ (c + .Color)
		
	function Overlay (|&imagepixel| self, |PreMultipliedColor| T)
		|| R = .raw
		|| D = ((R * t.a)>>16)+T
		D.a = r.a
		.raw = D

	function Color (|vec4|)
		return vec4(.r, .g, .b, .a) * (1.0/254.99)

	function Color (|&imagepixel| self, |vec4|)
		cpp_part ColorLoad
		rz = vec4.load(self|&byte|)
		rz *= (1.0/254.99)
		
	function Raw (|&imagepixel| self, |ivec4|)
		inline
		return ivec4.load(self|&byte|)

	function Raw (|&imagepixel| self, assigns:|ivec4|)
		.r = value.r
		.g = value.g
		.b = value.b
		.a = value.a
			
	
	syntax append (|float| v)
		disabled "Use a vector instead."
	
	syntax append (|&imagepixel| self, |float| r, |float| g, |float| b, |float| a=255)
		cpp_part AppendFloats
		disabled "Just make a vector instead."
		
	function Overlay (|&imagepixel| self, |vec4| T)
		disabled "Call .Premul on this first for great speed boost!"


	module 
		function New (|imagepixel|)
			rz = 255
		
		|ImagePixel| Bad
		|ImagePixel| White
		|ImagePixel| Clear

		init()
		
		helper Init
			white <~ vec4(1.0)
		
		function Char (|codepoint| c, |&imagepixel|)
			if (c&1)!=0
				return .white
			return .clear



function vec3.syntaxcast (|imagepixel|)
	disabled "use .px"
		
function vec4.syntaxcast (|imagepixel|)
	disabled "Use .px"

function ivec4.syntaxcast (|imagepixel|)
	disabled "Use .px"


function vec4.Px (|imagepixel|)
	|imagepixelstruct| Tmp
	Tmp.AppendVec4(self)
	return tmp.px

function vec3.Px (|imagepixel|)
	|imagepixelstruct| Tmp
	tmp.appendvec3(self)
	tmp.a = 255
	return tmp.px

function ivec4.Px (|imagepixel|)
	|imagepixelstruct| tmp
	tmp.r = .r, tmp.g = .g, tmp.b = .b, tmp.a = .a
	return tmp.px

