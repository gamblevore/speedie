

class PerryIDE (Window) 
	linkage: cpp_part IDE

	|Process|					Feedback
	|Process|					compilr
	|string|					CompileOKString
	|ShellStream|				RunCompiledApp
	|[error]|					StartupErrors
	|FileViewer|				FileList
	|Guicontrol|				Debugger
	|Guicontrol|				Tester
	|Guicontrol|				SearchArea
	|Guicontrol|				rborder
	|guicontrol| 				StdOutBorder
	|message| 					HistoryMarker
	
	|FileRow|					NotTodo
	|message--|					ProjMsg
	|[guicontrol]|				Views
	|File|						Project
    |ivec2|						AutoPoint
    |TextView| 					ProductPage
	|TextView|					SpeedieText
	|TextView|					JeeboxText
    |TextView|					MassSearchField
    |TextView|					EditMe
    |GraphicsEditor| 			DrawMe
    |TextView|					Status
    |TextView|					StatsInfo
    |TextView|					SelInfo
    |TextView|					NoNeeder
    |TextView|					PopupDisplay
    |message|					LastExtraInfo
    |StretchControl|			EditSep
    |StretchControl|			FileSep
	|listviewrow|				LogComms
	|listviewrow|				LogActions
	|menu|						AutoComplete	// ... todo
	|ListView|					Variables		// ... todo
	|ListView|					ErrorList
	|listview|					LogArea
	|ListView|					FoundList
    |textview| 					DebugArgsList
	|Guicontrol of buttonview|	ViewButtons
	|buttonview|				PrevView
    |ButtonView|				CurrFileName
    |ButtonView|				FunctionMenu
    |buttonview|				Toolbar
    |Buttonview|				Tabs
    |buttonview| 				CompileTabs // compilertabs
	|buttonview|				SubFindCheckBox    
    |Buttonview|				ViewErrors
    |Buttonview|				ViewFiles
    |Buttonview|				ViewSearch
    |Buttonview|				ViewDebugger
    |Buttonview|				ViewLog
    |Buttonview|				GoNext
    |Buttonview|				GoPrev
    |Buttonview|				StartScreen
    |Buttonview|				BuildButton
    |Buttonview|				RunButton
    |shellstream| 				Talker
    |message|					FileHistory
    |string|					OldJBCloser
    |string| 					lastCmdStr
    |string|					AttachedProgram
    |ProgressBar|				Progress
	|Faststring|				Stats
    |ivec2|						PopupDisplayCorner
	|date|						LastAutoCompleteDate
	|date|						PopupDateOn
	|int|						EditMeTabRetryThing
	|bool| 						StillJumping
	|bool|						DuringMsgFB  // canloadfile, canupdate, .disable 
	|bool|						IsTextOnly
	|bool|						UsingSpdLib
	|bool| 						DebugIsWaitingForCompile
	|byte|						IsLoading
	|bool|						FromNextPrev
	|bool|						InConstructor
	|byte|						NoClutter
	|bool| 						LoadingFind
	|bool|						ModifiedForCompile
	|bool| 						UpdateMem
	|bool| 						IsGraphics

		
	function UpdateStatusErrors
		.status.text = .PerryStatus


	function ExpandStr (|string| path, |string|)
		|| d = perry.pathdict init [ "spd"  :  perry.SpeedieDir ]

		rz = path.path_expand(perry.PathDict) #expect ("Unrecognised @ in: " + path)
		rz = rz.resolve(fileResolveMode.allowmissing)


	function GetBuildFile (|file|) 
		|| inside = .filelist.listsource.first
		|| found = inside.findnested(nil, "build.spd") as filerow
			return found.location.file

	
	function PerryError (|error|) 
		opt norefcounts
		if keys.shift
			|| u = sdlapp.tooltip.useable
				return u
		|| e = .editme.myerror.useable(0)
		if .editme.ParsedMessage and e				// don't show simple parse errors
			return e
		|| it = sdlapp.CompileStatus.Useable
			return it
		if e and .editme.expectsparse >= textview.probablyjeebox
			return e
		it = sdlapp.tooltip.useable
		if it
			return it
	
	
	function PerryStatus (|string|)
		opt norefcounts
		|| p = .PerryError
			return p.name


	function RemoveProjFromList
		|| r = .projmsg
			|| n = r.next
			n := r.prev
			.tabs.selected=(n)
			r.remove


	behaviour CancelClose 
		|| proj = .projmsg					#require
		|| n = proj.parent.slowcount?
		proj["pos"] = .editme.sel0

		Perry.save
		
		if !.filelist.AskSaveall
			return true // failed
		if !ClickedCancel(self)
			return true
		
		if n >= 2 and reason < sdlapp.ktryquit
			.RemoveProjFromList
		|| p = .prev
		if p isa perryide
			p.showide
			

	function LocateProjRoot (|string| path, |filerow|)
		opt norefcounts
		|| R = .FindPath(path)
		|| P = .MainProjFol
		if R and P and r.location[0, p.location]
			return r
			// what do i wanna do?
			

	function FindPath (|string| path, |filerow|)
		opt norefcounts
		|| it = .FileList
			return it.FindAPath(Path) 

		
	function MainProjFol (|filerow|)
		opt norefcounts
		|| it = .FileList
			|| r = it[0]
			return it.findapath("./input/", r)  ??  it.findapath("./*.input/", r) 


	behaviour AppForeGroundChanged
		.CheckModified
		.PopupHide
		if !.focus
			.setfocus(.editme)
	
	
	behaviour PostLoad
		require .project
		if !perry.checked
			perry.CheckInstallStatus(false)

	function StatsMode (|int|)
		rz = perryide.StatsMode|int|
		if rz > 3
			rz = 0
		rz = rz.clamp(0, 3)
		perryide.StatsMode = rz
		
	function InfoStatus (|string|)
		|| fs = .stats init FastString()
		|| i = .statsmode
		if i == 0
			fs <~ "  --" // :)
		  elseif i == 1
			|| e = .editme
			|| t = e.text
			fs <~ "${t.charcount} chars in ${t.linecount} lines"
			|| msg = .editme.ParsedMessage
				fs <~ "  (${msg.loc} LOC)"
			
		  elseif i == 2
			|| f = .filelist.FirstSelected as filerow
			if f.asdir
				fs <~ "fol: "
			  else
				fs <~ "proj: "
				|| fr = .filelist.listsource
				if fr isa filerow
					f = fr
			fs <~ "${f.lastsize.strsize} in ${f.lastfilecount} \11"
		  elseif i == 3
			fs <~ "Obj ${app.ObjMemory.strsize}  Str ${app.stringmemory.strsize}  Scr ${sdlapp.DrawSpace.bytecapacity.strsize}"
			
		return fs


	function ClickedStats
		perryide.StatsMode++
		.ShowLeftStats


	function ShowLeftStats
		.updatemem = false
		.StatsInfo.text = .InfoStatus	


	function ShowRightStats
		if .isgraphics
			(.selinfo isnt visible)
			return
		
		(.selinfo is visible)
		|| fs = FastString()
		|| t = .Editme.Text
		|| sel0 = .editme.sel0
		|| sel = .EditMe.SelText
		|| n = sel.linecount-1			
		fs <~ "ln "
		fs <~ t[0, sel0].LineCount
		if n
			fs <~ "+"
			fs <~ n
		fs.PadTo 9
		fs <~ " ch "
		fs <~ t.charcount(0, sel0)
		n = sel.CharCount
		if n
			fs <~ "+"
			fs <~ sel.CharCount
		fs.padto 25
		.SelInfo.text = fs	

	
	function ProjName (|string|)
		disabled "Use .name"
		
	function Name (|string|) //.ProjName
		opt norefcounts
		|| m = .projmsg
			return m.name.name


	function Show (|bool| FromClick=false)
		disabled "use .ShowIDE"
	
	
	function ShowIDE (|bool| FromClick=false)
		debug_require self // what?
		|| p = .Project
			app.pref("currproj") = p.path
		if FromClick
			if .islast
				.ClickedTodo
			  else
				.recheck
		if !.isfront
			.tabs.selected = .projmsg
			.editme.SetFocus // make it simple
			super.show
		.id = .name
		sdlapp.Title = .id


	helper UpdateSearchSwap (|textview|)
		opt norefcounts
		require .isfront
		if .focus == .inline.editor
			return .MassSearchField
		  elseif .focus == .MassSearchField
			return .inline.editor
	
	
	function UpdateSearchText
		opt norefcounts
		|| other = .UpdateSearchSwap #require 
		|| t = .focus.text
		sdlapp.LastSearch = t
		if other.text != t
			other.text = t
			other.Sel = 0


	function HideStuff 
		|| M  = .MouseXY
		|| LB = .ViewButtons.lastrect
		|| HideTop  = (m.y < LB.y1)
		|| HideSide = (m.x > LB.x2-2) // sigh... even happens when mouse over the side invis
		|| VisSide  = .filelist isnt decluttered // and .filelist.isviewable
		|| VisTop   = .tabs isnt decluttered

		// OK... so .. if one is visible, we don't make the other invis
		if VisSide and VisTop and (HideSide != HideTop) 
			HideSide = false
			HideTop = false
		if .filelist.cmm == .openedmenu
			hideside = false 
		
		require HideTop == VisTop  or  HideSide == VisSide
		if .viewing == .viewfiles
			if HideSide
				|| fl = .filelist.listsource as filerow
					.noneed fl.LastFileCount.render + " files"
			  else
				.noneed
		
		if !.CurrMouseDown
			|| h = HideTop + 2*hideside
			if .noclutter!=h
				.NoClutter = H
				.ViewAsCurr


	function TestCompilerAlive
		opt NoRefCounts
		|| c = .compilr
		if (c!=nil)
			if !c.Alive
				if c is dead
					.CrashedFB(c, "Process found dead.")
				c.Disconnect
			  elseif (c.closed)
				.CancelCompile
		c = .feedback
		if c != nil and C is dead
			(C is invalid)
			.CrashedFB(c, "Process found dead.")


	function SaveMemory
		require !.IsFront and !.UsingSpdLib
		|| f = .Feedback
		if f.IsOpen and f.lastsend.ago > date.seconds(30+.position)
			|| msg = "Released Speedie: " + .name
			.LogOneAction(@emb + msg)
			.feedback.KillButOK
		

	behaviour FrameUpdate // perframe, eachframe, onframe
		.tabs.TrimWidth
		if !ShouldNotDisturbGUI
			.SaveMemory
			if !.focus
				.setfocus(.editme) // shouldn't need this... why doesn't .focus setter get called?
		.UpdateDebuggedApp(false)
		.TestCompilerAlive
		.SpeedieMsgReceive(.feedback)
		.SpeedieMsgReceive(.compilr)
		.UpdateSearchText
		.UpdateStatusErrors
		.ReadLog
		.PopupDisplayFadeIn
		
			
		|| fc = sdlapp.FrameCount|int|
		require .islast
		if fc+1 isa 64
			require !.ProjClosed
			
		if !.openedmenu
			if (perryide.statsmode == 2) and (fc isa 64)
				.UpdateMem = true
			if .UpdateMem
				.ShowLeftStats
				
		if fc isa 32
			.CheckModified
		
		if !ShouldNotDisturbGUI and !.DebugArgsList.HasFocus
			.HideStuff

	function CheckModified
		.EditMe.document.checkmodified?
//		.drawme.document.checkmodified?
		

	function ProjClosed (|bool|)
		opt norefcounts
		|| f = .project
		require f and !f.exists
		
		if "This project can't be found on the file-system anymore.\n\nWould you like to close it?".confirm
			.close(sdlapp.kactivity)
			return true
			
		// So what if it doesn't exist? Tell the user, right?
			
		
	function ShowNextError (|int| dir=1, |bool|)
		opt norefcounts
		|| L = .ErrorList
		if !dir and !L.listsource.hasany
			return true
		
		|| Err = l.FirstSelected
		if keys.shift
			dir = -dir
		if err and dir
			err = err.loop(dir>0, nil)
		if !err
			err = (L.start, l.end)(dir>0)
		if err
			L.select(err)
		  else
			err = .editme.myerror
			if err isa error
				.ClickedError(err)
		
		return true


	function ShowFind (|bool|)
		.retextsubfind
		.ViewAsProject
		.View(.ViewSearch)
		.MassSearchField.SelectAll
		.MassSearchField.SetFocus
		return true


	function SendCrash
		"Trying to crash"
		.SendFeedbackmsg(@tmp+"crash")

	
	helper CmdKey (|keys| key, |bool|)
		if key is f
			if .masssearchfield.hasfocus
				if .PrevView
					.PrevView.Click
				return .editme.OpenSearch
			return .ShowFind
		if key is k
			|| t = .outtext
			if t and !super.keydown(key)
				t.text = ""
			return true
		if key is j
			return .SelTextParse
		if key is e
			return .ShowErrors(true)
		if key is comma
			return ClickedPrevNext(.goprev)
		if key is period
			return ClickedPrevNext(.gonext)
		if key is squote
			return .ShowNextError
		if key is r
			ClickedDebug(.runButton)
			return true
		if key is o
			if keys.shift
				clickedopenfile(self)
			  else
				clickedopenproj(self)
			return true
		if key is n
			if keys.shift
				clickedCreatefile(self)
			  else
				clickedCreateproj(self)
			return true
		if key is l // l = file list
			if keys.option or keys.Shift
				RightClickNext(.goprev)
				return .goprev.searchmenu
			  else
				return .ShowQuickStuff(true)
		if key is d
			return .ShowQuickStuff(false)
		if key is b
			Clickedcompile(.buildbutton)
			return true
		if key is s
			if .editme is visible
				.SaveEditing(documentstate.saving)
				return true
		if key is num0
			.ViewAsSwap
			return true
		if key is num9
			.EditSep.Flip
			return true


	function ShowQuickStuff (|bool| FuncMenu, |bool|)
		if FuncMenu
			if (.FunctionMenu.MenuIsOpen)
				FuncMenu = false
		  else
			if (.filelist.QuickOpen is visible)
				FuncMenu = true
		if FuncMenu
			// some double -L bug here
			.FileList.quickopen isnt visible
			if .FunctionMenu.SearchMenu
				return true
			return .FileList.ShowQuickOpen
			
		  else
			.FunctionMenu.SubMenu.CloseMenu
			if .FileList.ShowQuickOpen
				return true
			return .FunctionMenu.SearchMenu
			
	
	behaviour KeyDown
		if keys.cmd and .cmdkey(key)
			return true
		if (key is tab) and .openedmenu == .autocomplete
			return .autocomplete.doreturn
		return super.keydown(key)

	
	function GotoIncludedFile (|string| path, |filerow|)
		|| f = .FileList[path]
			.FileList.Select(f)
		return f
	
	
	function GotoAnyFile (|string| path, |string| line="")
		|| f = .GotoIncludedFile(path)
		f := .FileList.AddExtra(path)
		if f and line
			.EditMe.ViewLineAndSel(line.int)
	
		
	function Root (|filerow|)
		opt norefcounts
		return .FileList.start as filerow


	function file.NeedsOwnWindow (|bool|)
		if .IsProj
			return true
		if .isSource
			|| m = .parse
			if m.Find(@tmp, "main")
				return true


	function OpenDoc (GUIPasteEvent)
		require self
		if !.project
			.Loadproject(data.file)
			return self
		|| p   = data
		|| ext = p.ext
		|| f   = p.file
		if f.isdir
			p = p.pathdir
		if .GotoIncludedFile(p)
			rz = self
		  elseif f.NeedsOwnWindow
			rz = IdeAddProj(p)							// add as project
		  else
			.filelist.addextra(p)						// add root
			rz = self
		startupwindow.hide
		.showide


	Syntax UsingComplete
		.StillJumping = false
		.AddToJumpHistory

		
	Syntax Using (|PerryIDE|)
		.AddToJumpHistory
		.StillJumping = true
		return self


	module
		|bool| DummyTest
		|byte| StatsMode
		syntax access (|int| i, |perryide|)
			opt norefcounts
			for w in window.all
				if w isa perryide
					if i <= 0
						return w
					i--
		
		
		function New (|string| path, |perryide|)
			rz = perryide(false)
			if rz
				rz.LoadProject(path.file)
				rz.EditMe.SetFocus
		
		
		function EmptyBase (|perryide|)
			opt norefcounts
			for w in window.all
				if w isa perryide
					if !w.root
						return w
	
	
		function PerryOpenDoc (GUIPasteEvent)
			|| i = .ide
				require data.fileexists
			  else
				i = perry.ProjContaining(data)
				if !i
					i = IdeAddProj(data, nil) // need to find it, not use the front!
			return i.OpenDoc(after, data, purpose)

		
	function LoadErrors (|bool| jump, |bool| actual_compile) 
		opt norefcounts
		|| txt = .EditMe
		|| doc = txt.document
		|| path = (doc.location, "")(doc)
		|| lst = .errorlist
		.filelist.ClearErrors

		|error| jumpto 
		|| src = lst.ListSource
		|| ActualErrors = 0
		if src.hasany and src mustbe error
			for err in src
				if err.severity >= ErrorSeverity.Error
					ActualErrors++
				if err.path ~= path
					txt.LineErrorAdd(err)
					if jump and (!jumpto or err == lst.FirstSelected)
						jumpto = err
				if actual_compile
					.logarea <~ err.copy
				.filelist.ErrorAt(err)
				
		if jumpto
			txt.ErrorJump(jumpto)
		  elseif jump and actual_compile
			if .DuringMsgFB
				.DuringMsgFB = false
				lst.select(src.first)
		(self is broken) = ActualErrors > 0
		.RelistStartupErrors
		.logarea.listsource.keep(144)


	function EditRow (|listviewrow| r, |int|)
		if r isa filerow
			rz = .EditFile(r)
			.filelist.ScrollJump


	function CurrFileRow (|FileRow|)
		|| r = .FileList.FirstSelected as filerow
			return r
	
	
	function CurrPath (|string|)
		return .CurrFileRow.Location


	function EditFile (|FileRow| r, |int|) // editfile, loadfile, fileload, fileedit, openfile, fileopen
		require r and r.location and !.IsLoading
		.CurrFileName.text = r.name
		// the drawing thing needs a document too!
		// why not the same?
		// we could make editfield have an internal draw editor...
		// but at that point we might as well make a general viewer...
		// why not a 3D SDF viewer and audioplayer too.
		// or a fileviewer or a gamepreview player
		// better to have a generalised "fileviewer"
		|| g = (r isa "voi" or "png" or "qoi")
		if .IsGraphics != g
			.IsGraphics = g
			.IsLoading++
			.ViewAsCurr
			.IsLoading--
		|| ok = (.EditDraw(r), .EditText(r))(g)
		if ok != 1
			return ok

		.updatemem = true
		.IsLoading++
		.filelist.select(r)
		
		if !g
			.editme.ClearErrors
			.LoadErrors(true, false)
			if .editme.FindExpectsParse < 2
				.editsep.Collapse
		
		.popuphide
		.AddToJumpHistory
		if !g and .IsEditingSource and .feedback.closed
			.Recheck
		.IsLoading--
		
		return 1
			

	function EditDraw (|FileRow| r, |int|)
		if .drawme.LoadFile(r.location)
			return 1
		

	function EditText (|FileRow| r, |int|) // edittextfile, loadfile, fileload, fileedit, openfile, fileopen
		|| E	= .editme
		|| doc	= r.document
		if e.document == doc
			return -1
		
		|| Loaded =  E.LoadDocument(doc)
		doc.CompareTreesOnSave = .IsSpeedieCode
		.ListAllFuncs
		require Loaded
		|| it = .ProjMsg
			if !.isloading
				it["edit"] = r.location
			it["pos"] = doc.Position

		return 1


	function HandleAltered
		// well it depends on if we modified shared files?
		for i in perry.OpenProj
			i.ModifiedForCompile = true
		.recheck				// could be delayed, too.


	function UpdateActiveFile
		|| d = .editme.Document$
		|| l = d.Location.Resolve(true)$
		if l ~= app.prefpath.resolve
			.updateprefs
		  elseif l ~= .perryfile
			.updateperry
	
	
	function UpdatePerry
		.startuperrors.clear
		.StartFiles
		.LoadStartupErrors
	
	function UpdatePrefs
		|| oldPrefs = app.prefs
		app.prefs = nil
		if app.PrefsInit(0)
			.notify("Reloaded Prefs.")
		  else
			.notify("Prefs are corrupted")
			app.prefs = oldPrefs
		.LoadState


	function ParseErrorDetect
		// not necessarily an error!? what if the file is not spd?
		for e.toplist in .errorlist
			if e isa error
				if e is parse
					e.remove
		
		if .IsEditingSource	
			|| err = .editme.MyError
				.errorlist <~ err // right?

	
	function LoadStartupErrors
		while stderr.HasAnything
			|| err = stderr.pop
			notifications <~ err
			if err.IsBad
				.StartupErrors <~ err.copy


	function SaveDrawing
		.DrawMe.Save


	function SaveEditing (|int| Purpose) // savetext, savefile, filesave
		opt norefcounts
		if .DrawMe is visible
			return .SaveDrawing
		|| e = .editme
		.ParseErrorDetect
		
		if (!keys.shift and .IsSpeedieCode)
			.filelist.saveall(Purpose)
		  elseif e.WasEverAltered
			require e.Save
		  else
			return
		
		.UpdateActiveFile
		with .currfilerow
			.lastsize = e.Length
			if .location.pathiscode
				self.HandleAltered
		(self is modified) = (e is modified)


function string.GetSpeedieProj (|string| wanted, |string|)
	rz = self
	while rz and rz.ext ~!= wanted
		rz = rz.parent

