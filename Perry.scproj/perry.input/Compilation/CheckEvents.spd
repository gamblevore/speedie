

extend PerryIDE
	function RecheckAfterModify
		.ModifiedForCompile = true
		.recheck
	
	function Recheck
		if .ModifiedForCompile
			.ProjectWasModified
		|| p = .path					#debug_require

		|| StartAt = Perry.FinishedStartUp #require
		StartAt += 0.125s * .position
		|| now = date.now
		// remove or true later...
		if (true) or (now >= StartAt) or (now < Perry.FinishedStartUp)
			|| unused = @tmp + "unused"
			unused <~ p
			|| lf = .LostFunks
				unused <~ lf.copy
			.SendFeedbackMsg(unused)
	
	
	function ProjectWasModified
		.ModifiedForCompile = false
		require .projIsSpeedieCode and !.UsingSpdLib
		.Feedback = nil
		.AskCheck
	
	
	function AskCheck
		.SendFeedbackStr "check"
		

	syntax is (|ListViewState| s, assigns:|bool| mod)
		opt norefcounts
		|| r = .SharedProjectTabSource
			r.syntaxis(s) = mod
		
		if (s is modified)
			|| sub = .CurrFileName.SubMenu
				(sub.ListSource is modified) = Mod


	function ClearErrors (|bool| Compiled)
		isnt Broken
		.CompileOKString = ("Compile OK", "Check OK")(Compiled)
		.errorlist.Clear
		.editme.ClearErrors
		.filelist.ClearErrors
		.RelistStartupErrors
		.UpdateErrorCount
		
	
	function CheckedOK (|string| kind, |bool|)
		.ClearErrors(kind=="compile")
		if .viewing == .ViewErrors
			.NoNeed(.CompileOKString, .viewfiles)
		return true


	function message.ActualReplaceError (|string| src)
		|| SubError = src.parse.first
			.ReplaceWith(suberror)
	
	
	function message.CleanErrors
		opt norefcounts
		for e in self
			|| a = e.arg
				|| f = a["file"]
				|| str = a.firstName
				if (f ~= "(string)") and (str[0, "error\n"])
					e.ActualReplaceError(str)


	function ShowCompileErrors (|message!| msg, |bool| RealCompile, |bool|)
		|| MaybeOK = msg.last
		if (MaybeOK == @thg and "ok")
			.ErrorList.clear
			.UpdateErrorCount
			return .CheckedOK(msg.name)
	
		// inconsistant input...
		|| arg = msg
		if arg != @arg
			arg = msg.arg
		  else
			MaybeOK = msg
		arg.cleanErrors
		
		is Broken
		.NoNeed
		|| newlist = error.from(MaybeOK)
		newlist ?= Error()
		.errorlist.listsource = newlist
		.UpdateErrorCount
		if .IsFront
			if RealCompile or .ErrorList isnt Visible
				beep
		.ShowErrors


	function UpdateErrorCount
		opt norefcounts
		|| h = .errorlist.headers
			h.name = ""
			|| n = .errorlist.listsource.Count
				h.name = n of "issue"

	function ExpandCompileSep (|bool|)
		|| coll = .ProductSep.divider.Collapsed
			.ShowCompileTab(.SpeedieText)
			return !.ProductSep.divider.Collapsed


	function CheckMsg (|string| operation, |bool| SaveAll, |message|)
		if SaveAll
			require .filelist.SaveAll(documentstate.saving)
		|| cmd = @tmp + operation
		cmd <~ .Project.path
		return cmd


	function DebugFB (|message| msg)
		// || pp = .ProductPath
		// we actually... hmmm... can't open the debugger yet. not until it's made!
	
		
	function ErrorListFB (|message| msg, |bool|)			// errorfb, errorsfb
		|| RealErrors	= msg ~!= "check"
		.ClearErrors(RealErrors)
		|| NoErrors		= .ShowCompileErrors(msg, RealErrors)
		|| ErrsVis		= .isviewing(.ErrorList) 
		.errorlist.SelectFirst
		if !RealErrors
			0
		  elseif NoErrors
			if errsvis
				.view(.viewfiles)
			if msg ~= "debug"
				.debugFB(msg)
		  elseif !errsvis
			.view(.viewerrors)
			.say(" failed. Could not compile")
		.LoadErrors(RealErrors, realerrors)
		.showstats

	
	function ReadLog (|bool| Killed=false)
		|| c = .Compilr $
		|| StdOut = c.ReadStdOut
		.SpeedieText.log(StdOut)
		|| IsRunning = c.status.IsRunning
		require !IsRunning or Killed

		|| Bad = .CheckCrashed(c,  "compiler")
		|| Errors = c.readstderr
			|| p = errors.parse
				.ShowCompileErrors(p, true)
			// Notifications will pick up the err otherwise!
		  elseif !bad
			if !killed
				|| msg = @tmp + "compile"
				msg <~ (@thg, "ok")
				.ShowCompileErrors(msg, false)
			.CompiledOK(killed)
		.compilr = nil
		.RenableAfterCompile


	function Say (|string| str)
		target osx
			if !.IsFront or GUI.IsBackground
				.Talker = unixProcess.spawn("/usr/bin/say", [.name.trimext + str])
				(.talker)
	
	
	function CompiledOK (|bool| Killed)
		|| db = .DebugMode
		.CheckedOK("compile")
		|| last = .speedietext.text.parse.last
		
		ifn last == @tmp and "Product"
			if !killed
				error last
		  else
			|| path = last[@nil]
			if path.ExpectString
				|| file = @url + "file"
				file <~ path
				|| str = "\n\nCompiled OK!"
				|| f = path.name.file
				if !f.exists
					str += " But it doesn't exist :("
				.notify(.name + str, file)
				.say(str)
				if .DebugMode != db // hmmm why not just get it here?
				if !killed
					if (db is run or debug) and f.exists and stderr.ok
						.run_compile_wrap(f)


	function Notify (|string| What, |message| response=nil)
		|| c = what
		if response
			c = what + ("\n" + response.render) // hmmm... seems awkward
		.LogOneComm(@emb + ("\1b " + c))
		notifications <~ (what, response)
	
	
	function CancelCompile (|bool| Beep=false, |bool|)
		opt norefcounts
		|| c = .Compilr
		if !c
			if beep
				Notifications <~ "Nothing is building"
				beep
			return .RenableAfterCompile
		c.Kill(0)
		app.Sleep(0.025) // allow pipes to work
		.Readlog(true)
		return true


	function RenableAfterCompile (|bool|)
		.DebugMode = 0
		|| code = .ProjIsSpeedieCode
		(.buildbutton is enabled) = code
		(.runbutton is enabled) = code
		(.buildbutton is visible)
		(.progress isnt visible)
		.HideStuff
		isnt active
		return true


	function IsBuilding (|bool|) // .isbuilding, .iscompiling, .compiling 
		return .buildbutton isnt enabled



function fnBuildIsDead (fnConfirmCanceller)
	if self mustbe perryide
		if !.IsBuilding
			return .CancelCompile


function ClickedCancel (GUIAction)
	|| i = .ide
	if !i.Isbuilding
		return true
	|| can = ConfirmCanceller(i, fnBuildIsDead)
	|| name = i.project.TrimCodeExt
	|| q = "Currently building $name... Cancel Build of $name?"
	if q.confirm(can)
		return i.CancelCompile


