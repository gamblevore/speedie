

function ReturnDebugArgs (GUIListEvent)
	if row isnt editable
		|| r = .AddRow
		row.prev = r
		(r is editable)
		.Rename(r)
		return true
	  else
		.Rename(row)


function DebugArgsKeyDown (GUIKeyEvent)
	opt norefcounts
	if key.IsCancel
		.window.clearfocus
		return true
	
	
function FoundListKeys (GuiKeyEvent)
	if key.IsDelete
		if self isa ListView
			|| s = .sel
				.RemoveRow(s)
		return true


	
function DebugArgsGotFocus (guiaction)
	|| f = .ide.DebugArgsFile #require
	|| v = state == 1
	require (self is visible) != v
	(self is visible) = v
	if v and self isa TextView
		.text = f.ReadAll
		|| data = .parse
			if !data..args
				self <~ "\nargs\n\tArg1\n\tArg2\n"
			if !data..pwd
				self <~ "\npwd '.'\n"
			if !data..env
				self <~ "\nenv\n\tsetting=\"value\"\n"
		.window.setinnerfocus(self)
	  else
		f.SmartData = .text
		

function fnStillRunning (fnConfirmCanceller)
	if self isa perryide
		.UpdateDebuggedApp(false)
		if !.RunCompiledApp
			return true

	
function Window.Confirm (|string| Q, |fnConfirmCanceller| fn, |bool|)
	|| can = ConfirmCanceller(self, fn)
	if q.confirm(can)
		return true
	

function ClickedDebug (GUIAction)
	|| i = .ide	
	if .text == "\02" // play // the user cares about what he can see...
		i.DebugIsWaitingForCompile = true
		i.compile("debug")
		i.ShowText(i.ProductPage, "")
	  elseif .text == "\07" // stop
		if i.RunCompiledApp and i.confirm("Kill running product " + i.Name + "?", fnStillRunning)
			i.RunCompiledApp.kill
			i.UpdateDebuggedApp(true)


function PressingDebug (GUIAction)
	|| d = .ide.DebugArgsList
	DebugArgsGotFocus(d, 1)


function perryide.StartDebugging (|file| f)
	require f.MustExist

	|| file = .DebugArgsList.text.Parse$
	|| args = file["args"].AllNames
	if f.isdir
		args = [f] + args
		f = "/usr/bin/open".file

	|| fs = faststring()
	.RunCompiledApp = ShellStream(f, args, fs, fs)
	if .RunCompiledApp and .RunCompiledApp.PID
		.RunButton.text = "\07"
		


function perryide.UpdateDebuggedApp (|bool| Kill, |bool|)
	|| r = .RunCompiledApp						#require
	// so what if we have a shellstream? then what?
	|| fs = r.output
	if !r.userflags and fs.length
		.ShowStdOut
		r.userflags |= 1
	
	if !r.step or kill
		.runcompiledapp = nil
		.RunButton.text = "\02"
		
	.productpage <~ fs.GetResult // later we will make this NOT do string appends to create .text
	if kill
		.productpage <~ "(--Process Killed--)"
	return !kill
		
