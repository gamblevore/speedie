

function DebugArgsKeyDown (GUIKeyEvent)
	opt norefcounts
	if key.IsCancel
		.window.clearfocus
		return true
	
	
function FoundListKeys (GuiKeyEvent)
	if key.IsDelete
		if self isa ListView
			|| s = .FirstSelected
				.RemoveRow(s)
		return true


function DebugArgsGotFocus (guiaction)
	|| v = state == 1
	require (self is visible) != v
	(self is visible) = v
	if self isa textview
		.updatedebugargs(v)


function textview.UpdateDebugArgs (|bool| Visible=false)
	|| f = .ide.DebugArgsFile #require
	if !.Document
		.LoadDocument(Document(f))
	if !.text.Length
		self <~  qqfiles.DebugArgs
	if visible
		.window.setinnerfocus(self)
	  else
		if .text and .text != qqfiles.DebugArgs
			.Save
		  elseif f.exists
			f.size = 0
		

function fnStillRunning (fnConfirmCanceller)
	if self isa perryide
		.UpdateDebuggedApp(false)
		if !.RunCompiledApp
			return true

	
function Window.Confirm (|string| Q, |fnConfirmCanceller| fn, |bool|)
	|| can = ConfirmCanceller(self, fn)
	if q.confirm(can)
		return true
	

function ClickedDebug (GUIAction)
	|| i = .ide	
	if .text == "\02"		// play
		i.DebugIsWaitingForCompile = true
		i.compile("debug")
		i.ShowText(i.ProductPage, "")
	  elseif .text == "\07" // stop
		if i.RunCompiledApp and i.confirm("Kill running product " + i.Name + "?", fnStillRunning)
			i.RunCompiledApp.kill
			i.UpdateDebuggedApp(true)


function PressingDebug (GUIAction)
	|| d = .ide.DebugArgsList
	DebugArgsGotFocus(d, 1)


function perryide.DebugEnvs (|message| env)
	for rel in env
		|| ch1 = rel.first
		|| opp = rel[@opp, 1]
			opp.expect(@opp, "=")
		|| ch2 = opp.next
			check (ch1.name) (ch1, "No name found")
			check (ch2.name) (ch2, "No name found")
		if StdErr.ok
			app.ChildEnv(ch1.name) = ch2.name


function perryide.DebugActual (|file| f, |[string]| args)
	|| fs = faststring()
	.RunCompiledApp = ShellStream(f, args, fs, fs)
	if .RunCompiledApp and .RunCompiledApp.PID
		.RunButton.text = "\07"


function perryide.DebugPath (|file| f, |message| conf)
	|| p = .Project
	if !p.isdir
		p = p.Parent
	app.cwd = p
	
	|| path = conf["pwd"].goodname
	if path and path != "."
		app.cwd = path


function perryide.StartDebugging (|file| f)
	require f.MustExist and StdErr.ok

	.debugargslist.UpdateDebugArgs
	|| debugargs = .DebugArgsFile.parse #require
	|| ArgMsg = debugargs["args"]
	|| args = argmsg.AllNames
	if f.isdir
		check (!args) (ArgMsg, "You can't pass arguments to gui-apps (in this version).")
		args = [f]
		f = "/usr/bin/open".file


	|| old = app.cwd
	.debugpath(f, debugargs)	
	.DebugEnvs(debugargs["env"])		
	.DebugActual(f, args)

	if !StdErr.ok
		.DebugArgsList.FillErrors(StdErr)
		Notifications <~ StdErr.FirstError
	app.cwd = old


function perryide.UpdateDebuggedApp (|bool| Kill, |bool|)
	|| r = .RunCompiledApp						#require
	// so what if we have a shellstream? then what?
	|| fs = r.output
	if !r.userflags and fs.length
		.ShowStdOut
		r.userflags |= 1
	
	if !r.step or kill
		.RunCompiledApp = nil
		.RunButton.text = "\02"
		
	.productpage <~ fs.GetResult // later we will make this NOT do string appends to create .text
	if kill
		.productpage <~ "(--Process Killed--)"
	return !kill
		
