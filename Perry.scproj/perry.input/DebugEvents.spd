

function ReturnDebugArgs (GUIListEvent)
	if row isnt editable
		|| r = .AddRow
		row.prev = r
		(r is editable)
		.Rename(r)
		return true
	  else
		.Rename(row)


function DebugArgsKeyDown (GUIKeyEvent)
	opt norefcounts
	if key.IsCancel
		.window.clearfocus
		return true
	
	
function FoundListKeys (GuiKeyEvent)
	if key.IsDelete
		if self isa ListView
			|| s = .sel
				.RemoveRow(s)
		return true


	
function DebugArgsGotFocus (guiaction)
	|| f = .ide.DebugArgsFile #require
	|| v = state == 1
	require (self is visible) != v
	(self is visible) = v
	if v and self isa TextView
		.text = f.ReadAll
		|| data = .parse
			if !data..args
				self <~ "\nargs\n\tArg1\n\tArg2\n"
			if !data..pwd
				self <~ "\npwd '.'\n"
			if !data..env
				self <~ "\nenv\n\tsetting=\"value\"\n"
		.window.setinnerfocus(self)
	  else
		f.SmartData = .text
		



function ClickedDebug (GUIAction)
	|| i = .ide	
	i.DebugIsWaitingForCompile = true
	i.compile("debug")


function PressingDebug (GUIAction)
	|| d = .ide.DebugArgsList
	DebugArgsGotFocus(d, 1)


function perryide.StartDebugging (|file| f)
	require f.MustExist

	|| file = .DebugArgsList.text.Parse$
	|| args = file["args"].AllNames
	if f.isdir
		args = [f] + args
		f = "/usr/bin/open".file
	|| fs = faststring()
	.RunCompiledApp = shellstream(f, args, fs, fs)


function perryide.UpdateDebuggedApp
	|| r = .RunCompiledApp #require
	// so what if we have a shellstream? then what?
	|| fs = r.output
	if !r.userflags and fs.length
		.ShowStdOut
		r.userflags |= 1
	
	if !r.step
		.runcompiledapp = nil
		
	.productpage <~ fs.GetResult // later we will make this NOT do string appends to create .text
	// what else can we do? send some msgs via ipc? lol. i cant do anything else?
