

function ReturnDebugArgs (GUIListEvent)
	if row isnt editable
		|| r = .AddRow
		row.prev = r
		(r is editable)
		.Rename(r)
		return true
	  else
		.Rename(row)


function DebugArgsKeyDown (GUIKeyEvent)
	opt norefcounts
	if key.IsCancel
		.window.clearfocus
		return true
	
	
function FoundListKeys (GuiKeyEvent)
	if key.IsDelete
		if self isa ListView
			|| s = .sel
				.RemoveRow(s)
		return true


	
function DebugArgsGotFocus (guiaction)
	|| f = .ide.DebugArgsFile #require
	|| v = state == 1
	require (self is visible) != v
	(self is visible) = v
	if v and self isa TextView
		.text = f.ReadAll
		|| data = .parse
			if !data..args
				self <~ "\nargs\n\tArg1\n\tArg2\n"
			if !data..pwd
				self <~ "\npwd '.'\n"
			if !data..env
				self <~ "\nenv\n\tsetting=\"value\"\n"
		.window.setinnerfocus(self)
	  else
		f.SmartData = .text
		

function fnStillRunning (fnConfirmCanceller)
	if self isa perryide
		.UpdateDebuggedApp(false)
		if !.RunCompiledApp
			return true

	
function Window.Confirm (|string| Q, |fnConfirmCanceller| fn, |bool|)
	|| can = ConfirmCanceller(self, fn)
	if q.confirm(can)
		return true
	

function ClickedDebug (GUIAction)
	|| i = .ide	
	if .text == "\02" // play // the user cares about what he can see...
		i.DebugIsWaitingForCompile = true
		i.compile("debug")
		i.ShowText(i.ProductPage, "")
	  elseif .text == "\07" // stop
		if i.RunCompiledApp and i.confirm("Kill running product " + i.Name + "?", fnStillRunning)
			i.RunCompiledApp.kill
			i.UpdateDebuggedApp(true)


function PressingDebug (GUIAction)
	|| d = .ide.DebugArgsList
	DebugArgsGotFocus(d, 1)


function perryide.DebugEnvs (|message| env)
	for rel in env
		|| ch1 = rel.first
		|| opp = rel[@opp, 1]
			opp.expect(@opp, "=")
		|| ch2 = opp.next
			check (ch1.name) (ch1, "No name found")
			check (ch2.name) (ch2, "No name found")
		if StdErr.ok
			app.ChildEnv(ch1.name) = ch2.name


function perryide.DebugActual (|file| f, |[string]| args)
	|| fs = faststring()
	.RunCompiledApp = ShellStream(f, args, fs, fs)
	if .RunCompiledApp and .RunCompiledApp.PID
		.RunButton.text = "\07"


function perryide.StartDebugging (|file| f)
	require f.MustExist and StdErr.ok

	|| file = .DebugArgsList.text.Parse$
	|| ArgMsg = file["args"]
	|| args = argmsg.AllNames
	if f.isdir
		check (!args) (ArgMsg, "You can't pass arguments to gui-apps (in this version).")
		args = [f]
		f = "/usr/bin/open".file
	
	using file["pwd"].goodname.TempCWD
		.DebugEnvs(file["env"])		
		.DebugActual(f, args)

	if !StdErr.ok
		.DebugArgsList.FillErrors(StdErr)
		Notifications <~ StdErr.FirstError
		

function perryide.UpdateDebuggedApp (|bool| Kill, |bool|)
	|| r = .RunCompiledApp						#require
	// so what if we have a shellstream? then what?
	|| fs = r.output
	if !r.userflags and fs.length
		.ShowStdOut
		r.userflags |= 1
	
	if !r.step or kill
		.RunCompiledApp = nil
		.RunButton.text = "\02"
		
	.productpage <~ fs.GetResult // later we will make this NOT do string appends to create .text
	if kill
		.productpage <~ "(--Process Killed--)"
	return !kill
		
