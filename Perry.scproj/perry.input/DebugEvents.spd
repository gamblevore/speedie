

function ReturnDebugArgs (GUIListEvent)
	if row isnt editable
		|| r = .AddRow
		row.prev = r
		(r is editable)
		.Rename(r)
		return true
	  else
		.Rename(row)


function DebugArgsKeyDown (GUIKeyEvent)
	opt norefcounts
	if FoundListKeys(self, key)
		return true
	if key.IsAccept and self isa listview
		return ReturnDebugArgs(self, .listsource.last)
	if key.IsCancel
		.window.clearfocus
		return true
	
	
function FoundListKeys (GuiKeyEvent)
	if key.IsDelete
		if self isa ListView
			|| s = .sel
				.RemoveRow(s)
		return true


function DebugArgsGotFocus (guiaction)
	|| v = state == 1
	require (self is visible) != v
	|| lv = self|listview|			// .DebugArgsList
	|| i = .ide
	|| f = i.DebugArgsFile #require
	if v
		|| list = f.ReadAll.parse|listviewrow|
		lv.listsource = list
		for s in list
			(s is editable)
		
		|| L = list.msg(@str, "(Add Command Line Arg...)")|listviewrow|
		(L is AlignCenter)
		lv.SelectFirst
	  else
		|| list = lv.listsource
		|| l = list.last
		if (l is aligncenter)
			l.remove
		f.SmartData = list.render
		list <~ l
	(self is visible) = v



function ClickedDebug (GUIAction)
	|| i = .ide	
	i.DebugIsWaitingForCompile = true
	i.compile("debug")


function PressingDebug (GUIAction)
	|| d = .ide.DebugArgsList
	DebugArgsGotFocus(d, 1)
	d.SetFocus


function perryide.StartDebugging (|file| f)
	require f.MustExist

	|| args = .DebugArgsList.listsource.AllNames
	if f.isdir
		args = [f] + args
		f = "/usr/bin/open".file
	|| fs = faststring()
	.RunCompiledApp = shellstream(f, args, fs, fs)


function perryide.UpdateDebuggedApp
	|| r = .runcompiledapp #require
	// so what if we have a shellstream? then what?
	|| fs = r.output
	if !r.userflags and fs.length
		.ShowStdOut
		r.userflags |= 1
	
	if !r.step
		.runcompiledapp = nil
		
	.stdout <~ fs.GetResult // later we will make this NOT do string appends to create .text
	// what else can we do? send some msgs via ipc? lol. i cant do anything else?
