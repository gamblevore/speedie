

extend PerryIDE
	function Recheck 
		require .ModifiedForCompile
		.ModifiedForCompile = false
		.ForceRecheck
		
	function ForceRecheck
		if .IsSpeedieCode and !.UsingSpdLib
			.GetFeedbackStr "check"

	
	syntax is (|ListViewState| s, |bool|)
		return .projmsg.syntaxis(s)
	syntax isnt (|ListViewState| s, |bool|)
		return !.syntaxis(s)
	syntax is (|ListViewState| s, assigns:|bool| mod)
		.projmsg.syntaxis(s) = mod
		
		if (s == listviewstate.modified)
			|| sub = .CurrFileName.SubMenu
				|| src = sub.ListSource
					(src is modified) = Mod

	syntax isnt (|ListViewState| s, assigns:|bool| b)
		.syntaxis(s)=!b

	function ClearErrors (|bool| Compiled)
		isnt Broken
		.CompileOKString = ("Compile OK", "Check OK")(Compiled)
		.errorlist.Clear
		.editme.ClearErrors
		.filelist.ClearErrors
		.RelistStartupErrors
	
	
	function CompiledOK (|message| msg, |bool|)
		isnt active
		.ClearErrors(msg=="compile")
		if .viewing == .ViewErrors
			.NoNeed(.CompileOKString, .viewfiles)
		return true


	function ShowCompileErrors (|message| msg, |bool|)
		isnt active
		|| MaybeOK = msg.first
		sdlapp.CompileStatus = nil
		|| err = .editme.MyError
		if !err and (MaybeOK == "ok")
			.ErrorList.clear
			return .CompiledOK(msg)

		is Broken
		.NoNeed
		.errorlist.listsource = MaybeOK.jberrors
		.RelistStartupErrors
		if err
			.ErrorList <~ err


	function Compile (|string| operation)
		if !.Building
			.ActualCompile(.CompileMsg(operation, true))
		  elseif .editsep.div.Collapsed
			.ShowStdOut  
		  else
			ClickedCancel(.BuildButton)
			
	
	function CompileMsg (|string| operation, |bool| SaveAll, |message|)
		if SaveAll
			require .filelist.SaveAll(documentstate.saving)
		|| cmd = @tmp + operation
		cmd <~ .Project.path
		return cmd


	function DebugFB (|message| msg)
		// || pp = .ProductPath
		// we actually... hmmm... can't open the debugger yet. not until it's made!
	
		
	function ErrorListFB (|message| msg, |bool|)
		.filelist.ClearErrors
		|| NoErrors		= .ShowCompileErrors(msg)
		|| ErrsVis		= .isviewing(.errorlist) 
		.errorlist.selectfirst
		|| RealErrors	= msg ~!= "check"
		if !RealErrors
			0
		  elseif NoErrors
			if errsvis
				.view(.viewfiles)
			if msg ~= "debug"
				.debugFB(msg)
		  elseif !errsvis
			.view(.viewerrors)
		.LoadErrors(RealErrors, realerrors)
		.showstats


	function LogFB (|message| msg)
		// ignore.
	
	function Readlog
		if .Building
			.justreadlog

	function JustReadLog
		opt norefcounts
		.speedietext <~ .Compilr.ReadStdOut
	
	function CompileFB (|message| msg, |bool|)
		|| db = .DebugIsWaitingForCompile
		.CancelCompile
		|| first = msg.first						#require
		if first == @arg // an error-list
			return .ErrorListFB(msg)
		.CompiledOK(msg)
		
		require self isnt broken
		|| file = @url + "file"
		file <~ first
		|| str = "\n\nCompiled OK!"
		.notify(.name + str, file)
		target osx
			.Talker = ShellStream("/usr/bin/say", [.name.trimext + str])
		if db
			.StartDebugging(msg.first.name.file)
				
				
	function Notify (|string| What, |message| response=nil)
		|| c = what
		if response
			c = what + ("\n" + response.render) // hmmm... seems awkward
		.logonecomm(@emb + ("\1b " + c))
		notifications <~ (what, response)
	
	
	function CancelCompile 
		.DebugIsWaitingForCompile = false
		.compilr.KillButOK? // frees memory
		(.buildbutton is enabled)
		(.runbutton is enabled)
		(.progress isnt visible)
		.JustReadlog
		isnt active

