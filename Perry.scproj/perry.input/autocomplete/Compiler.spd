

extend PerryIDE
	function Recheck 
		require .ModifiedForCompile
		.ModifiedForCompile = false
		.ForceRecheck
		
	function ForceRecheck
		if .IsSpeedieCode and !.UsingSpdLib
			.SendFeedbackStr "check"


	syntax is (|ListViewState| s, |bool|)
		return .projmsg.syntaxis(s)
		

	syntax isnt (|ListViewState| s, |bool|)
		return !.syntaxis(s)
		

	syntax is (|ListViewState| s, assigns:|bool| mod)
		opt norefcounts
		.projmsg.syntaxis(s) = mod
		
		if (s == listviewstate.modified)
			|| sub = .CurrFileName.SubMenu
				|| src = sub.ListSource
					(src is modified) = Mod


	syntax isnt (|ListViewState| s, assigns:|bool| b)
		.syntaxis(s)=!b


	function ClearErrors (|bool| Compiled)
		isnt Broken
		.CompileOKString = ("Compile OK", "Check OK")(Compiled)
		.errorlist.Clear
		.editme.ClearErrors
		.filelist.ClearErrors
		.RelistStartupErrors
	
	
	function CompiledOK (|message| msg, |bool|)
		isnt active
		.ClearErrors(msg=="compile")
		if .viewing == .ViewErrors
			.NoNeed(.CompileOKString, .viewfiles)
		return true


	function ShowCompileErrors (|message| msg, |bool|)
		isnt active
		|| MaybeOK = msg.first
		if (MaybeOK == "ok")
			.ErrorList.clear
			return .CompiledOK(msg)

		is Broken
		.NoNeed
		.errorlist.listsource = error.from(MaybeOK)


	function Compile (|string| operation)
		if .Building
			if .editsep.div.Collapsed
				.ShowStdOut 
				return 
			require ClickedCancel(.BuildButton)
		.ActualCompile(.CompileMsg(operation, true))
			
	
	function CompileMsg (|string| operation, |bool| SaveAll, |message|)
		if SaveAll
			require .filelist.SaveAll(documentstate.saving)
		|| cmd = @tmp + operation
		cmd <~ .Project.path
		return cmd


	function DebugFB (|message| msg)
		// || pp = .ProductPath
		// we actually... hmmm... can't open the debugger yet. not until it's made!
	
		
	function ErrorListFB (|message| msg, |bool|)
		|| RealErrors	= msg ~!= "check"
		.ClearErrors(RealErrors)
		|| NoErrors		= .ShowCompileErrors(msg)
		|| ErrsVis		= .isviewing(.errorlist) 
		.errorlist.selectfirst
		if !RealErrors
			0
		  elseif NoErrors
			if errsvis
				.view(.viewfiles)
			if msg ~= "debug"
				.debugFB(msg)
		  elseif !errsvis
			.view(.viewerrors)
			.say(" failed. Could not compile")
		.LoadErrors(RealErrors, realerrors)
		.showstats


	function LogFB (|message| msg)
		// ignore.
	
	function Readlog
		if .Building
			.justreadlog

	function JustReadLog
		opt norefcounts
		.speedietext <~ .Compilr.ReadStdOut
	
	function Say (|string| str)
		target osx
			if !.IsFront or SDLApp.IsBackground
				.Talker = ShellStream("/usr/bin/say", [.name.trimext + str])
	
	function CompileFB (|message| msg, |bool|)
		|| db = .DebugIsWaitingForCompile
		.CancelCompile
		|| first = msg.first						#require
		if first == @arg // an error-list
			return .ErrorListFB(msg)
		.CompiledOK(msg)
		
		require self isnt broken
		|| file = @url + "file"
		file <~ first
		|| str = "\n\nCompiled OK!"
		.notify(.name + str, file)
		.say(str)
		if db
			.StartDebugging(msg.first.name.file)
				
				
	function Notify (|string| What, |message| response=nil)
		|| c = what
		if response
			c = what + ("\n" + response.render) // hmmm... seems awkward
		.logonecomm(@emb + ("\1b " + c))
		notifications <~ (what, response)
	
	
	function CancelCompile 
		.DebugIsWaitingForCompile = false
		.compilr.KillButOK? // frees memory
		(.buildbutton is enabled)
		(.runbutton is enabled)
		(.progress isnt visible)
		.JustReadlog
		isnt active

