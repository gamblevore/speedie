

function textview.RangeCheck (|int| r, |message| func_name, |message| prms, |bool|)
	|| l = func_name.position
	|| a = func_name.after 
	if prms and prms != @arg
		a  = prms.after
		a += !self[a].IsTextLine
	return r in (l, a) // allow a little lee-way
	

function textview.CodeInsertion (|textviewline| D, |&int| s_end, |&bool| inrange, |&message| found, |int|)
	visible
	opt norefcounts
	
	|| msg	= d.message.FindTightest(*s_End)
	|| msg0 = msg
	while
		require msg
		loop msg != @tmp and @arg
		msg = msg.parent
	
	ifn (msg == @tmp) and msg.name
		if msg in @tmp
			|| msg2 = msg.owning_modclass
				if (msg0 in @decl) and msg0.isfirst
					msg0 = msg0.parent
				if msg0 == @decl
					*inrange = true
					*found = msg0
					return 4					// 4: function a.b (|*|)
		if msg0 == @thg and msg0 in @decl and msg0.prev == @emb
			return -2
		return nil

	require d.after >= msg.after

	if !autocomplete.IsAFunc(msg)
		*found = msg
		return 10
	|| ConstructorLike = msg ~= "constructor" or "render"
	|| func_name = msg.first
	|message| prms
	if ConstructorLike and (func_name == @bra or @list)
		prms = func_name
		func_name = nil						// 0: constructor (|int| x)
		*inrange = .RangeCheck(*s_end, msg, prms)
	  else
		if !func_name or func_name == @arg
			*found = msg // i guess?
			if msg == "main"
				return 0 // all is good
			return 1 + ConstructorLike
		prms = func_name.next
		*inrange = .RangeCheck(*s_end, func_name, prms)
		if prms == nil							// 2: constructor *
			*found = func_name
			return 2							// 2: function a.b*
		if (func_name == @arg)
			*found = msg
			return 1 + ConstructorLike				// 1: function *{}
												// 2: constructor *{}
		ifn prms == @list or @bra // great
			*found = func_name
			return 2							// 2: function a.b*
		
	
	|| arg = prms.next
	require (arg==nil or @arg)
	|| decl = prms.first
	*s_end = prms.after
	
	|message| Name
	while decl == @decl
		|| Type = decl.first$
		Name = Type.next
		if name == "..."
			return -1
		if !name
			*found = decl
			return 4						// 4: function a.b (|*|)
		decl = decl.next
	
	if Name
		*found = name
		return 5							// 5:function a.b (|type| name*)
	*found = prms
	return 3




// abc. --> abc.*			// problem is syncing.

// abc.def
// abc.def___

module PerryAutoCompleteReason
	constants
		tab = "Tab"
		escape = "Escape"
		sel = "Sel"
		modified = "Modified"

function TextView.ParamDisplayPlace (|message| msg, |int| x, |message|)
	opt norefcounts
	while msg != @arg and nil
		if msg == @prm
			if msg.after <= x
				return nil
			return msg.parent
		msg = msg.parent


function TextView.DoTheParamDisplayThing (|int| x, |bool| Force, |bool|) // paramthing
	opt norefcounts
	|| i = .ide
	|| msg = .ClickedMsg(x, true)
	|| type = ("displayallforced", "displayall")(force)
	|| msg2 = .ParamDisplayPlace(msg, x)
		i.MaybeSendMessage(type, msg2, msg2.name, "Sel")
	  else
		// say that it is "forced" here? (by sending "displayallforced" to showextrainfoatpos)?
		// and if it IS forced... we need to send that across to maybesendmessage
		// and react to that by instantly showing the popup.
		.ShowExtraInfoAtPos(x, type)
	return true
	// we now have a place for params but what func?


function TextView.PerryTryAutoComplete (|int| x, |string| type, |string| Reason, |bool|)
	|| before	= self[x-1]
	|| after	= self[x]
	|| IsDot	= (before == '.') 
	if !keys.option
		|| OK = IsDot  or  (before in jeebox.CSWordmiddle) // or (before.iswhite and after.istextline)
			OK = after out jeebox.CSWordStart
		if !OK and reason ~= PerryAutoCompleteReason.escape or PerryAutoCompleteReason.sel
			return .DoTheParamDisplayThing(x, reason ~= PerryAutoCompleteReason.escape)
	
	if (reason ~!= "Sel") and (type ~= "autocomplete") and (.FakeAutoComplete >= 1)
		.ide.ShowAuto(true)
		return true
	
	|| ok2 = false
	|| i = .ide
	|| msg = .ClickedMsg(x, true)
		i.editme.CanAutoComplete = true
		ok2 = i.MaybeSendMessage(type, msg, msg.name, reason)
		rz = true
	if !ok2 or !sdlapp.IsTyping
		i.AutoComplete.CloseMenu


function perryide.SetAutoPoint (|int| x)
	.AutoPoint = .editme.XYOfChar(x)// - (0,.editme.lineheight)
	.PopupDisplayCorner = .autopoint // wait why do I have two?


function message.FindPrms (|int| p, |message|)
	opt norefcounts
	for ch.flat in self
		require ch.position < p
		if ch.func.IsBra and ch.after > p
			return ch


function string.CharMode (|int| x, |int|)
	|| c = self[x] 
	if c == ' ' or '\t'
		return ' '
	if (c == ',' or '(') or c.istextline
		return ','
	if (c == '|' or ')')
		return '|'
	if jeebox.CSWordMiddle[c]
		return '_'
	return c


function textview.AfterComma (|int| p, |int| x, |int|)
	|| s = .text
	while x > p
		|| c = s.charmode(--x) 
		if c == ','
			return x
		require c == ' '


function textview.BeforeDecl (|int| p, |int| x, |bool|)
	|| s = .text
	while x < p
		|| c = s.charmode(x++) 
		if (c == '|')
			return true
		require c == ' '


function textview.InPrmsAndBetweenDecls (|message| msg, |int| x, |int|)
	opt norefcounts
	// just wanna find the msg that owns us!
	|| list = msg.findprms(x)$
	|| fn = list.owning_func$
	if .text.charmode(x) == ','
		return x
	rz = .aftercomma(list.position, x)
	if rz
		require .beforedecl(list.after, x)


	
function PerryInsert6 (|textview| self, |intrange| a, |bool|)
	.undochecker = -1
	|| toInsert = "|| name"

	|| sel = a.x+1
	if self[a.x-1] == ','
		toInsert = " " + toInsert
		sel++

	if self[a.x2] != ')'
		toInsert += ", "
		
	.InsertSub(toinsert , a)
	.sel = sel
	return true								// f* --> fn *

function PerryInsert5 (|textview| self, |message| where, |intrange| A, |bool|)
	.undochecker = -1
	.insertsub(", ||", A)
	.sel = A.x+3
	return true								// fn X (|type| name*) --> fn X (|type| name, |*|) 
function PerryInsert34 (|textview| self, |message| where, |intrange| A, |bool|)
	.UndoChecker = -1
	.InsertSub(" ", A)
	.Insert("...", true)
	return true								// fn X (|T*|) -->fn X (|T| *)
function PerryInsert2 (|textview| self, |message| where, |intrange| A, |bool|)
	.undochecker = -1
	|| decl = " (||)"
	if self[a.x] == ' ' or '\t'
		decl = decl[1...]
		A += (1,1)
		
	.insertsub(decl, A)
	.sel = .sel0-2
	return true								// fn X* --> fn X (|*|)
function PerryInsert1 (|textview| self, |message| where, |intrange| a, |bool|)
	.undochecker = -1
	.InsertSub(" name ", a)
	.sel = (a.x2+1, a.x2+5)
	return true								// f* --> fn *


function TextView.IsClearBackLine (|int| x, |bool|)
	while x >= 0
		|| c = self[x--]
		if c.IsTextLine
			exit
		require c == ' ' or '\t'
	return true


function textview.IsInClass (|textviewline| d, |bool|)
	opt norefcounts
	while d
		|| msg = d.message
			return msg.owning_modclass
		d--


function textview.PerryDeclKey (|bool|)
	opt norefcounts
	|| s = .selrange
	require !s.width

	|| d = .FindDrawInfo(s.x)					#require
	|| m = d.message
		|| com = .InPrmsAndBetweenDecls(m, s.x)
			return PerryInsert6(self, (com,com)+1)
	  else
		require .parsedmessage
	
	|| clearback = .IsClearBackLine(s.x-1)
	|| endofline = self[s.x].istextline
	|| inclass = .IsInClass(d) 
	if clearback and !inclass
		return .insert("|| ")
	  elseif endofline or inclass
		if d.BackHasIgnoringSpaces("||", s.x)
			.insert(" ") // whatever
			return true
		.insert("||")
		.sel = .sel0-1 // :)
		return true



helper String.DetectNoSpaces (|string| find, |int| start, |bool| Fwd=true,  |ind|)
	while
		if .CharMode(start) == ' '
			0
		  elseif self[start, find]
			return start
		  else
			return -1
		start += fwd.dir
			
	
function textview.PerryInsertSyntax (|keys| Key, |int|)
	opt norefcounts
	|| ide = .ide
	if key is escape  and  ide.PopupDateOn.ago > 0.5
		ide.PopupHide
		return 1
	require  .ExpectsParse >= probablyjeebox
	|| s = .SelRange
	|| i2 = s.x2
	if  !s.width
		if key is escape
			return .PerryTryAutoComplete(i2, "autocomplete", PerryAutoCompleteReason.escape)|int|
		|| back = .text.DetectNoSpaces("|", i2-1, false)
		|| fwd  = .text.DetectNoSpaces("|", i2)
		if back and fwd // OK we are inside ||
			fwd++
			while .text.CharMode(fwd) == ' '
				fwd++
			
			s = (fwd, fwd)
			// we wanna sel the actual text
			while .text.CharMode(s.x2) == '_'
				s.x2++
			.Sel = s
			return 1
			

	
	require  !.MyError  and  key isnt escape
	|| dd = .FindDrawInfo(s.x)
	require  dd and dd contains i2
	|message| where
	|| inrange = false
	|| state = .CodeInsertion(dd, i2, inrange, where)
	if state == -2
		return 0
	if state == -1
		beep
		return 1
	
	if key == '\n'
		require state != 10 
		if (state >= 3)  and  !s.width 
			return (s.x <= i2)|int|
		if (state == 2)
			if s.width
				.sel = s.x2x2
			else
				require !self[s.x-1].istextline
			return 1 // why not
		return 0 // i think?
	
	|| after= where.after?
	|| A	= (after, after)
	if state != 10  and  (!s.width or state == 5)
		if state == 1
			return PerryInsert1(self, where, a)|int|
		if state == 2
			return PerryInsert2(self, where, A)|int|
		if inrange
			if state == 4
				return PerryInsert34(self, where, A)|int|
			if state == 5
				return PerryInsert5(self, where, A)|int|

	|| prevchar = self[i2-1]
	require (prevchar == '.') or jeebox.CSWordMiddle[prevchar]
	
	if ide.EditMeTabRetryThing
		return 0
	if  !s.width  and  (key is tab)  and  self[s.x].istextline
		|| C = .ide.autocomplete.listsource.slowcount
		if C > 0 
			if c == 1 and .FakeAutoComplete == -1
				return 0 // what?
			if .PerryTryAutoComplete(s.x, "autocomplete", PerryAutoCompleteReason.tab)
				ide.EditmeTabRetryThing = 1
				return 2


function perryide.IsEditingSource (|bool|)
	opt norefcounts
	|| f = .CurrFileRow
		return f.location.issource// or "jb" or "jbin"

	
function string.isSource (|bool|)
	return self isa "uwu" or "spd"


function guicontrol.ide (|perryide|)
	return .window|perryide|
