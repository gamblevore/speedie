


function PerryFuncListFilter (GUIListEditEvent)
	opt norefcounts
	.ide.listallfuncs(false, value)


function MenuAllFuncs (GUIaction)
	opt norefcounts
	if self isa buttonview
		.ide.ListAllFuncs(true, "")
		.OpenMenu


function perryide.ListAllFuncs (|bool| sel=false, |string| filter="")
	|| result = .FunctionMenu.submenu.listsource
	result.clear
	.ListAllFuncsMsg(.editme.Parse, result, filter)
	if sel
		.FindSelectedMenuItem(result)
	result.obj = (.editme._Start, nil)(sel)
	result.Sort(FuncListSorter)
	(.FunctionMenu is visible) = filter or result.HasAny
	.FunctionMenu.text = "(" + result.SlowCount.Render + ")"
	.ImproveFuncList(Result)


function message.FuncAtPos (|int| n, |message|)
	opt norefcounts
	for s in self
		if s.position > n
			return s.prev
	return .last


function PerryIDE.FindSelectedMenuItem (|message| result)
	opt norefcounts
	require result.hasany
	|| fn = result.FuncAtPos(.editme.sel0 )
	.FunctionMenu.submenu.select(result)
	
	
function PerryIDE.ImproveFuncList (|message| result)
	opt NoRefCounts
	|message| p0
	for s.fast in result
		|| p = s[0][0]
		if !p0 or !p.ShallowEquals(p0, true)
			|| d = listviewrow()
			d.name = "------<" + p.name + ">------"
			(d is disabled)
			s.prev = d
		|| n = s[0].name
		if p != @name
			n = "." + n 
		s.name = n
		p0 = p
				
					
function PerryFuncMenuSelected (GUIListEvent)
	opt norefcounts
	|| e = .ide.EditMe
	e.ClearFound
	if row
		e.ViewPos(row.position, 1, true) is found   // InViewExact
		return false
	|| obj = .ListSource.obj as TextViewLine
		e._Start = obj


// Can we... like do this more neatly? Maybe not huh? what if we wanna sort using two sortfuncs?
function FuncListSorter (SorterComparerMsg)
	opt norefcounts
	|| aa = *a
	|| bb = *b
	if aa.func != bb.func
		return aa.func|int| < bb.func|int|
	
	if aa == @emb
		return bb.name.SyntaxCompare(aa.name, true) < 0
	
	|| af = *aa
	|| bf = *bb
	|| an = af.name
	|| bn = bf.name
	|| cmp = bn.SyntaxCompare(an, true)
	cmp := (bf.func|int| - af.func|int|)
	cmp := bb.name.SyntaxCompare(aa.name, true)
	return cmp < 0


function message.funcarg (|message|)
	opt norefcounts
	|| s = .last
	if s == @arg
		return s


function perryide.ListAllFuncsMsg (|message| items, |message| result, |string| filter)
	opt norefcounts
	for line in items
		if line == @decl
			0 // result.IDEAddfunc(line, filter)
		  elseif line == @tmp
			if AutoComplete.owner.valuelower(line.name)						// class/module/etc
				.ListAllFuncsMsg(line.funcarg, result, filter)
			  elseif AutoComplete.isafunc(line)
				result.IDEAddfunc(line, filter)


function message.IDEAddfunc (|message| line, |string| filter)
	opt norefcounts
	if line == @decl
		0 // fn.msg(@emb, line.render)
	  else
		|| name = line.OwningFullName(@emb) 
		if filter.filter(name.name)
			|| fn = .msg(@str)
			fn.position = line.position
			fn <~ name


function string.filter (|string| find, |bool|)
	if !find
		return true
	for s in .words
		if s
			require find contains s
	return true

