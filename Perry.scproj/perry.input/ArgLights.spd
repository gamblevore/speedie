


// illuminates typeable areas of text and validates stuff too.
// eventually we'll make unilluminated areas become untypeable :)
// but that has some issues... like "how to type args {}" in one keystroke... which isn't possible
// sometimes its useful to go through invalid states to reach a valid one.
// sorting that out won't be easy... I'd need to make "correct syntax adders..."
// but overall, its the right approach!!
// very little code to do the right thing.

// I guess the idea is... "Why have a GUI when you can just turn a textView INTO a GUI??"

function ArgValidation (GUITextValidate)
	msg.Expect(@arg)
	for s in msg
		if (msg != @arg) or !s.Expect(@tmp)
			0
		  elseif s == "args"
			for a in s.Arg
				a.expectString
				(a is EditableAny)
		  elseif s == "notes"
			for f.flat in s
				if f != s and @arg
					(f is EditableAny)
		  elseif s == "env"
			for rel in s.Arg
				if rel.Expect(@rel)
					|| ch1 = rel[@thg, 0]
						(ch1 is EditableThing)
					|| opp = rel[@opp, 1]
						opp.expect(@opp, "=")
						(opp is EditableSyx)
					|| ch2 = rel[@nil, 2]
						ch2.goodname
						(ch2 is EditableAny)
		  elseif s == "pwd"
			|| ch = s[@nil]
				ch.ExpectString
				(ch is EditableString)
		  else
			error s
	
