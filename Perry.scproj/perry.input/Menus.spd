

function ButtonView.FillMenuPath (|string| L, |listviewrow| tab=nil)
	|| p = .submenu
	|| orig = l
	p.listsource.clear
	while l
		|| S = filerow.icon(l, "").render + " " + l.NameOrRoot
		p <~ filerow(l, s, (".nothing", "")(l != orig))
		if l.IsVolume
			exit
		l = l.parent
	.OpenMenu(tab)


function string.NameOrRoot (|string|)
	opt norefcounts
	|| s = .name
		return s
	return "Root"


function PerryIDE.EnablePrevnext
	|| m = .HistoryMarker
	(.gonext is enabled) = m and m.next
	(.goprev is enabled) = m and m.prev


function perryide.FindInHistory (|string|p, |string|n, |message|)
	opt norefcounts
	for s in .filehistory
		if s.name ~= p
			if s.first == n
				return s


function perryide.AddToJumpHistory
	require !.StillJumping
	|message| where
	|| old = .FindInHistory(.currpath, .editme.currline.render) 
		if .duringnextprev
			where = old
			.UpdateMarker(old)
		  else
			old.remove // keep the new scrollpos!
	if !where
		where = .buildmarker		


// unused?
//	|| p = .HistoryMarker			// this doesnt work cos the historymarker is removed!
//		while (|| x = p.next)
//			p.prev = x

	if !.duringNextPrev or !old
		.FileHistory.Keep(66, false)
		if !.duringnextprev or !.historymarker
			.FileHistory <~ where
		  else
			.historymarker.next = where
	.historymarker = where
	.EnablePrevNext
	

function perryide.DebugPop (|string| s)
	printline s
	.displayinpopup(s, true)
	.popupdisplay.size = 300~left by 20~inside


function perryide.MiniFileHistory (|string|)
	|| fs = faststring()
	for ch in .filehistory
		fs <~ ch.second.nyme
		fs <~ "\n"
	fs <~ "\n----------\n"
	|| h = .HistoryMarker
		fs <~ h.second.nyme
	return fs


function RightClickNext (GUIaction)
	if self isa ButtonView
		|| s = .submenu
			s.OnTypingFilter = PerryFileListFilter
			s.ListSource = .ide.SortedPrevious
			.OpenMenu


function PerryFileListFilter (GUIListEditEvent)
	opt norefcounts
	.ListSource = .ide.SortedPrevious(value)


function ChosePrevItem (GUIListEvent)
	|| i = .ide
	|| old = i.FileHistory.find(row)
	|| j = old ?? row
	i.GoToMarker(j)
	return true


function PerryIDE.GoToMarker (|message| m)
	require m 
	|| l = m.first
	.duringNextPrev = true	
	using self
		.GoToAnyFile(m.name, l.name)
		.editme.scrollpos = l.position
	.duringNextPrev = false


function perryide.SortedPrevious (|string| filter = "", |message|)
	|| seen = dictionary()
	rz = Message()
	for ch in .FileHistory
		|| n = ch[2].nyme.LowerCase
		if filter.filter(ch.second.nyme) and !seen[n]
			seen[n] = ch
			rz <~ ch.copy


function PerryIDE.UpdateMarker (|message| m)
	m.clear
	m.become(@tmp, .currpath)
	|| line = (@num + .editme.currline) 
	line.position = .editme.scrollpos
	m <~ line
	|| name = .CurrPath.name.widen(16)
	|| fnname = ""
	|| msg = .Editme.ClickedMsg
		|| fn = msg.owningfunc
			fnname = fn.OwningFullName(@emb).render
			name += " (" + fnname + ")"
	
	m <~ name
	m <~ .currpath + "/" + fnname

	
function PerryIDE.BuildMarker (|message|)
	rz = Message()
	.Updatemarker(rz)


function ClickedPrevNext (GUIaction)
	opt norefcounts
	|| i = .ide
	|| m = i.HistoryMarker
		m = m.step(self == i.gonext)
		i.GoToMarker(m)
		return true
	


function ProjectCMMShow (GuiMenuEvent)
	|| row = clicked.row as error
		|| i = .ide
		i.clickederror(row)
		i.view(i.viewfiles)


function PressingTabs (guiaction)
	opt norefcounts
	if self isa ButtonView
		|| p = .submenu|listview|
		|| ide = row.ide
			p.ListSource.clear
			|| name = ide.name
			p <~ ( "Copy " + name, MenuCopyProject, ide)
			p <~ ( "Reveal Project", MenuShowProject, ide)
			p <~ ( "Close", MenuCloseProject, ide)

			.OpenMenu(row) // "Yes" "no"


function message.IDE (|perryide|)
	opt norefcounts
	if self
		|| o = .obj as perryide
			return o
		for w in window.all
			if w isa PerryIDE
				if .name ~= w.Project
					return w


function MenuCopyProject (guimenuevent)
	opt norefcounts
	|| ide = menu.ide
		clipboard.text = ide.Project
		Notifications <~ "Copied: " + ide.Project


function MenuCloseProject (guimenuevent)
	opt norefcounts
	|| ide = menu.ide
		ide.Close


function MenuShowProject (guimenuevent)
	opt norefcounts
	|| ide = menu.ide
		ide.Project.Reveal
	

function RightClickedTabs (GUIAction)
	if row and self isa ButtonView
		.FillMenuPath(row.ide.Project, row)

	
