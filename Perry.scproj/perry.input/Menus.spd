

function ButtonView.FillMenuPath (|string| L, |listviewrow| tab=nil)
	|| p = .submenu
	|| orig = l
	p.listsource.clear
	while l
		|| S = filerow.icon(l, "").render + " " + l.volumename
		p <~ filerow(l, s, (".nothing", "")(l != orig))
		if l.IsVolume
			exit
		l = l.parent
	.OpenMenu(tab)


function PerryIDE.EnablePrevnext
	opt norefcounts
	|| m = .PrevMarker
	(.gonext is enabled) = m and m.next
	(.goprev is enabled) = m and m.prev


function perryide.AddToJumpHistory
	require .EnableHistoryChanges
	|| where = message()
	|| old = .previous.find(where)
		where = old
	  else
		.Mark(where)

	|| p = .PrevMarker			// .shunt all after prevmarker... before it.
		if p.parent != .previous
		while (|| x = p.next)
			p.prev = x
			
	.previous <~ where
	.prevmarker = where
	if .prevmarker.parent != .previous
	.previous.keep(66, false)
	.EnablePrevNext


function RightClickNext (GUIaction)
	if self isa ButtonView
		|| s = .submenu
			s.ontypingfilter = PerryFileListFilter
			s.ListSource = .ide.SortedPrevious
			.OpenMenu


function PerryFileListFilter (GUIListEditEvent)
	opt norefcounts
	.ListSource = .ide.SortedPrevious(value)


function ChosePrevItem (GUIListEvent)
	.ide.GoToMarker(row)
	return true


function PerryIDE.GoToMarker (|message| m)
	if m
		.AddToJumpHistory
		|| l = m.first
		.GoToAnyFile(m.name, l.name)
		.editme.scrollpos = l.first.int
	.EnablePrevNext


function perryide.SortedPrevious (|string| filter="", |message|)
	|| seen = dictionary()
	rz = Message()
	for ch in .Previous 
		|| n = ch[2].nyme.LowerCase
		if filter.filter(ch.second.nyme) and !seen[n]
			seen[n] = ch
			rz <~ ch.copy
	

function PerryIDE.Mark (|message| m)
	m.clear
	m.become(@tmp, .currpath)
	|| line = (@num + .editme.currline) 
	line <~ .editme.scrollpos
	m <~ line
	|| name = .CurrPath.name.widen(16)
	|| fnname = ""
	|| msg = .Editme.ClickedMsg
		|| fn = msg.owning_func
			fnname = fn.OwningFullName(@emb).render
			name += " (" + fnname + ")"
	
	m <~ name
	m <~ .currpath + "/" + fnname


function ClickedPrevNext (GUIaction)
	opt norefcounts
	|| i = .ide
	|| m = i.PrevMarker
		m = m.step(self == i.gonext)
		i.GoToMarker(m)
		return true
	


function ProjectCMMShow (GuiMenuEvent)
	|| row = clicked.row as error
		|| i = .ide
		i.clickederror(row)
		i.view(i.viewfiles)


function PressingTabs (guiaction)
	opt norefcounts
	if self isa ButtonView
		|| p = .submenu|listview|
		|| ide = row.ide
			p.ListSource.clear
			|| name = ide.name
			p <~ ( "Copy " + name, MenuCopyProject, ide)
			p <~ ( "Reveal Project", MenuShowProject, ide)
			p <~ ( "Close", MenuCloseProject, ide)

			.OpenMenu(row) // "Yes" "no"


function message.ide (|perryide|)
	opt norefcounts
	|| o = .obj as perryide
		return o
	for w in window.all
		if w isa PerryIDE
			if .name ~= w.Project
				return w


function MenuCopyProject (guimenuevent)
	opt norefcounts
	|| ide = menu.ide
		clipboard.text = ide.Project
		Notifications <~ "Copied: " + ide.Project


function MenuCloseProject (guimenuevent)
	opt norefcounts
	|| ide = menu.ide
		ide.Close(sdlapp.kactivity)


function MenuShowProject (guimenuevent)
	opt norefcounts
	|| ide = menu.ide
		ide.Project.Reveal
	

function RightClickedTabs (GUIAction)
	if row and self isa ButtonView
		.FillMenuPath(row.ide.Project, row)

	
