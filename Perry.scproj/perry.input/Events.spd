
 
function FileSepClicker (guiaction)
	opt norefcounts
	.ide.ViewAsSwap


function IdeAddProj (|string| Path, |PerryIDE| ide = nil, |PerryIDE|)
	|| old = perry.FindProj(path)
		ClickedTabs(nil, old)
		return old.ide
	ide := PerryIDE.EmptyBase
	ide := PerryIDE(false)
	ide.LoadProject(path.file)
	return ide


function string.TrimProj (|string|)
	if .isproj
		return .TrimExtAndPath
	return self


function Perry.CreateProj (|file| proj)
	expect (!proj.exists) (proj, "Can't create over existing project.")
	|| main = proj.child("input/main.spd")
	proj.child(".perry").write = qqfiles.Roots
	main.data = qqfiles.EmptyMainFile(proj.trimextandpath)
	proj.child("input/.todo").write = qqfiles.Todo
	IdeAddProj(proj)


function ClickedOpenProj (GUIaction)
	|| start		= "~/".resolve
	|| path			= app.AskOpen("spd,scproj/,input/", start, "Open Project")	#require
	|| better_path	= path.GetSpeedieProj("scproj")
		IdeAddProj(better_path)
	  else
		IdeAddProj(path)
	perry.HideStartIfNeeded
		

function ClickedCreateProj (GUIAction)
	|| i = .ide
	|| it = app.AskSave("scproj/",  "",  "New Project",  "Create")
		perry.CreateProj(it.file)
	perry.HideStartIfNeeded


function ClickedOpenFile (GUIaction)
	|| file = app.AskOpen("",  "",  "Open File")
		IdeAddProj(file)
	perry.HideStartIfNeeded


function ClickedCreateFile (GUIaction)
	|| path = app.AskSave("",  "",  "New File",  "New")
		if path.file.CreateEmpty
			ideaddproj(path)
	perry.HideStartIfNeeded



function perry.HideStartifneeded
	if .projects.hasany
		startupwindow.hide
		
	
function ClickedTabs (GUIAction)
	if row
		row.ide.showide(True)


function ClickedCompileTabs (Guiaction)
	.ide.StdOutSelect(row)


function PerryIDE.StdOutSelect (|object| Desired)	
	opt norefcounts
	for i in .tabs2.Items
		|| obj = i.obj as GUIControl
			|| vis = (Desired == i or obj)
			(i is selected)  = vis
			(obj is visible) = vis


function ClickedToolbar (GUIAction)
	opt norefcounts
	|| w = .ide
	if self isa ButtonView
		if w and (.clickcount == 2)
			w.ViewAsSwap


function file.InputFol (|file|)
	for c.files in self
		if  c.name ~= "input"  or  c isa "input"
			return c


function file.FindProjectMain (|file|)
	|| inp = .inputfol
	|| best = inp.child("main.spd")
	if best.exists
		return best
	best = inp.child("index.spd")
	if best.exists
		return best
	for c.files in inp
		if c isa "spd"
			return c


function PerryIDE.FindNotTodo (|bool|)
	if .IsSingleFileProject
		|| c = .CurrFileRow
		|| root = .FileList[0]
		if c != root
			.NotTodo = c
	.nottodo := .LocateProjRoot("./main.spd")
	.nottodo := .LocateProjRoot("./index.spd")
	|| F = .MainProjFol
		.nottodo := f.first
	return .nottodo


function PerryIDE.ClickedTodo
	|| fl	= .filelist #require
	|| todo	= .MainProjFol ?? fl[0]
	require .FindNotTodo and fl // what? fl is nil? it happened tho?
	if !todo
		todo = fl[0]
	|| Jumpback = (todo is selected) and .nottodo and (fl.listsource contains .nottodo) 
		todo = .NotTodo
		fl.show(todo)
		fl.scrolljump
	  else
		.nottodo = .CurrFileRow
	fl.SelectNoShow(todo)


function HeldReleaseButton (GUIaction)
	if self isa buttonview
		if !.OpenMenu
			.ide.notify("No build-tasks exist.")


function ClickedRelease (GUIaction)
	return false
	|| name = .tag as string
		.ide.compile("compile", name)
	  else
		beep


function fnBuildIsDead (fnConfirmCanceller)
	if self isa perryide
		.SpeedieMsgReceive(.compilr)
		if !.Building
			.CancelCompile
			return true


function Perryide.Building (|bool|) // .isbuilding, .iscompiling, .compiling 
	return .buildbutton isnt enabled


function ClickedCancel (GUIAction)
	|| i = .ide
	if !i.building
		return true
	|| can = ConfirmCanceller(i, fnBuildIsDead)
	if "Cancel Build of ${i.project.trimproj}?".confirm(can)
		i.CancelCompile
		return  true
		

function ClickedCompile (GUIaction)
	.ide.compile("compile")

		
function PerryFileRenamed (guilistevent)
	.ide.recheck

function ReturnProjectPath (GUIListEvent)
	if row isa filerow
		row.location.reveal
	return true


function ReturnAllFuncs (GUIListEvent)
	|| e = .ide.EditMe
	e.ShowAndSel(row.position)
	e.SetFocus
	return true

	
function OpenProjectPath (GUIaction)
	|| f = .ide.filelist.FirstSelected as FileRow
	if (self isa buttonview)
		.FillMenuPath(f.location)


function ClickedStatus (GUIaction)
	.ide.editme.ShowParseError


function ClickedStats (GUIaction)
	.ide.clickedstats


function PerryIDE.ShowErrors (|bool| FromKeys, |bool|)
	opt norefcounts
	.SaveEditing(documentstate.ErrorChecking)
	.recheck
	|| t = .istextonly
	.viewasproject
	if t and .isviewing(.errorlist)
		return true
	if !.isviewing(.errorlist)
		ClickedAView(.ViewErrors)
	  elseif .errorlist.hasany
		.ShowNextError
	  else
		ClickedAView(.Viewfiles)
	
	return true


function ClickedAView (GUIaction)
	opt norefcounts
	if self isa ButtonView
		|| i = .ide
		if (i.errorlist is visible) and .tag == i.errorlist
			i.ShowNextError(0)
		i.view(self)


function ClickedNoNeed (GUIaction)
	opt norefcounts
	|| t = .tag as buttonview
		.ide.view(t)	


function PerryIDE.ShowText (|textview| field, |string| Text)
	field.text = text
	.editsep.show
	.StdOutSelect(field)
	
	
function PerryIDE.SelTextParse (|bool|)
	opt norefcounts
	|| e = .editme
	if !e.selrange.width
		e.DoSelectLine
	|| s = e.seltext
	if s == .OldJBCloser
		.OldJBCloser = ""
		.editsep.Collapse
		.jeeboxtext.text = "" 
		return true
	.OldJBCloser = s
	|error| where
	|| msg = s.parsewitherror(where)
	.ShowText(.JeeboxText, (msg.renderast(0), where.render)(!where) )
	
	// could put some tabs into that area? QT creator does the same???
	// one for jeebox... one for stdout from shellstreamer...
	// then we can opt the shellstreamer to NOT copy the streaminfo if its not onscreen?
	// or atleast we can opt it somehow... like doing getresult and appending it
	// and having the textview able to stitch together stuff... via the textviewlines 
	// of course... the .text won't be legit anymore. Which would be bad.
	// we would like to append stuff without needing the whole file in RAM as one string!!
	// as long as that is possible... it should be ok?
	// Perhaps  .text  can come from a function that wraps a virtual func???
	// then it can stitch it together, if called for.
	// but the internal drawing/scrolling funcs wouldn't need it, right? Right??? RIGHT?
	
	return true


function PerryIDE.ClickedFile (|bool|)
	|| t = .editme.seltext.trim
	if t[0] == '/'
		|| it = t.inwhite
			t = t[0, it]
		if t.reveal
			return true


function PerryIDE.BatchPhind (|string| text, |uint| ID,  |bool|)
	|| found = .filelist.BatchFind(text, ID)
	.foundlist.use(found)
	.foundlist.setfocus
	return found.hasany


function PressedSelInfo (GUIaction)
	opt norefcounts
	|| i = .ide
	|| q = i.filelist.quickopen
	q.text = "line " + i.editme.CurrLine.Render
	i.filelist.showquickopen


function PressedSearchWithin (Guiaction)
	|| i = .ide
	|| f = i.FileList
	|| r = f.SearchWithin
		f.SearchWithin = nil
	  else
		f.SearchWithin = f.FindSearchWithin
	i.ReTextSubFind
	
	
function PressedSearchKeys (GUIKeyEvent)
	opt norefcounts
	|| w = .ide
	if key.isaccept
		w.ViewAsProject
		|| ID = ((perry.findID+1)&255) max 1
		perry.findID = ID
		w.BatchPhind(.text, ID)
		if w.foundlist.isempty and .text
			w.noneed("The search text “${.text}” wasn't found", nil)
			perry.FindElseWhere(w, .text, ID)
		  else
			w.noneed
		return true
	require key.iscancel
	if .text
		.text = ""
	  else
		w.view(W.viewfiles)
	return true


function EditMeSelChange (GUITextEvent)
	opt norefcounts
	|| i = .ide
	i.popuphide
	i.ShowRightStats
	i.EditMeTabRetryThing = 0
	require !TextWasAltered and i.feedback.isopen
	|| e = self|textview|
	|| s = e.selrange
	if s.width
		e.PerryTryAutoComplete(s.x2, "autocomplete_sel", PerryAutoCompleteReason.sel)


function EditMeSelError (GUITextErrorSelected)
	opt norefcounts
	|| i = .ide
	|| el = i.errorlist
	i.DuringMsgFB = true
	el.select(error.error)
	i.DuringMsgFB = false

	
	
function PressedEditKeys (GUIKeyEvent)
	opt norefcounts
	if self isa TextView
		require .ExpectsParse >= 2
		if key is Decl
			return .PerryDeclKey
		
		require key == -9 or -10 or 27
		key = key.abs
		
		|| tabkind = .PerryInsertSyntax(key)
			if tabkind == 1
				.ide.EditMeTabRetryThing = 0
			return true


function PerryIDE.MoveError (|error| row,  |string| p,  |int| i,  |error|)
	opt norefcounts
	while row
		|| nrow = row.step(i>0) 
		if !nrow or nrow.path != p
			return row
		row = nrow


function PerryIDE.ClickedError (|error| row)
	sdlapp.CompileStatus = row
	require !.DuringMsgFB
	using self
		|| f = row.path.file
		if (row.path != .editme.path) and f.IsNicelyViewable
			.GoToAnyFile(f)
		.editme.ShowAndSel(row.position)
		.editme.MyError = row


function file.IsNicelyViewable (|bool|)
	if .isdir
		return true
	require .exists
	require .size < 512KB
	return !.readall.isbinary


function PerryIDE.ClickedFind (|error| row)
	|| p = row.path
	.GotoIncludedFile(p)
	if row.position
		.editme.ShowAndSel(row.position, .MassSearchField.text.length)
	  else
		row = row.first
	|| curr = .MoveError(row, p, -1)
	|| last = .MoveError(row, p,  1)
	.editme.ClearFound

	while curr
		.editme.FoundAt(curr.position, row == curr)
		if curr == last
			exit
		curr++

	
function ClickedError (GUIListEvent)
	|| ide = .ide
	if row isa error
		if self == ide.errorlist
			ide.ClickedError(row)
		  else
			ide.ClickedFind(row)
	  elseif sdlapp.event.type is mousedown
		if !.Start and ide.filelist isnt visible
			clickedaview(ide.ViewFiles)
	return true


function LogAreaKeys (GuiKeyEvent)
	if key iscmd keys.k
		|| s1 = .ide.LogComms
		|| s2 = .ide.LogActions
		|| c = s1.slowcount + s2.SlowCount
			if "Clear log?\n\nContains $c items.".confirm
				s1.clear
				s2.clear
		return true


function ReturnErrorList (GuiListEvent)
	.select(row)
	.ide.editme.setfocus
	return true


function perryide.ReTextSubFind
	|| r = .filelist.SearchWithin
		.SubFindCheckBox.text = "Searches: " + r.Name
	  else
		.SubFindCheckBox.text = "Searches: All"


function SelectedFile (GuiListevent)
	if row isa FileRow
		return .ide.EditFile(row)


function RightClickErrorList (GUIListEvent)
	opt NoRefCounts
	if self isa FileViewer
		|| m = .newcmm
		m <~ ("Copy File Path",			FileViewerCopyPath)
		m <~ ("Show In Finder",			FileViewerCMMShow)
		m <~ ("Show In Project",		ProjectCMMShow)
	return true


function perry.FindElseWhere (|perryide| ignore, |string| find, |byte| FindID)
	for w in perry.OpenProj
		if (w != ignore) and w.BatchPhind(find, FindID)
			if "$find not found here, but was found in '${w.name}'.\n\nTake a look?".confirm
				w.showide
				w.ShowFind
			return


function HideSomeStuffOnResize (guiaction)
	if self isa guicontrol
		.ide.PopupHide
	

function PerrySearchWithin (GUIListEvent)
	opt NoRefCounts
	.ide.SubFindCheckBox is visible
	.ide.ShowFind
	
	
