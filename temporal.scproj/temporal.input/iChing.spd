

class YingYang // could make this a role on message.
	|string| Name
	|string| Opposite
	constructor (|message| line)
		.name = line.name
		.Opposite = line.firstName
	
	module
		|[yingyang]| _Items
		function States (|[yingyang]|)
			if ._Items: return ._Items
			._Items = rz
			for line in DataBank.parse
				rz <~ YingYang(line)
	
	
		|| DataBank = –digest file://yingyang.jb




module iChing
	|message| _DatabankMsg
	function Tome (|message!|)
		|| d = ._DatabankMsg
			return d
		d = ( –digest file://iching.jb ).parse // what about compress? D:
		if d
			d = d["hexagrams"]
		
		d := StdErr.LastError
		d := Message(@str, "Tome remains closed.")
		._DatabankMsg = d
		return d
		

	function DivineHexa (|stevemachine| maker=nil, |message|)
		maker := SteveMachine.create(9,64K)$
		
		maker.Hash // fixes weak output, Still suffers SAME output! what on earth? is it even a time-function?
		maker.Samples.DebugPrint
		|| HexaCoins = maker.Walk(6, 9*9)
		|| msg = .Tome[hexacoins]
			msg = msg.copy
			msg.arg.first.remove
			|| Marks = ~maker.Walk(6, 9*9) // ~, in case bad function gives 111111
			|| lines = msg["markedlines"]
			for (i.highbits in marks) (x)
				lines[x].Remove
			return msg

