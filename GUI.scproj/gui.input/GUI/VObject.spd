



class VObject (list)
	|vec3|			Pos				// .w = graphical aura size
	|vec3|			Radius			// .w = rounding
	|vec3|			Velocity
	|byte|			Nudge
	|vec4|			Color			// image pixel?
	|float|			Health			// are ints better? I think so?
	|DistanceFunction| Shape
	|ShaderFunction| Material

	visible false
	// ray acceleration
	|byte|			_ShapeID
	|?VObject--|	_CellNext
	|vec4|			_RayHit
	
	visible true
	
	constructor (|vec2| Pos,  |vec2| Size,  |vec4| Color=colors.white)
		cpp_part ConstructorBox2D
		.pos = (pos, 0.0)
		.Shape = BoxShape
		.Color = color
		.material = NormalColor
		.Health = 256
		.size = vec3(size,1.0)
		._ShapeID = nextID()

	constructor (|vec3| Pos,  |vec3| Rad, |DistanceFunction| shape, |shaderfunction| Shader,  |vec4| Color=colors.white)
		cpp_part ConstructorShape
		.pos = pos
		.Shape = shape
		.Radius = rad
		.Color = color
		.material = Shader
		.Health = 256
		._ShapeID = NextID()
	
	function BigR (|float|)
		return .radius.max
		
	function Towards (|vec3| P, |float| Speed)
		.Velocity = (P - .pos).Normal * Speed
	
	function y (|float|)
		return .pos.y

	function x (|float|)
		return .pos.x

	function left (|float|)
		return .pos.x - .Radius.x

	function right (|float|)
		return .pos.x + .Radius.x
	
	setter Size	(|vec3|)
		.Radius = value*0.5
		
	function Box2D (|vec4|)
		|| rad = .Radius.xy
		|| p = .pos.xy
		return (P-rad, P+rad)

	function Step
		.pos += .Velocity

	function OverlapsBlock (|VObject| B, |vec4|)
		return .OverlapsRect(b.box2d)
	
	function OverlapsRect (|vec4| B, |vec4|)
		return B.Clip(.box2d)
	
	function Screen (|ivec4|)
		return .box2d.Screen
	
	syntax cast (|ivec4|)
		return .Screen
		
	syntax is (|vobjectinfo| i, |bool|)
		return (.position & i) == i
	
	syntax is (|vobjectinfo| i, assigns:|bool| value)
		if value
			.position |= i
		  else
			.position &= ~i
		
	
	module
		|byte| ShapeIDs
		|float| DrawScale
		|vec2|  DrawMovement
		
		function NextID (|byte|)
			rz = ++.ShapeIDs
			if !rz
				rz = ++.ShapeIDs

		function Black (ShaderFunction)
		function CloudColor (ShaderFunction)
			// clouds aren't like this, they are more like aura-bulbs
			// with particles that drift off them randomly
			|| Str = 0.33*D.y / .Radius.x
			return (1.0, 1.0, 1.0, Str) * .Color
			
		function NormalColor (ShaderFunction)
			|| Norm = (P - .pos).normal.abs		// Spherical color
			return (norm, 1.0) * .Color

		function IceFudgeColor (ShaderFunction)
			|| Norm = (P - .pos).normal
			|| y = Norm.y.acos
			|| x = Norm.z.abs.atan2(Norm.x)
			|| str = 8.0
			|| spd = 30s
			|| grid = ((((x+y + gui.Cycle(spd))*str).fract - 0.5)*str).clamp*0.125 + 0.875
			return (grid, grid, grid, 1.0)*.Color
		
		
		function WierdShape (DistanceFunction)
			|| S = SphereShape(self, ray, P)
			if S.x > 0
			|| B = BoxShape(self, ray, P)
			// we could	return -dist as thickness for SDFs
			
			
		function SphereShape (DistanceFunction)
			opt min 3
			|| L = .pos - P
			|| t = L • Ray._CamDir
			if t > 0
				|| r = .Radius.x
				|| h = (r*r) + (t*t) - (L • L)
				if h >= 0
					h = h.Sqrt
					return (t-h, h*2, 0, 0)
			return vec4(float.max)
		
		
		function BoxShape (DistanceFunction)
			opt min 3
			|| orig = P - .pos
			|| r = .Radius
			|| idir = ray.iDir
			
			|| p0 = (orig - r) * idir
			|| p1 = (orig + r) * idir
			
			|| t1 = (P0 min P1).max
			|| t2 = (P0 max P1).min
			
			if t2 >= t1
				return (t1, t2-t1, 0, 0)
			return vec4(float.max)


		function Box (|vec3| Pos, |vec3| Radius, |shaderfunction| Shader=&vobject.normalcolor, |vec4| Color=colors.white, |vobject|)
			return VObject(pos, radius, BoxShape, shader, color)
			

		function Sphere (|vec3| Pos, |float| Radius, |shaderfunction| Shader=&vobject.normalcolor, |vec4| Color=colors.white, |vobject|)
			return VObject(pos, vec3(radius), SphereShape, shader, color)
			
// later: handle other ratios, for example (Add borders)
// could we try to get closer to phi? say trim a few pixels off the top? to 865 pixels

		function Size2D (|float| X, |float| Width, |float| Y, |float| Height, |controlrect|)
			if Width < 0
				x += Width
				Width = Width.abs
			if height < 0
				y += height
				height = height.abs
			|| V = (x, y, x+width, y+height)*16.0
			return V.iVec4|controlrect|

	prototype ShaderFunction (|vec3| P,  |vec4| D,  |vec4|)
		// what about a magical color system too?
		// what about a more generalised material system?
		// do we want every object to decide how it surface colors?
		// maybe this should be a "task". So the material info can be stored...

	prototype DistanceFunction (|raytracer| Ray, |vec3| P,  |vec4|)
		description "x: dist                 (SDF nearest dist)
		 y: thickness
		 zw: material-info
		
		 if dist < 0... ignore. We missed it
		 if dist == 0, we are inside of it. Stipple
		 if dist > 0, we *might* hit something
			 if thickness < 0, move by -thickness, for sdf
			 if thickness >= 0 end now.
				 > 0 is volumetric transparency
				 == 0 is a surface
"
		// how to test two objects? or an object vs a block?
		// seems it needs a different function?
		// what if instead of a raytracer, we just pass a shape?
		// like that just happens to be a ray. Or another shape?



datatype VObjectInfo (uint)
	constants
		Pellet
		Dead			// to remove


function controlsize.CalculateBlocks (|ivec4|)
	|| V = .gsize.vec4 * 16th
	return V.Screen


function vec4.ScreenFloat (|vec4|)
	return (self + VObject.Drawmovement.xyxy) * VObject.DrawScale

function ivec4.Screen (|ivec4|)
	return .Vec4.Screen

function vec4.Screen (|ivec4|)
	|| p = .ScreenFloat
	|| w = p.Width
	|| h = p.Height
	p = p.floor
	p.x2 = p.x + w
	p.y2 = p.y + h
	return p.iVec4


extend Window
	helper _ReadjustBlock2D
		description "Readjusts current draw-matrix. This converts object coords to screen coords." 
		|| Sc = .BlockScale$
		|| LR = .lastrect
		|| W = LR.width|float|
		|| H = LR.Height|float|
		|| Size = W
		if Sc < 0 
			sc = -sc
			Size = H
		
		Size /= sc
		Size = size.round(2)
		VObject.DrawScale = Size
		|| M = .BlockMove
		if .BlockMode&1
			M.x = ((W*0.5) + (Size * M.x))/Size
		if .BlockMode&2
			M.y = ((H*0.5) + (Size * M.y))/Size
		VObject.DrawMovement = M

	function BlockX (|bool| Middle=false, assigns:|float|)
		.BlockMove.x = Value
		.BlockMode = (.BlockMode &~1) ||| Middle
	
	function BlockY (|bool| Middle=false, assigns:|float|)
		.BlockMove.y = Value
		.BlockMode = (.BlockMode &~2) ||| (Middle<<1)
		
	setter BlockHeight (|float|)
		.Blockscale = -Value.abs
	
	setter BlockWidth (|float|)
		.Blockscale = Value.abs

