

class GUIControl (list)
	linkage: cpp_part ctrl
	
	contains GuiControl
	
	|ivec4| 					LastRect
	|string|					ID
	|string|					Text
	|string|					Tooltip
	|object?|					Tag
	|Drawstyle|  				GNormal
	|GUIAction?|				OnClicked
	|GUIAction?|				OnFocus
	|TimeFader|					Declutterer
	|uint|						_ScrollDrawTimer
	|ControlSize|				Sizer
	|uint16|					TabIndex
	|ControlClipMode|			ClipMode
	|GuiControlFlags|			State
	|TakesFocusFlag|			TakesFocus
	|uint16[2]| 				_SizeFraction
	|byte|						TextAlteredForDraw
	|byte|						ExpandOnMouseOver
	|bool|						PostLoaded
	|bool|						ClickOutsideCloses
	|bool| 						AttachedToParent
	|CopyPasteFlags|			CopyPaste


	constructor (|guicontrol| parent)
		super.constructor(parent)
		.id = ("", "root")(parent)
		if parent
			.tabindex = parent.loadtabindex
		.gnormal = drawstyle()

		._SizeFraction[0] = 4K
		._SizeFraction[1] = 4K
		is visible
		is Enabled
		is Drawsfocus

	render
		if !self
			fs <~ "(nil)"
		  else
			fs <~ "("
			fs <~ .class.name
			fs <~ "  "
			fs <~ .lastrect
			fs <~ `): '`
			fs <~ .id
			fs <~ "'"
			fs.indent++
			for ch in self
				fs.IndentLine
				ch|object|.render(Fs)
			fs.indent--
		
	
	virtual Search		(|string| s, |bool|JustUpdate, |bool|)
	virtual MouseWheel	(|ivec2| P,  |int|  Direction, |bool|)
	virtual MouseMove	(|ivec2| P,  |SDL_WindowEventID| State, |bool|)
	virtual MouseDown	(|ivec2| P,  |int| Clicks, |int|)
		return 1
	virtual RightClick	(|ivec2| P)
	virtual KeyDown		(|keys| Key, |bool|)
	virtual MouseUp		(|ivec2| P)
	virtual Draw		(|image| Where)
		opt norefcounts
		|| G = .GNormal
		using g
			g.Strengthen(.declutterer.strength)
			Where.RectStyled(.lastrect, g)
	virtual PostLoad
		0
	virtual Copy
	virtual GotFocus
		(.OnFocus)(self, 1)?
	virtual LostFocus
		(.OnFocus)(self, 0)?
	virtual AppForegroundChanged (|bool| IsForeGround)
		0
	

	behaviour Search
	behaviour MouseMove
	behaviour MouseWheel
	behaviour KeyDown
	behaviour RightClick
	behaviour MouseUp
	behaviour Copy
	virtual TypedString (|string| Input, |bool|)
		0

	function Size (|ivec2|)
		return .lastrect.size

	setter Size (|controlrect|)
		.sizer.setsize(value)
		if value.IsBasic
			.MiniSizeSet(value.basicsize)


	function MiniSizeSet (|ivec4| Rect)
		opt norefcounts
		|| p = .parent
		// not sure this should happen? its going to be set later, anyhow, right?
			|| l = p.lastrect
			if p isa window
				l = l.soothe
			rect += l.xyxy
			.LastRect = rect // right?


	helper Reflow (|ivec4| mine, |ivec4| Hard) 
		opt norefcounts
		|| prev = mine.x2y2x1y1 // noice
		for R in self
			|| curr = R.ReflowDoc(mine, prev, hard)
			if r is visible or Spacer
				prev = Curr


	helper LoadTabIndex (|uint16|)
		opt norefcounts
		|| w = .window
			rz = w.tabindex + 1
			if rz >= 0x10000
				rz = 1
			w.tabindex = rz


	helper NextFocus (|bool| dir, |bool| force, |guicontrol|)
		opt NoRefCounts
		real self
		|| c = self
		|| w = .window
		
		while
			c = c.loop(dir, w) // flatloop!
			if c == self
				exit
			if .IsBetterFocus(c, rz, force)
				rz = c


	helper tabbability (|guicontrol| c, |int|)
		return  c.tabindex|int|  -  .tabindex|int|
		
	
	helper isbetterfocus (|guicontrol| c, |guicontrol| b, |bool| force, |bool|)
		require c.isviewable and c is enabled
		require (c isa ListView or textview)
		require c.takesfocus.tab(force) or (c is opensmenu)
		if !b
			return true
		
		require c.tabindex
		if !b.tabindex		// 0 is lower priority... but better than nothing.
			return true
		
		|| c_extra = .tabbability(c)
		|| b_extra = .tabbability(b)
		if c_Extra > 0 == b_Extra > 0
			return c_Extra < b_Extra
		return c_Extra > 0
	
	
	function TextWidth (|int|)
		opt norefcounts
		return .text.bounds.x * font.width

	syntax cast (|ivec4|)
		return .lastrect
	syntax append (|guicontrol| g)
		super <~ g
		
	syntax is (|guicontrolflags| F, |bool|)
		if self
			return .state&F
		
	syntax is (|guicontrolflags|F, assigns:|bool|)
		require ((.state&f)!=0) != value
		
		if value
			.state |= f
		  else
			.state &= ~F
		if f & guicontrolflags.visible
			#!VisibleChange
			sdlapp.resized(self)

	function Decluttering (|bool|)
		return .Declutterer.final
	
	setter Declutter (|bool|) 
		.declutterer.fire(0.334, 0.5) = value
		
	function Decluttered (|bool|)
		return .Declutterer.Finished
	
	function Touch (|int| Amount = 2)
		opt norefcounts
		if sdlapp.TouchCount < amount
			sdlapp.touchcount = Amount
		(.window is modified)

	setter ScrollDrawTimer (|uint|)
		if ._ScrollDrawTimer != value
			._ScrollDrawTimer = value
			sdlapp.touch(self)

	function SizeFraction (|int|which=2, assigns:|float|)
		value = value.clamp * 4K
		which++
		if which&1
			._Sizefraction[0] = value
		if which&2
			._Sizefraction[1] = value
		sdlapp.resized(self)
		
	setter Visible (|bool|)
		(self is visible) = value

	
	function IsViewable (|bool|)
		if self
			return (self is visible) and .lastrect.ispositive

		
	function MouseIsInside (|bool|)
		opt norefcounts
		|| w = .window
		if w.IsFront
			return self contains w!.MouseIsOver
	
	
	helper DrawChildren (|image| where,  |ivec4| Lim,  |guicontrol| avoid=nil)
		opt norefcounts
		for R in self							// .last gets drawn last, so .last is actually the "front".
			if (r!=avoid) and R.isviewable
				|| SubLim = Lim.clip(r.LastRect)
				where.ControlClip = SubLim
				r.__Draw__(Where)
				if r.hasany
					r.drawchildren(where, Sublim, avoid)

	
	helper DoPaste (|Object| Data, |copypasteflags| Type = CopyPasteFlags.PasteText, |bool|)
		|| w = .window
		if w and (data isa string)
			|| c = self
			if !c.PasteEvent
				c = w
			  elseif !(c.CopyPaste & Type) and (w.copypaste & type)
				c = w
			
			|| P = c.PasteEvent
				if c.CopyPaste & copypasteflags.paste
					|| items = [Data]
					if (c.copypaste == copypasteflags.pastefile) // split by lines
						items = data.split
					|ListViewrow| After
					if c isa ListView
						after = c.lastselected
						c.selectnone
					for file in items
						if (file) and (P)(c, after, file, c.CopyPaste)
							rz = true
					return true
		beep
	
	
	helper PasteEvent (|GUIPasteEvent|)
		if self isa window
			return .onpaste
		if self isa ListView
			return .onpaste
		if self isa textview and self is editable
			return (&TextView.textPaste)|GUIPasteEvent|


	helper CopyEvent (|GUICopyEvent|)
		if self isa window
			return .onCopy
		if self isa ListView
			return .onCopy
		if self isa textview
			return (&TextView.textCopy)|GUICopyEvent|

	
	helper CopyList (|array|)
		if self isa ListView
			return .copylist
		if self isa textview
			return [.seltext]
		return []


	function Width (|int|)
		return .lastrect.width
	setter Width (|controlline|)
		.sizer.g(0) = value[0]|controlpoint|
		.sizer.g(2) = value[1]|controlpoint|

	function Height (|int|)
		return .lastrect.Height
	// dreams... of dance, fun, youth! healinggggg...
	setter Height (|controlline|)
		.sizer.g(1) = value[0]|controlpoint|
		.sizer.g(3) = value[1]|controlpoint|

	helper DoCopy (|object| item=nil, |bool|)
		|| S = .getcopy
		clipboard.text = s
		return S
	
	
	helper GetCopy (|object?| item=nil, |string|)
		return (.CopyEvent$)(self, item)
	
	syntax equals (|string| s, |bool| aware, |bool|)
		if self
			return .id.syntaxequals(s, aware)

	operator Contains (|ivec2| p, |bool|)
		return .lastrect.contains(p)
	
	function Window (|Window|)
		opt norefcounts
		nil checker
		for p.up in self
			if p isa Window
				return p
	
	setter Size (|int| i, |ControlPoint|)
		cpp_Part SizePart
		.sizer.g(i) = value
	
	function Right (|int|)			// these are not synced but i dont know what to do.....
		return .lastrect.x2			// set a controlpoint, but get a lastrect int?
	setter Left (|ControlPoint|)
		.size(0) = value
	setter Bottom (|ControlPoint|)
		.size(1) = value
	setter Right (|ControlPoint|)
		.size(2) = value
	setter Top (|ControlPoint|)
		.size(3) = value
		
	function AbsBottom (|int|)
		return .lastrect.y
	function AbsLeft (|int|)
		return .lastrect.x
	function AbsTop (|int|)
		return .lastrect.y2

	function Left (|controlpoint|)
		return .sizer.GSize[0]|controlpoint|
	function Bottom (|controlpoint|)
		return .sizer.GSize[1]|controlpoint|

	function Horz (|intrange|)
		return .lastrect.x1x2

	function Vert (|intrange|)
		return .lastrect.xx2


	function HasFocus (|bool|)
		opt norefcounts
		|| w = .window
			return self == w.realfocus 

	function HasAnyFocus (|bool|)
		opt norefcounts
		|| w = .window
			return self == w.focus or w.InnerFocus


	helper DrawFocus (|image| where, |float| strength=1.0)
		if self
			.drawfocusrect(Where, .lastrect, .FaintingEdge*strength)


	helper FocusBorderStyle (|drawstyle|)
		if (self isnt modified) or (self is NeverDrawModified)
			return ¥.Border
		return ¥.ModifiedBorder
		
		
	helper DrawFocusRect (|image| where, |ivec4| R, |float| Strength)
		opt norefcounts
		require strength > 0
		|| oldclip = where._ControlClip // maybe outside
		where.controlclip = (0, 0, 31K, 31K)
		where.EdgeAlpha(R, .FocusBorderStyle, Strength, .EdgeAllow)
		where.controlclip = oldclip
	
	
	helper FaintingEdge (|float|)
		opt norefcounts
		if self is drawsfocus
			return 1
		if .HasFocus
			return .FaintingEdgeSub
	
	helper FaintingEdgeSub (|float|)
		opt norefcounts
		|| w = .window!
		|| f = w.AlphaFader				#require
		|| delay = date() - f
		|| remain = 1s - delay
		if w.alphasubtle
			remain += 0.5s
		if remain > 0
			sdlapp.touch(Self)
			|| f2 = (remain)|float| / 1s|float|
			if w.alphasubtle
				f2 *= 0.2
			return f2
		w.alphafader = 0
		w.alphasubtle = false
		w.FlashSelf = false
	
			
	function SetFocus
		opt norefcounts
		.window$.setfocus(self)


	function ClearFocus
		opt norefcounts
		if .hasfocus
			.window!.clearfocus


	helper MouseIsDown (|bool|)
		opt norefcounts
		|| w = .window
			return w.CurrMouseDown == self
	
	setter Text (|string|)
		.textset(value)
	
	helper TextSet (assigns:|string| text, |bool|)
		cpp_part TextSetter
		require (self and text != .text)
		.text = text
		.TextAlteredForDraw |= 2
		sdlapp.Touch(Self)
		return true	
	
	
	function Hide
		isnt visible

	
	helper RefSanity
		visible
		opt norefcounts
		|| c	= .class		// Cls->Memory
		|| m	= c.layer
		|| rc	= m.refcount
		for r in self
			|| r2 = r
			r2.refsanity
	

	task_run SlideHeight (TaskGUI)
		|| Over = now - .StartTime
		.upon.sizefraction(1) = (Over)|float| / .duration|float|


	helper AddTask (|TaskGUI| t)
		opt norefcounts
		|| w = .window
			w.tasks <~ t


	task TaskGUI ( |...!| Upon,  |date| duration=0,  |date| StartTime=date.now )
		contains –parentclass // super cool feature
		constructor
			// upon, starttime, duration are automatically set
			upon.addtask(self)
		
		function RunOne (|date| now, |bool|)
			opt NoRefCounts
			require .upon.parent
				
			|| s = .starttime
			|| e = s + .duration
			if now >= s
				if now > e
					require self isnt finished
					is Finished
				is started
			  elseif self isnt waitstillstart
				return true
			|| ok = (self)(now)
			if self isnt Finished
				return ok
		
		run (|date| now,  |ErrorInt|)
			return -1


helper image.ControlClip (assigns:|GuiControl| G)
	.controlclip = g.lastrect


function image.Window (assigns:|window| W)
	|| s = w.LastRect
	.windowbase = s.xy
	.ControlClip = s.Soothe
