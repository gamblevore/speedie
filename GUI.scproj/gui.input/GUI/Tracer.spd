

// todo:
// 1) Add screen cells and culling
// 2) turn the spheres into chunks?
// 3) Optimisations around unmoving objects
// 4) hit-detection? (surely its just chunk vs chunk anyhow?)
// 5) 4 threads, each can do one quad.
// 6) more shapes:
	// * box    / sloped voxels / blends with neighbours
	// * pipe   / half-pipes    / bends
	// * sphere / capsule       / blobs
	// * SDFs
	// (All shapes: Provide raydist for drawing, nearest point for hit-detection)
	



class RayTracer
	visible false
	|vec4|			Color
	|float|			Dist
	//
	|vec2|			Size
	|vec2|			Scale
	|vec2|			Adjust
	//
	|Vec3|			_CamDir
	|vec3|			iDir
	|Mat4|			_LookAt
	|Vec3|			_Camera
	//
	visible true
	|[vobject]|		Shapes
	|float|			Pitch
	|float|			Spin
	
	constructor (|vec3| Camera)
		// Default RayTracer constructor should use the block positioning system
		// either by zpos or zoom
		._LookAt.reset
		.Camera(Camera)
	
	
	function Camera (|vec3|)
		return ._Camera

	setter Camera (|vec3|)
		._Camera = Value.MakeSane
	
	
	helper ViewMat (|&mat4|)
		.spin = .spin.Fract
		.Pitch = .Pitch.fract
		._LookAt = .spin.SinCos.RotateAroundY	// could make a faster version that creates already transposed thing
		|| M = .pitch.SinCos.RotateAroundX   	// or just creates needed values and applies directly
		._LookAt *= M							// and only needs a "virtual" vec3
		return ._LookAt
	
			
	function AntiAlias (|vec2| XY, |&imagepixel| pxl, |&imagepixel|)
		|| ID = pxl.a
		|| C = pxl.Color
		for i in 4
			|| sh = (i&1, i>>1).Vec2 - 0.5
			c += .GetColor(XY + sh*0.8)
		C *= 5th
		C.a = ID|float|*255th
		pxl <~ C
		return pxl
	
	
	function GetColor (|vec2| XY, |vec4|)
		opt min 3, opt norefcounts
		.Color = nil
		.Dist = float.max
		._CamDir = .Dir(xy)
		.idir = -1.0 / ._CamDir
		
		for sp in .Shapes
			|| t = (sp.Shape)(sp, .Camera, ._CamDir, .idir)
			|| tx = t.x
			if (tx > 0) and (tx < .Dist)
				.Dist = t.x
				|| P = .Camera + ._CamDir*tx
				|| Norm = (P - sp.pos).normal
				|| C = (norm.abs * sp.Color.xyz)
				.color = (C, sp.shapeID|float|*255th)
		return .Color
	

	function Dir (|int| X, |int| Y, |vec3|)
		cpp_part DirInt
		return .Dir((x,y).vec2)
	
	function Dir (|vec2| XY, |vec3|)
		XY = (xy + .adjust) * .scale
		return (xy, 1.0).Normal * ._LookAt
	
	
	function Redivide (|bool|)
		opt norefcounts,  opt min 3
		
		|| B = root init alloc(32)
			b.Redivide(self)
			for s in .shapes
				.Place(s)
	
			
	function Place (|vobject| v)
		// we need it's largest bound... easiest to do as a sphere?
		// boxes might be long and thin, though? thy could be done as lines... say 12 lines?
		// its a lot of maths...
	
	
	function RayTrace (|image| where, |float|)
		// should allow alpha for drawing over prev images...
		// meaning that the alpha can't be the ID!
		opt norefcounts,  opt min 3
		.ViewMat
		.size = where.size.vec2
		.scale = 1.0/.size.xx
		.adjust = .size * -0.5
		require .Redivide()
		|| P = vec2()
		|| w = where.Width|float|
		|| h = where.Height|float|
		
		
		while p.y < h
			|| PY = (0, p.y|int|)
			|| pxl = where[PY]
			|| below = where[PY+(0,-1)]			
			|| Left = pxl
			while p.x < w
				|| C = .GetColor(P)
				pxl <~ C
				if pxl.a!=left.a
					left = .AntiAlias(p-(1.0,0), left)
					pxl = .AntiAlias(p, pxl)
					rz++
				if pxl.a!=below.a
					below = .AntiAlias(p-(0,1.0), below)
					if pxl.a==left.a
						pxl = .AntiAlias(p, pxl)
					rz++
				// :O
				left = pxl
				pxl++
				below++
				p.x++
			p.y++
			p.x = 0
		rz /= where.size.area|float|		
	
	
	module
		// 30x19 normally...
		function Alloc (|int| px, |int| Size=4MB, |&RayBoost|)
			|| root = memory.zalloc(size)|&RayBoost|$
			px = 1<<px.log2
			.Root = root
			root.size.y2 = gui.Screen.height - 1
			|| w = gui.Screen.Width
			root.size.x2 = w - 1
			|| D = w.ContaingPowerOfTwo - (px.log2 + 1)
			return root.SubAllocate(root, D)
			
		|&RayBoost|			Root
		|&RayTraceNode|		StartNodes
		|&RayTraceNode|		EndNodes



struct RayBoost
	|vec4|					YDiv			
	|vec4|					XDiv
	|ivec4|					Size
	|&RayBoost[4]|			Quad
	|int|					Depth
		
	function Redivide (|raytracer| T)
		opt norefcounts,  opt min 3
		|| Q = .quad[0]
		|| S = Q.size
		|| D1 = t.Dir(S.x2, S.y1)
		|| DM = t.Dir(S.x2, S.y2)
		|| D3 = t.Dir(S.x1, S.y2)
		.xdiv = Plane3D.normals(d3, dm, t._Camera) // now just use these... and then subdivide!
		.ydiv = Plane3D.normals(d1, dm, t._Camera)

		for i in 4
			if .Depth > 0
				.quad[i].redivide(t)
			  else
				.quad[i] = nil
	
	helper SubAllocate (|!&RayBoost| Last, |int| H, |!&RayBoost|)
		.depth = H
		for i in 4
			.quad[i] = ++last

		|| bounds = .Size
		|| xy = bounds.xy
		|| hh = 1<<H
		|| LB = (xy,xy+hh-1)
		for yy in 2	
			for xx in 2
				|| S = lb + (hh*xx, hh*yy, hh*xx, hh*yy)
				|| Q = .Quad[xx+yy<<1]
				q.size = s min bounds
				if h > 0
					last = Q.SubAllocate(last, H-1)
		
		return last



struct RayTraceNode
	|vobject--|				Curr
	|&RayTraceNode|			Next



function int.ContaingPowerOfTwo (|int|)
	|| p = .log2
	|| rem = self - p
	return p + (rem!=0)
