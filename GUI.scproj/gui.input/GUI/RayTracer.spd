

// todo whenever its fun?
// * we should use • with the camdir and the vector
// * 4 threads, each can do one quad.
// * default RayTracer constructor uses block positioning system to match 2D/3D closely

// advancements: (do AFTER we have perry+speedie in an awesome state)
// 1) Make SpaceTree work
// 2) Optimisations around unmoving objects
// 3) hit-detection? (surely its just chunk vs chunk anyhow?)
// 4) more shapes:
	// * box    / sloped voxels / blends with neighbours
	// * pipe   / half-pipes    / bends
	// * sphere / capsule       / blobs
	// * SDFs
	// (All shapes: Provide raydist for drawing, nearest point for hit-detection)

	



class RayTracer
	visible false
	|vec4|				Color
	|float|				Dist
	|float|				MaxViewDistSq
	//
	|vec4|				Size
	|vec2|				Scale
	|vec2|				Adjust
	|vec4[4]|			Planes
	//
	|Vec3|				_CamDir
	|vec3|				iDir
	|Mat4|				_LookAt
	|vec3|				Fwd

	|Vec3|				Camera
	|float|				Pitch
	|float|				Spin
	|byte|				_StillGood
		
	|&RayBoost|			RootNode // make these not ?!
	|&RayTraceNode|		EndNodes
	|?&RayTraceCell|	Cells
	|?&RayTraceNode|	StartNodes
	|?&RayTraceNode|	CurrNode
	//
	|?&pico[4]|			Workers //!!nice I guess we can send messages? or not?
								// maybe easier to start/stop? or just spin on a value?
								// we could reduce pico to "just a place to store a few data pointers"
	//
	visible true
	|[vobject]|			Shapes
	
	
	constructor (|vec3| Camera, |int| Buff=4MB, |int| px=32)
		// Default RayTracer constructor should use the block positioning system
		// either by zpos or zoom
		.MaxViewDistSq = 1000.0.pow2
		.Camera = Camera
		
		|| root = memory.zalloc(Buff)|&rayboost| // just take the ptr in the constructor!
		if !root
			app.Quit("can't allocate ray-tracer")		
		"RayAlloc"
		.RootNode = root
		.EndNodes = (root|&byte| + Buff)|&RayTraceNode|
		root.px = px
	

	setter Camera (|vec3|)
		Value = Value|vec4|.MakeSane|vec3|
		if .Camera != value
			.Camera = Value
			._StillGood = 0


	setter Pitch (|float|)
		value = Value.Fract
		if .pitch != value
			.pitch = Value
			._StillGood = 0


	setter Spin (|float|)
		Value = value.Fract
		if .Spin != value
			.Spin = Value
			._StillGood = 0
	
	helper ViewMat (|&mat4|)
		ifn ._StillGood&2
			._StillGood |= 2
			._LookAt = .spin.SinCos.RotateAroundY	// could make a faster version that creates already transposed thing
			|| M = .pitch.SinCos.RotateAroundX   	// or just creates needed values and applies directly
			._LookAt *= M							// and only needs a "virtual" vec3
			.Fwd = (0.0, 0.0, 1.0) * ._LookAt
		return ._LookAt
	
	
	helper AntiAlias (|vec2| XY, |!&raytracenode| curr, |&imagepixel| pxl)
		opt min 3
		|| ID = pxl.a
		|| C = pxl.Color
		for i in 4
			|| sh = (i&1, i>>1).Vec2 - 0.5
			c += .GetColor(XY + sh*0.8, curr)
		C *= 5th
		C.a = ID|float|*255th
		pxl <~ C
	
	
	helper GetColor (|vec2| XY, |!&raytracenode| Rt, |vec4|)
		// Should allow alpha for drawing over prev images...
		// Meaning that the alpha can't be the ID!
		opt min 3, opt norefcounts
		.Color = nil
		.Dist = float.max
		._CamDir = .Dir(xy)
		.idir = -1.0 / ._CamDir
		
		while rt
			|| sp = rt.draw!
			|| t = (sp.Shape)(sp, .Camera, ._CamDir, .idir)
			|| tx = t.x
			if (tx > 0) and (tx < .Dist)
				.Dist = t.x
				|| P = .Camera + ._CamDir*tx
				|| Norm = (P - sp.pos).normal
				|| C = (norm.abs * sp.Color.xyz)
				.color = (C, sp.shapeID|float|*255th)
			rt = rt.next
		return .Color
	
	
	helper Dir (|vec2| XY, |vec3|)
		|| XY2 = (xy + .adjust) * .scale // -0.5 to +0.5
		rz = (xy2, 1.0).Normal * ._LookAt
	
	
	helper Plane (|vec4| P, |vec4|)
		|| D1 = .Dir(P.xy)
		|| D2 = .Dir(p.x2y2)
		return Plane3D.normals(d1, d2, .Camera)

	
	helper InPlanes (|VObject| b, |bool|)
		opt min 3
		|| ToObj = b.pos - .Camera
		|| D = ToObj.LengthSq		// Should use the radius if a sphere, or at least be able to ask for "the nearest point" from the function.
		require  ToObj • .Fwd > 0  and  D > 0.25  and  D < .MaxViewDistSq
		
		|| R = (b.radius, 0.0)
		|| Pos = (b.pos, 1.0)
		
		for i in 4
			|| Q = .planes[i].BoxVsPlane(r, pos)
			require Q > 0

		// Could also (later) check if the nearest frustrum point is in the box.
		// Need points[8] and a way to find which is the nearest to the box, or just check all?
		return true
		
	
	helper RemakeNodes (|int| S)
		.InitAllCells
		for C in self
			C.Node = nil
			C.Stride = S
		ifn ._StillGood & 1
			._StillGood |= 1
			.Planes[0] = -.plane(.size.x1y1x1y2) // 0001 // left
			.Planes[1] =  .plane(.size.x2y1x2y2) // 1011 // right
			.Planes[2] =  .plane(.size.x1y1x2y1) // 0010 // bottom
			.Planes[3] = -.plane(.size.x1y2x2y2) // 0111 // top
			.rootnode.Divide(self)
	
	
	helper PlayQuidditch (|int| Stride)
		opt norefcounts
		.RemakeNodes(stride)				
		for s in .shapes
			if .InPlanes(s)
				.Quadditch(.rootnode, s)
	
	
	function RayTrace (|image| where)
		opt min 3
		.ViewMat
		.size = where.size.__xy.vec4
		.scale = 1.0/.size.x2x2
		.adjust = .size.x2y2 * -0.5
		.PlayQuidditch(where.width)
		for C in self
			if c.node
				c.pxl = where[c.xy.ivec2]
				.TraceCell(C)
	
	iterator
		|| C = .Cells!
		|| C2 = C + .rootnode.area
		while C < C2
			yield C
			C++


	helper TraceCell (|&raytracecell| cell)
		// super-awesome system to reduce stack use (makes real difference!)
		// it might seem like 6 vars is a lot, but it could easily be 14...
		// if I didn't work miracles to reduce all this!
		opt min 3
		|| P = cell.xy
		|| pxl = cell.pxl
		|| pxl3 = pxl - cell.stride*cell.h
		while pxl > pxl3
			|| pxl2 = pxl + cell.w
			while pxl < pxl2
				#! Main pixel color
				cell.Aliased = false
				pxl <~ .GetColor(P, cell.node!)
				
				|| Left = pxl-1
				if p.x and pxl.a != left.a
					#! Anti-alias the left??
					.AntiAlias(p-(1.0,0), cell.node!, left)
					.AntiAlias(p, cell.node!, pxl)
					cell.Aliased = true
				
				if p.y
					#! Maybe below too??
					|| below = pxl + cell.stride
					if pxl.a != below.a
						.AntiAlias(p-(0,1.0), cell.node!, below)
						if !cell.Aliased
							.AntiAlias(p, cell.node!, pxl)
				pxl++
				p.x++
			pxl -= (cell.stride + cell.w)
			p.y++
			p.x = cell.xy.x
		cell.node = nil
	
	
	helper InitAllCells (|&RayBoost|)
		|| s2 = (0,0, gui.Screen.Width, gui.Screen.height)
		rz = .RootNode
		if rz.size != s2
			rz.size = s2
	
			|| px = 5
			rz.cellswide = (s2.x2+((px)~bits)) >> px
			rz.cellshigh = (s2.y2+((px)~bits)) >> px
			
			|| Last = rz.InitialCreation(rz+1, s2.x2.log2p-1, px)
			._StillGood = 0
			.cells = last|&Raytracecell|
			.StartNodes = (.cells+rz.area+1)|&RayTraceNode| // +1 for fakecell
			while last-- > rz
				if !last.depth and last.px
					last.Init(self)
		.CurrNode = .StartNodes



struct RayBoost
	|vec4|					XDiv
	|vec4|					YDiv			
	|ivec4|					Size
	|!(&RayBoost)[4]|		Quad			// rather shrink Quad
	|byte|					Depth	
	|byte|					PX
	|byte|					CellsWide		// shared with root
	|byte|					CellsHigh		// shared with root
	|byte|					ThreadLock		// In case I want to multi-thread
	

	function Area (|int|)
		return .CellsWide|int| * .CellsHigh|int|


	helper Init (|raytracer| T)
		for i in 4
			.quad[i] = .InitCell(T, i&1, i>>1)|&rayboost|
			
	
	helper InitCell (|raytracer| T, |int| x, |int| y, |&RayTraceCell|)
		|| sz = .size
		|| CellStart = sz.xy + ((x,y) << .px)
		|| CellEnd = (CellStart + (1<<.px)) min sz.x2y2
		|| D = CellEnd - CellStart
		rz = T.Cells!
		if d.x > 0 and d.y > 0
			|| i = (CellStart>>.px)  fma  .CellsWide
			rz  +=  i
			rz.xy = CellStart.vec2
			rz.w = d.x
			rz.h = d.y
		  else
			rz  +=  .area // fake cell. should never be reached? but might be?
	

	helper raytracer.Quadditch (|rayboost| ff, |vobject| v, |int| i=-1)
		real self,  opt min 3
		if i >= 0
			|| D = ff.depth
			ff = ff.quad[i]!
			if !D
				|| Cell = ff|&raytracecell|
				|| RT = .currNode!++
				if RT < .EndNodes	
					|| Old = cell.node
					cell.node = RT
					RT.next = old
					RT.Draw = V
				return				
			require ff.PX
		
		// for big chunks, we should also test that the quad corners are in the object.
		// inigo quilez has a good article on this.
		|| Rd = (v.radius, 0.0)
		|| RX = Rd sign ff.xdiv
		|| RY = Rd sign ff.ydiv
		|| VP = (V.pos, 1.0)
		|| L = ff.xdiv • (VP + RX) > 0
		|| R = ff.xdiv • (VP - RX) < 0
		|| B = ff.ydiv • (VP + RY) > 0
		|| T = ff.ydiv • (VP - RY) < 0
		
		if (b|||t) & (l|||r)
			if (L+R)+(B+T) == 2
				return .Quadditch(ff, V, R + (T<<1)) // tailcall
			
			if B
				if L
					.Quadditch(ff, V, 0)
				if R
					.Quadditch(ff, V, 1)
			if T	
				if L
					.Quadditch(ff, V, 2)
				if R
					return .Quadditch(ff, V, 3)

	
	function Divide (|raytracer| T)
		opt min 3
		|| S = .size.vec4
		require s.IsPositive            			// do nothing
		|| Sh = .px+.depth
		|| mid = s.xy+(1 << sh)|float|
		.yDiv = t.plane((  s.x2, mid.y,   s.x, mid.y)).MakeSane
		.xDiv = t.plane((mid.x,    s.y, mid.x,   s.y2)).MakeSane
		
		if .Depth
			for i in 4
				.quad[i].Divide(t)
	
	
	helper InitialCreation (|!&RayBoost| Last, |int| H, |int| px, |!&RayBoost|)
		.depth = H-px
		.px = px

		if h <= px
			return last

		for i in 4
			.quad[i] = last++
		
		|| bounds = .Size
		|| xy = bounds.xy
		|| hh = 1<<H
		|| LB = (xy, xy+hh)
		for y in 2	
			for x in 2
				|| S = lb + hh * (x,y,x,y)
				|| Q = .Quad[x + y<<1]!
				Q.depth = 0
				Q.size = s.clip(bounds)
				q.CellsWide = .CellsWide
				q.CellsHigh = .CellsHigh
				if q.size.ispositive
					last = Q.InitialCreation(last, H-1, px)
				  else
					q.px = 0 // unreachable
		
		return last



struct RayTraceNode
	|?vobject--|				Draw
	|?&RayTraceNode|			Next
	// Could be nice to put 3 items on here.
	// This makes it cache nicely! faster memory :)


struct RayTraceCell
	|vec2|						XY
	|?&RayTraceNode|			Node
	|&imagepixel|				pxl
	|uint16|					Stride
	|byte|						H
	|byte|						W
	|bool|						Aliased
	
//	function Count (|int|)
//		|| w = .node
//		while w
//			rz++
//			w = w.next

 
function Vec4.BoxVsPlane (|vec4| R, |vec4| Pos, |float|)
	description "Pos.w must be 1.0,  r.w must be 0.0"
	|| RB = R sign self
	return self • (pos + RB)

