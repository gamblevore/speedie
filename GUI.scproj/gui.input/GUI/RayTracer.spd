

// todo:
// 1) Add screen cells and culling
// 2) Add space-partitions... (can add parent nodes... map can be the memorylayer of spacetree nodes)
// 3) Optimisations around unmoving objects
// 4) hit-detection? (surely its just chunk vs chunk anyhow?)
// 5) 4 threads, each can do one quad.
// 6) more shapes:
	// * box    / sloped voxels / blends with neighbours
	// * pipe   / half-pipes    / bends
	// * sphere / capsule       / blobs
	// * SDFs
	// (All shapes: Provide raydist for drawing, nearest point for hit-detection)
	



class RayTracer
	visible false
	|vec4|			Color
	|float|			Dist
	|float|			MaxViewDistSq
	//
	|vec4|			Size
	|vec2|			Scale
	|vec2|			Adjust
	|vec4[4]|		Planes
	//
	|Vec3|			_CamDir
	|vec3|			iDir
	|Mat4|			_LookAt
	|Vec3|			_Camera
	//
	visible true
	|[vobject]|		Shapes
	|float|			Pitch
	|float|			Spin
	
	constructor (|vec3| Camera)
		// Default RayTracer constructor should use the block positioning system
		// either by zpos or zoom
		._LookAt.reset
		.MaxViewDistSq = 1000.0.pow2
		.Camera(Camera)
	
	
	function Camera (|vec3|)
		return ._Camera

	setter Camera (|vec3|)
		._Camera = Value.MakeSane
	
	
	helper ViewMat (|&mat4|)
		.spin = .spin.Fract
		.Pitch = .Pitch.fract
		._LookAt = .spin.SinCos.RotateAroundY	// could make a faster version that creates already transposed thing
		|| M = .pitch.SinCos.RotateAroundX   	// or just creates needed values and applies directly
		._LookAt *= M							// and only needs a "virtual" vec3
		return ._LookAt
	
			
	helper AntiAlias (|vec2| XY, |&imagepixel| pxl, |&imagepixel|)
		|| ID = pxl.a
		|| C = pxl.Color
		for i in 4
			|| sh = (i&1, i>>1).Vec2 - 0.5
			c += .GetColor(XY + sh*0.8)
		C *= 5th
		C.a = ID|float|*255th
		pxl <~ C
		return pxl
	
	
	helper GetColor (|vec2| XY, |vec4|)
		opt min 3, opt norefcounts
		.Color = nil
		.Dist = float.max
		._CamDir = .Dir(xy)
		.idir = -1.0 / ._CamDir
		
		for sp in .Shapes
			|| t = (sp.Shape)(sp, .Camera, ._CamDir, .idir)
			|| tx = t.x
			if (tx > 0) and (tx < .Dist)
				.Dist = t.x
				|| P = .Camera + ._CamDir*tx
				|| Norm = (P - sp.pos).normal
				|| C = (norm.abs * sp.Color.xyz)
				.color = (C, sp.shapeID|float|*255th)
		return .Color
	

	helper Dir (|int| X, |int| Y, |vec3|)
		cpp_part DirInt
		return .Dir((x,y).vec2)
	
	helper Dir (|vec2| XY, |vec3|)
		XY = (xy + .adjust) * .scale
		return (xy, 1.0).Normal * ._LookAt
	
	
	helper Plane (|vec4| P, |vec4|)
		|| D1 = .Dir(P.xy)
		|| D2 = .Dir(p.x2y2)
		return Plane3D.normals(d1, d2, ._Camera)


	helper InPlanes (|vobject| b, |bool|)
		|| D = (b.pos - ._Camera).lengthsq
		require D > 0.25 and D < .MaxViewDistSq
		|| R = (b.radius, 0.0)
		|| Pos = (b.pos, 1.0)
		for i in 4
			|| P = .planes[i]
			|| PX = pos + (R sign P)
			|| Q = p • PX
			require Q > 0
		// Could also (later) check if the nearest frustrum point is in the box.
		// Need points[8] and a way to find which is the nearest to the box, or just check all?
		return true
			
	
	helper DoFrustrum
		.Planes[0] = .plane(.size.x1y1x1y2) // 0001 // left
		.Planes[1] = .plane(.size.x2y1x2y2) // 1011 // right
		.Planes[2] = .plane(.size.x1y1x2y1) // 0010 // bottom
		.Planes[3] = .plane(.size.x1y2x2y2) // 0111 // top
	
	
	helper Redivide (|bool|)
		opt norefcounts,  opt min 3
		if 1
			return 1
		|| B = root init alloc(32)
			raytracer.currNode = raytracer.StartNodes
			.DoFrustrum
			b.Redivide(self)
			for s in .shapes
				if .InPlanes(s)
					b.Place(s)
			return true
	
	
	function RayTrace (|image| where, |float|)
		// should allow alpha for drawing over prev images...
		// meaning that the alpha can't be the ID!
		opt norefcounts,  opt min 3
		.ViewMat
		.size = where.size.__xy.vec4
		.scale = 1.0/.size.x2x2
		.adjust = .size.x2y2 * -0.5
		require .Redivide()
		|| P = vec2()
		|| w = where.Width|float|
		|| h = where.Height|float|
		
		while p.y < h
			|| PY = (0, p.y|int|)
			|| pxl = where[PY]
			|| below = where[PY+(0,-1)]			
			|| Left = pxl
			while p.x < w
				|| C = .GetColor(P)
				pxl <~ C
				if pxl.a!=left.a
					left = .AntiAlias(p-(1.0,0), left)
					pxl = .AntiAlias(p, pxl)
					rz++
				if pxl.a!=below.a
					below = .AntiAlias(p-(0,1.0), below)
					if pxl.a==left.a
						pxl = .AntiAlias(p, pxl)
					rz++
				// :O
				left = pxl
				pxl++
				below++
				p.x++
			p.y++
			p.x = 0
		rz /= where.size.area|float|		
	
	
	module
		// 30x19 normally...
		function Alloc (|int| px, |int| Size=4MB, |&RayBoost|)
			|| root = memory.zalloc(size)|&RayBoost|$
			px = 1<<px.log2
			.Root = root
			root.size.y2 = gui.Screen.height - 1
			|| w = gui.Screen.Width
			root.size.x2 = w - 1
			|| D = w.ContaingPowerOfTwo - (px.log2 + 1)
			|| Last = root.InitialCreation(root, D)
			StartNodes = last|&RayTraceNode|
			EndNodes = (root|&byte| + Size)|&RayTraceNode|
			return root
			
		|&RayBoost|			Root
		|&RayTraceNode|		StartNodes
		|&RayTraceNode|		CurrNode
		|&RayTraceNode|		EndNodes



struct RayBoost
	|vec4|					YDiv			
	|vec4|					XDiv
	|ivec4|					Size
	|&RayBoost[4]|			Quad
	|byte|					Depth	
	|byte|					ThreadLock // in case I want to multi-thread
	|uint16|				ID
		
	function SubPlace (|vobject| v, |int| i)
		|| Q = .quad[i]
		if .depth
			return Q.place(v)
		|&RayTraceNode| PP = Q|&RayTraceNode|
		|| New = raytracer.currNode!++
		PP[0] = New
		New.Next = nil
		New.Draw = V

		
	function Place (|vobject| v)
		|| Rd = (v.radius, 0.0)
		|| RX = Rd sign .xdiv
		|| RY = Rd sign .ydiv
		|| VP = (V.pos, 1.0)
		|| L = .xdiv • (VP - RX) > 0
		|| R = .xdiv • (VP + RX) > 0
		|| B = .ydiv • (VP - RY) > 0
		|| T = .ydiv • (VP + RY) > 0
		
		if (b|||t) & (l|||r)
			if (L+R)+(B+T) == 2
				return .SubPlace(V, R + (T<<1)) // tailcall
			
			if T
				if L
					.SubPlace(V, 0)
				if R
					.SubPlace(V, 1)
			if B
				if L
					.SubPlace(V, 2)
				if R
					return .SubPlace(V, 3)


	function Redivide (|raytracer| T)
		opt norefcounts,  opt min 3
		.ID = (self - raytracer.root)
		|| S = .quad[0].size
		|| D1 = t.Dir(S.x2, S.y1)
		|| DM = t.Dir(S.x2, S.y2)
		|| D3 = t.Dir(S.x1, S.y2)
		.xdiv = Plane3D.normals(d3, dm, t._Camera) // now just use these... and then subdivide!
		.ydiv = Plane3D.normals(d1, dm, t._Camera)

		for i in 4
			if .Depth > 0
				.quad[i].redivide(t)
			  else
				.quad[i] = nil
	
	
	helper InitialCreation (|!&RayBoost| Last, |int| H, |!&RayBoost|)
		.depth = H
		for i in 4
			.quad[i] = ++last

		|| bounds = .Size
		|| xy = bounds.xy
		|| hh = 1<<H
		|| LB = (xy,xy+hh-1)
		for yy in 2	
			for xx in 2
				|| S = lb + (hh*xx, hh*yy, hh*xx, hh*yy)
				|| Q = .Quad[xx+yy<<1]
				q.size = s min bounds
				if h > 0
					last = Q.InitialCreation(last, H-1)
		
		return last



struct RayTraceNode
	|vobject--|				Draw
	|?&RayTraceNode|		Next



function int.ContaingPowerOfTwo (|int|)
	|| p = .log2
	|| rem = self - p
	return p + (rem!=0)
