

// todo:
// 1) Add screen cells and culling
// 2) Add space-partitions... (can add parent nodes... map can be the memorylayer of spacetree nodes)
// 3) Optimisations around unmoving objects
// 4) hit-detection? (surely its just chunk vs chunk anyhow?)
// 5) 4 threads, each can do one quad.
// 6) more shapes:
	// * box    / sloped voxels / blends with neighbours
	// * pipe   / half-pipes    / bends
	// * sphere / capsule       / blobs
	// * SDFs
	// (All shapes: Provide raydist for drawing, nearest point for hit-detection)
	



class RayTracer
	visible false
	|vec4|			Color
	|float|			Dist
	|float|			MaxViewDistSq
	//
	|vec4|			Size
	|vec2|			Scale
	|vec2|			Adjust
	|vec4[4]|		Planes
	//
	|Vec3|			_CamDir
	|vec3|			iDir
	|Mat4|			_LookAt
	|Vec3|			_Camera
	//
	visible true
	|[vobject]|		Shapes
	|float|			Pitch
	|float|			Spin
	
	constructor (|vec3| Camera)
		// Default RayTracer constructor should use the block positioning system
		// either by zpos or zoom
		._LookAt.reset
		.MaxViewDistSq = 1000.0.pow2
		.Camera(Camera)
	
	
	function Camera (|vec3|)
		return ._Camera

	setter Camera (|vec3|)
		._Camera = Value|vec4|.MakeSane|vec3|
	
	
	helper ViewMat (|&mat4|)
		.spin = .spin.Fract
		.Pitch = .Pitch.fract
		._LookAt = .spin.SinCos.RotateAroundY	// could make a faster version that creates already transposed thing
		|| M = .pitch.SinCos.RotateAroundX   	// or just creates needed values and applies directly
		._LookAt *= M							// and only needs a "virtual" vec3
		return ._LookAt
	
			
	helper AntiAlias (|vec2| XY, |&imagepixel| pxl, |&imagepixel|)
		|| ID = pxl.a
		|| C = pxl.Color
		for i in 4
			|| sh = (i&1, i>>1).Vec2 - 0.5
			c += .GetColor(XY + sh*0.8)
		C *= 5th
		C.a = ID|float|*255th
		pxl <~ C
		return pxl
	
	
	helper GetColor (|vec2| XY, |vec4|)
		opt min 3, opt norefcounts
		.Color = nil
		.Dist = float.max
		._CamDir = .Dir(xy)
		.idir = -1.0 / ._CamDir
		
		for sp in .Shapes
			|| t = (sp.Shape)(sp, .Camera, ._CamDir, .idir)
			|| tx = t.x
			if (tx > 0) and (tx < .Dist)
				.Dist = t.x
				|| P = .Camera + ._CamDir*tx
				|| Norm = (P - sp.pos).normal
				|| C = (norm.abs * sp.Color.xyz)
				.color = (C, sp.shapeID|float|*255th)
		return .Color
	
	helper GetColor2 (|vec2| XY, |!&raytracenode| RT, |vec4|)
		opt min 3, opt norefcounts
		.Color = nil
		.Dist = float.max
		._CamDir = .Dir(xy)
		.idir = -1.0 / ._CamDir
		
		while
			|| sp = rt.draw
			rt = rt.next
			loop rt and sp
			|| t = (sp.Shape)(sp, .Camera, ._CamDir, .idir)
			|| tx = t.x
			if (tx > 0) and (tx < .Dist)
				.Dist = t.x
				|| P = .Camera + ._CamDir*tx
				|| Norm = (P - sp.pos).normal
				|| C = (norm.abs * sp.Color.xyz)
				.color = (C, sp.shapeID|float|*255th)
		return .Color
	

	helper Dir (|int| X, |int| Y, |vec3|)
		cpp_part DirInt
		return .Dir((x,y).vec2)
	
	helper Dir (|vec2| XY, |vec3|)
		XY = (xy + .adjust) * .scale
		return (xy, 1.0).Normal * ._LookAt
	
	
	helper Plane (|vec4| P, |vec4|)
		|| D1 = .Dir(P.xy)
		|| D2 = .Dir(p.x2y2)
		|| C = ._Camera
		return Plane3D.normals(d1, d2, C)


	helper InPlanes (|vobject| b, |bool|)
		|| D = (b.pos - ._Camera).lengthSq // should use the radius if a sphere, or at least be able to ask for "the nearest point" from the function.
		require D > 0.25 and D < .MaxViewDistSq
		|| R = (b.radius, 0.0)
		|| Pos = (b.pos, 1.0)
		
		for i in 4
			|| Q = .planes[i].BoxVsPlane(r, pos)
			require Q > 0
		// Could also (later) check if the nearest frustrum point is in the box.
		// Need points[8] and a way to find which is the nearest to the box, or just check all?
		return true
			
	
	helper DoFrustrum 
		.Planes[0] = -.plane(.size.x1y1x1y2) // 0001 // left
		.Planes[1] =  .plane(.size.x2y1x2y2) // 1011 // right
		.Planes[2] =  .plane(.size.x1y1x2y1) // 0010 // bottom
		.Planes[3] = -.plane(.size.x1y2x2y2) // 0111 // top
	
	
	function CameraChangedSinceLastTrace (|bool|)
		// return if campos+matrix is the same as last time...
		return true
	
	
	helper PlayQuidditch (|bool|)
		opt norefcounts,  opt min 3
		target !__PROJECT_PERRY__
			if 1
				return 1
		|| B = raytracer.GrabRoot(32)
			raytracer.currNode = raytracer.StartNodes + (b.chunkx*b.chunky)
			.DoFrustrum
			if .CameraChangedSinceLastTrace
				b.FillQuads(self)
			for s in .shapes
				if .InPlanes(s)
					b.Quadditch(s)
			return true
	
	
	function RayTrace (|image| where, |float|)
		// should allow alpha for drawing over prev images...
		// meaning that the alpha can't be the ID!
		opt norefcounts,  opt min 3
		.ViewMat
		.size = where.size.__xy.vec4
		.scale = 1.0/.size.x2x2
		.adjust = .size.x2y2 * -0.5
		require .PlayQuidDitch
		
// we need to go across the chunks. shouldn't be too hard?
//		|| curr = startnodes|&rayboost|
//		|| Last = curr
// we'll do a proper chunk lister... SOOOONNN

		|| P = vec2()
		|| w = where.Width|float|
		|| h = where.Height|float|
		
		while p.y < h
			|| PY = (0, p.y|int|)
			|| pxl = where[PY]
			|| below = where[PY+(0,-1)]			
			|| Left = pxl
			while p.x < w
				|| curr = rootnode!.FindChunkSub(p.x|int|>>5, p.y|int|>>5)
				|| C = .GetColor2(P, curr)
				pxl <~ C
				if pxl.a != left.a
					left = .AntiAlias(p-(1.0,0), left)
					pxl = .AntiAlias(p, pxl)
					rz++
				if pxl.a != below.a
					below = .AntiAlias(p-(0,1.0), below)
					if pxl.a==left.a
						pxl = .AntiAlias(p, pxl)
					rz++
				// :O
				left = pxl
				pxl++
				below++
				p.x++
			p.y++
			p.x = 0
		rz /= where.size.area|float|		
	
	
	module
		helper GrabRoot (|int| px, |int| Size=4MB, |&RayBoost|)
			|| s2 = (0,0, gui.Screen.Width, gui.Screen.height)
			px = 1<<px.log2

			|| root = .RootNode
				if root.size == s2 and root.px == px
					return root
				
			root = memory.Zalloc(size)|&RayBoost|$
			.RootNode = root
			root.px = px
			root.size = s2
			
			|| D = s2.x2.ContainingPowerOfTwo
			|| px2 = px.log2
			|| s3 = (s2.x2y2+(px-1)) >> px2
			root.chunkx = s3.x
			root.chunky = s3.y
			
			|| Last = root.InitialCreation(root, D-1, px2)
			StartNodes = last|&RayTraceNode|
			EndNodes = (root|&byte| + Size)|&RayTraceNode|
			return root
		
		
		|&RayBoost|			RootNode
		|&RayTraceNode|		StartNodes
		|&RayTraceNode|		CurrNode
		|&RayTraceNode|		EndNodes



struct RayBoost
	|vec4|					XDiv
	|vec4|					YDiv			
	|ivec4|					Size
	|(&RayBoost)[4]|		Quad			// rather shrink this.
	|byte|					ThreadLock		// in case I want to multi-thread
	|byte|					Depth	
	|byte|					PX
	|byte|					ChunkX
	|byte|					ChunkY
	

	function Quadditch (|vobject| v, |int| i=-1)
		real self
		if (i < 0)
			// do nothing
		  elseif .depth
			self = .quad[i]!
		  else
			|| Q = .quad[i]
			|&raytracenode| RT 
			|| Old = Q|&RayTraceNode|
				RT = raytracer.currNode!++
			  else
				RT = .FindChunk(i&1, i>>1)
			.quad[i] = RT|&rayboost|
			RT.Next = Old
			RT.Draw = V
			return
		
		// for big chunks, we should also test that the quad corners are in the object.
		// inigo quilez has a good article on this.
		|| Rd = (v.radius, 0.0)
		|| RX = Rd sign .xdiv
		|| RY = Rd sign .ydiv
		|| VP = (V.pos, 1.0)
		|| L = .xdiv • (VP + RX) > 0
		|| R = .xdiv • (VP - RX) < 0
		|| B = .ydiv • (VP + RY) > 0
		|| T = .ydiv • (VP - RY) < 0
		
		if (b|||t) & (l|||r)
			if (L+R)+(B+T) == 2
				return .Quadditch(V, R + (T<<1)) // tailcall
			
			if B
				if L
					.Quadditch(V, 0)
				if R
					.Quadditch(V, 1)
			if T	
				if L
					.Quadditch(V, 2)
				if R
					return .Quadditch(V, 3)
		  else
			debugger


	function FillQuads (|raytracer| T)
		opt norefcounts,  opt min 3      // .ID = (self - raytracer.RootNode)
		|| S = .size.vec4
		require s.ispositive             // do nothing
		|| Sh = .px+.depth
		|| mid = s.xy+(1 << sh)|float|
		.yDiv = t.plane((  s.x2, mid.y,   s.x, mid.y)).makesane
		.xDiv = t.plane((mid.x,    s.y, mid.x,   s.y2)).makesane
		
		for i in 4
			if .Depth
				.quad[i].FillQuads(t)
			  else
				.quad[i] = nil
	
	
	helper FindChunk (|int| x, |int| y, |&RayTraceNode|)
		|| V = .size.xy >> .px
		return .FindChunkSub(V.x + x, V.y + y)
	
	
	helper FindChunkSub (|int| x, |int| y, |&RayTraceNode|)
		|| w = .ChunkX
		return RayTracer.StartNodes! + x + (y*w)
	
	
	helper InitialCreation (|!&RayBoost| Last, |int| H, |int| px, |!&RayBoost|)
		.depth = H-px
		.px = px

		if h <= px
			return last

		for i in 4
			.quad[i] = ++last
		
		|| bounds = .Size
		|| xy = bounds.xy
		|| hh = 1<<H
		|| LB = (xy, xy+hh)
		for y in 2	
			for x in 2
				|| S = lb + hh * (x,y,x,y)
				|| Q = .Quad[x + y<<1]!
				Q.depth = 0
				Q.size = s.clip(bounds)
				q.chunkx = .chunkx
				if q.size.ispositive
					last = Q.InitialCreation(last, H-1, px)
		
		return last



struct RayTraceNode
	|?vobject--|				Draw
	|?&RayTraceNode|			Next
	// could be nice to put 3 items on here.
	// this makes it cache nicely! faster memory :)



function int.ContainingPowerOfTwo (|int|)
	|| p = .log2
	|| rem = self - p
	return p + (rem!=0)


function Vec4.BoxVsPlane (|vec4| R, |vec4| Pos, |float|)
	description "Pos.w must be 1.0,  r.w must be 0.0"
	|| RB = R sign self
	|| PX = pos + RB
	|| Q = self • PX
	return Q

