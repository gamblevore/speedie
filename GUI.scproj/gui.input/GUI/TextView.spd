

	
class TextView (GUIControl)
	linkage
		cpp_part Text
	|byte|						SingleLine

	|bool| 						ShowLineNumbers
	|bool|						GroupSaveAll
	|byte|						LineHeight
	|bool|						IsALogTextView // Is this textview used for displaying a Log.
	|byte|						ExpectsParse
	|int8|						YAdjust
	|MoveCode|					Alignment // centered, left, right

	|byte|						_CanAutoComplete
	|int|						_AutoCompleteBack
	|int64|						_LogTrimmed
	|string|					_AutoCompleteString

	|byte|						_LineNumWidth
	|byte|						_CodeInsertionState
	|uint16|					_LastDrawWidth
	|int|						_RemainingHeight
	|byte|						_ClicksDown
	|bool|						_PreferPrevLine
	|TextViewLine|				_Start
	|TextViewLine|				_Lines
	|ivec3|						_Reclaim		
	|IntRange|					_TypingPlace
	|IntRange|					_UncorrectedSel
	
	|GUIKeyEvent?|				OnKeyDown
	|GUITextEvent?|				OnTextChanged
	|GUITextEvent?|				OnSelChanged
	|Document?|					_Viewing

	|Error?|					MyError
	|DelayedShowError?| 		_ErrorDelayer
	|GUITextShowEvent?|			OnShowExtraInfo
	|GUITextErrorSelected?|		OnSelError

	constructor (|guicontrol| p, |guiaction| Clicked=nil, |GUIKeyEvent| keys=nil)
		super.Constructor(p)
		._reclaim = (0, 1GB, 0)
		|| TV = TextViewLine()
		._Lines = TV
		._Start = TV							// Make nilchecker happy
		.TakesFocus = TakesFocusFlag.On
		.OnClicked	= Clicked
		.OnKeyDown	= keys
		._CanAutoComplete = 2
		.LineHeight = font.Height + 4			// Whatever
		.ExpectsParse = TextView.allowjeebox
		.CopyPaste = CopyPasteFlags.CopyText ||| CopyPasteFlags.PasteText
		.onpaste = textPaste|GUIPasteEvent|
		.oncopy = textCopy|GUICopyEvent|
		.init

	destructor
		.document = nil		
	
	function Document (|document|)
		return ._Viewing
	
	function Document (assigns:|document?|)
		opt norefcounts
		require value != ._viewing
		|| old = ._viewing
			old.removeviewer(self)
		._viewing = value
		if value
			value.addviewer(self)
	

	libinternal Undoer (|Document?|)
		opt norefcounts
		|| v = ._viewing
		if v or self isnt editable
			return v
		._Viewing = v
		v = document("")
		v.AddViewer(self)
		return v
	
	
	behaviour MouseMove
		|| InScroll = .MouseMoveInScrollArea(P)
		
		if state is enter or moved
			if InScroll
				SystemCursor.hand.use
			  else
				|| InLines = ._LineNumWidth and (State isnt leave) and (p.x < .LineNumRight)
					SystemCursor.hand.use
				  else
					super.MouseMove(p, move, state)

		.ShowExtraInfo(P, true)
		return InScroll
	

	behaviour MouseDown
		if (clicks == 1) and (keys.cmd or keys.ctrl)
			.SendSpecialClick(p, !keys.PlatCmd)
			return MouseDragging.handled
		
		if .ClickedScroll(P, clicks)
			return MouseDragging.Within
		if (clicks >= 1) and .ClickedLineNum(P)
			return MouseDragging.Handled
		
		if self is editable or AlwaysScrollable
			if clicks >= 1							// remove this test?
				._ClicksDown = clicks
			|| x = .EditClickText(p, clicks, false)
				return x

		|| onc = .OnClicked
		if (onc) and clicks >= 0					// -1 = drag
			(onc)(self, clicks)
		if self is editable or AlwaysScrollable
			return MouseDragging.Within				// used to be 4, now 2?
		
		return MouseDragging.handled

	
	libinternal LineNumRight (|int|)
		return 5 + .lastleft + ._LineNumWidth*font.width
	
	
	libinternal string._FindBreakpoint (|int|)
		for (c in self) (i)
			if c == '/'
				c = self[i+1]
				if c == '/' or '*'
					return int.max
				return i
			if !c.IsWhite
				exit
		return -1
			
			
	libinternal string._TextLineClickedBreakpoint (|string|)
		|| i = ._FindBreakpoint
		if i == int.max
			beep
			return string.Error
		if i == -1 // ok... this means that the thing isn't found, so we can add it.
			return "/" + self
		// are these two branches the same? test later.
		// we did find one! but it might be in the middle!
		return .trimmiddle(i, i+1)

		
	libinternal ClickedLineNum (|ivec2| P, |bool|)
		require self is editable
		require p.x < .LineNumRight
		|| bs = (0, 0)
		|| d = .ByteAtXY(p, bs)
		require d is StartsNormally
		
		|| Restore = .selrange
		// so now we are within the area, and have a valid line. we can now alter the text!
		|| txt = d.Text._TextLineClickedBreakpoint
		if !txt.isok
			return true
		
		// adjust position first
		if Restore.x > d.position
			Restore += txt.length - d.text.length
		
		// now insert it		
		.InsertText(txt, d.Range, false)

		.selrange = Restore
		return true	
		
		
	libinternal ClickedScroll (|ivec2| P, |int| Clicks, |bool|)
		return .ClickedScrollbar(P, Clicks, .slh)
	
	
	setter ExpectsParse (|byte|)
		.ExpectsParse = value
		
		
	behaviour LostFocus
		.isinline.clear(False)?
		
		if !.KeepUndosOnLoseFocus
			.document = nil
		super.lostfocus


	behaviour GotFocus
		if (.isinline or .singleline) and !.selrange.width
			.selrange = .text.length
		GUI.SelChanged
		super.gotfocus

 
	behaviour Gesture
		if (self is editable or AlwaysScrollable) and !.singleline
			.StartLine = .StartLine.movecapped(wheel.y)
			return true


	libinternal LineAtY (|int| py, |textviewline|)
		opt norefcounts
		|| y = py max .lastbottom
		|| Dist = .lasttop - Y
		|| L = Dist / .lineheight|int|
		if dist < 0
			l = -1
		return .StartLine.move(L)

	
	libinternal ExpandToAntiWords (|intrange| t, |intrange|)
		opt norefcounts
		|| M = .MessageAt(t.x1)
		|| M2 = .MessageAt(t.x2)
		if false and m != nil and m == m2
			if m in @decl
				m = m.parent
				if t.x1 >= m.position and t.x2 <= m.after
					t.x1 = m.position
					t.x2 = m.after
					return t
			
		|| IsForward = t.x1 < t.x2 
		|| fwd = 0+( IsForward)
		|| bck = 0+(!IsForward)
		t.x1 += fwd
		t[bck] = .FindEnd(t[bck], -1)
		t[fwd] = .FindEnd(t[fwd],  1)
		return t

	
	libinternal TextViewLine.ooof (|bool| t, |int|)
		if t
			return .position
		return .after
		
		
	libinternal ExpandToVis (|intrange| t, |intrange|)
		opt norefcounts
		|| m = t
		|| d1 = .FindDrawInfo(m.x1)
		|| d2 = .FindDrawInfo(m.x2)
		t.x1 = d1.ooof(m.x1 <= m.x2)
		t.x2 = d2.ooof(m.x2 <  m.x1)
		return t
		
		
	libinternal ByteAtXY (|ivec2| p, |$ivec2| v, |textviewline|)
		opt norefcounts
		|| D = .LineAtY(p.y)
			|| x = p.x - .LineNumRight
			v = .LastLineFix(d, x)
			return d
		
		if p.y < .lasttop
			v = (.text.length, 0)

	
	libinternal LastLineFix (|textviewline| d, |int| x, |ivec2|)
		x += 2
		|| t = d.ByteOfX(x)
		|| PreferFirst = (d.after == t) and (d isnt last)
		if PreferFirst and d.endswithline
			t = .text.MoveCodePoint(t, -1)
			preferfirst = false
		return (t, PreferFirst|int|)
		
	
	libinternal ExpandSel (|ivec2| t, |int| C, |ivec2|)
		if (C == 2)
			return .ExpandToAntiWords(t)
		if (C == 3)
			return .ExpandToVis(t)
		if (C >= 4)
			return .lineexpand(t)
		return t


	function EditClickText (|ivec2| p, |int| clicks, |bool| CmdKey, |int|)
		opt norefcounts
		|ivec2| bs
		|| d = .ByteAtXY(p, bs)
		|| b = bs.x
		if !cmdkey  and  !clicks  and  .SelRange contains b
			return 0
		
		ifn .lastrect.vert contains p.y
			.show(b, textviewjumpmode.slowscroll)
			rz = mousedragging.EvenIfNoMovement
		
		|| t = ._UncorrectedSel
		if keys.shift or (clicks == -1)
			t.x2 = b
		  else
			t = (b, b)

		if !CmdKey
			.SelDirect(.ExpandSel(t, ._clicksdown), d)
		  else
			.SelDirect(t, d)
		._PreferPrevLine = bs.x2
		._UncorrectedSel = t


	function SendSpecialClick (|ivec2| p, |bool| IsRightClick)
		.EditClickText(p, 0, !IsRightClick)
		if IsRightClick and .__keydown__(keys.section)
			return
		|| Code = (-1, -2)(IsRightClick)
		(.onclicked)(self, Code)?
	
	
	behaviour RightClick
		.SendSpecialClick(p, true)

	function Sel (assigns:|int|)
		disabled "Use selrange"
		
	function SelRange (assigns: |int| r)
		cpp_part TypingPlaceInt
		.selrange = (r, r)
		
	function SelRange (assigns:|intrange|)
		.TypingPlaceTry(value, false, nil)

	function SelRange (|intrange|)
		return ._typingplace.resolve
		
	libinternal Sel0 (|int|)
		return .selrange.x
	
	libinternal Sel1 (|int|)
		return .selrange.y

	libinternal SelDirect (|IntRange| value, |TextViewLine| d)
		.TypingPlaceTry(value, false, d)

	autogen SelectedLine (|textviewline|)
		return .FindDrawInfo(.sel0)

	libinternal TypingPlaceReal (assigns:|intrange| result)
		opt norefcounts
		._TypingPlace = result
		|| doc = .document
			doc.TypingPlace = result
			|| L = doc.current
				L.typingplace = result

	libinternal TypingPlaceDirect (|intrange| result, |bool|)
		opt norefcounts
		require result != ._TypingPlace
		.TypingPlaceReal = result
		._PreferPrevLine = false
		if ._CanAutoComplete <= 1
			.CanAutoComplete = 0
			.autocompletestring = ""
		._UncorrectedSel = result
		gui.touch
		return true

	libinternal TypingPlaceTry (|IntRange| result, |bool| insert, |textviewline| d)
		opt norefcounts
		if .TypingPlaceDirect(result)
			.TypingPlaceChanged(insert, d)

	libinternal TypingPlaceChanged (|bool| insert, |textviewline| d)
		if .hasfocus
			GUI.selchanged
		if !.IsCleared
			(.OnSelChanged)(self, 0, insert)?
		d ?= .FindDrawInfo(.sel0)

		while
			.TryShowLineError(d)
			d++
			if  !d  or  d.Position > .sel1
				exit
	
	
	function TryShowLineError (|textviewline| d)
		opt norefcounts
		|| err = d.LineError
			(.OnSelError)(self, d)?
			if .OnShowExtraInfo
				.CancelDelayedError
				.ShowErrorInfo(d.position, err, false)
	
	
	libinternal CancelDelayedError
		opt norefcounts
		|| dse = ._ErrorDelayer
			dse.remove
			._ErrorDelayer = nil
		
	
	libinternal FindEnd (|ind| x,  |int| i,  |int|)
		opt norefcounts
		|| f = csAntiWords!
		|| avoid = false
		|| s = .text
		if i > 0
			|| x2 = s.MoveCodePoint(x, 1)
			if f[s[x]]	// so... if we have "|   " and we wanna move forward. then what?
				if !avoid
					return x2
				x = s.outcharset(f, x2) 
			  else
				x = s.find(f, x2...)
		  elseif x > 0
			|| x2 = s.MoveCodePoint(x, -1)
			if f[s[x2]]
				if !avoid
					return x2
				x = s.outcharset(F, x2, 0)
			  else
				x = s.find(f, x2, 0)
			if x
				x = s.MoveCodePoint(x, 1)
		if x
			return x
		if i > 0
			return s.length
	
	
	libinternal WordMove (|ind| pos, |int| dir, |ind|)
		opt norefcounts
		|| s = .text
		|| x = .WordMoveSub(pos, dir)
		|| Control = keys.platcmd(false)
		ifn (x!=pos) and control
			return .clamp(x)
		//
		|| shift = (dir==1)-1
		|| G = s.group(pos+shift)
		if  dir == 1  and  g == 1
			while
				if pos >= x
					return pos
				|| g2 = s.group(pos+shift)
				if g2 != g
					g = g2
					exit
				pos++
				
		while x != pos // move pos
			|| ng = s.group(pos+shift)
			if ng!=G
				if (dir == -1) and (G == 2) and (ng==1)
					pos--
				return pos
			pos+=dir
			if pos <= 0 or pos >= s.length
				exit
		return pos
	

	function string.Group (|int| i, |int|) // replace this with charprops.spd?
		|| b = self[i]
		if b.IsUpper
			return 1
		if b.IsLower or b == '_'
			return 2
		if b.IsInt
			return 3
		if b.iswhite
			return 4
		if b >= 128
			return 5

			
	libinternal WordMoveSub (|ind| pos, |int| dir, |ind|)
		opt norefcounts
		|| s = .text
		|| orig = pos
		if dir < 0
			if pos > 0
				pos = s.OutCharSet(textview.csantiWords!, pos-1, 0)
				if pos
					pos = s.find(textview.csantiWords!, pos, 0)
					if pos
						pos = pos max .FindLineSeperator(orig-1, pos)
						return pos + 1
		  else
			pos = s.OutCharSet(textview.csantiWords!, pos...)
			if pos
				pos = s.find(textview.csantiWords!, pos...)
				|| t2 = .FindLineSeperator(pos, orig+1)
					pos = pos min t2
			pos ?= s.length
			return pos
	
	
	libinternal MoveSel (|int| i, |bool|)
		opt norefcounts
		debug_require i
		GUI.showcursor(false)

		|| t = ._TypingPlace
		|| x = t.x2
		|| LineEnd = false
		|| fwd = false
		if !keys.shift
			|| r = t.resolve
			x = (r.x2, r.x)(i > 0)
		if keys.platCmd									// line-end
			|| t2 = (t.x - (i < 0), t.x2)
			x = .FindDrawLineEdge(t2, i)
			LineEnd = true
			fwd = (i > 0)
		  elseif keys.option or keys.platcmd(false)		// word by word
			x = .WordMove(x, i)
		  elseif (!t.width) or keys.shift
			x = .text.MoveCodePoint(x, i)
		  else
			fwd = i > 0

		x = .clamp(x)
			
		if keys.shift
			t.x2 = x
			if LineEnd and (x > t.x)
				x--
		  else
			t = (x, x)
		|| d = .show(x)
		._PreferPrevLine = fwd and (!d.emptyline or !d.EndsWithLine) 
		.SelDirect(t,d)
		return true
	
	target false {
	libinternal textviewline.InSane (|textviewline|s, |bool|)
		if (.position < 0)
			return true
		if s and (s.position != .after)
			return true


	libinternal Sanity
		opt norefcounts
		for p in ._lines
			|| s = p.next
			if p.insane(s)
				debugat
				return
			p = s
	}

	libinternal ShowTypingPlace (|ivec2| r)
		opt norefcounts
		|| i = (r.width>0)|int|
		.ViewPos(r[i], 0)


	function CurrLine (|int|)
		return .text[0, .sel0].linecount
	
	
	libinternal DrawInfoAtLine (|int| L, |textviewline|)
		opt norefcounts
		.PrepareLinesOfText
		for r in ._lines
			if r.tline >= l
				return r
		return ._lines.last
	
	
	function ViewLineAndSel (|int| L)
		|| d = .DrawInfoAtLine(L)
			.ShowAndSelect(d.position)

	
	function Show (|int| x, |TextViewJumpMode| Mode=0,  |TextViewLine|)
		return .ViewPos(x, .MaxVisibleLines/3, mode)
	

	function ShowAndSelect (|int| P, |int| Length=0, |bool| Explode=false, |textviewline|)
		opt NoRefCounts
		rz = .Show(P)
		.SelDirect((P, P + length), rz)

		if explode
			.Doexplode(rz)


	libinternal InRange (|int| pos, |bool|)
		opt norefcounts
		|| d = ._Start
		require pos >= d.Position
		|| d2 = d.MoveCapped(.MaxPartialVisibleLines)
		return pos <= d2.After
	
	
	libinternal ViewPos (|int| x, |int| before, |TextViewJumpMode| Mode=0, |TextViewLine|)
		opt NoRefCounts
		|| i	= 0
		|| d	= .FindDrawInfoSub(x, i)
		before = before.abs

		|| lim = .MaxVisibleLines
		if i inrange lim
			return d
		|| vdiff = d.vline - ._Start.vline
		if vdiff > 0
			before = (vdiff min (lim-(before+1))) max 0
			
		.StartLine(mode) = d.MoveCapped(-before) 
		return d
		
		
	function MoveSelection (|int| x, |int| Before=0, |bool|)
		// views X, and sets new typing place.
		opt norefcounts		
		|| t = ._typingplace
		x = .Clamp(x)
		|| d = .ViewPos(x, before) // idk
			
		if keys.shift
			t.x2 = x
		  else
			t = (x, x)
		.SelDirect(t, d)
		return true	


	function Clamp (|intrange| r, |intrange|)
		cpp_part Clamp2
		r = r.resolve
		return (.clamp(r.x), .clamp(r.x2))


	function Clamp (|int| x, |int|)
		return x.clamp(.text.length)
		

	libinternal MoveSelLine (|int| i, |int| Page, |bool|)
		opt norefcounts
		debug_require i
		GUI.showcursor(false)
		if !page
			page = (keys.Option)|int|
			target osx
				page |= (keys.ctrl)|int|
			
		|| x  = (.text.length, 0)(i > 0)
		|| t  = ._TypingPlace
		|| bs = .FindDrawSelMove(t, i, page>0)
		if .SingleLine and (t == bs.x)
			return .MoveListLine(i)

		if !page and Keys.Cmd
			._PreferPrevLine = i < 0
			.MoveSelection(x)
			._PreferPrevLine = i < 0
			return true

		.MoveSelection(bs.x)
		._PreferPrevLine = bs.x2
		return true
	
	
	behaviour Search
		|| inl = .IsInline
		if inl and inl.editingfor
			.InlineAcceptSearch
			return true
		if JustUpdate
			return true
		|| r = .SelRange
		|| range = (R.x2, .text.length)
		if keys.shift
			range = (r.x, 0)
		range = .text.stretchyfind(s, range.x, range.x2)
			
		if range.x < 0
			range = (0, int.max)
			if keys.shift
				range = range.yx
			range = .text.stretchyfind(s, range.x, range.x2)
			require range.x >= 0
		
		.SelDirect(range, nil)
		|| D = .ViewPos(range.x, .MaxVisibleLines/2)
		.Doexplode(D)

		return true
			
	
	behaviour KeyDown
		opt norefcounts
//		if key is cmd // should change cursor.
			
		if self is editable
			if (.OnKeyDown)(self, key)?
				return true
		if .KeyDownTest(key) // to be called by other funcs
			return true
		|| oncl = .onclicked
		if oncl and (self isnt editable) and (key.isaccept or key.IsCmm)
			(oncl)(self)
			return true			
		if (key is RGUI or LGUI) and GUI.CursorVisible
			.ShowExtraInfo(.mousexy)
	

	libinternal KeyDownTest (|keys| key, |bool|)
		if self is editable
			if .IsInline
				if key.IsCancel:		return .CancelEditing
				if key.IsAccept:		return .InlineAcceptKey
				if key iscmd keys.g:	return .InlineAcceptSearch
				if key is tab:			return .FinishEditing(true)
			if key.IsAccept:			return .NewLine
			if .ClickOutsideCloses and key.IsCancel
				return .CancelEditing
			if key is LEFTBRACKET:		return .tabIndent(-1, "\t")
			if key is RIGHTBRACKET:		return .TabIndent(1, "\t")
			if (key is tab) and !keys.option
				return .trytab
			if key iscmd keys.SLASH:	return .CommentSlash(false)
			if key iscmd keys.Num8:		return .CommentSlash(true)
			if key is delete:			return .DeleteKey(keys.shift)
			if key is ForwardDELETE:	return .DeleteKey(!keys.shift)
			if (key iscmd keys.x) or (key is cut)
				return .DoCut
			if (key iscmd keys.z) or (key is undo or again)
				return .DoUndo(!keys.shift)

		if key is left:				return .MoveSel(-1)
		if key is section:			return .SectionKey
		if key is right:			return .MoveSel(1)
		if key is pageup:			return .MoveSelLine(-1, 1)
		if key is pagedown:			return .MoveSelLine( 1, 1)
		if key is up:				return .MoveSelLine(-1, 0)
		if key is down:				return .MoveSelLine( 1, 0)
		if key is home:				return .MoveSelection(0)
		if key is end:				return .MoveSelection(.text.length)

		if (key iscmd keys.c or keys.x) or (key is copy or cut)		// copy
			return .CopyToClipboard
		if (key iscmd keys.a) or (key is select)					// select all
			return .DoSelectAll
	
	
	libinternal DoSelectAll (|bool|)
		.selrange = (0, .text.length)
		return true
	
	
	libinternal SectionKey (|bool|)
		return (.onclicked)(self, -1)?
	
		
	libinternal DoCut (|bool|)
		.CopyToClipboard
		.Insert("")
		return true


	libinternal IndentCount (|int| x, |int|)
		|| l	= .lineexpand((x,x))
		|| r	= l.x
		|| allspace = true
		while
			|| c = self[r++]
			if c == ' '
				rz++
			  elseif c == '\t'
				rz = rz &~ 3
				rz += 4
				allspace = false
			  else
				exit
		if allspace
			rz = -rz


	libinternal ImproveIndent (|int| Curr, |int| extra, |string|)
		|| c = curr
		if c < 0
			c = -c
		c = c &~ 3
		c += extra
		if (curr < 0) and (c > 0) 
			return " " * c
		return "\t" * (c/4)


	libinternal NewLineSub (|int|extra, |bool|)
		|| sr = .selrange
		|| ind = 0
		|| i = 0
		if !.SingleLine and !keys.shift
			|| b4 = self[sr.x - 1]
			if !b4.IsTextLine
				ind = .IndentCount(sr.x2)
				if !sr.width
					while (|| c = self[sr.x+i])
						if c == ' ' or '\t'
							i++
						  else
							.selrange = sr.x+i
							exit
		
		.UndoChecker = -1
		.Typed("\n" + .improveindent(ind, extra))
		if i
			.selrange = .selrange.x-i
		.UndoChecker = -1 // needed
		return true
	
	
	libinternal SwapChars (|bool|)
		|| i  = .selrange
		|| i0 = i.x1
		|| i2 = i
		if i.width
			return true
		|| t = .text
		i2 = (t.MoveCodePoint(i0, -2), t.MoveCodePoint(i0,  -1))
		
		|| s1 = self[ i2 ]
		|| s2 = self[ i2.x2,  i0 ]
		.InsertText(s2+s1, (i2.x, i0)) 
			
		return true
	
	
	libinternal NewLine (|bool|)
		if .SingleLine
			return true // eat it
		|| extra = 0
		if ((.onkeydown)(self, -10)?) and !keys.shift
			.selrange = .ExtendToLineEnd(.sel1-1) // move sel to end of line
			extra = 4
		.NewLineSub(Extra)
		return true
	
	
	function Log (|string| s, |int| Max=256K)
		require s and max >= 1
		|| NewLength = .text.Length + s.Length
		|| Lost = NewLength - Max
		if Lost <= 0
			.text = .text + s
			return
		
		|| NewLog = ._LogTrimmed + Lost
		if s >= max
			.text = s.right(max)
		  else
			.text = .text.right(max - s.length) + s
		._LogTrimmed = NewLog

//		|| L = 0
		// use d.FindWhereLineBreaks(.text,  CharW,  .singleline,  p) isntead
//		for line.lines in s
//			._AddLine(line, L++)
	
	
//	libinternal _AddLine (|string| s, |int| i)
//		|| last = ._lines.Last!
//		if !last.EndsWithLine
//			last.Text += s
//			return 
//		(last isnt last)
//		|| d = TextViewLine(last.after)
//		d.vline = last.vline + 1
//		d.tline = last.tline + 1
//		last.next = d
			
		

	syntax access (|int| i, |string| s, |bool|)
		cpp_Part Match
		return .text[i, s]
	
		
	libinternal DeComment (|bool|)
		require !.singleline
		|| r = .selrange
		|| s = ""
		if self[r.x, "/*"]  and  self[r.x2-2, "*/"]
			s = self[r + (2,-2)]
		  elseif self[r.x-2, "/*"]  and  self[r.x2, "*/"]
			s = self[r]
			r = r + (-2, 2)
		  else
			return false
		.InsertText(s, r, true)
		return true


	libinternal string.IsSlashComment (|bool|)
		for s.lines in self
			|| i = s.OutWhite
				require s[i, "//"]
		return true
		

	libinternal string.DeslashComment (|string|)
		|| i = .OutWhite
			if self[i, "//"]
				return .insert("", i, 2)
		return self
		
	
	libinternal DeslashComment (|bool|)
		|| r = .CommentableRange
		|| t = self[r]
		require t.IsSlashComment
		|| fs = FastString()
		for (s.lines in t) (p)
			fs <~ s.DeSlashComment
			if p
				fs <~ t[p] // match line-ending
		.TypingPlaceReal = r
		.InsertText(fs, r, true)
		return true		
		
	
	libinternal CommentSlash (|bool| star, |bool|)
		require !.SingleLine
		ifn keys.shift or star
			if !.DeSlashcomment
				.tabindent(1, "//")
		  elseif !.decomment
			|| s = .SelText
			s ?= "\n\n"
			.Insert("/*" + s + "*/", true)
		return true
	
	
	function CanAutoComplete (|int|)
		opt inline
		return ._CanAutoComplete

	function AutoCompleteString (|string|)
		opt inline, visible
		return ._AutoCompleteString
	
	
	function AutoCompleteBack (|int|)
		opt inline, visible
		return ._AutoCompleteBack


	function CanAutoComplete (assigns:|byte|)
		if ._CanAutoComplete != value
			._CanAutoComplete = value
			.touch

	function AutoCompleteString (assigns:|string|)
		if ._AutoCompleteString != value
			._AutoCompleteString = value
			.touch

	function AutoCompleteBack (assigns:|int|)
		if ._AutoCompleteBack != value
			._AutoCompleteBack = value
			.touch

	function InsertAutoComplete (|bool|)
		require ._CanAutoComplete == 1
		|| c2 = ._AutoCompleteString			#require
		|| trim = c2.InsertTrim
		|| ins = .sel0
		|| old = self[ins - ._autocompleteback, ins]
		if old != c2
			c2 = c2.DeleteTwoBytes(trim)
			|| r = .selrange - (._autocompleteback, 0)
			if (c2 endswith "()") and self[r.x2] == '('
				c2 = c2[0, c2.length-2]
			.undochecker = -1
			.InsertText(c2, r, false)
			.selrange += (trim - c2.length)
			rz = true


	libinternal TypeTab (|bool|)
// not sure why I did this?
//		|| sr = .SelRange
//		if !sr.width and .IsJeeboxMode
//			if .TabIndent(1, "\t", true)
//				return true
		return .typed("\t")


	libinternal CanTypeTab (|bool|)
		return !(.SingleLine & 1)
	
	
	libinternal TryTab (|bool|)
		require .CanTypeTab
		|| sh = keys.shift
		ifn .seltext.find(charprop.Line)
			if .InsertAutoComplete
				return true
			if (.onkeydown)(self, -9)?
				return true
			if !sh or .isinline
				return .TypeTab
		return .TabIndent(-sh.dir, "\t")

		
	syntax access (|int| p, |byte|)
		cpp_Part Byte
		return .text[p]
	syntax access (|ivec2| p, |string|)
		cpp_Part RangeVec
		return .text[p]
	syntax access (|int| a, |int|b, |string|)
		cpp_Part Range
		return .text[a, b]


	libinternal LineExpand (|IntRange| s, |bool| canback=false, |intrange|)
		// this thing seems borked.
		opt norefcounts
		s = .clamp(s)
		if canback
			|| back = s.x2-1 
			if self[back].istextline
				s.x2 = back
		
		if self[s.x].istextline and self[s.x-1].istextline and !s.width
			return s
		|| A = .FindLineSeperator(s.x, 0 )
		|ind| b = s.x2
		b += self[b-1].istextline
			
		B = .FindLineSeperator(b) ?? .text.length
		return (A+1, b) // don't include the line.

	
	function ShowNextParseError
		opt norefcounts
		|| start = .selectedline
		|| d = start.Loop
		while d != start
			|| err = d.LineError
				.ErrorAt(err)
				return 
			d = d.loop
	
	
	function FillErrors (|ErrorReceiver| err)
		for e in err
			.ErrorAt(e)
	
	
	function JumpToError (|int| pos)
		.MoveSelection(pos, .MaxVisibleLines/2)
	
	
	function ErrorAt (|error| err)
		opt norefcounts
		if err
			.JumpToError(err.position)
			.AddErrorToLine( err, true )
	

	function ClearErrors
		opt norefcounts
		.MyError = nil
		|| s = .Selectedline
		for d in ._lines
			if d.LineError
				if d == s
					.shownoextra
				d.LineError = nil


	function AddErrorToLine (|error| e, |bool| ForceParse=true, |textviewline|)
		opt norefcounts
		require ForceParse or !.NeedsPrepare
		|| p = .clamp(e.position)
		|| r = .FindDrawInfo(p)

		|| old = .myerror
		if r.TrySetError(e) or !old
			if e.WorseThan(old)
				.MyError = e
			GUI.touch(Self)
			return r
		return nil
		


	function DoExplode (|textviewline| D)
		opt NoRefCounts
		|| w = .window
			.LineAttention(1.0s, gui.framestart, D)


	task LineAttention (taskgui, |TextViewLine| D)
		constructor
			is Animation
		
		run
			require .d in .upon._Lines
			|| LH = .upon.lineheight|float|
			|| Y = .upon.Y(.d)|float| + LH*0.75
			|| H = .upon.lastrect.x1x2.vec2
			|| HM = (H.x+H.x2)/2.0
			|| WH = 1.0/h.width
			|| S = .StartTime
			|| ago = s.ago.float
			|| mush = S|int|
			|| color = (1.0, 1.0, 2.0, 1.0)
			|| err = .d.LineError
				color = (err.Textcolor-0.1)*2.0
			
			while h.x < h.x2
				|| Rect = (h.x, Y, h.x, Y) ± -5.0
				|| vib = (s+(h.x*32191.23)|int|).ago.cycle(1s) - 2.5
				vib += (s+(h.x*3191.23)|int|).ago.cycle(0.27s)
				vib += s.ago.float
				|| middleness = 0.5-((h.x-hm).length)*WH
				rect = rect.up(vib*LH*0.15 + LH*-0.3 + ago*0.3)
				|| str = (1.0-ago*0.7th)*0.5 max -0.01
				color.a = str*middleness*2.5
				GUI.Screen.DrawSoftCircle( Rect, color )
				h.x += 10.0 - (mush.hash&1)|float|*2.3
				mush++


	libinternal message.LastAfter (|int| IgnoreAfter, |ind|)
		opt norefcounts
		nil self
		for a.flat in self
			|| af = a.after
			if af < ignoreafter
				rz = rz max af
	
	
	libinternal textviewline.after_with_msg (|int|)
		opt norefcounts
		|| a = .after
		|| la = .message.LastAfter(a)
			return la.clamp(.position, a)
		return a
	
	
	function MessageAtSel (|message|)
		return .MessageAt(.sel0)
	
	
	function MessageAt (|int| pos, |bool| named=false, |message|)
		opt NoRefCounts
		|| d   = .findDrawInfo(pos)
		require d isnt fakemsg
		|| msg = d.message						#require
		|| after = d.after_with_msg
		if pos > after
			pos = .text.outwhite(pos, after)
			if pos < 0
				return nil
		
		|| found = msg.FindTightest(pos, named)
		if named and !found
			found = msg.FindTightest(pos, false) 
		if found in @rel
			|| p = found.parent
			if found == p.second
				return p
		return found

	
	libinternal CommentableRange	(|intrange|)
		|| sel	= .selrange
		|| r	= sel.width and self[sel.x2 - 1].istextline
		|| r2	= (0, r|int|)
		|| t	= .LineExpand(sel - r2)
		//if t.width > 0
		t.x2 -= self[t.x2].istextline
		t.x2++ // whatever... just for now
		return  t

	
	libinternal PrevIsTabbable (|int| R, |bool|)
		|| s = .SelRange
		require !s.Width
		|| i = s.x
		while R < i
			|| c = self[r]
			require (c == '/') or c.IsWhite
			r++
		return true
		
		
	libinternal TabIndent (|int| dir, |string| mark, |bool| IsTypingLike=false,  |bool|)
		|| t = .CommentableRange
		if Istypinglike and !.PrevIsTabbable(t.x)
			return false
		if (mark != "\t") and .text[t.x, mark]
			dir = -dir
		
		|| old = self[t]
		|| Tabbed = .TabIndentAll(dir, mark, old)
		if old == tabbed
			beep
			return true
		
		|| s = .sel0
		.TypingPlaceReal = t
		.InsertText(Tabbed, t, !IsTypingLike)
		if istypinglike
			.selrange = s + (dir > 0)
		return true
	
	
	libinternal string.FindTabInfo (|ivec3|)
		rz.z = .Length
		for (c in self) (i)
			if c == '\t'
				rz.x = (rz.x+1).alignup(4)
			  elseif c == ' '
				rz.x++
			  elseif (c == '/') and (self[i+1] != '/')
				rz.y++
				rz.x++
			  else
				rz.z = i
				exit
	
	
	libinternal string.GUITabIndent (|int| n, |string| mark, |faststring| fs)
		if mark != "\t"
			if n < 0
				fs <~ self
				return
			fs <~ mark
			fs <~ self
			return

		|| br = .FindTabInfo
		if br.y
			fs <~ '/'
		if br.x&3==1
			br.x = (br.x-1).AlignUp(4)
		br.x += n*4
		br.x = br.x max 0
		fs <~ ('\t', br.x/4)
		fs <~ (' ', br.x&3)
		fs.AppendRange(self, br.z)

	
	libinternal TabIndentAll (|int| dir, |string| mark, |string| txt,  |string|)
		|| fs = faststring()
		|| curr = -1
		while curr < txt
			|| next = txt.find(charprop.Line, curr+1)
			if !next
				next = txt.length
			
			|| l = txt[curr+1, next]
			l.GUITabIndent(Dir, mark, fs)
			curr = next
			|| ch = txt[curr]
				fs <~ ch
			
		return fs
	

	function CancelEditing (|bool|)
		opt norefcounts
		|| i = .isinline
			i.clear
		  else
			.ClearFocus
		return true
	
		
	libinternal IsInline (|&InlineEditor|)
		opt norefcounts
		|| w = .window
			|| t = w.Inline
			if self == T.editor
				return t
	
	
	libinternal FinishEditing (|bool| Focus, |bool|)
		|| it = .isinline
			|| c = it.cell
			|| lv = it.editingfor
			it.FinishAndClear(focus)
			if focus and c and lv isa listview // try next tab
				c = c.tab(!keys.shift, lv)
				if c
					lv.EditCell(c)
					
		return true
	
	
	libinternal InlineAcceptSearch (|bool|)
		opt norefcounts
		|| i = .isinline #debug_require
		i.AcceptSearch(.text, false)
		return true


	libinternal InlineAcceptKey (|bool|)
		opt norefcounts
		|| i = .isinline$
		|| e = i.editingfor
		if e isa listview
			if e._isediting
				.finishediting(e.IsSpreadSheetLike)
				return true
		
		return .InlineAcceptSearch
	
	
	function SelectAll
		.selrange = (0, .text.length)
			

	libinternal init
		.gnormal.edge  = (0.5, 0.5, 0.5, 1.0).px
		.gnormal.Bg    = (0, 0, 0, 0.5).px
		.clear("")
	
	
	libinternal SelMsgValid (|ivec2| sel, |bool|)
		opt norefcounts
		require  sel.width or .SyntacticEndOfLine_(sel.x)

		if .expectsparse
			|| d = .finddrawinfo(sel.x)
			while d and (d.range overlaps sel)
				require d.message or .parsedmessage
				d++
		return true


	function SyntacticEndOfLine_ (|int| p, |ind|) // .endofline
		opt norefcounts
		|| n = .length
		|| s = .text
		while p < n
			|| c = s[p]
			if c.IsTextLine
				return p
			if '/' == c and '/' == s[p+1]
				return p
			require c.IsWhite
			p++

		
	libinternal CounterPartType (|string| s, |bool|)
		require (!.singleline and s.length == 1)
		|| sel  = .SelRange
		|| sel2 = sel.x2
		|| t    = .seltext

		if (!sel.width and s == "=")			//   a |=| b   -->   a |= b
			if  self[sel2] == '|'  and  self[sel2-1] == '|'
				.selrange = (sel2, sel2+1)
			return false

		require t or (.ExpectsParse >= probablyjeebox)
		|| c     = counterparts.find(s)
		|| After = self[sel2]
		if !c
			c = CounterParts2.find(s)
			if c and after.equals(s)
				.selrange = sel2+1
				return true				// sigh could simplify this. cant be bothered
			return false
		
		if (t.length == 1) and counterparts.find(t)  // stop awkward things like: " --> (")
			require (s == "'" or "\"") and (s != t)
		
		// what about ' within a comment. its quite frustrating.
			
		|| Other = CounterParts2[c]
		if other.equals(s) and other==after
			.selrange = sel2+1
			return true

		require .SelMsgValid(sel) // we want to avoid this after comments. how do we know if something is commented?
								  // only after parsing, really. we can backscan. but thats more of a pain. 

		if !sel.width
			require s != "{"
		
		.undochecker = -1
		|| x = .insert(s + t + other.render)
		.selrange = (x+1, x+t.length+1)
		return true


	function SelText (|string|)
		return self[.selrange]
		
	function SelText (assigns:|string|)
		.Insert(value, true)

	
	behaviour TypedString
		// shouldn't it be shift-space? option-space is a real char.
		if (keys.option and input == " ") or input == " "
			return .SwapChars
		
		if input == "\\"
			input = "|"
		  elseif input == "|"
			input = "\\"
		  elseif (input == "§") and !(keys.option or keys.shift)
			return false
		if input.LengthUTF8 == 1
			if (.onkeydown)(self, input.codepoint(false))?
				return true
		return .typed(input)
	

	libinternal Typed (|string| s, |int|)
		debug_require self is editable
		GUI.ShowCursor(false)
		
		if .CounterPartType(s)
			return 2
		.insert(S)
		return 1

	
	function Insert (|string| s, |bool| selnew = false, |int|)
		return .InsertText(s, .selrange, selnew)


	libinternal ValidateNewText (|message|)
		|| msg = .text.Parse
			msg.obj = .path
			if .MyError is parse
				.MyError = nil
		  else
			|| e = StdErr.pop
			if .expectsparse >= currentlyjeebox
				.myerror = e

		|| v = ._Viewing
			v.ShouldntSave = false
			if .ExpectsParse > probablyjeebox
				v.ShouldntSave = !msg
			v.DocParsed = msg
		return msg

	
//	libinternal CanAlterRange (|intrange| r, |bool|)
//		disabled "This would be a massive project"
//		opt norefcounts
//		|| p = .ParsedMessage
//		|| s1 = p.findtightest(r.x1)
//		|| s2 = p.findtightest(r.x2)
//		return s1 is editable and s2 is editable
//		// good for now!

	
	function InsertText (|string| s, |intrange| p, |bool| SelectText=false, |bool| Show = true, |int|)
		p = .clamp(p)
		|| Same = (p.width == s.length) and self[p.x, s] 
		|| i	= (p.x + s.length, p.x2)(!Same)
//		if show
//			.show(i)
		
		if !same
			i = p.x + s.length
		|| UpdatedSel = (i,i)
		if (SelectText)
			UpdatedSel.x = p.x
				
		if Same
			.TypingPlaceTry(UpdatedSel, true, nil)
		  else
			|| t = .text
			|| nt = t.insert(s, p.x, p.width)
			|| u = .undoer
				|| c = u.current
					c.typingplace = p
			if ._CanAutoComplete <= 1
				.CanAutoComplete = 0
				.AutoCompleteString = ""
			|| x = (p.x, p.x2)(s)
			|| tab = (s in '\t')
				.UndoChecker() = -1
			
			._Reclaim = (p, s.length - p.width)
			.TryCaptureUndo(x, nt, updatedsel)
			|| it = .isinline
				it.UpdateSearch(nt)
		
		if show
			.ShowTypingplace((p.x, i))
		.UndoChecker = i
		return p.x


	libinternal AlphaFade
		opt norefcounts
		require .hasfocus
		|| w = .Window
			w._alphafader = gui.FrameStart
			w._FlashSelf |= 2

	
	function WasEverAltered (|bool|)
		opt norefcounts
		with .document
			return .current != .original
		return self is modified


	function Save (|bool|)
		opt norefcounts
		if .undoer.save(DocumentState.saving)?
			.AlphaFade
			return true


	function Path (|string|)
		|| u = .document
			return u.Location


	function DeleteKey (|bool| fwd, |bool|)
		|| d = (1, -1)(fwd)
		if !.deletekeysub(d)
			beep
		GUI.showcursor(false)
		return true


	function ExtendToLineEnd (|ind| i, |ind|)
		return .LineExpand((i,i)).x2

	
	function Length (|int|)
		return .text.length

	
	function FindLineSeperator (|int|start=0, |int|end=int.max, |ind|)
		return .text.find(charprop.Line, start, End )


	libinternal SelectToLineStart (|intrange|)
		|| r = .SelRange
		|ind| A = .FindLineSeperator(r.x, 0)+1
		|ind| B = r.x2
		if (b > a) and self[b-1].istextline
			b-- 
		if a != r.x
			return (a, b+1)
		|| b2 = .FindLineSeperator(b)
			return (a, b2+1)
		return (a, .length+1) 
	
	
	libinternal DeleteLine (|bool|)
		|| i = .SelectToLineStart
		if i.width <= 1
			return false
		if !keys.option
			i -= (0, 1)
		.InsertText("", i, false)
		return true
		
		
	libinternal DeleteKeySel (|int| d, |intrange|)
		|| r = .selrange
		if r.width
			return r

		|| x = r.x
		if keys.option or keys.platcmd(false)
			r.x2 = .wordmove(x, (1,-1)(keys.shift))
			return r
	
		if  (self[x-1] == '(')  and  (self[x] == ')')
			|| c = .MessageAt(x)
				if c == @prm or @bra or @list
					return (x-1,x+1)
		
		r.x2 = .text.MoveCodePoint(x, d)
		return r.resolve


	libinternal DeleteKeySub (|int| d, |bool|)
		if  keys.platCmd  and  !.singleline
			if .DeleteLine
				return true
			
		|| r = .DeleteKeySel(d)
		if r.width
			.InsertText("", r)
			return true


	libinternal SelectorRect (|int| pos, |ivec4|)
		|| i = .XYOfChar(pos) + (-1,1)	
		|| i2 = (1, .lineheight+1)
		rz = (i, i+i2)
		if !.singleline
			rz.y++


	libinternal DrawSelRange (|image| Where, |intRange| R, |drawstyle| g)
		opt norefcounts
		|| i	= 0
		|| d	= .StartLine
		|| End	= d.movecapped(.maxvisiblelines + 1)
		if end is last
			end = nil
		while d and d != End
			d.DrawSelSub(where, r, self, i++, g)
			if d.after > r.x2
				exit
			d++


	setter Text (|string|)
		cpp_part TextSetReal
		isnt modified
		if .Clear(value)
			.undoer.ClearTo(value)?
	

	function TextLeft (|int|)
		return .lastleft + 2 + ._LineNumWidth*font.width


	libinternal DrawSel (|image| where, |ivec4| c)
		opt norefcounts
		|| r = .SelRange
		if R.width
			if .SingleLine
				c.y--
				c.y2--
				where.ControlClip = c
			|| g = (¥.TextSelection, ¥.TextSelectionUnfocus)(.HasAnyFocus)
			.DrawSelRange(Where, r, g)
		  elseif .ShouldDrawSel
			|| Cp = (1.0, 1.0, 1.0, 0.666).px
			Where.DrawRect(.SelectorRect(r.x), Cp)
	
	
	libinternal ShouldDrawSel (|bool|)
		opt norefcounts
		require GUI.FlashSelector and !.hasinline and .window.islast
		if .hasfocus
			return true
		|| w = .Window
			if self in w.InnerFocus
				return true
	
	
	libinternal HasInline (|bool|)
		opt norefcounts
		|| w = .window
			return w.inline.editingfor == self


	libinternal FoundInfo (|ivec2| m, |int| Pos, |bool|)
		if M contains Pos
			if (m.x2 == Pos) and !._PreferPrevLine
				return false
			return true

	
	function FindDrawInfo (|int| Char, |TextViewLine!|)
		|| vline = 0
		return .FindDrawInfoSub(char, vline)
	

	libinternal FindDrawInfoSub (|int| Char,  |$int| VLine,  |TextViewLine!|)
		.PrepareLinesOfText
		opt norefcounts
		char = .clamp(char)
		|| c = -int.max
		|| s = .StartLine
		|| d = .needfirst
		
		while
			|| n = d.next
			if d == s
				c = 0
			if !n or .FoundInfo(d.Range, char)
				vline = c
				return d
			d = n
			c++
	
	
	libinternal Y (|textviewline| D,  |int|)
		rz = .lasttop - (D.vline - (._Start.vline-1)) * .lineheight|int|

	
	function XYOfChar (|ind| pos, |ivec2|)
		opt norefcounts
		|| VLine = 0
		|| d = .FindDrawInfoSub(pos, VLine)
		if  vline >= 0  and  vline <= .maxvisiblelines
			return .XYOfCharSub(d, vline, pos)


	libinternal XYOfCharSub (|textviewline| D, |ind| vline, |ind| pos, |ivec2|)
		|| y = .lasttop - (vline+1) * .lineheight|int|
		|| x = d.XOfChar(pos) + font.width + .textleft // sigh
		return (x, y) - 2
	

	libinternal FindDrawLineEdge (|intrange| t, |int| i, |bool| CanAvoid=true, |int|)
		|| x2 = t.x2
		if (i > 0) and (keys.shift) and (self[x2].IsTextLine)
			x2++
		
		|| d = .FindDrawInfo(x2)
		|| r = d.range
		x2 = r.x2
		if (i > 0) and (keys.shift) and (d is avoidlastchar) and !d.endswithline
			//
		  elseif (d is AvoidLastChar) and canavoid
			x2 = .text.MoveCodePoint(x2, -1)
		return (r.x, x2)(i < 0) 
 

	libinternal FindDrawSelMove (|intrange| t, |int| i, |bool|page, |ivec2|)
		opt norefcounts		
		debug_require i.abs == 1
		|| pos = t.x2
		if !keys.shift
			t = t.resolve
			pos = (t.x, t.x2)(i < 0)
			if (t.width) and (pos > 0) and (i > 0) and (self[pos-1].IsTextLine)
				pos--
		if page
			i *= (.maxvisiblelines-1)
		|| d = .FindDrawInfo(pos)
		|| x = 0
		if !t.width or keys.shift
			x = d.xOfChar(Pos)
		  else
			x = d.xofchar(t.lower)
		|| movedCount = 0
		d = d.MoveCapped(i, movedCount) 
		if MovedCount
			return .lastlinefix(d, x)
		if i > 0
			return (d.after, 0)
			
	
	behaviour Draw
		opt norefcounts
		super.Draw(Where)
		|| c = where.controlclip
		where.ControlClip = c ± 1
		
		.PrepareLinesOfText
		.DrawPreparedText(where)
		|| Sel = self is Editable or AlwaysScrollable
			.DrawSel(where, c)
		where.ControlClip = c			/// restore!

		require  !._CanSeeAllLines and .DrawScrollStrength
		if .MyError or (._Lines is breakpoint)
			.DrawScrollMarks(where)
		if sel
			.DrawScroll(.slh, where)
	
	
	libinternal DrawScrollMarks (|image| where)
		opt norefcounts
		require .DrawScrollStrength
		for s in ._lines
			|| E = s.LineError
				|| Sev = E.Severity
				|| c = Sev.color(1.0)
				if sev == ErrorSeverity.Hint
					c.a *= 0.6
				.DrawErrorMark(where, s, C)
			  elseif s is BreakPoint
				.DrawErrorMark(where, s, colors.purple)


	libinternal DrawPreparedText (|image| where, |int|)
		|| Remain = .DrawPreparedTextSub(where, false)
		|| Old = ._RemainingHeight
		._RemainingHeight = Remain
		if !._CanSeeAllLines and Remain > Old and Old > 0 // lets try to decrease that remaining height!
			|| NO = old / .LineHeight
			|| NR = Remain / .LineHeight
			|| Diff = NO - NR
			if Diff < 0
				._RemainingHeight += Diff * .LineHeight
				.start = ._Start.MoveCapped(Diff)
// were losing some remain somehow. not sure why. IDK maths?
//				|| OldLoss = Old - (NO * .lineheight)
//				|| NewLoss = Remain - (NR * .lineheight)
//				._RemainingHeight += NewLoss - OldLoss
					
		return .DrawPreparedTextSub(where, true)
			
	
	libinternal DrawPreparedTextSub (|image| where, |bool| Draw, |int|)
		opt norefcounts
		
		|| d		= .StartLine
		|| lc		= .LineNumColor
		|| y		= (.lineheight - font.height) + .LastTop
		|| yEnd		= .LastBottom
		|| Remain	= .LastRect.Height
		|| UseCol	= .UseColorAnyway

		y += .YAdjust-2
		if .SingleLine
			y-=self is Editable
		  else
			yend += font.height-2
		
		._CanSeeLastLine = false
		._CanSeeAllLines = false
		while (y > yEnd)
			y -= .LineHeight
			Remain -= .LineHeight
			if Draw
				.DrawOneLine(where, D, y, usecol, lc)
			d++
			if !d
				._CanSeeLastLine = true
				._CanSeeAllLines = !.StartLine.position
				exit

		return Remain


	function MaxWidthInChars (|int|)
		|| C = (.width - 9) / font.Width
		return c max 16


	function MaxPartialVisibleLines (|int|)
		|| h = .height
		h += .LineHeight-3
		return .height / .lineheight|int|
	
	
	function MaxVisibleLines (|int|)
		return .height / .lineheight|int|
	
	
	libinternal ShowNoExtra
		(.OnShowExtraInfo)(self, (0,0), nil, nil, "", false)?
	

	libinternal ShowExtraInfo (|ivec2| P, |bool| MouseMove=false)
		opt norefcounts
		require .OnShowExtraInfo and .isjeeboxmode

		|ivec2| b
		P += (0,2)				// too easy to slip down to lower line otherwise
		|| d = .ByteAtXY(P, b)

		if keys.cmd
			.ShowExtraInfoAtPos(B.x, "", nil)
		  elseif d and d.LineError
			.ShowErrorInfo(b.x, d.LineError!, mousemove)
		  else
			.CancelDelayedError
			.ShowNoExtra
		

	libinternal ShowErrorInfo (|int| B, |error| err, |bool| Later)
		opt norefcounts
		|| P2 = .XYOfChar(B)
		P2.x = -1
		if !later
			.CancelDelayedError
			(.OnShowExtraInfo!)(self, P2, nil, err, "error", false)
			return
		
		|| dse = ._ErrorDelayer
		if !dse or dse.err != err
			.CancelDelayedError
			._ErrorDelayer = DelayedShowError(self, 0.33s, gui.framestart, err, P2)
				
	
	
	function ShowExtraInfoAtPos (|int| B, |string| reason, |error| err)
		opt NoRefCounts
		|| fp = .OnShowExtraInfo
			|| xy = (0, 0)
			|| M = .MessageAt(B)
				xy = .XYOfChar(M.position)
			(fp)(self, XY, M, err, reason, false)
	
	
	libinternal StartLine (|TextViewLine|)
		return ._Start
	
	
	libinternal StartLine (|TextViewJumpMode| mode=0, assigns:|TextViewLine| d)
		cpp_part StartAtLine
		.StartWithoutScrollDraw(mode) = d
		.TouchScrollBar
	
	
	function StartLine (assigns:|int| v)
		cpp_part StartAtInt
		.StartLine = .needfirst.MoveCapped(V)!
	
	
	function NeedFirst (|textviewline|)
		opt norefcounts
		|| f = ._lines.first
			return f
		rz = TextViewLine()
		._lines <~ rz
	
	
	function TextViewLine.SlowMove (|TextViewLine| start, |int| amount, |...!|)
		if start == self
			return self
		|| diff = start.vline - .vline
		rz = start
		for amount
			|| curr = start.Step(diff<0) #loop
			rz = curr		
	
	
	libinternal StartWithoutScrollDraw (|TextViewJumpMode| mode=0, assigns:|TextViewLine!| d)
		opt norefcounts
		if mode is SlowScroll
			d = d.SlowMove(._Start, 2)

		|| n = 3 - .MaxVisibleLines
		|| L = ._lines.last!
		|| last = L.movecapped(n)!
		
		if d.position > last.position
			d = last
		.Start = d
	
	
	function Start (assigns:|textviewline!| d)
		opt norefcounts
		require ._Start != d
		._Start = d
		|| p = d.Position
			._lines.Position = p
			|| doc = .document
				doc.scrollpos = p
		.ShowExtraInfo(GUI.mousexy, false)
		GUI.touch(self)
			
	
	libinternal Clear (|string| NewText, |bool|)
		rz = super.textset(NewText)
		require rz or !._lines.hasany

		._LogTrimmed = 0
		|| sel = (.text.length, 0)(.SingleLine) 
		.TypingPlaceDirect((sel,sel))
		
		.NoScroll
		.TextAlteredForDraw |= 2	// This might not clear text?
//		._Start = ._lines
		._lines.clear

		|| d = textviewline()
		._lines <~ d
		.ClearReclaim
		d.tline = 1
		d.position = -1
		.start = D


	libinternal NextVline (|TextViewLine| place, |TextViewLine| curr, |int| p, |TextViewLine|)
		opt norefcounts
		
		rz = curr.next
		if !rz
			rz = textviewline(p)
			place.next = rz
		  else
			rz.ClearForPrepare
		rz.vline = place.vline + 1


	libinternal NeedsPrepare (|int|)
		|| CW	= .MaxWidthInChars
		|| ldw	= ._LastDrawWidth
		._LastDrawWidth = CW
		if (!._lines.hasany) or (.TextAlteredForDraw & 2)
			return 2
		if (CW != ldw)
			return 1


	function string.Bounds (|ivec2|)
		|| w = 0
		rz.y = 1
		for c in self
			if c.istextline
				rz.y++
				if rz.x < w
					rz.x = w
//				(rz.x max= w) 
				w = 0
			  elseif c != '\t'
				w++
			  else
				w += w.tabswidth
		if rz.x < w
			rz.x = w


	function TextSize (|string| s, |ivec2|)
		|| mul = (font.width, .lineheight)
		|| bd  = s.bounds
		|| add = (6, 0)
		return bd * mul + add 


	libinternal WillAttemptParse (|int| Expect, |bool|)
		require (expect >= ProbablyJeebox)
		require !.singleline
		|| L = .text.Length
		if Expect == allowJeebox
			return L < 64K
		return L < 4MB	// my largest jb file is 60k! 
// todo: Just segment longer files into "chapters". No one needs 10000KB file word-wrapped.


	function ParsedMessage (|message|)
		opt norefcounts
		|| v = ._viewing
			return v.DocParsed
						

	function Parse (|message|)
		return .Parse(false, .ShouldDisplayJeebox)
	
	
	libinternal Parse (|bool| Changed, |int| expect, |message|)
		cpp_Part ViewParseSub
		if !.WillAttemptParse(expect)
			.MyError = nil // more reliable
			return nil
		
		|| p = .ParsedMessage
		if p and !changed
			return p
		|| sel = .SelRange
		if !sel.width and sel.x > 0
			parser._DotInsertAllow = true

		p = .ValidateNewText
		
		if expect <= textview.AllowJeebox
			.myerror = nil
		return p


//	libinternal ColoriseRoot (|message| p)
//		opt norefcounts
//		for m in p	// do this directly in the actual coloriser!!
//					// uncool to do this here
//			if (m == @tmp) and .coloriseasroot.ValueLower(m.name)
//				m.flags |= textview.NotRoot


	libinternal IsCleared (|bool|)
		opt norefcounts
		|| d = ._lines.first
		return !d or d.position < 0


	libinternal StartPos (|int|)
		opt norefcounts
		if ._start.position < 0
			._start.position = 0
		return ._lines.position


	libinternal AddLogTrim (|TextViewLine| d, |TextViewLine|)
		opt norefcounts
		d.position = 0
		(d isnt last)
		d.tline = 0
		d.vline = 0
		d.Text = "(--Trimmed: ${._LogTrimmed.strsize}--)\n"
		return .NextVline(d, d, 0)


	libinternal PrepareLinesOfText 
		opt norefcounts
		|| Changed    = .NeedsPrepare						#require
		.TextAlteredForDraw = 0
		|| expect	  = .ShouldDisplayJeebox
		|| msg   	  = .Parse(changed >= 2, expect)
		|| ParsedOK   = (msg!=nil) or (.ExpectsParse <= AllowJeebox)
		|| Pos	 	  = .StartPos
		|| StayAtEnd  = .IsALogTextView and ._CanSeeLastLine// and .StartPos > 0
		|| d		  = .NeedFirst
			
		// could be nice to make it the general case anyway?
		// like if new lines are added... we just stay at the end.
		// its useful for typing even. or pasting stuff!
		
		|int| CharW	= ._LastDrawWidth - ._LineNumWidth
		if .SingleLine
			charw = 4KB
	
		|| ARGH = 0 // .ReclaimRestart(d) // disabled for now.
		|| t = d.tline // always 0?
		|| p = 0
		(._Lines isnt breakpoint)
		._LineNumWidth = 0
		if .ShowLineNumbers or Expect >= 3
			._LineNumWidth = .text.TextLineCount.LineNumWidth

		if ._LogTrimmed
			d = .AddLogTrim(d)

		while
			p = d.FindWhereLineBreaks(.text,  CharW,  .singleline!=0,  p)
			t = d.InitDefaults(self, t)
			if expect >= allowJeebox // didn't I use to have it on allowjeebox?
				msg = d.colorise(msg, ParsedOK)
			if d is breakpoint
				(._Lines is breakpoint)
			loop p >= 0
			|| n = d.next
				
			if  true  or  !n  or  n.position < ._reclaim[1]
				d = .NextVline(d, d, p)
			  elseif p < ARGH
				d = .NextVline(d, nil, p)
			  else
				d = d.ReclaimEnd(t, ._reclaim[2])
				exit

		d.RemoveAfter
		._PreferPrevLine = false
		if StayAtEnd
			|| n = 1 - .MaxVisibleLines
			d = d.MoveCapped(n)
		  elseif (changed == 1) or .IsALogTextView
			d = .FindScroll(pos)
		  else
			d = ._Lines.first!
		.StartWithoutScrollDraw(d)
		.ClearReclaim	
	
	
	libinternal textview.ClearReclaim
		._reclaim  = (0, 1GB, 0)
	

	target ReclaimAttempt {
	function ReclaimRestart (|textviewline| d, |int|)
		return int.max // too hard to do right now.
		opt norefcounts

	
	libinternal MapToOld (|int| P, |int|)
		|| add = ._reclaim[2]
		if p < ._reclaim[0]
			return p
		
		|| R1 = ._reclaim[1]
		if p - add > R1
			return p - add
		return R1
	}
		
	
	libinternal TextCopy (GUICopyEvent)
		if .SelRange
			return .SelText
		if self isnt editable
			return .text
	
	
	function ScrollPos (|int|)
		return ._Start.position

	setter ScrollPos (|int|)
		opt norefcounts
		for s in ._Lines
			if s.Position >= Value
				.start = s
				return

	libinternal FindScroll (|int| Value, |textviewline!|)
		opt norefcounts
		for s in ._Lines
			if s.Position >= Value
				return s
		return ._lines.first!
		
		
	libinternal UnloadDoc (|document| old)
		opt norefcounts
		old.ScrollPos = .scrollpos
		old.TypingPlace = .selrange
		|| c = old.current
			c.typingplace = .selrange
		if old <= 1
			old.clear
		.document = nil
		.MyError = nil


	function LoadDocument (|document| D, |bool| Show, |bool|)
		|| old = .document
			require .GroupSaveAll or old.DocClose
			.UnloadDoc(old)
		
		d.SimpleUpdateFromDisk
		if d.Load
			.document = d
			.MyError = nil
			if show
				.SelDirect(d.TypingPlace, nil)
				.scrollpos = d.scrollpos
				// 
				// .ShowAndSelect(s.x, s.width)
			return true
		
		.Clear("")


	libinternal TextPaste (GUIPasteEvent)
		if (self is editable) and (purpose is PasteTextLike)
			if data > 1
				.UndoChecker = -1
			if .ExpectsParse >= textview.AlwaysJeebox
				data = data.SpacesToTabs
				if (data contains ";") and !data.parse
					|| Q = "The text below contains ';'. Would you like to strip it?\n\n" + data.Preview(200)
					if Q.Confirm
						data = data.ReplaceAll(";", "")
			.Insert(data)
			return true


	function ShouldDisplayJeebox (|int|)
		opt norefcounts
		|| d = .Document
			if d.WasJbin
				.ShowLineNumbers = true
		|| t = .text
		if t.HasWord("//lineson")
			.ShowLineNumbers = true
		if t.HasWord("//linesoff")
			.ShowLineNumbers = false
		rz = .ExpectsParse
		if rz
			if rz >= AlwaysJeebox
				return rz
			if t.HasWord("<?jb?>") or t.hasword("//jb")
				rz = CurrentlyJeebox
		if d
			(rz max= d.ExpectJeebox)


	libinternal IsJeeboxMode (|bool|)
		return .ShouldDisplayJeebox >= ProbablyJeebox
	
	
	function GuessExpectsParse
		|| mode = .expectsparse
		require mode > 0 and mode < alwaysjeebox

		mode = AllowJeebox
		|| d = .document
			|| l = d.Location
				|| ext = l.ext
				if ext ~= "spd" or "box" or "jbin" or "xml" or "jb"
					mode = CurrentlyJeebox
				  elseif ext ~!= "todo" and "txt"
					mode = ProbablyJeebox // this seems wrong
		.ExpectsParse = mode

	
	flags
		NotRoot = 0x800
	
	constants
		NotJeebox = 0
		AllowJeebox
		ProbablyJeebox
		CurrentlyJeebox
		AlwaysJeebox
		SingleLine = 1
		SingleLineWithTabs = 2
	
	module
		|| csAntiWords		= ~charprop.NameMid
		|| CounterParts		= <(`{[(`'"|`)>
		|| CounterParts2	= <(`}])`'"|`)>
		
		function Block (|guicontrol| parent, |float| x, |float| w, |float| y, |float| h, |textview|)
			rz = TextView(parent)
			rz.MakeInline
			rz.BlockSize(x,w,y,h)
			if w < 0
				rz.Alignment = MoveCode.Right
		
		task DelayedShowError (TaskGUI, |error| err, |ivec2| Point)
			constructor
				is WaitStillStart
			
			run (TaskGUI)
				// would be better to make OnShowExtraInfo actually a task
				// then we can just refire it... when necessary.
				|| fp = .upon.OnShowExtraInfo
					(fp)(.upon, .Point, nil, .err, "error", true)



libinternal string.InsertTrim (|ivec2|)
	|| i = .find('<')
		|| i2 = .find('>', i)
		return (i, i2-1)
	i = .length
	return (i, i)



libinternal string.DeleteTwoBytes (|ivec2|r, |string|)
	|| fs = faststring(.length-2)
	fs <~ self[0,       r.x]
	fs <~ self[r.x+1,   r.x2+1]
	fs <~ self[r.x2+2,  int.max]
	return fs



function TextView.MakeInline (|string| txt="", |bool| Editable=false, |textview|)
	visible
	(self is editable) = Editable
	(self is Enabled) = Editable
	.text = txt
	.GNormal.Edge <~ (0,0,0,0)
	.Size = (3~right for 89)  by  14~down
		


datatype TextViewJumpMode (int)
	linkage: numeric false
	flags
		|TextViewJumpMode|
		Nothing = 0
		SlowScroll
		WantAGoodView
	syntax is (|TextViewJumpMode| m, |bool|)
		return self|int| & m|int|

