

class ButtonView (GUIControl)
	linkage
		cpp_part Btn
		
	|GUIAction|					Pressing
	|GUIAction|					OnOver
	|guiaction|					OnRightClick
	|date|						StepDuration
	|date|						DelayTill
	|guicontrol|				SubControl
	|listviewrow|				CurrOverItem
	|listviewrow|				Items
	|listviewrow|				ClickedItem
	|int|						ItemWidth
	|int| 						ItemGap
	|byte|						ClickCount
	|bool|						PressingDone
	|bool|						PressMakesLighter
	|bool|						MouseDownDoesClick
	|bool| 						NoDrawClicked
	|ListViewState|				Align

	constructor (|guicontrol| p,  |GUIAction| act,  |GUIAction| pressing=nil,  |GUIListEvent| ret=nil, |guiaction| OnRightClick=nil)
		super.constructor(p)
		.onclicked = act
		.pressing = pressing
		.itemgap = 4
		.OnRightClick = OnRightClick
		.StepDuration = 0.75s
		.align = ListViewState.aligncenter 
		.subcontrol = .InitMenu(ret)

	helper InitMenu (|GUIListEvent| ret,  |menu|)
		require ret
		rz = menu(self, nil, ret)
		if rz
			rz.AttachedToParent = true

	function SubMenu (|menu|)
		opt norefcounts
		|| s = .SubControl
		if s isa menu
			return  s

	function Click
		opt norefcounts
		.click((int.min, int.min))
	
	
	function Click (|ivec2| p, |bool| left=true)
		cpp_part ClickXY
		opt norefcounts

		|| sub = .SubControl
			|| w = .window
			require w and w.innerfocus != sub // we shouldn't get a mouseup if we opened a menu?

		|| Always = (p == (int.min, int.min)) 
		require always or .lastrect contains p

		|| c = (nil, .itemat(p.x))(always)
		.selected = c
		|| prev = (nil, c)(always)

		if left
			(.onclicked|GUIAction|)(self, C, prev)?
		  else
			(.onrightclick|GUIAction|)(self, C, prev)?


	setter Selected (|ListViewRow|)
		opt norefcounts
		for i in .items
			(i is Selected) = (i == value)

	function Selected (|listviewrow|)
		opt norefcounts
		for i in .items
			if i is Selected
				return i


	behaviour MouseMove
		opt norefcounts
		if (state is enter or leave)
			sdlapp.touch
		|| item = .itemat(p.x)
		if .CurrOverItem != item
			.CurrOverItem = item
			sdlapp.touch
			(.onover)(self, state|int|, item)?


	function XOfItem (|listviewrow| row, |ind|)
		opt norefcounts
		require  row
		rz = 0
		|| W = .ItemWidth
		|| r = .items.first
		while row != r
			rz += w + .itemgap
			r++

	function ItemAt (|int| P, |ListViewRow|)
		opt norefcounts
		|| W = .ItemWidth
		|| R = .lastrect.horz
		R.x2 = R.x + W
		for i in .items
			if R contains P
				return i
			R += W + .itemgap

	helper ClearMouse
		.DelayTill = nil
		.ClickedItem = nil
		
	behaviour MouseUp
		opt norefcounts
		.clearmouse
		if .PressingDone
			.PressingDone = false
		  else
			.click(p)

	behaviour RightClick
		opt norefcounts
		.Click(p, !.onrightclick)
		
	helper DoPressing (|listviewrow| D, |bool|)
		.ClearMouse
		return (.Pressing)(self, 0, D)
	
	behaviour MouseDown
		opt norefcounts
		.clickcount = clicks
		|| D = .itemat(P.x)
			if d isnt active and self is decluttered
				d = nil
		
		|| ret = 0
		if .clickeditem and clicks == -1		// drag
			if D and D != .ClickedItem
				.ClickedItem.moveto(D)
				.PressingDone = true
			if !.pressing or .PressingDone
				return 4
			ret = 5 // ?
		
		if keys.option and .pressing
			.DoPressing(D)
			return 5
		
		if !(D or !.items)  or  (.ItemWidth and !D)
			return ret
		
		if .MouseDownDoesClick
			.pressingdone = true
			.click(p)
			return 1

		if D
			.ClickedItem := d
		
		if !.Pressing
			return (4, 1)(D)
		
		|| n = date()
		if !.DelayTill
			.DelayTill = n + 0.7s
		  elseif (D == .clickeditem) and (n >= .DelayTill)
			.DelayTill = n + .StepDuration
			.PressingDone = true
			ifn .DoPressing(D)
				.delaytill = 0
				return 1
		return 5

	
	function ivec4.TextCorner (|drawstyle| g, |string| T, |ListViewState|C, |ivec2|)
		|| MV = (.height - g.height(t))-3
		if C & ListViewState.aligncenter
			|| MH = .width - g.width(t)
			|| vmid = .y+((mv-1)/2) + 2
			return (.x+(mh/2), vmid)
		ifn c & ListViewState.align
			|| vmid = ((mv)/2) + 2
			|| xy = .xy + (0, vmid)
			ifn (C == ListViewState.alignright or ListViewState.aligncenter)
				xy += (5, 0)
			return xy 


	function DrawItem (|image| where, |ivec4| R, |ivec4| grow, |listviewrow| i)
		|| disabled = (i and i is disabled) or (self isnt enabled)
			grow = nil
		|| MouseXInside = R.x1x2 contains sdlapp.mousexy.x
		|| clicked = .MouseIsDown and mouseXinside and !.NoDrawClicked
		|| strength = 1.0
		
		|| WillDrawFocus = clicked and i and .ClickedItem
		if i is Active
			strength += SDLApp.cycle(1s)*0.5
			SDLApp.Touch
		  else
			require self isnt decluttered
		if WillDrawFocus or MouseXInside
			grow += r
		  else
			grow = r
		
		where.ControlClip = grow
		Where.DrawRect(Grow, .GNormal, strength)
		if (i is Selected) or (!i and clicked)
			|| darker = (!i and clicked)
			if .PressMakesLighter
				darker = !darker
			|| w = (colors.black(0.2), colors.white(0.20))(darker)
			where.fillrect(grow, W, W) 
		if WillDrawFocus
			.drawfocusrect(where, grow, 1.0)
		
		if !i and .SubMenu
			i = .SubMenu.ListSource // allow these text to be added.
		|| t = i.ButtonText(.text)
		|| Pn = R.TextCorner(.gnormal,  t,  .align) + (-1, 1)
		|| White = (.align & listviewstate.DrawWhiteSpace)!=0
		pn.x = font.small.DrawText(t,  Where,  Pn, White) + 2
		if .pressing and (MouseXInside) and r.Width > 19
			(pn.x min= r.x2-(font.Width+2))
			font.small.DrawText("\03", where, pn, white)
		if disabled
			|| px = colors.gray(0.55)
			where.fillrect(R, px, px)
		
		
	function ListViewRow.ButtonText (|string| Default, |string|)
		if !self
			return default
		rz = .text
		rz := Default
		if self is Broken
			rz += " \17"
		if self is dead
			rz += " (!)"
		if self is Modified
			rz += "*"
	
	
	behaviour Draw
		opt norefcounts
		|| r = .lastrect
		|| g = .MouseisInside|int| * .ExpandOnMouseOver
		|| grow = (-g,-g, g, g)
		where.ControlClip() += grow
		|| w = .ItemWidth
		if !w
			.drawitem(where, r, grow, nil)
			return 
			
		|| rx1 = r.x
		R.x2 = rx1 + W
		for i in .items
			.drawitem(where, R, grow, i)
			R = R right W + .itemgap
			loop r.x < where.width


	function TrimWidth
		|| n = .items.slowcount max 1
		|| w = n * (.itemwidth + .itemgap) - .itemgap
		.sizer.g(2)	= (w) ~ long


	function OpenMenu (|listviewrow| row=nil, |bool|)
		|| m = .submenu			#require
		expect m.listsource.hasany (beep)
		if .MouseIsDown
			.window.CurrMouseDown = m // right?
		|| x = .XOfItem(row)
		m.stopfilter
		m.ShowCmm(self, 0, x)
		return true
