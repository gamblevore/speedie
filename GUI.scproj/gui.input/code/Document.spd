 

// use the simplegraph instead...
// this way... documents can have multiple viewers...
// and viewers can have multiple documents... 
// for example, a project has a something open.
// i wonder how do we describe the strength of the link, though?


class Document (RingTree)
	linkage
		cpp_part Doc
	contains DocumentState
	|int|					UndoChecker
	|int|					ScrollPos
	|byte|					MaxUndos
	|bool|					WasCompressed
	|bool|					WasJbin
	|bool|					LoadedFromFile
	|DocumentState|			Current
	|DocumentState|			Original
	|message|				DocParsed
	|error|					DocError	
	|string|				Location
	|date|					FileDate
	|date|					ViewDate
	|intrange|				Sel
	|DocumentViewer|		Viewers
	|CachedPath|			Ref // remove too? dict into viewers?
	
	
	constructor (|string| path, |bool| Dummy)
		.ref		= CachedPath(path, document.Cache, self)
		.maxundos	= 60
		.Viewers	= DocumentViewer(nil)
		.Location	= path

	
	destructor
		.Viewers.clear
		.ref.clear
	
	render
		fs <~ .location
		fs <~ "\n"
		super.render(fs)


	function Clear 
		.original = nil
		.current = nil
		.loadedfromfile = false
		super.clear
		
	
	function Name (|string|)
		return .Location.name
	
	function Text (|string|)
		opt norefcounts
		return .Current.text?

	function ExpectCurr (||)
		opt NoRefCounts
		|| o = .original
		|| c = .current
		if c and (c.parent|object| != self|object|)
			debugger //!!??
			c = nil
		if o and (o.parent|object| != self|object|)
			debugger //????
			o = nil
		if (!c)
			c = .first
			.current = c
		return c


	function UpdateState (|string| nt, |ivec2| ns)
		|| c = .current
			if c != .original
				c.text = nt
				c.typingplace = ns
				return
		
		.addstate(nt, ns)
	 

	function AddState (|string| nt, |ivec2| ns, |DocumentState|)
		|| c = .current
			if c.text == nt
				return c
			c.RemoveAfter
		
		|| latest	= documentstate()
		latest.typingplace = ns
		latest.text = nt
		self <~ latest
		
		.current = latest
		.original := latest
		.Trim
		return latest


	function ClearTo (|string| s)
		.clear
		.AddState(s, nil)


	function IsModified (|bool|)
		opt norefcounts
		|| c = .current
		|| o = .original
		require o and c
		return (c != o) and (c.text!=o.text)


	function DocClose (|bool|)
		if !.ismodified
			return true
		|| Answer = AskSaveOrCancel("Save file " + .Location.name + "?") 
		if answer >= 1		// save
			return .save(DocumentState.Closing)
		return answer == 0	// don't


	helper SaveText (|documentstate| l, |string|)
		|| t = l.text
		if .Wasjbin
			t = t.digest
		if .WasCompressed
			t = t.compress
		return t


	function Save (|int| Purpose=0, |bool|)
		// purpose is unused, right now.
		// it was used, originally... and might be again.
		|| l = .Location	#require
		|| c = .current		#require	
		|| f = l.file
		|| t = .savetext(c)
		if !t and !f.visible
			rz = f.delete
		  else
			rz = f.data(t)
		if rz
			.filedate = f.modified
			.original = c
			.UpdateSavedState


	helper CheckModified (|bool|)
		|| f = .Location.file
		require .filedate
		
		if .filedate == f.modified
			return false
		
		if !.ismodified
			return .load(true)

		|| Options	= ["Save", "Reload"]
		|| Answer	= ConfirmIt("The file ${f.name} has been externally modified. Reload or resave?", "", Options) 
		if answer >=  1			// save
			.save(DocumentState.errorchecking)
		if answer ==  0			// reload
			.load(true)
		return true


	function Length (|int|)
		return .current.text.length


	function ShowErrorInViewers
		opt norefcounts
		|| e = .docerror$
		for it in .viewers
			if it isa textview
				it.ErrorAt(e)


	function UpdateViewers (|int| Reason)
		opt norefcounts
		|| a = .current$
		for it in .viewers
			if it isa textview
				it.UseState(a,  self,  a.typingplace, Reason)


	function UpdateSavedState 
		opt norefcounts
		for it in .viewers
			if it isa textview
				(it is modified) = false
				(it.ontextchanged)(it, documentstate.Saving, false)?


	function LoadSub (|bool| ChangedExternal, |bool|)
		|| f		= .Location.file
		|| Lim      = document.AskLimit(f)
		|| Data		= f.readsafely(lim, true)		#require
		
		.viewdate	= date()
		.wascompressed = data.IsCompressed
		if .wascompressed
			data = data.decompress
		.WasJBin = data.Isjbin
		if .wasjbin
			data = data.parse.render
			
		.filedate	= f.modified
		if !ChangedExternal
			.clear
		.AddState(data, nil)
		.Original = .Current
		.LoadedFromFile = true
		return true


	function Load (|bool| ChangedExternal = false, |bool|)
		if !.LoadedFromFile or ChangedExternal
			require .loadsub(ChangedExternal)
		.UpdateViewers(DocumentState.Initialset)
		return true


	function Trim
		opt norefcounts
		|| L = .last$
		|| F = .first
		require L != F
		|| n = .maxundos|int| - 2
		for (n)
			l--
			require L != F
		while
			|| nxt = f.next
			if nxt == l
				exit
			nxt.remove
		if !.current.parent	 // how?? its the last!
			debugger			
			self <~ .current
		if !.original.parent // original sometimes isnt first
			debugat // just wanna see :)
			.first = .original
			f.remove


	module
		|dictionary of cachedpath| Cache = dictionary()
		function New (|string| path, |document|)
			cpp_part NewShared
			if path
				rz = .Cache.DocumentCached(path)
			rz := document(path, true)
		function AskLimit (|file| f, |int|)
			|| n = f.size
			if n <= 128MB or n >= int.max
				return 128MB
			if "The file ${f.name} is ${n|int|.strsize} big. Do you still want to load it?\n\nText-editor performance may suffer.".confirm
				return n+1
			return 128MB



extend TextView
	function KeepUndosOnLoseFocus (|bool|)
		return (self is editable) and !.isinline

	
	function UpdateAllViews (|string| nt, |ivec2| NS, |int| Reason)
		opt norefcounts
		|| u = .document
			u.UpdateViewers(Reason)
		  else
			super.textset(nt)
			(self is modified) = true
			.touch
			.TypingPlaceTry(ns, true, nil)
			(.OnTextChanged)(self, reason, true)?

	helper TryCaptureUndo (|int| x, |string| nt, |ivec2| ns)
		opt NoRefCounts
		|| u = .undoer
			if self is editable
				if x == u.UndoChecker
					u.UpdateState(nt, ns)
				  else
					u.AddState(nt, ns)
		.UpdateAllViews(nt, ns, DocumentState.Typing)				// updates self


	function UndoChecker (assigns:|int| x)
		opt norefcounts
		with .undoer
			.UndoChecker = x


	function DoUndo (|bool| undo, |bool|)
		.undo(undo)
		return true


	function Undo (|bool| undo)
		opt norefcounts
		|| u = .undoer$
		|| m = u.ExpectCurr$
		|| pos = m.TypingPlace.xx
		
		m = m.step(!undo)		#expect beep
		if undo
			pos = m.TypingPlace
		u.current = m
		
		if .text != m.text
			.usestate(m, u, pos, DocumentState.UndoOrRedo)


	function UpdateModState (|document| D, |int| reason)
		|| ismod = d.ismodified
		if (self is modified) != ismod 
			(self is modified) = ismod
			if ismod
				.touch
		(.OnTextChanged)(self, Reason, ismod)?


	function UseState (|DocumentState| L,  |document| D,  |ivec2| ty,   |int| Reason)
		require .parent
		.UndoChecker = -1
		if reason == DocumentState.UndoOrRedo
			.ViewPos(ty.x)
		.Clear(l.text, reason<0)
		.TypingPlaceTry( ty, true, nil)

		.GuessExpectsParse
		|| pos = d.ScrollPos
		if reason != DocumentState.UndoOrRedo and pos >= 2
			.PrepareLinesOfText
			if reason != DocumentState.typing 
				.Goto(pos)
		
		.UpdateModState(d, reason)
	



class DocumentState (RingTree)
	linkage
		cpp_part dcs
	contains DocumentState
	|string|			Text
	|IntRange|			TypingPlace 

	constants
		InitialSet = 0
		Typing = -1
		UndoOrRedo = -2
		Saving = -3
		Closing = -4
		ErrorChecking = -5
		

	setter Text (|string|)
		.text = value
		
	render
		fs <~ '"'
		fs.appendescape(.text.preview(150))
		fs <~ '"'
