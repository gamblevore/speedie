
// we want to slowly leak some data through from one to the other!


// a few graphics effects
class JeeboxEffects
	linkage: cpp_part jfx
	|image| 			Tmp
	|vec4| 				Aura
	|imageblurrer|		Blurry
	|imagepixel[8]|		Cols
	|random|			rnd
	
	
	constructor (|float| blurr)
		.tmp = image()
		.Blurry.create(blurr)
		.aura = (0.0,1.0, 0.0,1.0)
		.cols[0] = (0.1,	0.1,	0.1)
		.cols[1] = (0.2,	0.2,	0.2)
		.cols[2] = (0.8,	0.1,	0.9)
		.cols[3] = (1.0,	0.8,	0.2)
		.cols[4] = (0.1,	0.12,	0.12)
		.cols[5] = (0.15,	0.17,	0.12)
		.cols[6] = (0.4,	0.2,	1.0)
		.cols[7] = (0.15,	0.17,	0.12)


	helper MakeSubBoxes (|image| img, |int| Size, |float| opacity=1.0)
		opt norefcounts
		|int| a = opacity * 255.0
		for r in img.tile(size)
			|| c = .cols[.rnd.int&7]
			c.a = a
			img.fillrect(r, c)


	function MarkSobel (|image| where, |ivec4| a)

	function DoSobel (|image| where)
		

	function MakeBoxes (|image| img, |int| seed)
		|| base = 6
		.rnd.seed(seed)
		
		.MakeSubBoxes(img, base*6,  0.99)
//		.MakeSubBoxes(img, base*12, 0.5)
		.MakeSubBoxes(img, base,    0.35)


	helper image.BlurInto (|image| wr, |&ImageBlurrer| blur, |int|v)
		opt norefcounts
		for (P in wr) (C)
			|| total = vec4()
			for (W in blur) (O)
				|| off = (O, O)
				off[v] = 0
				|| col = (self)(C+off)+(self)(C-off)
				total += col*W
			P <~ total


	setter Aura (|float|)
		.aura = (value, value+0.25).sincos


	function Apply (|fnImageShader| fn, |image| r, |image| w, |float| scale)
		for (px in w) (P)
			|| v4 = (fn)(self, r,  P.vec2+0.5, scale)
			px <~ v4


	function Jeebox (|image| B, |int| seed)
		opt norefcounts
		|| A = .tmp
		if A.size == B.size
			A.copyto(B)
			return 
	
		|| start = date.now
		A.size = B.size
		.MakeBoxes(A, seed)
		for 3
			A.BlurInto(B, .blurry, 1)
			b.BlurInto(A, .blurry, 0)
		
		.apply(sobelmain, A, B, 1.5)
		B.copyto(A)
		Duration += date.now - start
		
	module
		|date| Duration



struct ImageBlurrer
	|float[15]|		Values
	|int|			Count
	
	constructor (|float| Sigma)
		.create(sigma)
	
	function Create (|float| Sigma)
		.count = 0
		|| nn = 15
		|| Lim = 0.0 // Lim may only be 0.6 by the end!!
		// each number is used twice.
		|| W = &.values[0]
		for i in nn
			|| g = i|float|.Gaussian(Sigma)
			if i == 0: g *= 0.5
			W[i] = g
			Lim += g
		
		Lim *= 1.0 - 72th // 0.986, approx 99% brightness
		|| Found = 0.0
		for i in nn
			loop Found < Lim
			Found += W[i]
			.Count++
	
		|| norm = 0.5/found
		for i in nn
			W[i] *= norm


	iterator
		|| c = .count
		|| i = 0
		while (i < c)
			yield .values[i]  (i)
			i++



prototype fnImageShader (|JeeboxEffects| self, |image| Read, |vec2| P, |float| scale, |vec4|)

function image.Sqrt (|vec2| xy, |float| scale, |vec4|)
	return (.interp(xy)*scale).sqrt


helper image.SobelSub (|vec2| XY, |float| scale, |vec2| Move, |vec4|)
    || s1 = .Sqrt(XY - Move * 1.5, scale)
    || s2 = .Sqrt(XY + Move * 1.5, scale)
    || s3 = .Sqrt(XY - Move, scale)
    || s4 = .Sqrt(XY + Move, scale)

    || sx = 4.0 * ((s4 + s3) - (s2 + s1))
    || sy = 4.0 * ((s2 + s4) - (s1 + s3))

    return sx*sx + sy*sy


function SobelMain (fnImageShader)
	|| S1	= read.SobelSub(P, scale, (0.0,1.0))
	|| S2	= read.SobelSub(P, scale, (1.0,0.0))
	|| Sobel= mix(S1, S2, 0.5)
	return (Sobel.rgb, 1.0)


struct ImageTiler
	|ivec4| Bounds
	|ivec2| Tile
	iterator
		|| b = .bounds
		|| curr = (0, b.y, 0, b.y + .tile.y)
		while curr.y < B.y2
			curr.x = b.x
			curr.x2 = b.x + .tile.x
			while curr.x < B.x2
				yield curr
				curr += .tile.x_x_
			curr += .tile._y_y
			

datatype JeeboxEffectsFlags (byte)
	flags
		|JeeboxEffectsFlags|
		None = 0
		Pastels = 1
		Sobel = 2
	syntax is (|JeeboxEffectsFlags| b, |bool|)
		return self == b
		
