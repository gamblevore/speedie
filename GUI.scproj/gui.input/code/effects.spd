
// we want to slowly leak some data through from one to the other!


// a few graphics effects
struct JeeboxEffects
	linkage: cpp_part jfx
	|image| 			Tmp
	|vec4| 				Aura
	|imagepixel[8]|		Cols
	|random|			rnd
	|bool|				Invalidated
	
	
	function Init (|float| blurr)
		.tmp = image()
		.aura = (0.0,1.0, 0.0,1.0)
		.cols[0] = (0.1,	0.1,	0.1)
		.cols[1] = (0.2,	0.2,	0.2)
		.cols[2] = (0.8,	0.1,	0.9)
		.cols[3] = (1.0,	0.8,	0.2)
		.cols[4] = (0.1,	0.12,	0.12)
		.cols[5] = (0.15,	0.17,	0.12)
		.cols[6] = (0.4,	0.2,	1.0)
		.cols[7] = (0.15,	0.17,	0.12)


	helper MakeSubBoxes (|image| img, |int| Size, |float| opacity=1.0)
		opt norefcounts
		|int| a = opacity * 255.0
		for r in img.tile(size)
			|| c = .cols[.rnd.int&7]
			c.a = a
			img.fillrect(r, c)


	function MarkSobel (|image| where, |ivec4| a)
		

	function DoSobel (|image| where)
		

	function MakeBoxes (|image| img, |int| seed)
		|| base = 6
		.rnd.seed(seed)
		
		.MakeSubBoxes(img, base*6,  0.99)
//		.MakeSubBoxes(img, base*12, 0.5)
		.MakeSubBoxes(img, base,    0.35)


	function DebugBoxes (|image| img)
		|imagepixel[4]| col 
		col[0] = (1.0, 1.0, 1.0, 1.0)
		col[1] = (0.0, 0.0, 0.0, 1.0)
		col[2] = (1.0, 0.0, 1.0, 1.0)
		col[3] = (0.0, 1.0, 0.0, 1.0)
		
		for (t in img.tile((img.size+1)/2)) (i)
			img.fillrect(t, col[i])
		

	helper image.boxtest  (|image| wr, |int| extent)
		|| copy = .copyimage
		.boxblursafe(wr, extent)
		copy.boxblur(wr, extent)
		if .diffat(copy)
			.DebugPixels
			copy.DebugPixels
			debugger
		
		
	helper image.BoxBlurSafe (|image| wr, |int| extent, |bool| Tp=false)
		debug_require wr.size == .size

		for i in .height - 1 downto 0
			.BoxBlurRow(wr, extent, false, i)
			wr.BoxBlurRow(self, extent, Tp, i)
	
	
	helper image.BoxBlur (|image| wr, |int| extent, |bool| Tp=false)
		debug_require wr.size == .size

		for i in .height - 1 downto 0
			.BoxBlurRow(wr, extent, false, i)
			wr.BoxBlurRow(self, extent, Tp, i)


	helper image.BoxBlurTp (|image| wr, |int| extent)
		debug_require wr.size == .size.yx

		for i in .height - 1 downto 0
			.BoxBlurRow(wr, extent, true, i)

	helper image.BoxBlurRow (|image| wr, |int| extent, |bool| Rotate, |uint| row)
		row = .height - (row+1)
		require row < .height and .width > extent
		
		|| wd     = .Width
		|| wrp    = wr.Pixels + row*wd
		|| wrend  = wrp + wd
		|| stride = 1
		|| sh     = 16
		if extent|uint| > wd: extent = wd
		|| scale  = (1<<sh) / (2*extent+1)
		|| align  = 1<<(sh-1)

		if rotate
			stride = .height
			wrp    = wr.pixels + row
			wrend  = 1 + wrp + (wd-1) * stride

		|| Begin  = .Pixels + row*wd
		|| add    = Begin 
		|| addend = Begin + wd
		|| Sub    = Begin - extent 
		|| LastAdd= add++.raw
		|| LastSub= LastAdd 
		|| tot    = LastAdd * (extent + 1)
		for extent
			tot += add++.raw
		
		while 
			wrp.raw = (tot * scale + align) >> sh
			wrp += stride, loop wrp < wrend
			
			if add < addend
				lastadd = add.raw
			if sub >= begin
				lastSub = sub.raw
			tot += lastadd - LastSub
			add++
			sub++
	

/*
		20	21	22	23
		10  11  12  13
		00  01  02  03

		03  13  23
		02	12	22
		01  11  21
		00  10  20

		22	03  13  23
		11  21	02	12
		00  10  20  01
*/
		

	setter Aura (|float|)
		.aura = (value, value+0.25).sincos


	function RunOutline  (|image| r, |image| w, |float| scale)
		for (px in w) (P)
			|| v4 = OutlinePixel(self, r,  P.vec2+0.5, scale)
			px <~ v4
	
	
	function StartJeebox (|image| D, |message| conf)
		opt norefcounts
		|| T = .tmp
		if T.size != D.size
			.Invalidated = true
		if !.Invalidated
			T.copyto(D)
			return
		
		|| S = D.size
		require T.resizeto(s)
		.Invalidated = false
		
		|| seed = conf["seed"].int		?? 1
		|| reps = conf["reps"].int		?? 3
		|| LineStr = conf["sobel"].float?? 1.75
		|| start = date.now
	
		.MakeBoxes(D, seed)
		//.DebugBoxes(d)
		
		
		T.size = S.yx
		d.boxblurtp(t, 5)

		D.size = S.yx
		t.boxblur(D, 5)

		D.size = S
		t.boxblurtp(d, 5)
		
		d.size = S
		t.size = S
		d.copyto(t)
		//for i in 3
		//	T.boxblurpass(D, 4)
		
		.RunOutline(d, t, LineStr)
		Duration += date.now - start
		
	module
		|date| Duration



prototype fnImageShader (|&JeeboxEffects| self, |image| Read, |vec2| P, |float| scale, |vec4|)

function image.Sqrt (|vec2| xy, |float| scale, |vec4|)
	return (.interp(xy)*scale).sqrt


helper image.outlineSub (|vec2| XY, |float| scale, |vec2| Move, |vec4|)
    || s1 = .Sqrt(XY - Move * 1.5, scale)
    || s2 = .Sqrt(XY + Move * 1.5, scale)
    || s3 = .Sqrt(XY - Move, scale)
    || s4 = .Sqrt(XY + Move, scale)

    || sx = 4.0 * ((s4 + s3) - (s2 + s1))
    || sy = 4.0 * ((s2 + s4) - (s1 + s3))

    return sx*sx + sy*sy


function OutlinePixel (fnImageShader)
	|| S1 = read.outlineSub(P, scale, (0.0,1.0))
	|| S2 = read.outlineSub(P, scale, (1.0,0.0))
	|| V0 = mix(S1, S2, 0.5)
	return (v0.rgb, 1.0)


struct ImageTiler
	|ivec4| Bounds
	|ivec2| Tile
	iterator
		|| b = .bounds
		|| curr = (0, b.y, 0, b.y + .tile.y)
		
		|| i = (0)
		while curr.y < B.y2
			curr.x = b.x
			curr.x2 = b.x + .tile.x
			while curr.x < B.x2
				yield (curr) (i)
				curr += .tile.x_x_
				i++
			curr += .tile._y_y
			
