// if the picture is the same, I should cache it.
// we want to slowly leak some data through from one to the other!


// a few graphics effects
class JeeboxEffects
	linkage: cpp_part jfx
	|image| 			Orig
	|image| 			Tmp
	|vec4| 				Aura
	|imageblurrer|		Blurry
	|imagepixel[8]|		Cols
	
	
	constructor (|image| Orig, |float| blurr)
		.orig = orig
		.Blurry.create(blurr)
		.cols[0] = (0.1, 0.1, 0.1)
		.cols[1] = (0.2, 0.2, 0.2)
		.cols[2] = (0.8, 0.1, 0.9)
		.cols[3] = (1.0, 0.6, 0.2)
		.cols[4] = (0.1, 0.12, 0.12)
		.cols[5] = (0.15, 0.17, 0.12)
		.cols[6] = (0.4, 0.2, 1.0)
		.cols[7] = (0.15, 0.17, 0.12)


	function MakeBoxes (|image| img, |int| seed)
		opt norefcounts
		|| sm = 24
		
		|random| rnd
		rnd.seed(seed)
		for r in img.tile(sm)
			|| c = .cols[rnd.int&7]
			img.fillrect(r, c)
		
		for r in img.tile(6)
			|| c = .cols[rnd.int&7]
			c.a = 96
			img.fillrect(r, c)
	
	
	function Start
		opt norefcounts
		|| P = .orig.size
		.tmp := image(P, "temp")
		if .tmp.size != P
			.tmp.resizeto(P)
	
	
	helper Blur (|image| rd, |image| wr, |int|v)
		opt norefcounts
		for (P in wr) (C)
			|| total = vec4()
			// not the fastest loop ever invented
			// I suppose we'd have to hard-code the h/v versions
			// cos we can add +1 easily but the vert is harder.
			for (W in .Blurry) (O)
				|| off = (O, O)
				off[v] = 0
				|| col = (rd)(C+off)+(rd)(C-off)
				total += col*W
			P <~ total
		
	
	setter Aura (|float|)
		.aura = (value, value+0.25).sincos

	

	function Apply (|fnImageShader| fn, |image| w, |image| r)
		for (px in w) (P)
			|| v4 = (fn)(self, P.vec2+0.5, r)
			px <~ v4
	
	
	function Jeebox
		opt norefcounts
		.start
		|| A = .tmp
		|| B = .orig

		.MakeBoxes(A, 1)
		for 2
			.Blur(A, B, 1)
			.Blur(B, A, 0)
		//.apply(sobelmain, A, B)



struct ImageBlurrer
	|float[15]|		Values
	|int|			Count
	
	constructor (|float| Sigma)
		.create(sigma)
	
	function Create (|float| Sigma)
		.count = 0
		|| nn = 15
		|| Lim = 0.0 // Lim may only be 0.6 by the end!!
		// each number is used twice.
		|| W = &.values[0]
		for i in nn
			|| g = i|float|.Gaussian(Sigma)
			if i == 0: g *= 0.5
			W[i] = g
			Lim += g
		
		// OK, so lets say lim == 0.6, now what do we do?
		// Count the number of pixels needed
		Lim *= 1.0 - 72th // 0.986, approx 99% brightness
		|| Found = 0.0
		for i in nn
			loop Found < Lim
			Found += W[i]
			.Count++
	
		|| norm = 0.5/found
		for i in nn
			W[i] *= norm


	iterator
		|| c = .count
		|| i = 0
		while (i < c)
			yield .values[i]  (i)
			i++



prototype fnImageShader (|JeeboxEffects| self, |vec2| P, |image| Read, |vec4|)

function image.Sqrt (|vec2| xy, |vec4|)
	return (self)(xy).sqrt


helper image.SobelSub (|vec2| XY, |vec2| Move, |vec4|)
    || s1 = .Sqrt(XY - Move * 1.5)
    || s2 = .Sqrt(XY + Move * 1.5)
    || s3 = .Sqrt(XY - Move)
    || s4 = .Sqrt(XY + Move)

    || sx = 4.0 * ((s4 + s3) - (s2 + s1))
    || sy = 4.0 * ((s2 + s4) - (s1 + s3))

    return sx*sx + sy*sy


function SobelMain (fnImageShader)
    || S1	= read.SobelSub(P, .Aura.xy) // aura circles
    || S2	= read.SobelSub(P, .Aura.yz)
    || Sobel= mix(S1, S2, 0.5)
	return (Sobel.rgb, 1.0)


struct ImageTiler
	|ivec4| Bounds
	|ivec2| Tile
	iterator
		|| b = .bounds
		|| curr = (0, b.y, 0, b.y + .tile.y)
		while curr.y < B.y2
			curr.x = b.x
			curr.x2 = b.x + .tile.x
			while curr.x < B.x2
				yield curr
				curr += .tile.x_x_
			curr += .tile._y_y
			

