

class FileViewer (ListView)
	linkage
		cpp_part FV
    |dictionary|					Excludes
    |dictionary|					NoFind
    |TextView|						QuickOpen
    |ListView|						ListOpen
    |textView|						Editme
    |filerow| 						Extra
    |filerow| 						SearchWithin
    |[string]|						SizeCheckers
    |GUIListEvent|					OnSearchWithin
    
	constructor (|window| p, |GUIListEvent| sel, |GUIListEvent| ret, |textview| editme)
		super.constructor(p, sel, ret)
		.MultiSelection 	= true
		.editme				= editme
		.OnRightClick		= RightClickFileList
		.quickopen			= textview(nil,		nil,		nil)
		.Listopen			= ListView(nil,		nil, 		ClickedOpenList)
		.ondrawrow			= InsideFileViewRowDraw
		.tryeditcell		= FileRowRenamer
		.listsource			= filerow("", "root")
		
		.quickopen.tag = self
		.listopen.tag = self
	
	
	destructor
//		.quickopen.tag = nil
//		.listopen.tag = nil // causes crashes if set here
		.quickopen.disposeall
		.listopen.disposeall


	function Init
		.IsTree	= true
		.NoSeps	= true
		.EnableDrag
		with .quickopen
			is enabled
			is editable
			isnt visible
			.clipmode		= ControlPoint.SlideBackInWindow
			.ID				= "quickopen"
			.size 			= 400~wide by 15~high
			.OnKeyDown		= QuickOpenKey
			.OnTextChanged	= QuickOpenModified
			.takesfocus		= takesfocusflag.On
			.onfocus		= QuickOpenFocus
			.SingleLine		= true
			.gnormal.solid	= (0.0, 0.1, 0.0, 0.90)

		with .listsource|filerow|
			.AsDir = true
			
		with .Listopen
			is enabled
			is unsearchable
			isnt editable
			isnt visible
			.onealwaysselected = true
			.ID				= "listopen"
			.gnormal.solid	= (0.0, 0.1, 0.0, 0.90)
			.takesfocus 	= 0
	
	
	behaviour MouseDown
		rz = super.mousedown(p, clicks)
		if clicks == 1 or 0
			.TryReloadPath
	
	
	behaviour AppForegroundChanged
		.TryReloadPath
	
	
	behaviour keydown
		if key.isdelete
			|| r = .FirstSelected
			if r isa filerow
				r.AskDelete(self)
				return true
		rz = super.keydown(key)
		.TryReloadPath


	function filerow.DirSize (|[string]|sc, |ivec2|)
		opt norefcounts
		require .asdir
		for f in self
			if f isa filerow
				for ext in sc
					if f isa ext
						rz += (f.lastsize|int|, 1)
						exit
				if f.asdir
					rz += f.dirsize(Sc)
		.lastsize = rz[0]
		.lastfilecount = rz[1]
	
	
	function CheckSize
		opt norefcounts
		|| f = .listsource
		if f isa filerow
			f.dirsize(.sizecheckers)
	
	
	function ShowQuickOpen (|bool|)
		opt norefcounts
		|| w = .window
		|| q = .quickopen
		q.text := .editme.seltext.before("\n").trim
		w <~ q
		w <~ .listopen
		if q is visible
			.HideOpenList
			return true
		(q is visible)
		q.SetFocus
		q.SelectAll
		.OpenQuickRelist(q.text)
		return true


	function SavedFileData (|string| path, |string|)
		opt norefcounts
		|| f = self[path]
			return f.savedfiledata

			
	function AddRoot (|file| fol, |bool| IsMainProj = false, |filerow|)
		|| C = 3000
		rz = .AddRootSub(fol, IsMainProj, C)
		self <~ rz


	helper AddRootSub (|file| fol, |bool| IsMainProj, |&int| C, |filerow|)
		|| p = fol.path
		if !fol.isdir
			return FileRow(p, p.name)
		|| F = FileRow(p, p.TrimExtAndPath, .folfile)
		f.InMainProj = IsMainProj
		(f is expanded) = IsMainProj
		f.FillFilesSub(fol, .excludes, .folfile, c)
		return f


	function Conf (|string|)
		opt NoRefCounts
		return .start|filerow|$.location.child(.folfile)
	
	
	function FolFile (|string|)
		return .listsource.name
	
	
	function FolFile (assigns:|string|)
		.listsource.name = value


	function ErrorAt (|error| e)
		with self[e.path]
			.HasError = true

			
	function ClearErrors
		opt norefcounts
		for s in self
			s.haserror = false


	iterator
		|| _curr = .listsource.first|filerow|
		while _curr
			|| N_ = _curr.FlatNext|filerow|
			yield _curr
			_curr = N_
		(self)


	function SaveAll (|int| Purpose, |bool|)
		cpp_part SaveAllArr
		rz = true		
		|| Decision = 0
		|| m = .Modified // what if like 100 are invalid? THEN? ask for all?
		for f in m
			if .CanSave(purpose, f, Decision)
				if !f.Save(purpose)
					rz = false


	helper CanSave (|int| Purpose, |filerow| f, |&int| Decision,   |bool|)
		|| d = f._Document#require
		if !d.DocError
			return true
		.editme.LoadDocument(d)
		d.ShowErrorInViewers
		if Purpose == DocumentState.ErrorChecking
			return false 
		if (purpose == DocumentState.Saving)
			if !*Decision
				|| q = "Save invalid jeebox for document?\n" + f.location
				*decision = q.confirm.dir
			return *Decision > 0
		return true


	function Modified (|[FileRow]|)
		for f in self
			if f.ismodified
				rz <~ f
		if rz.length == 0
			rz = nil


	function AskSaveAll (|bool|)
		|| m = .modified 
		if !m
			return true
		.focuson(m[0])

		|| fs = faststring()
		if m.length == 1
			fs <~ "Save file '"
			fs <~ m[0].readname
			fs <~ "'"
		  else
			fs <~ "Save ${m.length} files in project "
			fs <~ .start.name
		fs <~ "?"
		if m.length > 1
			fs <~ "\n"
			for m0 in m
				fs <~ "\n"
				fs <~ m0.readname
		
		|| answer = AskSaveOrCancel(fs)
		if answer >= 1  // save
			return .saveall(documentstate.saving)
		if answer == -1 // cancel
			return false
		if answer == 0	// don't
			return true


	syntax access (|int| i, |filerow|)
		return .listsource[i]|filerow|


	syntax access (|string| path, |filerow|)
		cpp_part AccessPath
		opt norefcounts
		for f in self
			if f.location ~= path
				return f


	helper string.name (|bool| YeahReally, |string|)
		cpp_part NameMaybe
		if YeahReally
			return .name
		return self


	helper string.PathMatch (|string| path, |int|)
		if path contains ".todo"
		if path[0] == '/'
			require (self ~= path)
			return 10
		if self globs path
			return 8
		if (path[0] == '.' and path[1] != '/') and .endswith(path, true)
			return 1

		if path.length < 2
			return 0
		|| slah = path contains '/'
		if (self, .name)(slah) contains path
			if self.endswith(path) and self[(self-path)-1] == '.'
				return 1 // sigh
			return 2

	
	function FindAPath (|string| path,  |filerow| within=nil, |bool| Copy=false, |filerow|)
		return .FindPaths(path, within, copy)[0]


	function FindPaths (|string| path,  |listviewrow| within=nil, |bool| Copy=false, |[filerow]|)
		opt norefcounts
		require path
		|| NameOnly = path[0, "./"] 
			path = path[2...]

		within := .listsource
		for f.flat in within
			if f isa filerow
				|| it = f.match(path, NameOnly)
					f.rangelength = it
					if Copy
						f = FileRow(f)
					rz <~ f
					if copy and f.Location.file.IsDir
						f.name = f.name.PathDir
		
		if rz
			rz.sort(FileRowScoreSorter)
			|dictionary of filerow| D = dictionary.new
			for f in rz
				f.samenameasprev = false
				|| old = D[f.name]
					old.SameNameAsPrev = true
					f.samenameasprev = true
				d[f.name] = f
		
		for (f in rz) (i)
			if f.SameNameAsPrev
				|| name = f.name + "  --  " + f.location.neatenpath
				f = filerow(f)
				f.name = name
				rz[i] = f
		
		
	function Listviewrow.FileSort
		.sort(&fileviewer.FileRowNameSorter)
	

	helper message.ExtractRecent (|message| into)
		opt norefcounts
		for s in self
			if s|error|.when
				into <~ s
		
	helper CanFind (|filerow| f, |uint| id, |bool|)
		if id
			require f.findid != id
		f.findID = ID
		
		if .SearchWithin
			|| Restrict = .searchwithin.location
			if !f.location[0,Restrict]
				return false
		
		if !.NoFind or !.nofind.valuelower(f.name)
			return true
		
	helper BatchFindSub (|string| str, |message| all, |uint| id)
		opt norefcounts
		for f in self
			if (f isa filerow)
				if .canfind(f, id)
					f.FindAll(str, all)


	function BatchFind (|string| str, |uint| findid=0, |message|)
		|| All = message()
		if !str
			return all
		.BatchFindSub(str, all, findid)
		all.ExtractRecent(rz)			// Split into recent and not recent
		rz.sort(ErrorSearchSorter)		// recent
		all.sort(ErrorSearchSorter)		// not recent
		for s in all
			rz <~ s


	function HideOpenList (|bool|)
		.ListOpen.clear
		.QuickOpen.hide
		.ListOpen.hide
		return true


	function OpenQuickRelist (|string| path)
		.QuickOpen.text = path
		if path < 2
			.listopen.clear
			return
		if path[0, "/"] or path[0, "~/"]
			.OpenQuickRelistDir(path.file)
			return
			
		|| r = .FindPaths(path, nil, true)
		|| l = .listopen
		(l is visible) = r.length > 0
		l.QuickOpenFill(r)
		l.size = the~same by 0~before back (l.desiredheight.clamp(100,200))


	helper ListView.QuickOpenFill (|[filerow]| Items)
		// does not need to copy these! each item is already a copy
		// change later :D
		.clear
		for p in items
			|| m = message(@str, p.name) 
			self <~ m
			m.obj = p

	helper OpenQuickRelistDir (|file| path)
		|| invis = path endswith "/."
		|[filerow]| items
		for ch in path
			if invis or ch.visible
				|| s = path[ch]
				if s.IsDir
					ch += "/"
				items <~ filerow(s, ch)
		items.sort(FileRowScoreSorter)
		.listopen.QuickOpenFill(items)
	
	
	function OpenQuick (|string| s)
		|| LineByte = (0, 0)
		|| Path = s.ExtractPathAndLine(LineByte)				
			|| r = .FindAPath(path) ?? .AddExtra(path)
				.Select(nil) // do we need this?
				.SelectFast(r)
		  else
			.editme.SetFocus
		
		if LineByte.x1
			.editme.ViewLineAndSel(LineByte.x1)
		if LineByte.x2
			.editme.ShowAndSel(LineByte.x2)


	function AddExtra (|string| path, |filerow|)
		|| f = path.file
		require f.mustexist
		|| x = .extra
		if !x
			x = filerow("", "(Extra)", ".")
			.extra = x
			self <~ x
		
		|| C = 3000
		rz = .AddRootSub(path.file, false, C) 
		x <~ rz
		.SelectFast(rz)

	module
		function FileRowRenamer (guilisteditevent)
			|| o = cell.row
			if o isa filerow
				if o.moveto(value)
					return true
			
		function FileRowScoreSorter (SorterComparer)
			opt norefcounts
			|| aa = a|filerow|
			|| bb = b|filerow|
			if bb.rangelength == aa.rangelength
				|| aprj = aa.InMainProj
				|| bprj = bb.InMainProj
				if aprj == bprj
					return FileRowNameSorter(aa, bb)
				return aprj
				
			return aa.rangelength < bb.rangelength


		function ErrorSearchSorter (SorterComparer)
			// spds first.
			|| aa = a|error|
			|| bb = b|error|
			|| an = aa.path.name 
			|| bn = bb.path.name 
			|| ae = an.ext
			|| be = bn.ext
			|| it = isbetter(ae, be, "spd")
				rz = it == 1
			  else
				it = isbetter(ae, be, "box")
				if it
					rz = it == 1
				  else
					rz = (be < ae, an > bn)(be != ae)


		function FileRowNameSorter (SorterComparer)
			opt norefcounts
			|| aa = a|filerow|
			|| bb = b|filerow|
			if (bb.asdir) != (aa.asdir)
				return (bb.asdir)
			return (bb.name ~<= aa.name)

		function QuickOpenModified (GUITextEvent)
			|| fv = .tag|fileviewer|
			require fv.mustbe(fileviewer)
			fv.OpenQuickRelist(.text)

		function QuickOpenKey (guikeyevent)
			|| fv = .tag|fileviewer|
			require fv.mustbe(fileviewer)
			|| l = fv.listopen
			if key.IsAccept
				|| row = l.FirstSelected
					ClickedOpenList(l, row)
				  else
					fv.OpenQuick(.text)				
				rz = true
			  elseif (key is escape)
				rz = fv.HideOpenList
			  elseif key is up or down
				rz = l.KeyDown(key)


		function QuickOpenFocus (guiaction)
			require state == 0
			|| fv = .tag
			if fv.MustBe(FileViewer)
				rz = fv.hideopenlist


		function ClickedOpenList (GuiListevent)
			|| V = .tag|FileViewer|
			|| r = row.obj|filerow|
			require r isa filerow  and  V isa fileviewer

			|| loc = r.location
			if loc.file.isdir
				V.OpenQuickRelist(loc)
				return true
			v.OpenQuick(loc)
			V.HideOpenList
			return true
			

		function InsideFileViewRowDraw (ListViewRowDraw)
			opt norefcounts
			if self isa filerow
				|| z	= parent.lastrect
				|| d	= ._Document
				|| sh	= font.width*2
				|| v	= (6 + .depth(parent)*sh, texty)
				|| mod	= d.ismodified?
				|| ddd	= (Colors.black(0.5), Colors.clear)(mod)
				font.small.drawicon(.Modifier, where, V, ddd)

				if .HasError
					v.x = z.x2-sh
					font.small.drawicon('\17', where, V) // not sure???
				return (sh, 0)


		function isbetter (|string| a, |string| b, |string| ext, |int|)
			if (b == ext) != (a == ext)
				return (a==ext)+1


helper string.PlatformVisible (|bool| AtRoot, |bool|)
	require self[0] != '.'
	if !atroot
		return true
	if platform.osx
		return (.length > 3) and !.islower
	return true


function FileRow.Modifier (|byte|)
	if .DoesntExist
		return '?'
	return icon(.location, "", self is expanded, !.asdir)


extend_module filerow
	helper icon (|string| self, |string| types, |bool| Expanded = false, |bool| NotDir = false, |byte|)
		|| n = .name
		|| ext = n.ext
		if (.last == '/') and !notdir
			if types and types.TypeContains(ext + "/")
				return '\19'
			if expanded
				return '\1A'
			return '\10'
		  elseif (ext == "app" or "scproj" or "uwuz")
			return '\19'
		return '\11'



function fileviewer.FindSearchWithin (|filerow|)
	opt norefcounts
	|| s = .FirstSelected|filerow|
		while (s isa filerow) and !s.AsDir
			s = s.parent|filerow|
		return s
	
	
function RightClickFileList (GUIListEvent)
	opt NoRefCounts
	if self isa fileviewer
		|| m = .newcmm
		|| within = .FindSearchWithin
			m <~ ("Search Within: " + within.name, FileViewerSearchWithin, within)
			m.addsep
		
		|| rem = .FirstSelected|filerow|
			if rem and (.extra contains rem) and rem != .extra
				m <~ ("Remove From Project",	FileViewerRemove)

		m <~ ("Rename File",		FileViewerRenameFile)
		m <~ ("Create File",		FileViewerCreateFile)
		m <~ ("Copy File Path",		FileViewerCopyPath)
		m <~ ("Show In Desktop",	FileViewerCMMShow)
		m.addsep
		m <~ ("Move To Trash",		FileViewerTrash)
	return true


function FileViewerCMMShow (GuiMenuEvent)
	|| row = clicked.row
	if row isa FileRow
		row.location.Reveal


function FileViewerRenameFile (GuiMenuEvent)
	|| row = clicked.row|filerow|
	self|Fileviewer|.rename(row)
	

function FileViewerCreateFile (GuiMenuEvent)
	|| row = clicked.row|filerow|
	if !row.asdir
		row = row.parent
	|| l = row.location
	|| f = l.file.UniqueChild("untitled")
	if f and f.create
		|| created = filerow(f.path, f.name) 
		row <~ created
		row.filesort
		self|Fileviewer|.rename(created)
		self|Fileviewer|.checksize


function FileViewerCopyPath (GuiMenuEvent)
	|GuiMenuEvent| test
	|| row = clicked.row
	if row isa FileRow
		clipboard.text = row.location

//FileListSearchWithin
function FileViewerTrash (GuiMenuEvent)
	|| row = clicked.row
	if  row isa FileRow  and  self isa fileviewer
		row.AskDelete(self)


function FileViewerRemove (GuiMenuEvent)
	|| row = clicked.row
	if row isa FileRow
		row.remove


function FileViewerSearchWithin (GuiMenuEvent)
	opt norefcounts
	|filerow| row
	|| obj = menu.obj
	if obj isa FileRow
		row = obj
	if self isa FileViewer
		if row == .listsource
			row = nil
		if row != .Searchwithin
			.SearchWithin = row|filerow|
			(.OnSearchWithin)(self, row)?
		
	

