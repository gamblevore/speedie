

module SDLApp
	linkage
		cpp_part App
	|SDL_Event|					Event
	|KeyMod|					KeyMod
	|GUIPasteEvent|				AppDocumentOpen
	|[string]|					PendingAlerts
	|array|						DrawDrag = nil
	|image|						DrawSpace
	|&SDL_Window|				ScreenWindow
	|&SDL_Renderer|				Renderer
	|&SDL_Texture|				Raw
	|error|						ToolTip = error()
	|error|						CompileStatus // remove
	|string|					LastSearch
	|ivec2| 					NewSize
	|ivec2| 					CurrMouseXY
	|ivec2| 					AppResizingXY
	|ivec2|						TryResizeLater
	|date|						FrameLength
	|date|						OpenedFirst
	|date|						LastFrameDate
	|date|						LastWindowClose
	|date|						SelSolidUntil
	|date|						FixScreenBug
	|date|						FastToolTipDate
	|uint|						LastMouseDownRepeat
	|uint|						FrameCount
	|uint|						LastFrameSelMove
	|uint|						DrawCount
	|float|						Scale
	|bool|						StartedProperly
	|bool|						AlertsAreSurprising
	|bool|						IsBackground
	|bool|						FlashSelector
	|bool|						WantsQuit
	|bool|						IsQuitting
	|bool|						AControlWasResized
	|bool|						LastWasKeyWindowClose
	|bool|						TextInputEnabled
	|bool|						TextInputEnabledAtStart
	|byte|						TouchCount=4  // draw the first few frames always
											  // helps with startup events! at least on osx
	|byte|						SingleFrameNest
	|byte|						TouchFingersDown
	|byte|						CanDrag
	|byte|						ResizedCounter // for resize bug fix
	
	
	cpp_wrapper SDL_Init				(|uint| c)
	cpp_wrapper SDL_Quit				()

	cpp_wrapper SDL_CreateWindow		(|cstring| title, |int| x, |int| y, |int| w, |int| h, |uint| flags, |&SDL_Window|) 
	cpp_wrapper SDL_SetWindowTitle		(|&SDL_Window| win, |cstring| title) 
	cpp_wrapper SDL_GetWindowTitle		(|&SDL_Window| win, |cstring|) 
	cpp_wrapper SDL_CaptureMouse		(|bool| state, |int|) 
	
	cpp_Wrapper SDL_CreateRenderer		(|&SDL_Window| window, |int| index, |Uint| flags, |&SDL_renderer|)

	cpp_Wrapper SDL_GetRendererOutputSize (|&SDL_Renderer| renderer, |&int| w, |&int| H, |int|)
	cpp_Wrapper SDL_CreateTexture		(|&SDL_Renderer| renderer, |Uint| format, |int| access, |int| w, |int| h, |&SDL_Texture|)
	cpp_Wrapper SDL_GL_GetDrawableSize	(|&SDL_Window| window, |&int| w, |&int| h)
	cpp_wrapper SDL_RenderCopy			(|&SDL_Renderer| renderer,  |&SDL_Texture| texture,  |&SDL_Rect| srcrect, |&SDL_Rect| dstrect)
	cpp_Wrapper SDL_RenderPresent		(|&SDL_Renderer| renderer)
	cpp_Wrapper SDL_GetMouseState		(|&int| x, |&int|y, |mousebutton|) 
	cpp_wrapper SDL_EventState			(|int| event, |int| enable, |byte|)
	cpp_wrapper SDL_SetWindowPosition	(|&SDL_Window| w,  |int| x, |int| y)
	cpp_wrapper SDL_ShowCursor			(|int| show=-1, |int|)
	cpp_wrapper SDL_GetDisplayBounds	(|int| displayIndex, |&SDL_Rect| rect, |int|)
	cpp_wrapper SDL_SetWindowMaximumSize (|&SDL_Window| window, |int| max_w, |int| max_h)
	cpp_wrapper SDL_SetWindowMinimumSize (|&SDL_Window| window, |int| max_w, |int| max_h)
	cpp_Wrapper SDL_MaximizeWindow		(|&SDL_Window| window)
	cpp_wrapper SDL_SetWindowFullscreen	(|&SDL_Window| window, |int| Mode=0x1001, |int|)
	cpp_Wrapper SDL_RestoreWindow		(|&SDL_Window| window)
	cpp_wrapper SDL_GetWindowPosition	(|&SDL_Window| w,  |&int| x, |&int| y)
	cpp_wrapper SDL_GetWindowSize		(|&SDL_Window| w,  |&int| x, |&int| y)
	cpp_wrapper SDL_SetWindowSize		(|&SDL_Window| window, |int| w, |int| h, |int|)
	cpp_WRapper SDL_GetModState			(|keymod|)
	cpp_wrapper SDL_StartTextInput		()
	cpp_wrapper SDL_StopTextInput		()
	cpp_wrapper SDL_ShowSimpleMessageBox		(|int| Flags, |cstring| title, |cstring| msg, |&SDL_Window| window)
	cpp_Wrapper JB_SDL_RemoveWindowBorder (|_voidptr| window)
	cpp_Wrapper JB_SDL_SetModified (|_voidptr| window, |bool| b)
	cpp_wrapper JB_SDL_FullScreen (|_voidptr| w, |bool| On=true)
	cpp_Wrapper SDL_GetCurrentDisplayMode (|int| displayIndex, |&SDL_DisplayMode| mode, |errorint|)

		
	function DocumentOpened  (|bool|Clear=true, |String|)
		cpp_Wrapper JB_App__DocumentOpened
		
	function InitDelegates
		cpp_Wrapper JB_App__InitStuff

	function Screen (|ivec4|)
		cpp_Part GetScreen
		return (.ScreenOrig.vec4 / .scale).ivec4 	

	function NativeWindow (|_voidptr|)
		|SDL_SysWMinfo| data
		.screenwindow.SDL_GetWindowWMInfo(data)
		return data.window|_Voidptr|

	function Alert (|string| msg, |string| title="")
		cpp_part MsgBox
		visible
		SDL_ShowSimpleMessageBox(0, title.cstr, msg.cstr, nil)


	function SelChanged
		.LastFrameSelMove = .FrameCount+32


	function ScreenOrig (|ivec4|)
		|| P = .ScreenPosOrig
		return (p, p + .SizeOrig) 	


	function SizeOrig (|ivec2|)
		|| aaa = (&rz)|&int|
		.SDL_GetWindowSize(.ScreenWindow,  aaa,  aaa+1)


	function SizeOrig (assigns:|ivec2|)
		|| p = .ScreenPosOrig
		|| r = (p, p + value)
		.screenorig(r)


	function Title (|string|)
		return SDL_GetWindowTitle(.screenwindow).render


	function Title (assigns:|string|)
		SDL_SetWindowTitle(.screenwindow, value.cstr)


	function ScreenPosOrig (|ivec2|)
		|| aaa = (&rz)|&int|
		.SDL_GetWindowPosition(.screenwindow,  aaa, aaa+1)

		
	function ShowCursor (|bool| v = true)
		SDL_ShowCursor(v|int|)

	function CursorVisible (|bool|)
		return SDL_ShowCursor()
		
	function Size (assigns:|ivec2| S)
		|| pos	= .ScreenPosOrig
		|| s2	= (s.vec2*.scale).ivec2
		.ScreenOrig((pos, s2)) // shouldn't i be adding pos to s2? 


	function ScreenOrig (assigns:|ivec4| result, |bool|)
		require .ScreenWindow
		if (result.x <= 0) and (result.y <= 0)
			.JB_SDL_FullScreen(.nativewindow) // SDL2 had a bug in it... probably still exists
			return true
		|| Old = .SizeOrig
		|| align = .scale * (1+.IsHighDPI)
		|| wh = result.size-1
		if align > 1
			 wh = wh align align
		.SDL_SetWindowSize(.screenwindow, wh.x, wh.y)
		if .SizeOrig != wh
			.TryResizeLater = wh
		if result.xy
			.SDL_SetWindowPosition(.ScreenWindow, result.x, result.y)

		|| Niew = .SizeOrig
		if old != Niew
			.NewSize = niew
		return true
		
	
	function Touch (|guicontrol| modified=nil)
		.TouchCount := 1

	
	function Resized (|guicontrol| modified=nil)
		.AControlWasResized = true
		.Touch(modified)


	function DropEnable
		SDL_EventState(SDLEventType.DROPFILE, 1)
	
	
	helper IsTyping (|bool|)
		return .event.type is textinput or keydown


	function RunAndQuit (|GUIApplicationInit| fn=nil, |object| Anything=nil,  |ivec2| size=(414, 256))
		target !gui
			disabled `Put "targets gui" in the app's conf section to use this!`
		
		.Init(size)
		(fn)(anything)?
		app.clearcaches
		while .SingleFrame
			.PostLoads
		.quit

	
	helper PostLoads
		opt norefcounts
		|| s = .TryResizeLater
			.TryResizeLater = nil // clear... in case of inf loop
			.SizeOrig = s

		for w in window.all
			if !w.PostLoaded
				w.PostLoaded = true
				w.__PostLoad__


	function MouseXY (|ivec2|)
		|| x = 0
		|| y = 0
		SDL_GetMouseState(&x, &y)
		return (x,y).sdlxy
		
		
	function MouseButtons (|Mousebutton|)
		return SDL_GetMouseState(nil, nil)

	
	constants
		SDL_PIXELFORMAT_ARGB8888 = 372645892
		SDL_PIXELFORMAT_RGBA8888 = 373694468
		SDL_PIXELFORMAT_ABGR8888 = 376840196
		ChosenPixelFormat = SDL_PIXELFORMAT_ABGR8888
		SDL_INIT_TIMER =			0x00000001
		SDL_INIT_AUDIO =			0x00000010
		SDL_INIT_VIDEO =			0x00000020  /** implies SDL_INIT_EVENTS */
		SDL_INIT_JOYSTICK =			0x00000200  /** implies SDL_INIT_EVENTS */
		SDL_INIT_HAPTIC =			0x00001000
		SDL_INIT_GAMECONTROLLER =	0x00002000  /** implies SDL_INIT_JOYSTICK */
		SDL_INIT_EVENTS =			0x00004000
		SDL_INIT_SENSOR =			0x00008000
		SDL_WINDOWPOS_CENTERED =	0x2FFF0000
		SDL_TEXTUREACCESS_STREAMING = 1
		SDL_WINDOW_RESIZABLE =		0x20
		SDL_WINDOW_ALLOW_HIGHDPI =	0x00002000

	helper InitWindow (|ivec2| s, |string|name)
		SDL_Init(SDL_INIT_AUDIO (|) SDL_INIT_VIDEO (|) SDL_INIT_EVENTS (|) SDL_INIT_HAPTIC)

		.screenwindow = SDL_CreateWindow(name.cstr,
			SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, s.x, s.y, SDL_WINDOW_RESIZABLE (|) SDL_WINDOW_ALLOW_HIGHDPI)

		.SDL_SetWindowMaximumSize(.screenwindow, 2K, 2K)
		.SDL_SetWindowMinimumSize(.screenwindow,  400,  200)
		.vsync = true
		.renderer = SDL_CreateRenderer(.screenwindow, -1, 0)

		|| scr = .CurrDisplaySize
		if (s.x >= scr.x) and (s.y >= scr.y)
			.JB_SDL_FullScreen(.nativewindow)


	helper vsync (assigns:|bool|)
		|| v = ("1", "0")(value)
		.SetHint("SDL_RENDER_VSYNC".cstr, v.cstr)
	
	
	helper RemoveBorder
		JB_SDL_RemoveWindowBorder(.NativeWindow)


	function SavePrefs
		if app.prefs
			app.prefs["screen"] = sdlapp.screenorig.list
			app.saveprefs


	function CurrDisplaySize (|ivec2|) // screensize
		// we call the monitor a "display"
		// and our SDL window we call it a "screen"
		// cos we have sub-windows. They can't both be windows
		|sdl_displaymode| mode = nil
		if SDL_GetCurrentDisplayMode(0, mode)
			return (mode.w, mode.h)


	helper IsHighDPI (|bool|)
		|int[2]| SmallPx
		|int[2]| BigPx
		SDL_GetWindowSize(.ScreenWindow,  &BigPx[0],  &BigPx[1] )
		SDL_GL_GetDrawableSize( .screenwindow,  &SmallPx[0],  &SmallPx[1] )
		require SmallPx[0] and BigPx[0]
		return SmallPx[0] > BigPx[0]
		
	function IsFullScreen (|bool|)
		|| scr = .CurrDisplaySize
		return scr.x >= .ScreenOrig.x
		
		
	helper BumpSize
		description "Fixes a MacOSX bug. Not my fault!" 
		.FixScreenBug = 0
		|| was = .IsFullScreen
		.JB_SDL_FullScreen(.nativewindow, false)
		if was
			.JB_SDL_FullScreen(.nativewindow, true)
	
	
	function Scaling (assigns:|float| scale)
		|| bigPx = (.SizeOrig.vec2/scale).ivec2
		.DrawSpace = image(bigPx, 0|&byte|, "read")
		.Raw = SDL_CreateTexture(.renderer, ChosenPixelFormat, SDL_TEXTUREACCESS_STREAMING, bigPx.x, bigPx.y)
		.scale = Scale
		window.all.lastrect = bigPx.rect
		

	function GUICheck
		if app.yes("version")
			printline app.conf("version")
			app.quit
		if app.yes("created")
			printline __now__|date|.render
			app.quit
	
	function NiceAppName (|string|)
		with app.conf("selfname")
			return it
		with app.conf("name")
			return it
		return app.appname
	
	
	helper Init (|ivec2| s) // startup
		require !.framelength
		.FrameLength = 60th*1s
		.openedfirst = date.now
		app.PrefsInit(.openedfirst)
		|| PrevSize = app.prefs["screen"].ivec4
			s = PrevSize.size
		  else
			s = (800, 600)
		s = s min (2K, 2K) max (500, 400)
		
		.GUICheck
		if !font.small
			sdlapp.Alert("Exitting...", "SmallFont not loaded.")
			app.quit
		.FastToolTipDate = 1

		.InitWindow(s, .niceappname)
		.scaling = 2 - (0.5*.ishighdpi)
		
		.CheckQuarantine
		appmenu.InitAppMenu
		.InitDelegates
		if !PrevSize
			.JB_SDL_FullScreen(.nativewindow)		
		.StartedProperly = true
		
	
	helper SetHint (|cstring| name, |cstring| value)
		cpp_wrapper SDL_SetHint
	
	
	helper TrySelectorFlash
		|| Visible = !.IsBackground and (((.FrameCount-.LastFrameSelMove)>>6) mod 2) 
		if .FlashSelector != Visible
			.FlashSelector = Visible
			.Touch


	function ClearAlerts
		|| it = .PendingAlerts
			.PendingAlerts = []
			for s in it
				app.alert(s)


	function DialogIsOpen (|bool|)
		opt norefcounts
		return .FrontDialog


	function FrontDialog (|window|)
		opt norefcounts
		for w.reverse in window.all
			if w.isdialog
				return w


	function StatusInfo (|string|)
		// remove?
		if .ToolTip.Fired
			return .Tooltip.name


	helper FastUpdate (|bool|)
		return !.IsBackground or .DroppingInto
	
	
	helper FrameAndEvents (|sdlactivity|)		
		while !rz
			while .Event.Poll
				rz |= .CheckEvent(.event)
			.Event.type = 0
			if .WantsQuit
				rz |= .TryQuit(SDLActivity.Exiting)
			if .NewSize
				rz |= SDLActivity.activity

			if .TouchCount				
				|| f = (.FrameLength, 0.5s)(.FastUpdate)
				if .LastFramedate.ago >= f
					.TouchCount--
					rz |= SDLActivity.activity
			//while !sdl_event.poll
			//	|| f = (0.005s, 0.25s)(.FastUpdate)
			//	app.sleep( f )

		.FrameCount++
		.LastFramedate = date()
		// how to fix this? // it has 2 problems now.
			// its too slow
			// its very too slow
	
	
	function DroppingInto (|guicontrol|)
		opt norefcounts
		return __modules__.window.front.droppinginto?
	
	
	function UpdateTextFocus (|window| w)
		opt norefcounts
		|| f = w.realfocus // if theres nothing to focus, we can still type into the window!
		|| allow = !f or (f is editable) or (f isa menu) 
		require .TextInputEnabled != allow
		.TextInputEnabled = allow
		if allow
			.sdl_starttextinput
		  else
			.sdl_stoptextinput
		
			
	function PreframeText (|window| W)
		.TextInputEnabledAtStart = .TextInputEnabled		
		if ListView.delayedItTill.fired
			ListView.delayedItTill = 0
			|| lv = w.realfocus
			if lv isa ListView
				lv.TryDelayedEdit

	
	function OpenDocument (|string| path, |object|)
		require path
		|| d = .AppDocumentOpen
			|| f = path.file
			if f.exists
				rz = (d)(nil, nil, f.path, CopyPasteFlags.PasteFile)
	
	
	function HandleOpenFile
		|| d = .DocumentOpened$ // don't alter fixscreenBUG!!
		.opendocument(d)
		if .openedfirst.ago < 3s
			.FixScreenBug = date.now + 1s


	function OrderWindows (|window|)
		opt norefcounts
		|window| w
		for c in window.all
			if c is visible
				if w
					c.position = w.position + 1
				w = c
			  else
				c.position = -1
				window.all.first = c
		return w

		
	function PreFrame (|sdlactivity|)
		if .FixScreenBug.Fired
			.BumpSize
			rz = SDLActivity.activity
		
		while stderr.HasAnything
			notifications <~ stderr.pop
			beep
			rz = SDLActivity.activity

		.HandleOpenFile
		
		|window--| w = .OrderWindows$
		.UpdateTextFocus(W)
		.PreFrameText(w)
		
		|| ed = w.inline
		if ed.needshide
			ed.clear

		if .candrag > 4
			.touch
			w.DoMouseDrag(.MouseXY, true)
			rz = SDLActivity.activity

		.ClearAlerts
	
	
	function MouseDownRepeatOK (|bool|)
		require (.CanDrag >= 3) and (.MouseButtons is left)
		|| gap = .framecount|int64| - .LastMouseDownRepeat|int64|
		if gap > 24
			.LastMouseDownRepeat = .framecount
			return true
		
	
	function DoDrawDrag (|window|w, |image| where)
		|| s = .drawdrag
		require s
		|| d = w.DroppingInto
		require d and d != w.currmousedown
		|| P	= .mousexy
		|| sigh	= P.grow((6,6))
		where.drawcircle(sigh, ¥.DragAndDrop, 0.0)
		sigh	= P.grow((10,10))
		where.drawcircle(sigh, ¥.DragAndDrop, 7.0)
		
		where.controlclip = sigh
		|| t	= s.length.render 
		|| x	= t.length*font.width
		|| h	= font.height
		|| P2	= (x,h)/2
		font.small.drawtext(t, where, P-P2, true)
	

	function PutDialogsInFront
		opt norefcounts        
		|| GoAfter = .firstnondialog
		|| curr = goafter.prev as window
		while curr
			|| p = curr.prev as window
			if curr.isdialog and curr is visible
				goafter.next = curr
				debugger
			curr = p
		
		
	function WinList (|string|)
		disabled
		|| fs = faststring()
		for w.fast in window.all
			fs <~ w.id
			fs <~ "\n"
		return fs


	function FirstNonDialog (|window|)
		opt norefcounts
		for w.reverse in window.all
			if !w.isdialog
				return w


	function DrawWinFrom (|window|)
		opt norefcounts
		for w.reverse in window.all
			if w.isviewable and w.isfullscreen
				return w
		return window.all.first
	

	function StartResize
		opt norefcounts
		require .acontrolwasresized
		.acontrolwasresized = false
		|| BigRect = .DrawSpace.rect
		|| Rect = (0, 0, 0, 0)
		for w in __modules__.window.all
			rect = w.reflowdoc(bigrect, rect, bigrect)
		for w in notifications.Alerts
			w.reflowdoc(bigrect, nil, bigrect)
	
	
	helper DrawSub (|window| w)
		if w.isviewable
			w.__draw__(.DrawSpace)
	
	
	function DrawFrame
		opt norefcounts
		
		|| w1 = .DrawWinFrom$
		.StartFrame(.Raw)
			
// draw windows first...
		while w1
			if !w1.isdialog
				.DrawSub(w1)
			w1 = w1.next as window // dumb check... we'd need a stronger type system... with 3 layers for ringtree

// then dialogs		
		for w2 in window.all
			if w2.isdialog
				.DrawSub(w2)
			
		notifications.Draw

		|| ws = __modules__.window.all
		.DoDrawDrag(ws.first, .DrawSpace)
		.EndFrame(.Raw)


	function UpdateWindowFrames
		opt norefcounts
		.StartResize
		|| nodlg = !.DialogIsOpen
		for w  in  window.all
			w.EveryFrame
			if nodlg
				w.__FrameUpdate__(w.openedmenu!=nil)
		.StartResize
		
		
	function Mod (|int| period, |float|)
		return (.FrameCount mod period)|float| / period|float|

	function Cycle (|date| amount, |float|)
		// FrameLength is 1/60
		return (.mod((amount*60).WholeSeconds).sin + 1) * 0.5

	function ShowWindows
		opt norefcounts
		for w in window.all
			if w is NewlyShown
				sdlapp.Resized(w)
			(w isnt newlyshown)
	
	
	helper SingleFrame (|bool|)
		require .SingleFrameNest <= 2
		.SingleFrameNest++
		.ShowWindows
			
		|| occured = .PreFrame (|) .FrameAndEvents
		ifn Occured is Exiting
			.HandleAppResize
			.UpdateWindowFrames
			.PutDialogsInFront // original
			if occured is activity
				.DrawFrame
			
			.SingleFrameNest--
			return true


	function CheckQuarantine
		if platform.osx and app.isquarantined
			sdlapp.alert("Please drag this app to the /Applications/ folder to stop MacOSX quarantining it.", "Quarantine Warning" )

	helper Rescale (|float| NewScale, |bool|)
		if (NewScale >= 1 and NewScale <= 8)
			.scale = NewScale
			.NewSize = .SizeOrig
		  else
			beep
		return true
	
	
	helper HandleAppResize
		if !.NewSize
			if .ResizedCounter
				.ResizedCounter--
			return
		.ResizedCounter = 4
		
		.raw.dispose
		|| v = (.NewSize.vec2/.Scale).ivec2
		.newsize = nil										// phew
		.DrawSpace.size = v
		.Raw = SDL_CreateTexture(.renderer, ChosenPixelFormat, SDL_TEXTUREACCESS_STREAMING, v.x, v.y)

		window.all.FullScreen = v
		.StartResize


	function StartFrame (|&SDL_Texture| T)
		opt norefcounts
		|| stride = 0
		|| Where = &(.DrawSpace._ptr)
		t.lockThatZerosEventhoughItShouldnt(nil, where|&_voidptr|, &stride)

	
	function EndFrame (|&SDL_Texture| T)
		.Drawcount++
		target release
			|| stride = 0
			|| Img = &.DrawSpace._ptr
			if .ResizedCounter
				t.UnlockThatCopiesEvenThoughItShouldnt // force refresh of confused window
				t.LockThatZerosEventhoughItShouldnt(nil, img|&_voidptr|, &Stride)
		|SDL_Rect| dstrect
		SDL_GL_GetDrawableSize( .screenwindow,  &dstrect.w,  &dstrect.h )
		SDL_RenderCopy(.renderer, T, nil, &dstrect)
		SDL_RenderPresent(.renderer)
		t.UnlockThatCopiesEvenThoughItShouldnt // seems like we are double doing this?


	function Delay (|int| ms)
		cpp_Wrapper SDL_Delay


	function Quit
		.saveprefs // in case we crash during quit
		for w in __modules__.window.all
			w.close(SDLActivity.Exiting)
		.saveprefs
		.sdl_quit

	
	function FileDroppedIntoApp (|window| w, |string| path, |CopyPasteFlags| p)
		|| c = w[.MouseXY] ?? w
		c.DoPaste(path, p)
		w.DroppingInto = nil


	function AllowKeyDown (|&SDL_KeySym| Ev, |bool|)
		opt norefcounts
		if !.TextInputEnabledAtStart or ev.command
			return true
		|| k = ev.sym
		if k is tab or escape
			return true
		if k.iscmm
			return true
		if k.isscan or k.isaccept or k.isdelete
			return true


	function AllowTyping (|bool|)
		opt norefcounts
		return .TextInputEnabledAtStart and !keys.cmd
	
	
	function Window.MenuAt (|ivec2| xy, |bool| Test, |guicontrol|)
		opt norefcounts
		|| F = .openedmenu$
		if (!test) or (f.lastrect.horz contains xy.x)
			return f
	
	
	function Window.ControlOrMenuAt (|ivec2| xy, |bool| Test = true, |guicontrol|)
		opt norefcounts
		return .menuat(xy, test) ?? self[xy]


	function StandardKeys (|keys| key, |bool|)
		|| w	= __modules__.window.front
		|| g	= w.realfocus
			if keys.cmd
				if (key is g)
					if !g.__Search__(sdlapp.lastsearch, false)
						beep
					return true
				if (key is f) and !(keys.shift or keys.option)
					return g.OpenSearch
			  elseif (key is find or AC_SEARCH)
				return g.OpenSearch

		|| gw	= g ?? w
		if keys.cmd
			if (key is PLUS or EQUALS)
				return .Rescale(.scale+0.5)
			  elseif (key is minus)
				return .Rescale(.scale-0.5)
			if (key is f) and keys.option
				.JB_SDL_FullScreen(.nativewindow, false)
				return true
			if (key is l) and keys.shift
				JB_Mem_ClassLeakCounter()
			if (key is c)
				return gw.DoCopy
			if (key is v)
				return gw.DoPaste(clipboard.text)
		  elseif (key is paste)
			return gw.DoPaste(clipboard.text)
		  elseif (key is copy)
			return gw.DoCopy


	function TryQuit (|SDLQuitReason|reason=kTryQuit, |SDLActivity|)
		opt norefcounts
		if (reason is QuitEvent)
			|| w = .LastWindowClose.ago
			if (w and w < 0.1s)
				return 0 // just block it. SDL is sending duplicate events
		  elseif reason is windowclose
			.LastWindowClose = date.now
			if !sdlapp.AskQuit
				return 0
		
		rz = SDLActivity.Exiting
		for w in window.all
			if w.isdialog
				w.cancelreturn
				if w.CanJustCloseForQuit
					w.remove
				  else
					rz = 0
		if !rz
			return 0

		.IsQuitting = true
		for w in window.all
			if !w.close(reason)
				rz = 0
				exit
		.IsQuitting = false
		if !rz
			.WantsQuit = false // sigh.


	function TryCloseFrontWindow (|int|)
		.LastWindowClose = date.now
		if !.DialogIsOpen
			|| w = window.front
			if w and w.close(SDLActivity.activity)
				rz = SDLActivity.activity


	function AppIsBackground (|bool| v, |int|)
		require .IsBackground != v // what? why is tihs happenin 
		.IsBackground = v
		if !.DialogIsOpen
			for w in __modules__.window.all
				w.__AppForegroundChanged__(!v)
		.touch
		return SDLActivity.activity
		

	function CheckEvent (|&SDL_Event| ev, |int|)
		visible
		|| KeyW = .LastWasKeyWindowClose
		.LastWasKeyWindowClose = false
		|| t = ev.type
		 
		if (t is APP_DIDENTERFOREGROUND or APP_DIDENTERBACKGROUND)
			beep.OK = 1
			.keymod = 0
			.AppIsBackground(t is APP_DIDENTERBACKGROUND)
			return SDLActivity.activity
		
		.keymod = .SDL_GetModState
		if  t is APP_TERMINATING
			return .tryquit(sdlquitreason.Terminating)
		
		if (t is QUIT)
			return .tryquit(sdlquitreason.QuitEvent)
		
		if  t is WINDOWEVENT
			|| wev = ev.window
			|| wt = wev.event
			if (wt is CLOSE)
				if keyw
					return .TryCloseFrontWindow
				  else
					return .TryQuit(sdlquitreason.WindowClose)
			if (wt is RESIZED)
				.NewSize = (wev.data1, wev.data2)
				return SDLActivity.activity
			  elseif (wt is FOCUS_GAINED)
				return .appisbackground(false)
			  elseif (wt is FOCUS_LOST)
				return .appisbackground(true)
			return SDLActivity.nothing


		|| w = .FrontDialog ?? __modules__.window.front
		if (!w)
			return SDLActivity.nothing

		if T is dropbegin
			w.DroppingInto = w[.MouseXY] ?? w
			return SDLActivity.activity
		if t is DROPFILE or Droptext
			|| flags = (copypasteflags.pastefile, copypasteflags.pastetext)(t is dropfile)
			.FileDroppedIntoApp(w, ev.drop.filestr, flags)
			return SDLActivity.activity
		if (t is dropcomplete)
			w.DroppingInto = nil
			return SDLActivity.activity
		
		|| b = ev.button
		|| xy = b.xy
		
		if  t is MOUSEDOWN
			beep.OK = 1
			if notifications.Clickedat(xy)
				return SDLActivity.activity
				
			|| InsideWin = w.lastrect.soothe contains xy
			if !InsideWin and (w == .FrontDialog)
				if w.ClickOutsideCloses
					w.CloseDialog
					return SDLActivity.activity
				return SDLActivity.nothing
			.candrag = nil
			if .inResizeCorner(xy)
				return SDLActivity.activity

			|| foc = w.realFocus
			if foc and foc.ClickOutsideCloses and !(foc contains xy)
				w.ClearFocus
				return SDLActivity.activity

			if w.Click(b.button, b.clicks, xy)
				return SDLActivity.activity
			return SDLActivity.nothing


		  elseif  t is MOUSEMOVE
			|| mxy = .mousexy
			if .AppResizingXY
				return .DoAppResize(mxy)
			if .CurrMouseXY != mxy
				.CurrMouseXY = mxy
				.ShowCursor
				if (.CanDrag >= 2) and (.MouseButtons is left)
					w.DoMouseDrag(xy, .CanDrag > 3)
					return SDLActivity.activity
				
				|guicontrol--| OldMM = w.MouseIsOver
				|guicontrol--| r     = w.ControlOrMenuAt(Xy, false)
				w.MouseIsOver = r 
				
				.SetToolTips(r)
				if oldmm and oldmm != r
					oldmm.__MouseMove__(xy, SDL_WindowEventID.leave)
				|| state = SDL_WindowEventID.moved
				if oldmm != r
					state = SDL_WindowEventID.enter
					
				if r and R.__MouseMove__(xy, state)
					return SDLActivity.activity
				if w.CurrMousedown
					.touch
					return SDLActivity.activity


		  elseif  t is MOUSEUP
			SDL_CaptureMouse(false)
			.AppResizingXY = nil
			.LastMouseDownRepeat = nil
			|| dd   = .drawdrag 
			|| di	= w.DroppingInto
				for c in dd
					di.dopaste(c, copypasteflags.pastefile)
			
			|| dow	= w.CurrMouseDown
			|| F	= w.openedmenu
			w.ClearDrops
			if !(di and dd) and (b.button == 3) and (dow != F) and f and (f contains xy)
				f.__rightclick__(xy)
			  elseif dow and (B.button!=3) and !Scroller.JustClicked
				dow.__MouseUp__(xy)
			Scroller.JustClicked = false
			return SDLActivity.activity


		  elseif  t is MOUSEWHEEL
			|| weel = ev.wheel
			w.__mousewheel__(weel.xy, weel.direction)
			return SDLActivity.activity

		  elseif  t is TEXTINPUT
			#!textinput!
			if .AllowTyping and .CanDrag < 2
				|| e = ev.Editing.str
				if w.__typedstring__(e)
					return SDLActivity.activity
			return SDLActivity.nothing

		  elseif  t is KEYDOWN
			#!keydown!
			|| kev = ev.keysym
			|| key = kev.sym

			if key.IsCancelled or .CanDrag >= 2
				return SDLActivity.nothing
			beep.OK = 1
			
			if (key is w) // checking for keys.cmd actually doesnt always work!!
				.LastWasKeyWindowClose = true

			if !w.openedmenu and !.AllowKeyDown(kev)
				return SDLActivity.nothing
			keys.AddKey(key)
			
			ifn (key is escape) and keys.escape.heldkey
				if .StandardKeys(key)
					return SDLActivity.activity
				if w.__keydown__(key)
					return SDLActivity.activity
			
			if (.singleframenest < 2) and keys.escape.HeldKey(0.75s)
				keys.escape.eat
				return  AppMenu.show
			
		  elseif  t is KEYUP
			keys.Removekey(ev.key.key)
			return SDLActivity.activity
		return SDLActivity.nothing
		
	
	helper Window.Click (|int| bn,  |int| clicks,  |ivec2| xy, |bool|)
		target osx
			|| Ctrl = keys.control // only osx needs this
		  else
			|| ctrl = false
		|guicontrol--| clicked 
		if (bn == 3) or (Ctrl and bn == 1) 
			clicked = .ControlOrMenuAt(xy)
			if clicked
				clicked.__rightclick__(xy)
		  else
			if !clicked
				mousebutton.DownAt = date()
			clicked = .DoMouseDown(xy, clicks)
		.currmousedown = clicked
		return clicked


	function FindResizeCorner (|ivec2| p, |ivec2|)
		opt norefcounts
		|| R = window.all.lastrect.x2
		return (r-p.x, p.y)


	function DoAppResize (|ivec2| M, |int|)
		|| P = .FindResizeCorner(M)
		|| D = .AppResizingXY - p
		|| L = window.all.lastrect.size
		|| R = ((0, 0, l + D).vec4*.scale).ivec4
		.ScreenOrig = R
		return SDLActivity.activity
	
	
	function InResizeCorner (|ivec2| P, |bool|)
		p = .FindResizeCorner(p)
		|| m = 30
		if p.x < m  and  p.y < m
			.AppResizingXY = p
			SDL_CaptureMouse(True)
			return true


	function GuiControl.ContainedName (|string|)
		|| fs = FastString()
		fs <~ "Name: "
		while
			fs <~ .ID
			self = self.Parent
			loop self and !(self isa window)
			fs <~ " <~ "
		return fs
	
	
	function SetToolTips (|guicontrol| r)
		opt norefcounts
		|| w = r.window$
		require w.ToolTipControl != r
		w.ToolTipControl = r
		if  r.id  and  keys.Control  and  keys.LALT  and  keys.LGUI
			Notifications <~ r.ContainedName
		
		|| info = ""
		ifn r isa textview  and  r is editable
			info = r.Description
		|| t = .tooltip$
		|| delay = (0.0s, 1.5s)(!sdlapp.FastToolTipDate.fired)
		|| now = date()
		if t.name and t.when.fired
			sdlapp.FastToolTipDate = now + 1s
		t.when = now + delay
		t.name = info


function guicontrol.Description (|string|)
	return .tooltip // :)


//function timelog (|string| s)
//	printline sdlapp.OpenedFirst.ago.render + ": " + s + "\n"
	
	
	
datatype SDLActivity (uint)
	flags
		|SDLActivity|
		Nothing = 0
		Activity
		Exiting
	syntax is (|SDLActivity| act, |bool|)
		return self == act
		
	
datatype SDLQuitReason (uint)
	flags
		|SDLQuitReason|
		TryQuit
		WindowClose
		QuitEvent
		Terminating
	syntax is (|SDLQuitReason| act, |bool|)
		return self == act
