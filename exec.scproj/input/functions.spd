

class SpdFunc
	|uint16|			Length
	|uint16|			Position
	|string|			Name
	|?&ASMblob|			SpeedieFunc

	constructor
		.Position = spdtable.funcs.Length
		.name = "(unused code)"
	
	constructor (|message| code)
		opt norefcounts
		.Position = spdtable.funcs.Length
		.name = (code.name, "")(code.func == @tmp)
		|| F = code.first
			code = F
		if code.func == @tmp
			.Length = 0
			.SpeedieFunc = nil
		  else
			Spdtable.First ?= self // .first = self
			Spdtable.last = self
			
			|| s    = Code.name
			|| n    = s.length>>2
			|| blob = (s.addr-4)|&ASMBlob|
			|| orig_str = CakeRun.FileSrc
			|| orig_addr = orig_str.addr
			|| orig_after = orig_addr + orig_str.Length
	
			check  (blob|&byte| >= orig_addr and blob|&byte| < orig_After)	(Code, "ASM escaped.")
			check !(blob|int64|&3)											(Code, "ASM unaligned.")
			check  (n > 0)													(Code, "ASM missing.")
			check  (n < 64K-1)												(Code, "ASM oversized.")
			
			blob.CallCount = 0
			.length = n
			.SpeedieFunc = blob

	function After	(|&asm|)
		return .start + .Length
		
	function Start	(|&asm|)
		|| mu = .SpeedieFunc
			return &mu.asm[0]
	
	function RelativeStart (|int|)
		|| SPD = .SpeedieFunc
		return SPD - spdtable.first!.SpeedieFunc
	
	function Run (|&ivec4|)
		// we are passing in alength, but we need to be able to use the entier compile!
		/// ARGHJHKLAS
		|| spd = .Start
			Cake.Registers
			return cake.Run(spd)
		error (self, "Can't Run")
		return Dummy
		
	render
		fs <~ "0x"
		fs.AppendHex(.RelativeStart, 6)
		fs <~ ' '
		fs <~ .name

	function DebugSuccess (|int| id)
		SpdTable.LinksOK++
		printline "${spdtable.LinksOK}: ${SpdTable.CurrFunc!.Name} linked to $.name ($id)"
	
	module
		|ivec4| Dummy

