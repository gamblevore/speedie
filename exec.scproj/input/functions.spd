

class function
	|int|				Index
	|int|				Length
	|string|			Name
	|Message?|			Src
	|?&ASMblob|			SpeedieFunc
	|?&nil|				CFunc
	

	constructor (|message| spd)
		opt norefcounts
		.name = spd.name
		.speediefunc = nil
		|| ASM = spd.first
		if asm.IsString
			.LoadCode(asm)
		  else
			asm.Expect(@bin)

	
	constructor (|?&nil| fn, |string| name)
		.name = name
		.CFunc = fn
	
		
	function LoadCode (|message| ASM)
		opt norefcounts
		|| s    = asm.name
		|| blob = s.addr|&ASMBlob|
		|| n    = (s.length/4) - 2
		// we actually aren't allowed to write to string addresses!!
		// right? I mean... internal ones anyhow?
		.length = n
		check (n > 0) ("Missing asm for: " + .name)
		check (!blob.guard and !blob.callcount) ("Corrupted asm for: " + .name)
		blob.guard = bear // bobobear
		blob.callcount = 0
		.speediefunc = blob
	
	
	function Run (|int64|)
		jb_vm.vm.ClearRegisters 
		return jb_vm.Run(.speediefunc!.ASM[0], .length)
	
	
	function LinkCpp
	
		
	function LinkSpd
		// app-funcs are already linked
		// lib-funcs no...
		// I guess we can do it like func-num + SmallOffset?
		// We might want a small offset, say 256 instructions inside.
		// small offsets can't work with cpp lol.

	
	syntax call (|int|):	return .run
	render:					fs <~ .name

	constants
		bear = 0xB0B0BA14

	module
		syntax access (|message| s, |function|)
			if s == @num
				return .int(s)
			return Linker[s]
		
		function int (|message| s, |function|)
			opt norefcounts
			|| i = s.int
			|| i2 = i >> 1
			if i & 1
				|| fn = AppTable[i2]
					return fn
			  else
				|| fn = LibTable[i2]
					return fn
			s.CantFindFunc

	
	
	
module Linker
	|dictionary of function|	AllFuncs = dictionary()		// this is for the entire app...  inbuilt,  and pack combined

	syntax append (|function| fn)
		AllFuncs.ValueLower(fn.name) = fn
		
	syntax access (|message| s, |function|)
		opt norefcounts
		|| fn = .AllFuncs.ValueLower(s.name)
			return fn
		s.cantfindfunc




module LibTable	
	|[function]|				Funcs

	function AddLibFunc (|function| fn, |bool|)
		expect (.Funcs < 16K) ("Too many functions")
		fn.index = .Funcs.length
		.Funcs <~ fn
		linker <~ fn
		return true
	
	
	syntax access (|int| i, |function|)
		return .Funcs[i]


	function LoadLibFuncs (|bool|)
		|&&nil| Internals 
		|| spd = package.LibFuncLayout(&Internals).parse
		rz = .LoadLibSub(spd.first, internals)

	
	function LoadLibSub (|message| spd, |&&nil| Internals, |bool|)
		opt norefcounts
		while spd
			|| fn = *Internals++  #expect  (spd, "Missing cpp function")
				
			require .AddLibFunc( function(fn, spd.name) )
			spd++
					
		return (!*Internals) #check "Extra InternalFunction" 
		


module AppTable 
	|int|			FnLim = 64K // allow configure? its more about corrupted files,
								// Not "we can't handle more"!
	|[function]|	Funcs
	|[function]|	LinkOrder 

	syntax append (|function| fn, |bool|)
		if (.Funcs < FnLim)
			fn.index = .Funcs.length
			.Funcs <~ fn
			return true
		error (package.funcs, "Too many functions")
	
	syntax access (|int| i, |function|)
		return .Funcs[i]
		
	function LinkEmUpâ€¼ (|bool|)
		Description "Checks that stdlib has all needed functions... and gets a reference to them."
		
		.LoadNameTableSub(package.linkage)
		return stderr.ok


	function LoadNameTableSub (|message| func_list)
		opt norefcounts
		for name in func_list
			|| fn = Linker[name]
				AppTable.LinkOrder <~ fn
			  else
				name.cantfindfunc



function message.CantFindFunc
	error (self, "Can't find function: " + .name)


//////////          //////////            //////////
//////////          //////////            //////////
