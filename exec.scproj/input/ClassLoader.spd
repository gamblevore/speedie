

function CakeRun.CountClasses (|message| list)
	opt norefcounts
	|| N = 0
	|| B = 0
	for c.fast in list
		|| PK = c[1]
			N++
			|| PB = pk.Count
			B += PB
			pk.RangeLength = PB
	Classdata.cakeprepare(N, B)
		
	
function CakeRun.LoadClasses (|bool|)
	opt norefcounts
	for cd in ClassData.First_
		.StoreClass(cd)

	.CountClasses(.clss)
	for c.fast in .Clss
		.LoadOneClass(C)
	return StdErr.ok


function Cakerun.Func (|message| V, |uint64|)
	opt norefcounts
	|| Info = V.int(0, 1, 64K)$
	|| Index = Info >> 1
	|| Spd = 1|uint64|<<63
	if Info&FuncIsLib
		return ((spdtable.RawFuncs+Index)|int64|) &~ Spd

	|| Fn = SpdTable.Funcs[Index]					#expect (V, "Virtual out of bounds")
	|| spdfn = fn.SpeedieFunc						#expect (V, "Virtual is missing")
	return spdfn|int64| ||| Spd
	
	
function Cakerun.UnpackClass (|message| s, |message| c, |&?&classdata| where, |message| PK)
	opt norefcounts
	|| sz = c[2].int
	|| Parent = cakerun[c[@thg, 1]]$

	|| Name = s.Name
	Name.Addr[name.Length] = 0 // :]
	|| ClsData = Classdata.CakeNew(name.Addr|cstring|, sz, Parent, PK.rangelength)
	where[0] = ClsData
	cakerun.ClassTable[name] = ClsData

	|| V = ClsData.Virtuals
	for VFn.fast in PK
		V++[] = .Func(Vfn[@num])|&nil|


function Cakerun.LoadOneClass (|message| s)
	opt norefcounts
	|| c = S[@list]!
	|| Num = c[@num]
	|| I = Num.int									#require
	
	|| Where = ((globals.GlobBase!)|&byte| + I)|&?&classdata|
	|| PK = c.next
		PK.Expect(@list)
		return .UnpackClass(s, c, where, pk)
	where[0] = cakerun[s]


function CakeRun.SyntaxAccess (|message| m, |&ClassData|)
	opt norefcounts
	if m
		|| obj = .ClassTable[m.name]
			return (obj.PrivValue)|&Classdata|
		error (m, "Can't find class: " + m.name )


function CakeRun.StoreClass (|ClassData| cd)
	|| name = cd.Name.wrap
	.ClassTable.ValueLower(name) = cd


/*
How to cross-call? Single-table, and branch

* From Cpp using branch. (GOOD! HAPPY WITH THIS)
	* Cpp is easy
	* finds SPD
		* LongJump
		* Run VM
	* wrap SPD in a C-func
		* awkward and not fun

* From SPD using branch (EASY BUT IM NOT HAPPY WITH IT. WHY?)
	* spd is easy
	* cpp is easy
	* SPeedie is not virtual obsessed
		* Just make it work!
		* Speedie is all about direct calls... or function pointers.
		* virtuals are just to get things working. just deal with it!

tmp tetris
	list ...
	list
		unit "Destructor"
			num "64"
		unit "Render"
			num "3455"
*/


function cakerun.Virtuals (|int| n, |$?&&nil| Cpp, |$?&&nil| Spd) 
	cpp_Wrapper JB_Cake__Virtuals

function @ClassData.CakeNew  (|cstring| Name, |int| Size, |?&ClassData| Parent, |int| Virtuals,  |&ClassData|)
	cpp_wrapper JB_Cake__Class

function @ClassData.CakePrepare  (|int| ClassCount, |int| VCount, |bool|)
	cpp_wrapper JB_Cake__Prepare

function ClassData.Virtuals  (|&&nil|)
	cpp_wrapper JB_Cake_Virtuals

	


datatype BaseType (int)
	constants (
		|BaseType|
		Module = 0 // not actually a type
		Nil
		Object
		Struct
		DataType
		FuncProto
	)
	syntax is (|BaseType| d, |bool|)
		return self == d

