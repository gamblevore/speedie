

module SpdTable 
	|int|			LinksOK
	|[SpdFunc]|		Funcs
	|spdfunc--|		CurrFunc
	|SPDFunc--|		First
	|SPDFunc--|		Last
	|&&nil|			LibFuncs = cakerun.LibFuncs
	
	function RunMain (|int|)
		opt norefcounts
		|| init = .funcs[1]!
		|| main = .funcs[2]					#expect ("Missing main")
		expect (init.Run|&int64|[] == 0)	("Init failed")
		return main.Run|&int64|[]


	syntax Append (|message| spd)
		opt norefcounts // the limit is just to detect corrupted files.
		expect (.funcs.Length < 32K)		(spd, "Too many functions. An entire compiler would only need 3K funcs!")
		if spd == @num
			for spd.int
				.Funcs <~ SpdFunc()			// placeholder
		  else
			.Funcs <~ SpdFunc(spd)
	
	
	function LoadFuncs (|message| code)
		opt norefcounts
		.funcs <~ SpdFunc()					// null func
		for spd.fast in code
			self <~ spd
		
		.Funcs.Shrink
		|| CodeLength = .CodeLength
		check  (CodeLength < 1MB)			(code, "Oversized code: " + CodeLength)
		check  (.Funcs >= 3)				(code, "Missing 'main'")
		

	function CodeLength (|int|)
		opt norefcounts
		|| f = spdtable.first
		|| l = spdtable.last
		if f and l
			return l.After - f.Start


	function Link (|&asm|)
		opt norefcounts
		for f in .funcs
			.currFunc = f
			f.Link❗

		|| f = .first$
		|| l = .last!
		cake.load(f.Start!, .codelength)

	function spdfunc.Link❗
		// could be multi-threaded... doesn't allocate / alter ptrs :] // no need for now. 
		|| Base = .start$
		|| after = base + .Length
		while base < after
			|| asm = base[]
			|| Op = asm.op
			if op.IsSPDFunc
				base.PutCandlesOnCake(asm)
			  elseif op.IsGlob and asm.IsLibGlob
				base.LibGlob(asm)
			base += asm.size


function asm.PutCandlesOnCake (|&asm| self, |asm| Old) // SPDLink, LinkFunction, linkall
	opt norefcounts
	|| ID = ((Old << 13) >> 13) - 31
	require ID > 0 // not a register!
	
	|| fn = SpdTable.Funcs[id]
		|| Pos = fn.SpeedieFunc						// Fast-branch for speed.
			|| Jump = self - &Pos.ASM[0]			// 19-bits // later we can upgrade to 21-bit
			if  Jump  ==  (Jump << 13) >> 13
				|| Final = (Jump|uint| << 13) >> 13
				Final |= (Old>>24) << 24
				self[] = Final
//				fn.DebugSuccess(id)
				return
			expect (false) (spdtable.Currfunc, "Executable too large to link: " + fn.name )
		expect (false) (spdtable.Currfunc, "Function was trimmed: " + fn.name )
	error (spdtable.Currfunc, "Bad function ID: "  + id )


function asm.LibGlob (|&asm| self, |asm| Old) // Globlink, DoGlobs
	opt norefcounts
	|| ID = (Old << 15) >> 15
	expect (ID > 0 and ID < globals.LibMax)					(spdtable.Currfunc, "Bad LibGlob ID: " + ID )
	
	ID = globals.LibLink![ID]
	if (old.op == asm.GOBJ)
		old = (Old >> 17) << 17
		old |= ID >> 3
	  else			//GTAB
		old = (Old >> 18) << 18
		old |= ID
	self[] = old

