

struct FuncASMTable
	|&uint|  Data
	|&asm|	 Base
	|uint|   DataLength
	
	function FindRange (|uint| ToFind, |!&uint| x, |!&uint| x2,  |&uint|)
		while x < x2
			|| extra = (x2 - x)|uint| >> 1
			|| x3 = x + extra
			|| fx3 = x3[]
			if fx3 == Tofind
				return x3
			if fx3 > ToFind			// too far.
				x2 = x3				// move back
			  else
				x = x3				// move forward
		return x
	
	
	function Find (|&asm| ASM, |ivec2|)
		|| ToFind = asm - .base
		|| d = .data
		|| found = .findrange(ToFind, d, d + .datalength)

		|| FuncID = found - .data
		|| FuncBase = found[]
		// simple way to find a function ID, and it's base address							
	

/*
	We want a special func-finding-table... 
	
	It will find the start of each function, given a random address within the code-block.
	
	We need a stack-trace in general, even for non-crash errors.
	
	We can store the func-names separate from the code-block. Tightens up the code and compresses better.
	
	In fact, we can store the debug-info separate from the func-name table. So the debug-info can be deleted in one go, if needed.
	
	The table should look like this:
	
	|uint[]| x = {0, 19, 39, 41, 45, 1002, 1004, etc}			// Now we can do a binary search in it.
	
	We also can just overwrite the original-jbin. This allows us to store the "call-count" directly in the decompressed code. We'll need 4-bytes per func, i guess. (What about the guard? Can we just over-write that?)
	
	I think... considering that op-0 is an error... unless we reach 16M calls... it stays an error. So thats quite good. We can just over-write the guard :) I guess the guard can start at 0.
	
	So thats great.
	
	We want to keep each function in jbin, separately. This allows modability. Very important!!! Can just copy/paste new code in! wonderful!
	
	I think... ideally... we should store the strings as int-positions, not even c-strings. Generate StringObjs on request.
	
	If you look at all the overhead per-string, its a lot.
	
	avoiding 2 bytes barely cuts it. At 13-bytes average per func-name. then 8-bytes per array-position, and 24-bytes per string-shared. So 45-bytes overhead.	

	Saving that 45-bytes seems better than 2.	

	So... to do that, we need to load func-names separately than function-code. And on-demand. And just get one name at a time, not all. I guess just like backtrace works. (Perhaps reserve some space for it?)
	
	...
	
	So perhaps compressing the files in chunks could help? Not sure. How would you tell perry to resave it.
	
	I think, we need a special TMP. like @@names
*/

//#"names"

