

module debugger
	|message|		Root
	|[string]|		Files
	|string|		SrcMap
	|&uint|			Base
	|int|			Length
	|bool|			GotBreaks
	
	function Start
		opt norefcounts
		|| p = perry
			debugger.Read(p, 5.0)
			if !.GotBreaks
				p <~ "error: nobreakpoints"

		
	function Read (|SpdProcess| Perry, |float| Delay)
		while (|| m = perry.Get(delay))
			.HandleRead(m)
		

	function HandleRead (|message| M)
		require m.expect(@tmp)
		if m == "breakpoints"
			.GetBreaks(m)
	
	
	function GetBreaks (|message| B)
		.GotBreaks = true
		for F.fast in b[@arg]
			if f.expect(@tmp)
				printline f
				
		
		
	function CakeVM.DebugFoundLocation (|FileWithData| F, |uint| Position, |bool|)
		|| str = F.GetLine(position)
		|| comment = str.find("//") // whoop!
			str = str[0, comment]
		str = str.trim

		print "\t\t\t\t"
		print F.name
		print ": "
		printline str

	// we need to respond to a few things:
		// pause
		// run
		// step over
		// step in
		// step out
		// ask for vars
		// ask for stack
		// hit breakpoints and stop!
		// deal with crashes.

	// of course... we can't actually do these.
	// not without the xpd file
	// So... lets say they press pause. what do we do? well... we can't do anything
	// so what are we doing? Testing?
	// planning?
	// preparing?
	// lets pretend we paused. then send back some messages.
	// send back... variables, and stack
	
	// what about asking for ASM? That goes through speedie.
	// So might as well do that first?
	
	function StartUp (|&int|)
		|| V = &__Viewer__
		if !CakeArgs.WantDebug and !perry
			V = nil
		return cake.IsDebugging(V)
	
	
	function Path (|int| i, |filewithdata|)
		opt norefcounts
		|| Path = .files[i]
		expect Path!=nil ("Missing file at index: " + i)
		if path isa FileWithData
			return path

		|| p = FileWithData(path)
		debugger.files[i] = p
		return p
	
	
	function __Viewer__ (cakevm.CakeChef)
		opt norefcounts
		|| Index = .index(code)
		if index < debugger.Length
			|| Where = debugger.Base![index]
			|| Path = debugger.path(where & (11~bits))$
			return .DebugFoundLocation( Path, Where>>11 )
		if StdErr.ok
			error ("Code map too short: " + index)
	
	
	function Load (|bool|)
		opt norefcounts
		|| R = .root
		if !R
			target debug
				.BreakAll
			return true
		
		|| Vars = R[@nil, 0].name.Decompress.parse
		|| Curr = SpdTable.Funcs[0]
		while vars.hasany
			|| V = vars.first
			if !curr 
				error (v, "Orphan debug info found")
				exit
			curr <~ v
			curr++

		check (!curr) (vars, "Missing some debug info")
			
		|| M = R[@nil, 1]
		.SrcMap = M.name
		.Files = r[@nil, 2].name.decompress.Split
		.base = .SrcMap.Addr|&uint|
		|| L = .SrcMap.Length >> 2
		.Length = L // just for speed
		
		check (L < 1MB)						("Oversized source-map: " + L)
		|| L2 = spdtable.CodeLength
		check (L2==L)						("map-length is: " + L) + (" but code-length is: " + L2)
		
		return StdErr.ok


	function BreakAll
		|| s = __Globals__.BreakPoints
			for i in spdtable.CodeLength
				s[i] = 1<<31



class FileWithData (stringshared)
	default NIL
	false NIL
	|string?|   _Data

	function GetLine (|int| Pos, |string|)
		opt norefcounts
		|| d = .data
		|| Start = d.Find(charset.Line, pos, 0) // or should that be -1? what if pos == 0?
		|| End = d.find(charset.line, pos, int.max)
		return d[Start+1, End]
		
	function Data (|string|)
		opt norefcounts
		return ._Data init .ReadAll
	
	constructor (|string| Name)
		super.constructor(name)
		._data = nil

