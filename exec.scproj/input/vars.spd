

class XVar (list)
	|Wierdness[5]|	Weirdness // pointers, references, carrays
	|int|			CodeEnd
	|bool|			NormalView
	|uint16|		Reg
	|DataTypeCode|	DataType
	|string|		Name
	
	
	constructor (|InputStream| s, |int| pos, |int| reg, |int| After)
		.normalview = true
		.position = pos
		.reg = reg
		.name = s.CString
		.obj = xtype.GetType(s.hint, nil)
		.DataType = s.HInt

		for i in â€“count .Weirdness
			|| x = 0
			if s.Position < After
				x = s.hint
			.Weirdness[i] = x

	function Close (|int| Pos)
		expect (self) ("Bad close var index")
		.CodeEnd = pos
	
	
	function Print (|!&ivec4| Reg)
		|| fs = FastString(nil|faststring|)
		.Render(fs, reg, true)
		printline fs.GetResult
	
	
	function Render (|faststring| fs, |!&ivec4| Reg, |bool| Full)
		opt norefcounts
		Reg += .reg
		if full
			.TypeName(fs)
			fs <~ " "
			fs <~ .name
			fs <~ "(${.reg|int|}): " // remove .reg once this is reliable
		|| C = .obj|&nil||xtype|
			if c.IsObject
				return .RenderObject(fs, reg)

		return .RenderData(fs, reg)
	
	
	function RenderObject (|faststring| fs, |!&ivec4| Reg)
		opt norefcounts
		require .TestMem(fs, reg, 8)
		|| obj = reg|&object|[]		// this should share our classes, so class tests should work.
		if !obj
			fs <~ "(nil)"
		  elseif obj isa string
			fs <~ '"'
			fs.AppendEscape(obj)
			fs <~ '"'
		  elseif obj isa faststring
			fs <~ '"'
			fs.AppendEscape(obj|&nil||string|)
			fs <~ '"'
		  elseif obj isa Message
			if .NormalView
				obj.RenderAST(Fs)
			  else
				obj.render(Fs)
		  else
			fs <~ "0x"
			fs.AppendHex(obj|int64|, 8)
			fs <~ "*"
			fs <~ obj.refcount
			
		// object, message, string
		// arrays are a bit sussy. Cos they can contain themselves! Better to force expansion
	
	
	function TypeName (|faststring| fs)
		opt norefcounts
		for W in .Weirdness
			loop W
			if w is Reference // ref
				fs <~ "$"
			if w is Pointer
				fs <~ "&"
			w >>= 2
			if w
				fs <~ "[$w]"
			
		|| C = .obj|&nil||xtype|
			 fs <~ C.Name
		  else
			.DataType.Render(Fs)
		
	
	function TestMem (|faststring| fs, |!&ivec4| Reg, |int| N, |bool|)
		|| Err = memory.test(reg, N)
			return true
		fs <~ Err.signalname
		fs <~ ": 0x"
		fs.AppendHex(reg|int64|, 8)
	
	
	function RenderData (|faststring| fs, |!&ivec4| Reg)
		|| T = .DataType
		|| V = t.VecCount
		|| BC = t.ByteCount
		if (bc >= 12): bc = 16		
		|| W = .weirdness[0]
		if W is pointer or reference
			require .TestMem(fs, reg, 8)
			|| Ptr = Reg|&&nil|[]|int64|
			fs <~ "0x"
			fs.AppendHex(ptr, 8)
			require !.weirdness[1]
			reg = ptr|&ivec4|

		require .testmem(fs, reg, bc)			
				
		if t is bool
			fs <~ (reg|&bool|)[].string
		  elseif t is int
			if v <= 1
				if BC > 4
					fs <~ (reg|&int64|)[]
				  elseif t.IsSigned 
					fs <~ (reg|&int|)[]
				  else
					fs <~ (reg|&uint|)[]
			  elseif v == 2
				fs <~ (reg|&ivec2|)[]
			  elseif v == 3
				fs <~ (reg|&ivec3|)[]
			  elseif v == 4
				fs <~ (reg|&ivec4|)[]
		  else
			if v <= 1
				if BC <= 4
					fs <~ (reg|&float|)[]
				  else
					fs <~ (reg|&f64|)[]
			  elseif v == 2
				fs <~ (reg|&vec2|)[]
			  elseif v == 3
				fs <~ (reg|&vec3|)[]
			  elseif v == 4
				fs <~ (reg|&vec4|)[]
	
	
	syntax is (|datatypecode| T, |bool|)
		return .DataType.SyntaxIs(t)
	


function message.xvariables (|[xvar]|)
	opt norefcounts
	if self
		|xvar[32]| Regs
		.xvariables(Regs, rz)


function message.xproperties (|[xvar]|)
	opt norefcounts
	if self
		.xvariables(nil, rz)


function message.xvariables (|?&xvar| Registers, |[xvar]| out)
	opt norefcounts
	|| input = xtype.shared
	input.Reset(.name)
	while (|| Section = input.byte)
		|| After = input.Position + Section
		|| pos = Input.hint
		|| reg = Input.hint
		expect (registers and reg|uint| < 32) ("Too large register")
		
		if input.Position >= After // Close
			if Registers
				Registers[reg].Close(pos)
		  else
			|| var = xvar(input, pos, reg, After)
			if Registers
				Registers[reg] = var
			out <~ var

		expect (input.position == After) ("Corrupted debug vars")

