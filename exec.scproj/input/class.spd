


class Type (Class)  
	|datatypecode|			DataType
	|BaseType|				BaseType


class Class 
	linkage
		cpp_class ClsInfo
	|stringzeroterminated|				Name
	|?Message|							Src
	|?class|							Super
	|&classdata|						RealClass
	
	
	constructor (|!&classdata| Cls)
		opt norefcounts
		.realclass = cls
		.name = string.Wrap(cls.name)
		addclass(self)
	

	constructor (|message!| Ch)
		opt norefcounts
		debugat
		|| pr = ch[@str]
		|| sz = pr.next(@num)
		|| beh = sz.next(@list)
		|&ClassData| ParentCls
		|| parent = class.Table[pr.name]
			parentcls = parent.realclass
		  else
			error (pr, "Linked to missing class")		
		
		.name = ch.name.cstr
		.src = Ch
		.super = parent
		
		.RealClass = classdata.new(.name.cstring, sz.int, parentcls)
		.LoadBehaviours(beh)
		addclass(self)


	function Size (|int|)
		return .realclass.size
	
	
	function LoadSuper 
		opt norefcounts
		|| P = .realclass.Parent
			|| str = P.name.str
			|| cls = table.valuelower(str)
				.super = cls
				return
		.super = Obj
	
	
	syntax equals (|string| s, |bool| aware, |bool|)
		return .name ~= s
	
	
	render
		|| sup = .super.name?
		fs <~ "Class: $.name ($.size, $sup)"


	function ClassData.AllocateBehaviour (|int| n, |&&&nil| Cpp, |&&&nil| Spd) 
		cpp_Wrapper JBClassAllocBehaviour


/*
		clss
			+"mycuteclass"   "List"         16  (des1, ren1)
			+"mycuteclass2"  "MyCuteClass"  24  (des2, ren2)
*/


	function LoadBehaviours	(|message| list)
		opt norefcounts
		|| i = 0
		|| bc = list.SlowCount max 2
		|&?&nil| Cpp,  |&?&nil| Spd 
		
		debugat
		.realclass.AllocateBehaviour(bc, cpp, spd)
		
		for ch in list
			|| fn = function[ch]
				debugat
				cpp[i] = fn.CFunc
				spd[i] = fn.SpeedieFunc   #check   (fn.src, "Cpp function lacks a speedie-wrapper")
			i++
		
				
	module
		function AddClass (|class| c)
			.list <~ c
			.table.ValueLower(c.name) = c
		

		function LoadAppClasses (|bool|)
			opt norefcounts
			for ch in package.ProjClasses
				|| c = class.new(ch)
			return stderr.ok


		function LoadInbuiltClasses (|bool|)
			opt norefcounts
			for cd in ClassData.first
				class.new(cd)
			.obj = table.valuelower("object")$
			for c in .list
				c.LoadSuper
			return stderr.ok
		
		
		function dictionary.syntaxaccess (|&classdata| c, ||)
			|| n = c.name
				|| s = n.str
				rz = self.valuelower(s)
			
	
		|class|					Obj
		|[class]|				List
		|dictionary of class|	Table = dictionary.new




datatype BaseType (int)
	constants (
		|BaseType|
		Module = 0 // not actually a type
		Nil
		Object
		Struct
		DataType
		FuncProto
	)
	syntax is (|BaseType| d, |bool|)
		return self == d

