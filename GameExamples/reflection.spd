#!/usr/local/bin/spd
import "GUI"

main
	return Breakout().RunAsMain(2.0)

// wierd bug with evreything being hit.
// remove explosions after a while, (make them explode)
	// why do they disappear SOMEtIMES?
	// block nudge... for vibration on hit



class Breakout (Window)
	|fpstextview|		FPS
	|[vobject]|			Blocks
	|vobject|			Bar
	|[vobject]|			Balls
	|[vobject]|			Explosions
	|float|				BallSpeed
	|int|				Hits
	|[vobject]|			Spirals

	constructor
		.bar = vobject(vec4())
		.fps = fpstextview(self)
		.fps.MakeInline()
		.reset

	function AddBalls (|vec2| P, |vobject|)
		Rz = vobject((P, 16th,  16th))
		rz.Velocity = vec2(0, -.ballspeed)
		.balls <~ rz

	function reset (|string| msg="")
		if msg
			beep msg
		.ballspeed = 0.09
		.bar.pos = vec2(10.0, 0.5)
		.bar.radius = vec2(1.0,  0.125)
		.balls.length = 0
		.Blocks.Length = 0
		.Explosions.Length = 0
		for y in 2.0
			.addballs((10.3, 6.0+y))
		for y in 5.0
			|| y2 = -1.0 + y*3th
			for x in 10.0
				|| pos = (2.0+x*(16.0/9.0), 9.0+y*0.5,  0.75, 0.2)
				|| bl = vobject(pos)
				bl.Health = 1.0 + y
				.Blocks <~ bl
	
	
	function BounceBar (|vobject| bar, |vobject| B,  |bool|)
		|| Hit = bar.OverlapsBlock(B)
		require hit.Exists
		|| v = b.Velocity
		require v.y < 0.0
		|| D = (b.pos - bar.pos) / bar.Radius
		v.y = -v.y
		v.x = d.x * 0.2
		b.Velocity = v.Normal*.ballspeed
		return true


	function Bounds (|vobject| b)
		|| bvx = b.Velocity.x
		if bvx < 0
			if b.left <= 0
				bvx = -bvx
		  else
			if b.right >= 20.0
				bvx = -bvx
		b.Velocity.x = bvx
		
		if b.y >= 12.0
			b.Velocity.y = -b.Velocity.y
	
	
	function Incr (|float|)
		|| h = ++.Hits
		|| add = 0.02 / h|float| pow 1.5
		.BallSpeed += add
		return .BallSpeed
	
		
	function HitOne (|vobject| bl, |vec4| R, |vobject| ball, |bool|)
		|| R2 = bl.OverlapsRect(R)
		require r2.exists
		|| Cn = r2.Center
		.spirals <~ vobject((cn, 3.0, 3.0), vec4(0.5,0,0,0))
		
		if r2.Height > r2.Width
			ball.Velocity.x = -ball.Velocity.x
		  else
			ball.Velocity.y = -ball.Velocity.y
		ball.Velocity = ball.Velocity.Normal * .incr

		|| hp = --bl.Health
		if (hp <= 0) or 0.5[]
			|| pu = .PowerUp(8)
			if !pu
				0 //
			  elseif pu <= 2
				|| b2 = .addballs(cn)
				|| old = .Blocks.now!
				b2.towards(old.pos, .BallSpeed)
			  elseif pu <= 5
				|| b2 = vobject((ball.pos, vec2(1+(pu-3))*0.3 ))
				b2.Color = colors.Red // 
				.Explosions <~ b2
			  elseif pu <= 7
				ball.Radius += 16th
			  elseif pu == 8
				.Bar.Radius.x += 8th
				if .bar.Radius.x > 2.5
					.bar.Radius.x = 2.5
				.Bar.Radius.x += 8th
		return hp <= 0
// guidable flurry aura
		
	
	function PowerUp (|float| n, |int|)
		|| x = .Blocks.Length|float|
		|| chance = (12.0 / x)
		if chance[]
			return 1+random.shared.float(n)|int|


	function DoHits (|vobject| ball)
		|| R = ball.box
		for (bl.backwards in .Blocks) (i)
			if .HitOne(bl, r, ball)
				.blocks.FastRemove(i)
				if !.blocks
					.reset( "Success! You beat level-1")
				return 
	
	
	behaviour FrameStep
		require GUIActive
		|| minsp = .BallSpeed/4
		for (b.backwards in .explosions) (i)
			b.Radius -= 0.03
			if b.Radius.x <= 0.02
				.explosions.fastRemove(i)
			  else 
				.Dohits(b)
		
		for (b.backwards in .balls) (i)
			|| y = b.Velocity.y
			if y.Abs < minsp
				b.Velocity.y = minsp.CopySign(y)
			b.Step
			.Bounds(b)
			.Dohits(b)
			.BounceBar(.bar, b)
			if b.y <= 0
				.balls.FastRemove(i)
				if !.balls
					.reset( "You failed")
					exit
		
		.bar.Pos.x += keys.movement.x.sign * 0.2
		|| bl = .bar.left
		if bl < 0
			.bar.pos.x -= bl
		bl = .bar.right
		if bl > 20.0
			.bar.pos.x -= (bl-20.0)
		
		for (s.backwards in .Spirals) (i)
			s.Radius -= 0.03
			if s.Radius.x < 0
				.Spirals.Remove(i)
		gui.Touch
		.fps.update
	
	
	behaviour Drawbackground
		where.DrawRect(self, colors.black)
		for x in .Width
			|| Col = Colors.rainbow(x div .width, 1, 0.5)
			where.DrawLineV((x,0), .height, col)
		
		for b in .Blocks
			|| H = (1.0-b.health)*12th
			|| Col = colors.wheel(H, 0.8, 0.5)
			where.DrawRect(b, col)
			Col = colors.wheel(H, 1.0, 0.4)
			where.DrawOutlineOnly(b, col)
		where.DrawRect(.bar)

		|| L = 24s()
		for (s in .Spirals) (i)
			|| B = s.Screen
			where.DrawSpiral(0.01*b.width|float|*vobject.drawscale, L, b.center, s.color * 0.2[], (3s+i*1s)())
		.BallDraw(where, .balls)
		.BallDraw(where, .explosions)
	
	
	function BallDraw (|image| where, |[vobject]| List)
		for b in list
			|| bx = b.Box.scr0 Â± -4.0
			where.DrawSoftCircle(bx, b.Color, 2.0)


function image.DrawSpiral (|float| Max, |float| angle, |vec2| XY, |vec4| HSB, |float| Pulse)
	|| sub = 24.0
	max += sub/2
	Pulse = Pulse * max
	for j in max
		if j <= sub
			continue 
		|| i = j - sub
		|| R = ((i*0.2123)+angle).SinCos
		|| closeness = (i - Pulse + 4.0() ).abs
		|| strength = (-0.005*closeness.pow2).Exp * 5.0

		|| P = R*(50.0+i+strength) + XY
		|| Circle = (P-4.0, P+4.0)
		|| A = ((Max-i)*2.0)/max
		|| C = Colors.wheel((i*0.005, 0.7, 1.0, A)+HSB)
	
		.DrawSoftCircle(Circle, C)


// copy your favourite arkanoid examples. (any on sega megadrive?)
