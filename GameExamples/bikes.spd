#!/usr/local/bin/spd
import "GUI"

// lets make a plan:
// 2) Add frustrum culling, make sure nothing good is missed.
	// How can we do this? The culling, because its not a frustrum
	// Lets look at the shape first?
	// We could get 3 points and find the "worst"? or perhaps theres always a worst point?
// 3) Some kind of visual partitioning system with cells?
// 4) turn the spheres into chunks?
// 5) Optimisations around still objects
// 6) hit-detection? (surely its just chunk vs chunk anyhow?)


main
//	|| fwd = vec3(0,0,1)
//	|| V = fwd * -0.125.Rotation
//	|| M2 = V.Camera2()
//	V = V.yxz
//	print m2
//	"----"
//	printline fwd * m2
//	"----\n"
//	|| M3 = v.Camera3
//	print m3
//	"----"
//	printline fwd * m3
//	"----\n"
//	
//	|| m4 = m3 * m2
//	print m4
//	"----"
//	printline fwd * m4
//	"----\n"
//	return 0
	
	gui.init(3)
	return RayScene().RunAsMain(True)



class RayScene (window)
	|date| 			LastDraw
	|raytracer|		T
	|textview| 		FPS
	|date| 			LastFPSChange

	constructor
		.t = RayTracer((1.6, 5.0, -22.0))
		.FPS = TextView(self)
		.fps.MakeInline
		.GNormal.clear // black background
//		|| Found = RayTracer(where, .cam, .LookAt)
		
		|| L = 10.0
		for i in (-L to L)
			|| sh = (i, 0.0, i.abs)*24.0
			|| C = vec4((2.0-i)*0.5, 1, 1, 1)
			.T.shapes <~ vobject(sh+(-1.0, 1.5, 12.0), 2.0, C)
			.T.shapes <~ vobject(sh+( 1.5, 2.5, 18.0), 3, C)
			.T.shapes <~ vobject(sh+( 7.0, 8.0, 18.0), 4, C)
			.T.shapes <~ vobject(sh+( -2.0, 9.0, 24.0), 6, C)
			.T.shapes <~ vobject(sh+( 12.0, 3.0, 24.0), 4, C)


	function PrepareDraw
		|| Ago = .LastDraw.ago
		.LastDraw = date.now
		.LastFPSChange ?= .LastDraw
		if .LastFPSChange.ago > 0.5s
			|| fps = (1.0/ago.Float).Render(1) + "fps"
			.fps.text = fps
			.LastFPSChange = .LastDraw
	
	
	behaviour Gesture
		.t.pitch += wheel.y|float|*0.001
		
		
	behaviour MouseMove
		.t.spin += Move.x|float| * 0.0005
	
	
	behaviour Drawbackground
		opt norefcounts,  opt min 3
		.PrepareDraw
		.T.RayTrace(where)
		gui.Touch
	
	
	behaviour FrameStep
		|| m = keys.Movement
			m = m.keyfix((0.6, 0.25, 5.0))
			|| P = m.xyz
				.t.MoveNicely(P.normal)
			.t.spin += m.w*0.003


function float.KeyFix (|vec3| V, |float|)
	if self
		return ((.abs * v.r + v.g) min v.b).CopySign(self)


function vec4.KeyFix (|vec3| V, |vec4|)
	for i in 4
		self[i] = self[i].KeyFix(V)
	return self
	
	