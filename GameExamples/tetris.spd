#!/usr/local/bin/spd
import "GUI"

// todo:
// forgiveness like tetris has
// score board needs history
// pink cloudy blocks with cute faces? and hearts/rainbows/stars as they disappear
	// Clouds via overlapping volumetric spheres and edge detection post-processing
	// the ghost block kinda spoils the fun a bit... you end up staring at the bottom all the time.
		// maybe speed the game up over time? then add it.
	// frilly frames?

main
	gui.Init(2.0)
	return TetrisWin().RunAsMain


datatype Tetromino (uint64)
	flags
		|uint64|
		(1<<8)
		Ghost
		Dropper
		Pivot
		Real
		Destroying
		Proper = Dropper + pivot

	syntax is (|Tetromino| V, |bool|)
		return self&V

	syntax is (|Tetromino| V, assigns:|bool|, |tetromino|)
		if Value
			return self|||v
		return self&~v

	function byte.real (|Tetromino|)
		return self|Tetromino| ||| Tetromino.Real
	
	function byte.dropper (|Tetromino|)
		return self|Tetromino| ||| Tetromino.Dropper

|| Shapes = [
	"aa\naa"
	"bb\n Bb"
	" Bb\nbb"
	"ccCc"
	"ccCc"
	"dDd\nd"
	"dDd\n  d"
	"eEe\n e"
	// I could add 0 bombs. like a shape with a hole in it, to punish players lol.
]


class TetrisWin (Window)
	|Tetris|			Grid
	|textview|			Score
	|int|				FramesLeft
	|int|				FrameRate
	
	constructor
		.grid = Tetris()
		.Score = TextView(self)
		.Score.MakeInline
		.score.blocksize(-3.5,3.0,  17.5,-10.0)
		.score.Alignment = MoveCode.Right
		.blockheight = 24
		.blockX(true) = -6
		.blockY = 1.5
		.FrameRate = 48
		.FramesLeft = .FrameRate*2		
	
	behaviour Framestep
		require GUIActive
		|| M = keys.Movement((8th, 0, 0, 4th))
		if .Grid.State == 1 // game over
			if keys.SPACE or Keys.RETURN
				.Grid.Restart
		  else
			|| w = m.w
				.grid.rotate(w)
			|| x = m.x
				.grid.move(x.sign|int|)
			if (.FramesLeft <= 0) or (m.y > 0) or (m.z < 0 and .framesleft isa 2)
				.FramesLeft = .FrameRate
				if .Grid.drop
					keys.Clear
			.grid.makeghost
			.FramesLeft--
		gui.Touch

	behaviour DrawBackground
		where.DrawRect(self, colors.black)
		.Grid.draw(where)
		.Score.Text = .grid.Score.Render



class Tetris (GridSection)
	contains Tetromino
	|int|	Score

	constructor
		.Dimensions[1] = 24
		.restart
		
	function Restart
		.State = 0
		.Score = 0
		|| i = 0
		|| h = .Height
		for y in h
			for x in 12
				|Tetromino| B
				if !y or (x == 0 or 11)
					B = '*'.real
					b += y >= (h-4)
				  elseif y <= 4
					B = ++i & 15
					b|=!b
					b = b|byte|.real
				self[x, y][] = b
			if y
				self[10()+1, y][] = 0
		.AddShape(shapes[0]!)

	syntax Access (|int| x, |int| y, |&Tetromino|)
		return .at(x + y*16)
			
	function AddShape (|string| s)
		|| y = 21
		|| x = 0
		for c in s
			if c == '\n'
				y--
				x = 0
			  else
				if c != ' '
					|| T = c.dropper
					(T is pivot) = c.IsUpper
					self[x+4,y][] = T&~32
				x++
		.move(-16)

	function NextShape
		.AddShape(shapes.now!)

	function FindPivot (|int| adjust, |ivec2|)
		for y in .Height
			for x in 10
				|| c = self[x+1,y][]
				if !adjust
					if c is pivot
						return (x+1,y)
				  elseif c is Dropper
					if adjust == 1
						return (x+1,y)
					adjust--
				

	///// ROTATIONS /////
	function RotateOne (|ivec2| P, |int| x, |int| y, |Tetromino| b, |float| r, |int| move,  |bool|)
		|| V = (x,y) - p
		if r > 0
			v = v.RotateRight
		  else 
			v = v.RotateLeft
		V += P
		require  v.x|uint| <= 10  and  v.y|uint| >= 1
		|| NewPos = self[v.x, v.y]+move
		if NewPos[] is Real
			return .Fail
		NewPos[] |= b<<16
		return true
		

	function Rotate (|float| r)
		require .FindPivot(0)
		for pivot in 4
			for Move in 3
				require !.CanRotate(r, (move&1)-((move&2)>>1), pivot)

		.CanRotate(r,16,0)

		
	function CanRotate (|float| r, |int| move, |int| pivot, |bool|)
		|| P = .FindPivot(pivot)$
		for y in .Height
			for x in 11
				|| c = self[x,y][]
				if c is Dropper
					require .RotateOne(p, x, y, c, r, move)
		return .pass
	////////////////////////
	
	function Fail (|bool|)
		for (b in self) (c)
			c[] = b & 16~bits

	function Pass (|bool|)
		for (b in self) (c)
			|| m = b>>16
				b = m
			  elseif b is Dropper
				b = 0
			c[] = b & 16~bits // flush
		return true
		
	function MoveIsBlocked (|int| x, |tetromino| test, |tetromino|)
		rz = -1
		for (b in self) (c)
			if b is dropper
				rz = 0
				|| dest = x+c
				|| T = (dest[]&test, -1)(dest >= .at)
					.fail
					return t
				dest[] |= b<<16

	function Move (|int| x, |bool|)
		return !.MoveIsBlocked(x, tetromino.real) and .Pass
	
	function RowIsFull (|int| y, |bool|)
		for x in 10
			require self[x+1, y][]
		return true
	
	function PullDown (|int| y)
		for x in 10
			self[x+1, y][] = 0
		while y < .Height-1
			for x in 10
				self[x+1, y][] = self[x+1, y+1][]
			y++
			
	function GameOver
		beep "Game Over"
		.State = 1
		
	function Drop (|bool|)
		return !.Move(-16) and .MakeReal
		
	function MakeGhost
		.FlushGhost
		|| i = -32
		while .MoveIsBlocked(i, tetromino.real ||| tetromino.proper) isnt Real
			.FlushGhost
			i-=16
	
		
	function FlushGhost
		for (b in self) (c)
			|| m = b>>16
				b = m
				(b isnt proper)
				(b is ghost)
			  elseif b is ghost
				b = 0
			c[] = b & 16~bits // flush
		
	function MakeReal (|bool|)	
		for (b in self) (c)
			if b is Dropper
				c[] = (b &~ Tetromino.proper)|||Tetromino.Real
		
		|| Score = 0
		for y in .Height-1
			if .RowIsFull(y+1)
				if !Score
					score = 100
				  else
					Score *= 3
				.PullDown(y+1)
				y--
		
		.Score += Score
		if .Reached >= .height-5
			.GameOver
		  else
			.NextShape
			return true
	
	function Reached (|int|)
		for y in 23 downto 1
			for x in 10
				if self[x+1,y][] is Real
					return y
		
	function Draw (|image| where)
		|| h = .Reached|float|
		for y in 21
			.DrawRow(where, y, h)
	
	function DrawBlock (|image| where, |int| y, |int| x, |tetromino| b, |float| h)
		|| R = (x, y, x+1, y+1).screen
		|| Hu = ((b&31)+8) div 11
		Hu -= (b is pivot)|float| * 0.025
		if b&255 == '*'
			Hu = 0.75+(h*70th)
		
		|| sa = 1.0
		|| Br = 0.8
		if b is ghost
			br = 0.05
		|| C = colors.wheel(Hu, SA, br, 1.0)
		where.DrawRect(R, C)
		
		// outline
		if b is Dropper
			if b is Pivot
				br += 4th
			  else 
				br *= 0.9
		  else
			hu += 24th
		if b is ghost
			br = 0.075
			r+=(0,0,1,1)
		C = colors.wheel(Hu, SA, br, 1.0)
		where.DrawOutlineOnly(R, C)
	
	function DrawRow (|image| where, |int| y, |float| h)
		|| row = .at(y*16)
		|| f = y >= (.Height-4)
		|| x = 0+f
		while x < (12-f)
			|| b = row[x]
				.DrawBlock(where, y, x, b, h)
			x++

	iterator
		|| y = 0
		while y < .height
			|| x = 0
			while x < 12
				|| c = self[x,y]
				yield (c[]) (c)
				++x
			y++

