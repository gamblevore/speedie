#!/usr/local/bin/spd
import "GUI"

// todo:
// forgiveness like tetris has
// score board needs history
// pink cloudy blocks with cute faces? and hearts/rainbows/stars as they disappear
	// Clouds via overlapping volumetric spheres and edge detection post-processing
	// frilly frames?

target !imported
	main
		gui.Init(2.0)
		return TetrisWin().RunAsMain


datatype Tetromino (uint64)
	flags
		|uint64|
		(1<<8)
		Ghost
		Dropper
		Pivot
		Real
		Destroying
		Proper = Dropper + pivot

	syntax is (|Tetromino| V, |bool|)
		return (self&V)==V

	syntax is (|Tetromino| V, assigns:|bool|, |tetromino|)
		if Value
			return self|||v
		return self&~v

	function byte.real (|Tetromino|)
		return self|Tetromino| ||| Tetromino.Real
	
	function byte.dropper (|Tetromino|)
		return self|Tetromino| ||| Tetromino.Dropper

|| Shapes = [
	"aa\naa"
	"bb\n Bb"
	" Bb\nbb"
	"ccCc"
	"ccCc"
	"dDd\nd"
	"dDd\n  d"
	"eEe\n e"
	// I could add 0 bombs. like a shape with a hole in it, to punish players lol.
]


class TetrisWin (Window)
	|Tetris|			Grid
	|textview|			Score
	|int|				FramesLeft
	
	constructor
		.grid = Tetris()
		.Score = TextView(self)
		.Score.MakeInline
		.score.blocksize(-2.5,2.5,  17.5,-1.0)
		.blockheight = 24
		.blockX(true) = -6
		.blockY = 1.5
		.FramesLeft = 48
	
	behaviour Framestep
		require GUIActive
		|| M = keys.Movement((8th, 0, 0, 4th))
		if .Grid.State == 1 // game over
			if keys.SPACE or Keys.RETURN
				.Grid.Restart
		  else
			|| w = m.w
				.grid.rotate(w)
			|| x = m.x
				.grid.move(x.sign|int|)
			
			if (m.y > 0 or m.z < 0) or (.FramesLeft <= 0)
				.FramesLeft = 60
				.Grid.drop
			.FramesLeft--
		gui.Touch

	behaviour DrawBackground
		where.DrawRect(self, colors.black)
		.Grid.draw(where)
		.Score.Text = .grid.Score.Render



class Tetris (GridSection)
	contains Tetromino
	|int|	Score

	constructor
		.Dimensions[1] = 24
		.restart
		
	syntax Access (|int| x, |int| y, |&Tetromino|)
		return .at(x + y*16)
			
	function AddShape (|string| s)
		|| y = 20
		|| x = 0
		for c in s
			if c == '\n'
				y--
				x = 0
			  else
				if c != ' '
					|| T = c.dropper
					(T is pivot) = c.IsUpper
					self[x+4,y][] = T
				x++

	function NextShape
		.AddShape(shapes.now!)
		
	function FindPivot (|ivec2|)
		for y in .Height
			for x in 10
				if self[x+1,y][] is pivot
					return (x+1,y)

	///// ROTATIONS /////
	function RotateOne (|ivec2| P, |int| x, |int| y, |Tetromino| b, |float| r,  |bool|)
		|| V = (x,y) - p
		if r > 0
			v = v.RotateRight
		  else 
			v = v.RotateLeft
		V += P
		require  v.x|uint| <= 10  and  v.y|uint| >= 1
		|| NewPos = self[v.x, v.y]
		NewPos[] |= b<<16
		return NewPos[] isnt Real
		
	function Rotate (|float| r)
		|| P = .FindPivot$
		|| Cancel = false
		for y in .Height
			for x in 11
				|| c = self[x,y][]
				Cancel |= (c is Dropper) and !.RotateOne(p, x, y, c, r)
		.Flush(cancel)
	////////////////////////
	
	function Flush (|bool| Cancel, |bool|)
		for (b in self) (c)
			if !Cancel
				|| m = b>>16
					b = m
				  elseif b is Dropper
					b = 0
			c[] = b & 16~bits // flush
		return Cancel

	function Move (|int| x, |bool|)
		for (b in self) (c)
			if b is dropper
				|| dest = x+c
				rz |= dest[] is Real
				dest[] |= b<<16
		rz = .Flush(rz)
	
	function Restart
		.State = 0
		.Score = 0
		|| i = 0
		|| h = .Height
		for y in h
			for x in 12
				|Tetromino| B
				if !y or (x == 0 or 11)
					B = '*'.real
					b += y >= (h-4)
				  elseif y <= 4
					B = ++i & 15
					b|=!b
					b = b|byte|.real
				self[x, y][] = b
			if y
				self[10()+1, y][] = 0
		.AddShape(shapes[0]!)

	function RowIsFull (|int| y, |bool|)
		for x in 10
			require self[x+1, y][]
		return true
	
	function PullDown (|int| y)
		for x in 10
			self[x+1, y][] = 0
		while y < .Height-1
			for x in 10
				self[x+1, y][] = self[x+1, y+1][]
			y++
			
	function GameOver
		beep "Game Over"
		.State = 1
		
	function Drop
		if .Move(-16)
			.MakeReal

	function MakeReal		
		for (b in self) (c)
			if b is Dropper
				c[] = (b &~ Tetromino.proper)|||Tetromino.Real
		
		|| Score = 0
		for y in .Height-1
			if .RowIsFull(y+1) // animating this would be better
				if !Score
					score = 100
				  else
					Score *= 3
				.PullDown(y+1)
				y--
		
		.Score += Score
		if .Reached >= .height-5
			return .GameOver
		
		.NextShape
	
	function Reached (|int|)
		for y in 23 downto 1
			for x in 10
				if self[x+1,y][] is Real
					return y
		
	function Draw (|image| where)
		|| h = .Reached|float|
		for y in 21
			.DrawRow(where, y, h)
	
	function DrawBlock (|image| where, |int| y, |int| x, |tetromino| b, |float| h)
		|| R = (x, y, x+1, y+1).screen
		|| Hu = ((b&31)+8) div 11
		Hu -= (b|byte|.IsUpper)|float| * 0.025
		if b&255 == '*'
			Hu = 0.75+(h*70th)
		
		|| SA = (0.2, 1.0)(b is Ghost)
		|| Br = 0.8
		|| C = colors.wheel(Hu, SA, br, SA)
		where.DrawRect(R, C)
		if b is Dropper
			br *= 0.9
		  else
			hu += 24th
		C = colors.wheel(Hu, SA, br, SA)
		where.DrawOutlineOnly(R, C)
	
	function DrawRow (|image| where, |int| y, |float| h)
		|| row = .at(y*16)
		|| f = y >= (.Height-4)
		|| x = 0+f
		while x < (12-f)
			|| b = row[x]
				.DrawBlock(where, y, x, b, h)
			x++

	iterator
		|| y = 0
		while y < .height
			|| x = 0
			while x < 12
				|| c = self[x,y]
				yield (c[]) (c)
				++x
			y++

