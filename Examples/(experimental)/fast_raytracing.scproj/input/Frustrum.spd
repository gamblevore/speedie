

// we can do this using a back plane and a front-plane
// then we can subdivide the screen into blocks.
// each block can take the edges of it's parent...

class ViewFrustrum
	|float|		CellSize
	|vec2|		Scale
	|vec2|		Adjust
	|vec4|		Screen
	|vec2|		LastSize
	|Plane|		Back
	|Plane|		Fwd
	|Plane[4]|	Edges

	constructor (|int| CellSize)
		.CellSize = (1<<CellSize)|float|
		
	function Draw (|vec4| B)
		// draw stuff in the list
	function ShrinkList (|vec4| B, |bool|)
		// need the box-planes
		// just recalc for now... 
	function RestoreList
		

	function Griddy (|vec2| Size)
		require .LastSize != size
		.LastSize = size
		.scale = 1.0/size.xx
		.adjust = size * -0.5
		|| log = (size.max/.cellsize).log2.ceil		// (1440, 900) --> (6,6) // < (2K, 2K)
		|| bounds = (vec2(), vec2(2.0) pow vec2(log))
		.SubDivide(bounds)	
	
	function SubDivide (|vec4| B)
		|| Clip = B.Clip(.screen)
		require Clip.area > 0.0
		if .ShrinkList(B)
			|| Half = B.Size * 0.5
			if half.x <= .CellSize
				.draw(B)
			  else
				|| S = B.xy
				|| M = S+Half
				
				|| LD = (S, M)
				|| LU = LD.up(M.y)
				|| RU = LD.right(M.x)
				|| RD = RU.up(M.y)
				.SubDivide(LD)
				.SubDivide(LU)
				.SubDivide(RD)
				.SubDivide(LD)
		.RestoreList
		

		

/*
https://stackoverflow.com/questions/13665932/calculating-the-viewing-frustum-in-a-3d-space
    vec3 nearCenter = camPos - camForward * nearDistance;
    vec3 farCenter = camPos - camForward * farDistance;
Compute the widths and heights of the near and far planes:

    real nearHeight = 2 * tan(fovRadians/ 2) * nearDistance;
    real farHeight = 2 * tan(fovRadians / 2) * farDistance;
    real nearWidth = nearHeight * viewRatio;
    real farWidth = farHeight * viewRatio;
Compute the corner points from the near and far planes:

    vec3 farTopLeft = farCenter + camUp * (farHeight*0.5) - camRight * (farWidth*0.5);
    vec3 farTopRight = farCenter + camUp * (farHeight*0.5) + camRight * (farWidth*0.5);
    vec3 farBottomLeft = farCenter - camUp * (farHeight*0.5) - camRight * (farWidth*0.5);
    vec3 farBottomRight = farCenter - camUp * (farHeight*0.5) + camRight * (farWidth*0.5);

    vec3 nearTopLeft = nearCenter + camY * (nearHeight*0.5) - camX * (nearWidth*0.5);
    vec3 nearTopRight = nearCenter + camY * (nearHeight*0.5) + camX * (nearWidth*0.5);
    vec3 nearBottomLeft = nearCenter - camY * (nearHeight*0.5) - camX * (nearWidth*0.5);
    vec3 nearBottomRight = nearCenter - camY * (nearHeight*0.5) + camX * (nearWidth*0.5);
Compute each plane from any three corners of the plane, wound CW or CCW to point inward (depending on coordinate system).

    vec3 p0, p1, p2;

    p0 = nearBottomLeft; p1 = farBottomLeft; p2 = farTopLeft;
    vec3 leftPlaneNormal = Normalize(Cross(p1-p0, p2-p1));
    vec3 leftPlaneOffset = Dot(leftPlaneNormal, p0);

    p0 = nearTopLeft; p1 = farTopLeft; p2 = farTopRight;
    vec3 topPlaneNormal = Normalize(Cross(p1-p0, p2-p1));
    vec3 topPlaneNormal = Dot(topPlaneNormal , p0);

    p0 = nearTopRight; p1 = farTopRight; p2 = farBottomRight;
    vec3 rightPlaneNormal = Normalize(Cross(p1-p0, p2-p1));
    vec3 rightPlaneNormal = Dot(rightPlaneNormal , p0);

    p0 = nearBottomRight; p1 = farBottomRight; p2 = farBottomLeft;
    vec3 bottomPlaneNormal = Normalize(Cross(p1-p0, p2-p1));
    vec3 bottomPlaneNormal = Dot(bottomPlaneNormal , p0);
*/	
	function Ray (|ivec2| p, |vec3|)
		|| XY = (p.vec2 + .adjust) * .scale
		return (xy, 1.0).Normal

		
	function Contains (|vec4| Sphere, |bool|)
		for i in 4
			require .Edges[i].sphere(Sphere)
		return true


class Frustrum
	|Plane[6]| Planes
	function Contains (|vec4| Sphere, |bool|)
		for i in 6
			require .planes[i].sphere(Sphere)
		return true

datatype SignedDistance (float)
	syntax cast (|bool|)
		return self <= 0

datatype Plane (vec4)
	function Point (|vec4| S, |SignedDistance|)
		return (s dot3 self) + .w
	function Sphere (|vec4| S, |SignedDistance|)
		return .Point(S) - s.w

function vec4.operatordot3 (|vec4| V, |float|)
	V*=self
	return v.x+v.y+v.z
