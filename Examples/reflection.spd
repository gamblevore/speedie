#!/usr/local/bin/spd
import "GUI"

main
	return Breakout()
 

// make spirals expand (or just replace with explosions)
// some blocks add balls...
	// they will head towards a random block (with random offset so it might miss)
// some blocks explode nearby things
// some are resistant (by color)


class Breakout (Window)
	|fpstextview|		FPS
	|[block]|			Blocks
	|block|				Bar
	|[block]|			Balls
	|float|				BallSpeed
	|int|				Hits
	|[block]|			Spirals

	constructor
		.bar  = block(vec4())
		.fps = fpstextview(self)
		.fps.MakeInline()
		.reset

	function addballs (|int| n)	
		|| H = 6.0
		for n
			|| b = block(vec4(10.3, H, 16th,  16th))
			H++
			b.Velocity = vec2(0, -.ballspeed)
			.balls <~ b

	function reset
		.ballspeed = 0.09
		.bar.pos = vec2(10.0, 1.0)
		.bar.radius = vec2(1.0,  0.125)
		.balls.length = 0
		.Blocks.Length = 0
		.addballs(2)
		for y in 5.0
			|| y2 = -1.0 + y*3th
			|| Col = colors.hsb(((-y2+0.75)*16th, 0.8, 0.5, 1.0))
			for x in 10.0
				|| pos = (2.0+x*(16.0/9.0), 9.0+y*0.5,  0.75, 0.2)
				.Blocks <~ block(pos, col)
	
	
	function BounceBar (|block| bar, |block| B,  |bool|)
		|| Hit = bar.OverlapsBlock(B)
		require hit.Exists
		|| v = b.Velocity
		require v.y < 0.0
		|| D = (b.pos - bar.pos) / bar.Radius
		v.y = -v.y
		v.x = d.x * 0.2
		b.Velocity = v.Normal*.ballspeed
		return true


	function Bounds (|block| b)
		|| bvx = b.Velocity.x
		if bvx < 0
			if b.left <= 0
				bvx = -bvx
		  else
			if b.right >= 20.0
				bvx = -bvx
		b.Velocity.x = bvx
		
		if b.y >= 12.0
			b.Velocity.y = -b.Velocity.y
	
	
	function Incr (|float|)
		|| h = ++.Hits
		|| add = 0.02 / h|float| pow 1.5
		.BallSpeed += add
		return .BallSpeed
	
			
	function DoHits (|block| b)
		|| R = b.box
		for (bl.backwards in .Blocks) (i)
			|| R2 = bl.OverlapsRect(R)
			if r2.exists
				|| Cn = r2.Center
				.spirals <~ block((cn, 3.0, 3.0), vec4(0.5,0,0,0))
				
				.blocks.FastRemove(i)
				
				if r2.Height > r2.Width
					b.Velocity.x = -b.Velocity.x
				  else
					b.Velocity.y = -b.Velocity.y
				b.Velocity = b.Velocity.Normal * .incr
				exit 
	
	
	behaviour FrameStep
		require !ShouldNotDisturbGUI
		for (b.backwards in .balls) (i)
			b.Step
			.bounds(b)
			.Dohits(b)
			.BounceBar(.bar, b)
			if b.y <= 0
				.balls.FastRemove(i)
				if !.balls
					beep "You failed"
					.reset
		.bar.Pos += keys.Vec3.xz * (0.2, 0.0)
		
		for (s.backwards in .Spirals) (i)
			s.Radius -= 0.03
			if s.Radius.x < 0
				.Spirals.Remove(i)
		gui.Touch
		.fps.update
	
	
	behaviour Drawbackground
		where.DrawRect(self, colors.black)	
		|| C = .LastRect.vec4
		|| J = ((c.width, c.height, 0, 0) / (20.0, 12.5, 1.0, 1.0))
		for b in .Blocks
			b.draw(Where, J)
		.bar.draw(Where, J)
		|| L = 24s()
		for (s in .Spirals) (i)
			|| B = s.boxj(J)
			where.DrawSpiral(0.01*b.width|float|*j.x, L, b.center, s.color * 0.2[], (3s+i*1s)())
		for b in .balls
			b.draw(where, J)


class Block
	|vec2| Pos
	|vec2| Radius
	|vec2| Velocity
	|vec4| Color
	
	constructor (|vec4| Pos_Rad, |vec4| Color=colors.white)
		.pos = Pos_Rad.xy
		.Radius = Pos_Rad.zw
		.Color = color
	
	function y (|float|)
		return .pos.y

	function x (|float|)
		return .pos.x

	function left (|float|)
		return .pos.x - .Radius.x

	function right (|float|)
		return .pos.x + .Radius.x
		
	function Box (|vec4|)
		|| rad = .Radius
		return (.pos-rad, .pos+rad)

	function BoxJ (|vec4| J, |ivec4|)
		|| P = .box * J.xyxy + J.zwzw
		|| w = p.Width
		|| h = p.Height
		p = p.floor
		p.x2 = p.x + w
		p.y2 = p.y + h
		return p.iVec4
		
	function Draw (|image| where, |vec4| J, |ivec4|)
		rz = .BoxJ(J)
		where.DrawRect(rz, .Color)

	function Step
		.pos += .Velocity

	function OverlapsBlock (|block| B, |vec4|)
		return .overlapsrect(b.box)
	function OverlapsRect (|vec4| B, |vec4|)
		return B.Clip(.box)
		
// later: handle other ratios, for example (Add borders)
// could we try to get closer to phi? say trim a few pixels off the top? to 865 pixels


	
function image.DrawSpiral (|float| Max, |float| angle, |vec2| XY, |vec4| HSB, |float| Pulse)
	|| sub = 24.0
	max+=sub/2
	Pulse = Pulse * max
	for j in max
		if j <= sub
			continue 
		|| i = j - sub
		|| R = ((i*0.2123)+angle).SinCos
		|| closeness = (i - Pulse + 4.0() ).abs
		|| strength = (-0.005*closeness.pow2).Exp * 5.0

		|| P = R*(50.0+i+strength) + XY
		|| Circle = (P-4.0, P+4.0)
		|| A = ((Max-i)*2.0)/max
		|| C = Colors.HSB((i*0.005, 0.7, 1.0, A)+HSB)
	
		.DrawSoftCircle(Circle, C)

