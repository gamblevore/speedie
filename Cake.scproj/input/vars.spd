

class XVar (list)
	|Wierdness[5]|	Weirdness // pointers, references, carrays
	|int|			CodeEnd
	|bool|			NormalView
	|uint16|		Reg
	|DataTypeCode|	DataType
	|string|		Name
	
	constructor (|InputStream| s, |int| pos, |int| reg, |int| After)
		.normalview = true
		.position = pos
		.reg = reg
		.name = s.CString
		.obj = xtype.GetType(s.hint, nil)
		.DataType = s.HInt
		.CodeEnd = int.max

		for i in â€“count .Weirdness
			|| x = 0
			if s.Position < After
				x = s.hint
			.Weirdness[i] = x

	function Close (|int| Pos)
		expect (self) ("Bad close var index")
		.CodeEnd = pos
	
	operator contains (|int| P, |bool|)
		// if p == .position, then the instruction isn't yet run.
		return P > .Position and P < .codeend
		
	function CanBeNil (|bool|)
		return .DataType & (DataTypeCode.PossibleBits+1)

	function Print (|!&ivec4| Reg0, |int| TabTo=0)
		opt norefcounts
		.Render(Printer, reg0, true, TabTo)
		printline Printer.GetResult
	
	
	module
		|| Printer = faststring()
	
	
	render
		opt norefcounts
		.Render(fs, nil, true, 0)
	
	function Render (|faststring| fs, |?&ivec4| Reg0, |bool| Full, |int| TabTo)
		opt norefcounts
		if full
			if TerminalColor.Enabled
				fs <~ terminalcolor.yellow
			
			|| M = fs.mark
			fs <~ "|"
			.TypeName(fs)
			fs <~ "|"
			fs <~ " "
			fs <~ .name
			fs <~ ": "
			if TerminalColor.Enabled
				fs <~ terminalcolor.normal
			if TabTo
				|| Missing = TabTo - (fs.mark - M)
				fs <~ (' ', missing)
		
		require reg0
		if TerminalColor.Enabled
			fs <~ terminalcolor.red

		|| Reg = Reg0 + .reg
		|| C = .obj|&nil||xtype|
		if c and c.IsObject
			.RenderObject(fs, reg)
		  else
			.RenderData(fs, reg)
		if TerminalColor.Enabled
			fs <~ terminalcolor.normal
	
	
	function RenderObject (|faststring| fs, |!&ivec4| Reg)
		opt norefcounts
		require .TestMem(fs, reg, 8, "Bad Stack")
		|| obj = reg|&object|[]		// this shares our classes, class tests should work!
		require .TestObj(fs, obj)
		
		if !obj
			fs <~ "(nil)"
		  elseif obj isa string
			fs <~ '"'
			fs.AppendEscape(obj)
			fs <~ '"'
		  elseif obj isa faststring
			fs <~ '"'
			fs.AppendEscape(obj|&nil||string|)
			fs <~ '"'
		  elseif obj isa Message
			if .NormalView
				obj.RenderAST(Fs)
			  else
				obj.render(Fs)
		  else
			fs <~ "0x"
			fs.AppendHex(obj|int64|, 8)
			fs <~ "*"
			fs <~ obj.refcount
		// Contains can contain themselves! So no deep rendering... for now. Maybe if we mark/unmark them.
	
	
	function TypeName (|faststring| fs)
		opt norefcounts
		for W in .Weirdness
			loop W
			if w is Reference // ref
				fs <~ "$"
			if w is Pointer
				fs <~ "&"
			w >>= 2
			if w
				fs <~ "[$w]"
			
		|| C = .obj|&nil||xtype|
			 fs <~ C.Name
		  else
			|| T = .DataType|||datatypecode.Numeric
			T.Render(Fs)
		
	
	function TestObj (|faststring| fs, |object| Obj, |bool|)
		return .TestMem(fs, obj|&nil|, -1, "Bad Object")
	
	
	function TestMem (|faststring| fs,  |?&nil| Mem,  |int| N,  |string| ErrName,  |bool|)
		if !Mem
			return true
		|| Err = memory.test(Mem, N)
			return true
		fs <~ ErrName
		fs <~ ": 0x"
		fs.AppendHex(Mem|int64|, 8)
	
	
	function RenderData (|faststring| fs, |!&ivec4| Reg)
		opt norefcounts
		|| T = .DataType
		|| V = t.VecCount
		|| BC = t.ByteCount
		if (bc >= 12): bc = 16		
		|| W = .weirdness[0]
		
		|| Err = "Bad Stack"
		if W is pointer or reference
			require .TestMem(fs, reg, 8, Err)
			|| Ptr = Reg|&&nil|[]|int64|
			fs <~ "0x"
			fs.AppendHex(ptr, 8)
			require !.weirdness[1]
			reg = ptr|&ivec4|
			Err = "Bad Pointer"

		require .TestMem(fs, reg, bc, Err)
				
		if t is bool
			fs <~ (reg|&bool|)[].string
		  elseif t is int
			if v <= 1
				if BC > 4
					fs <~ (reg|&int64|)[]
				  elseif t.IsSigned 
					fs <~ (reg|&int|)[]
				  else
					fs <~ (reg|&uint|)[]
			  elseif v == 2
				fs <~ (reg|&ivec2|)[]
			  elseif v == 3
				fs <~ (reg|&ivec3|)[]
			  elseif v == 4
				fs <~ (reg|&ivec4|)[]
		  else
			if v <= 1
				if BC <= 4
					fs <~ (reg|&float|)[]
				  else
					fs <~ (reg|&f64|)[]
			  elseif v == 2
				fs <~ (reg|&vec2|)[]
			  elseif v == 3
				fs <~ (reg|&vec3|)[]
			  elseif v == 4
				fs <~ (reg|&vec4|)[]
	
	
	syntax is (|datatypecode| T, |bool|)
		return .DataType.SyntaxIs(t)
	


function message.xvariables (|[xvar]|)
	opt norefcounts
	cpp_part xvar0
	if self
		|xvar[32]| Regs
		.xvariables(Regs, rz)


function message.xvariables (|?&xvar| Registers, |[xvar]| out)
	opt norefcounts
	cpp_part xvar
	|| input = xtype.shared
	input.Reset(.name)
	while (|| Section = input.byte)
		|| ReadEnd = input.Position + Section
		|| pos = Input.hint
		|| reg = Input.hint
		|| OK = !Reg
		if registers: OK = (reg-1)|uint| < 31
		expect (OK) ("Bad register")
		
		if input.Position >= ReadEnd // Close
			expect (Registers) "Bad register"
			Registers[reg].Close(pos)
		  else
			|| var = xvar(input, pos, reg, ReadEnd)
			if Registers
				Registers[reg] = var
			out <~ var

		expect (input.position == ReadEnd) ("Corrupted debug vars")
	

