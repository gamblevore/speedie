
// we need to respond to a few things:
	// pause
	// run
	// step over
	// step in
	// step out
	// ask for vars
	// ask for stack
	// hit breakpoints and stop!
	// deal with crashes.

// of course... we can't actually do these.
// not without the cake file
// So... lets say they press pause. what do we do? well... we can't do anything
// so what are we doing? Testing?
// planning?
// preparing?
// lets pretend we paused. then send back some messages.
// send back... variables, and stack

// what about asking for ASM? That goes through speedie.
// So might as well do that first?


module debugger
	|message|		Root
	|Message|		Globs
	|[string]|		Files
	|string|		SrcMap
	|&uint|			Base
	|int|			Length
	|bool|			GotBreaks
	|bool|			WantDebug
	
	function Start
		opt norefcounts
		|| p = cake.perry
			debugger.Read(p, 5.0)
			if !.GotBreaks
				p <~ "error: nobreakpoints"

		
	function Read (|SpdProcess| Perry, |float| Delay)
		while (|| m = perry.Get(delay))
			.HandleRead(m)
		

	function HandleRead (|message| M)
		require m.expect(@tmp)
		if m == "breakpoints"
			.GetBreaks(m)
	
	
	function GetBreaks (|message| B)
		.GotBreaks = true
		for F.fast in b[@arg]
			if f.expect(@tmp)
				printline f
	
	
	function StartUp (|&int|)
		|| V = &__Viewer__
		if !debugger.WantDebug and !cake.perry
			V = nil
		return cake.VM.IsDebugging(V)
	
	
	function Path (|int| i, |filewithdata|)
		opt norefcounts
		|| Path = .files[i]
		expect Path!=nil ("Missing file at index: " + i)
		if path isa FileWithData
			return path

		|| p = FileWithData(path)
		debugger.files[i] = p
		return p
	
	
	function __Viewer__ (cakevm.CakeChef)
		opt norefcounts
		if index >= debugger.Length
			check (!stderr.ok) ("Code map too short: " + index)
			return 0
		
		|| Where = debugger.Base![index]
		|| Path = debugger.path(where & (11~bits))
		|| fn = spdtable.Find(index)
		if path
			|| TabTo = .PrintCodeLocation(Path, fn, Where>>11 )
			if fn and fn.HasVar(index)
				.PrintStackVars(index, fn, Reg0, TabTo)


	function spdfunc.HasVar (|int| Index, |bool|)
		opt norefcounts
		for v in .obj|&nil||[xvar]|
			if v contains index
				return true
	
		
	function Load (|bool|)
		opt norefcounts
		|| R = .root
		if !R: return true

		|| L = .LoadDebug(R)
		|| L2 = SpdTable.CodeLength
		
		expect (L < 1MB)					("Oversized source-map: " + L)
		expect (L2 == L)					("Map-length is: " + L) + (" but code-length is: " + L2)
		
		if Platform.IsDebug or debugger.wantdebug
			.BreakAll
		
		for fn in SpdTable.funcs
			fn.loadvars
		return StdErr.ok
		

	helper LoadDebug (|message| R, |int|)
		opt norefcounts
		xtype.loadtypes R["class"]
		.Globs = R["glob"]
		.Files = R["files"].value.decompress.Split
		.SrcMap = R["pos"]
		.base = .SrcMap.Addr|&uint|
		rz = .SrcMap.Length >> 2
		.Length = rz					// just for speed


	function BreakAll
		|| s = cake.BreakPoints
			for i in spdtable.CodeLength
				s[i] = 1<<31

		
		
function CakeVM.PrintCodeLocation (|FileWithData| File,  |spdfunc| fn,  |uint| Position, |int|)
	print "\t\t\t\t\t\t"
	if TerminalColor.Enabled
		print terminalcolor.green.render
	
	print file.filename
	print " "
	if fn
		print fn.name
		print ": "
	
	if TerminalColor.Enabled
		print TerminalColor.normal

	|| Code = File.GetLine(position)
	|| comment = Code.find("//") // whoop!
		Code = Code[0, comment]
	Code = Code.trim

	printline Code
	return 7 + file.filename.Length + fn.Name.Length


function CakeVM.PrintStackVars (|int| Index, |spdfunc| Fn, |&ivec4| Reg0, |int| TabTo)
	opt norefcounts 
	index -= fn.Position
	for v in fn.obj|[xvar]|
		if v contains index
			print "\t\t\t\t\t\t"
			v.Print(reg0, TabTo)
	printline

