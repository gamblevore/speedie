
// we need to respond to a few things:
	// pause
	// run
	// step over
	// step in
	// step out
	// ask for vars
	// ask for stack
	// hit breakpoints and stop!

datatype SourceLocation (uint)
	function FileNum (|uint|)
		return self >> 21
	
	function BytePos (|uint|)
		return self & 21~bits
	
	function MatchScore (|sourcelocation| ToFind, |int|)
		require .FileNum == ToFind.FileNum
		|| Diff = .BytePos - ToFind.BytePos
		if diff >= 0
			return int.max - diff


module debugger
	|message|		Root
	|Message|		Globs
	|[fileWithData]|	Files
	|dictionary of filewithdata| FileMap
	|string|		SrcMapStr
	|string|		Breakables
	|string|		BreakPoints
	|uint|			Length
	|uint|			OverFlowTrack
	|bool|			WantDebug
	|bool|			BreakMapBad
	
	
	function SrcMap (|uint| Index, |SourceLocation|)
		|| Base = .SrcMapStr.Addr|&uint|
		if index < .Length
			return base[index]
	
		
	function Read (|SpdProcess| Perry, |float| Delay)
		while (|| m = perry.Get(delay))
			.HandleRead(m)
		

	function HandleRead (|message| M)
		require m.expect(@tmp)
		if m == "breakpoints"
			.GetUserBreaks(m)
			return
		printerror "Debugger received unexpected " + m.name
	
	
//	function Break (|uint| Index, |&uint|)
//		|| B = cake.BreakPoints
//			if index < .Length
//				return b+index

	
	function ActivateInbuiltBreaks
		|| CakeBreak = cake.BreakPoints$
		|| P = .Breakpoints.Addr|&uint|
		|int| n = .Breakpoints.Length >> 2
		for i in n
			|| Code = P[i++]
/			if Code < .Length
				CakeBreak[Code] |= (1<<31)
	

	function UserMultiBreak (|FileWithData| Path, |uint| Position, |bool| Active=true)
/		|| CakeBreak = cake.BreakPoints$

		|| Map = .Breakables.Addr|&sourcelocation|
		|| n = .Breakables.Length >> 2
		|| i = 0		
		|| ToFind = (path.index << 21) ||| Position

		while i < n
			|| Src = Map[i++]
			|| Code = Map[i++]
			if (Src == ToFind)
				path = nil
				.SetUserBreak(cakebreak, Code, active)
				
		require path != nil

		i = 0
		|| BestScore = 0
		|| BestIndex = 0
		while i < n
			|| Src = Map[i]
			|| Score = Src.MatchScore(ToFind)
			if Score > BestScore
				BestScore = Score
				BestIndex = i
			i += 2
		
		if BestScore
			.SetUserBreak(cakebreak, Map[BestIndex+1], active)
	
	
	function SetUserBreak (|&uint| CakeBreak, |uint| Code, |bool| Active)
		if Code < .Length
			|| B = CakeBreak[Code] &~ (1<<31)
			B |= Active<<31
			CakeBreak[Code] = B
		  elseif !.BreakMapBad
			.BreakMapBad = true
			printerror "BreakMap out of range"
		
	
	function GetUserBreaks (|message| B)
		opt norefcounts
		for P.fast in b[@arg]
			if p.expect(@tmp)
				|| F = .FileMap[p.name]
					for Pos in P
						|| i = p.int
						if i >= 1
							.UserMultiBreak(F, i)
				  else
					error (F, "Breakpoint is in missing file")
	
	
	function StartUp (|&uint|)
		cake.vm.__View__ = __Viewer__
		return cake.VM.IsDebugging(debugger.WantDebug or cake.perry)
	
	
	function Path (|int| i, |filewithdata|)
		opt norefcounts
		return .files[i]						#expect ("Missing file at index: " + i)
	
	
	function __Viewer__ (cakevm.CakeChef)
		opt norefcounts
		if index < 0							// stack overflow  or crash
			return .PrintCrashTrace(Index, Reg0|&CakeStack|)

		if index|uint| >= debugger.Length
			check (!stderr.ok)					("Code map too short: " + index)
			return 0
		
		|| Where = debugger.SrcMap(index)
		|| fn = spdtable.Find(index)
		|| Path = debugger.path(Where.FileNum)
			|| TabTo = .PrintCodeLocation(Path, fn, Where.BytePos )
			if fn and fn.HasVar(index)
				.PrintStackVars(index, fn, Reg0, TabTo)


	function spdfunc.HasVar (|int| Index, |bool|)
		opt norefcounts
		for v in .obj|&nil||[xvar]|
			if v contains index
				return true
	
		
	function Load (|bool|)
		// this could come before the linking
		// then we can move  fn.loadvars into the link-loop
		
		opt norefcounts
		|| R = .root
		if !R
			expect (!debugger.WantDebug)	("Program file doesn't contain debug info. Remove -d to run it.")
			return true

		xtype.loadtypes R["class"]
		.Globs = R["glob"]
		.LoadFiles(R["files"].value.decompress)
		.SrcMapStr = R["pos"]
		.Breakables = R["breakmap"]
		.Breakpoints = R["breakpoint"]
		.Length = .SrcMapStr.Length >> 2

		|| L2 = SpdTable.CodeLength
		expect (L2 == .Length)				("Map-length is: " + .Length) + (" but code-length is: " + L2)
		expect (L2 < 1MB)					("Oversized source-map: " + L2)
		
		.ActivateInbuiltBreaks
		
		for fn in SpdTable.funcs
			fn.LoadVars
		
		return StdErr.ok
	

	helper LoadFiles (|string| List)
		opt norefcounts
		|| Last = 0
		|| i = 0
		|| out = .Files
		.FileMap = Dictionary()
		while
			|| P = list.NextField('\n', Last)
			if P == nil
				exit
			|| F = FileWithData(P, i++)
			out <~ F
			.FileMap![F] = F

		
		
function CakeVM.PrintCodeLocation (|FileWithData| File,  |spdfunc| fn,  |uint| Position, |int|)
	print "\t\t\t\t\t\t"
	if TerminalColor.Enabled
		print terminalcolor.green.render
	
	print file.filename
	print " "
	if fn
		print fn.name
		print ": "
	
	if TerminalColor.Enabled
		print TerminalColor.normal

	|| Code = File.GetLine(position)
	|| comment = Code.find("//") // whoop!
		Code = Code[0, comment]
	Code = Code.trim

	printline Code
	return 7 + file.filename.Length + fn.Name.Length


function CakeVM.PrintStackVars (|int| Index, |spdfunc| Fn, |&ivec4| Reg0, |int| TabTo)
	opt norefcounts 
	index -= fn.Position
	for v in fn.obj|[xvar]|
		if v contains index
			print "\t\t\t\t\t\t"
			v.Print(reg0, TabTo)
	printline



/*
	OK... so how does... the code get stored?
	At the start... the start stack contains .Code of the END of the VM
	so thats no use.

	Lets say we go to the next stack... OK fine.
	So... whats the code return point? Well... its the calling function?
	So... lets say we call a func from main. The .code of the second one...
	Would be "main" but its not where we jumped TO.
	
	It might be useful, tho. I mean... 
	
	We COULD store the latest jump point, but its not very useful.
	
	We COULD... do the checking (without crashing) in bumpstack? I mean...
	its better, right?

	What if main had a HALT instruction? then we don't need a HALT when main returns
	
	It kinda makes sense? I think its the only way to test this anyhow.
*/


function CakeVM.PrintCrashTrace (|int| Err, |?&CakeStack| LastStack,  |int64|)
	opt norefcounts, (err)
	"****** CRASHED ******"
	if debugger.OverFlowTrack // in case we crash during a stack-trace
		"! Crashed during CrashTrace"
	  else
		debugger.OverFlowTrack = 1
		|| BadMsg = .PrintStackTrace(laststack)
			printline BadMsg
	"---------------------"


function CakeVM.PrintStackTrace (|?&CakeStack| LastStack, |?string|)
	opt norefcounts
// We need to make the new JB_FS_AppendVArg to get the numbers printing nicely.
// into FastString... maybe with the new JB_FS_AppendVArg idea? Should be cool, right?

//Tue Feb 10 23:49:23 2026
//Signal 11 in /tmp/SpeedieApps/6074286623726617078/hello_world [
//]
//
//0   JB_App__BackTrace + 28
//1   JB_CrashTracer + 56
//2   JB_CrashHandler + 352
//3   _sigtramp + 56
//4   JB_App__Crash + 60
//5   JB_Main + 20
//6   JB_SP_Run + 344
//7   main + 28
//8   start + 7184

	|| Stack = (.Registers(false)-2)|&CakeStack|
	|| Depth = Stack.Depth
	LastStack ?= Stack + 1MB/16
	while Memory.Test(Stack, 16)
		if (Depth >= 1K):						return "..." // huge stacks aren't that useful
			
		|| CodePtr = Stack.Code
		if !CodePtr:							return "! Missing CodePtr"
		print "\t"
		|| index = .index(CodePtr)
		|| fn = spdtable.Find(index)
			print fn.Name
		  else
			print "[Unknown]"					// Avoid string/memory alterations by using faststring...
		printline "()"

		require stack!=LastStack
		if stack > LastStack:					return "! Stack Too Large"
		|| Up = stack.GoUp	#require
		Stack += Up+1
		Depth++
		if (Up > 32):							return "! Stack Chain Invalid"
		if stack.Depth!=Depth:					return "! Stack Depth Invalid"
	return nil


