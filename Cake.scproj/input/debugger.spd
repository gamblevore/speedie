
// we need to respond to a few things:
	// pause
	// run
	// step over
	// step in
	// step out
	// ask for vars
	// ask for stack
	// hit breakpoints and stop!
	// deal with crashes.

// of course... we can't actually do these.
// not without the cake file
// So... lets say they press pause. what do we do? well... we can't do anything
// so what are we doing? Testing?
// planning?
// preparing?
// lets pretend we paused. then send back some messages.
// send back... variables, and stack

// what about asking for ASM? That goes through speedie.
// So might as well do that first?


datatype SourceLocation (uint)
	function FileNum (|uint|)
		return self & 11~bits
	
	function BytePos (|uint|)
		return self >> 11


module debugger
	|message|		Root
	|Message|		Globs
	|[fileWithData]|	Files
	|dictionary of filewithdata| FileMap
	|string|		SrcMapStr
	|uint|			Length
	|bool|			GotBreaks
	|bool|			WantDebug
	|uint|			OverFlowTrack
	
	
	function SrcMap (|uint| Index, |SourceLocation|)
		|| Base = .SrcMapStr.Addr|&uint|
		if index < .Length
			return base[index]
	

	function Start
		opt norefcounts
		|| p = cake.perry
			debugger.Read(p, 5.0)
			if !.GotBreaks
				p <~ "error: nobreakpoints"

		
	function Read (|SpdProcess| Perry, |float| Delay)
		while (|| m = perry.Get(delay))
			.HandleRead(m)
		

	function HandleRead (|message| M)
		require m.expect(@tmp)
		if m == "breakpoints"
			.GetBreaks(m)
			
		
		
	function Break (|uint| Index, |&uint|)
		|| B = cake.BreakPoints
			if index < .Length
				return b+index
	
	
	// seems that break info should be generated by speedie
	// then it has all the info needed. Some kinda break-map...
	// that maps source-positions to multiple points
	// then some algorithm to collect them.
	
	function AddBreak (|FileWithData| Path, |uint| Position, |bool| Active=true)
		|| Breaks = cake.BreakPoints$
		|| Map = .SrcMapStr.Addr|&sourcelocation|
		|| i = 0
		|int| n = .Length
//		|| State = 0			// for inlines, which exist all over, but they can come from the same file...? sigh...
		|| Fiel = path.Position // checking for the filenum isnt enough. We actually need the func-num.
								// what if an inline is called twice, in a func?
		while i < n
			|| V = Map[i++]
			if V.FileNum == Fiel
				if v.BytePos >= Position
//					State |= 2
					|| B = breaks[i] &~ (1<<31)
					B |= Active<<31
					breaks[i] = B
//				State |= 1
//			  else
//				State = 0
		// we also need to sendback breakpoints? they might not be the same as set, due to optimisations...
		// idk really.
	
	function GetBreaks (|message| B)
		opt norefcounts
		.GotBreaks = true
		for P.fast in b[@arg]
			if p.expect(@tmp)
				|| F = .FileMap[p.name]
					for Pos in P
						|| i = p.int
						if i >= 1
							.AddBreak(F, i)
				  else
					error (F, "Breakpoints set in missing file")
			
	
	
	function StartUp (|&uint|)
		cake.vm.__View__ = __Viewer__
		return cake.VM.IsDebugging(debugger.WantDebug or cake.perry)
	
	
	function Path (|int| i, |filewithdata|)
		opt norefcounts
		return .files[i] #expect ("Missing file at index: " + i)
	
	
	function __Viewer__ (cakevm.CakeChef)
		opt norefcounts
		if index < 0						// stack overflow  or crash
			return .PrintCrashTrace(Index, Reg0|&CakeStack|)

		if index|uint| >= debugger.Length
			check (!stderr.ok) ("Code map too short: " + index)
			return 0
		
		|| Where = debugger.SrcMap(index)
		|| Path = debugger.path(Where.FileNum)
		|| fn = spdtable.Find(index)
		if path
			|| TabTo = .PrintCodeLocation(Path, fn, Where.BytePos )
			if fn and fn.HasVar(index)
				.PrintStackVars(index, fn, Reg0, TabTo)


	function spdfunc.HasVar (|int| Index, |bool|)
		opt norefcounts
		for v in .obj|&nil||[xvar]|
			if v contains index
				return true
	
		
	function Load (|bool|)
		// this could come before the linking
		// then we can move  fn.loadvars into the link-loop
		// test later...
		
		opt norefcounts
		|| R = .root
		if !R
			expect (!debugger.WantDebug)	("Program file doesn't contain debug info. Remove -d to run it.")
			return true

		|| L = .LoadDebug(R)
		|| L2 = SpdTable.CodeLength
		
		expect (L < 1MB)					("Oversized source-map: " + L)
		expect (L2 == L)					("Map-length is: " + L) + (" but code-length is: " + L2)
		
		if Platform.IsDebug or debugger.wantdebug
			.BreakAll
		
		for fn in SpdTable.funcs
			fn.loadvars
		return StdErr.ok
	

	helper LoadFiles (|string| List)
		opt norefcounts
		|| Last = 0
		|| i = 0
		|| out = .Files
		|dictionary of filewithdata| d = Dictionary()
		.FileMap = d
		while
			|| P = list.NextField('\n', Last)
			if P == nil
				exit
			|| F = FileWithData(P, i++)
			out <~ F
			d[F] = F
		


	helper LoadDebug (|message| R, |int|)
		opt norefcounts
		xtype.loadtypes R["class"]
		.Globs = R["glob"]
		.LoadFiles(R["files"].value.decompress)
		.SrcMapStr = R["pos"]
		rz = .SrcMapStr.Length >> 2
		.Length = rz					// just for speed


	function BreakAll
		|| s = cake.BreakPoints
			for i in spdtable.CodeLength
				s[i] = 1<<31

		
		
function CakeVM.PrintCodeLocation (|FileWithData| File,  |spdfunc| fn,  |uint| Position, |int|)
	print "\t\t\t\t\t\t"
	if TerminalColor.Enabled
		print terminalcolor.green.render
	
	print file.filename
	print " "
	if fn
		print fn.name
		print ": "
	
	if TerminalColor.Enabled
		print TerminalColor.normal

	|| Code = File.GetLine(position)
	|| comment = Code.find("//") // whoop!
		Code = Code[0, comment]
	Code = Code.trim

	printline Code
	return 7 + file.filename.Length + fn.Name.Length


function CakeVM.PrintStackVars (|int| Index, |spdfunc| Fn, |&ivec4| Reg0, |int| TabTo)
	opt norefcounts 
	index -= fn.Position
	for v in fn.obj|[xvar]|
		if v contains index
			print "\t\t\t\t\t\t"
			v.Print(reg0, TabTo)
	printline



/*
	OK... so how does... the code get stored?
	At the start... the start stack contains .Code of the END of the VM
	so thats no use.

	Lets say we go to the next stack... OK fine.
	So... whats the code return point? Well... its the calling function?
	So... lets say we call a func from main. The .code of the second one...
	Would be "main" but its not where we jumped TO.
	
	It might be useful, tho. I mean... 
	
	We COULD store the latest jump point, but its not very useful.
	
	We COULD... do the checking (without crashing) in bumpstack? I mean...
	its better, right?

	What if main had a HALT instruction? then we don't need a HALT when main returns
	
	It kinda makes sense? I think its the only way to test this anyhow.
*/


function CakeVM.PrintCrashTrace (|int| Err, |?&CakeStack| LastStack,  |int64|)
	opt norefcounts, (err)
	"****** CRASHED ******"
	if debugger.OverFlowTrack // in case we crash during a stack-trace
		"! Crashed during CrashTrace"
	  else
		debugger.OverFlowTrack = 1
		|| BadMsg = .PrintStackTrace(laststack)
			printline BadMsg
	"---------------------"


function CakeVM.PrintStackTrace (|?&CakeStack| LastStack, |?string|)
	opt norefcounts
// We need to make the new JB_FS_AppendVArg to get the numbers printing nicely.
// into FastString... maybe with the new JB_FS_AppendVArg idea? Should be cool, right?

//Tue Feb 10 23:49:23 2026
//Signal 11 in /tmp/SpeedieApps/6074286623726617078/hello_world [
//]
//
//0   JB_App__BackTrace + 28
//1   JB_CrashTracer + 56
//2   JB_CrashHandler + 352
//3   _sigtramp + 56
//4   JB_App__Crash + 60
//5   JB_Main + 20
//6   JB_SP_Run + 344
//7   main + 28
//8   start + 7184

	|| Stack = (.Registers(false)-2)|&CakeStack|
	|| Depth = Stack.Depth
	LastStack ?= Stack + 1MB/16
	while Memory.Test(Stack, 16)
		if (Depth >= 1K):						return "..." // huge stacks aren't that useful
			
		|| CodePtr = Stack.Code
		if !CodePtr:							return "! Missing CodePtr"
		print "\t"
		|| index = .index(CodePtr)
		|| fn = spdtable.Find(index)
			print fn.Name
		  else
			print "[Unknown]"					// Avoid string/memory alterations by using faststring...
		printline "()"

		require stack!=LastStack
		if stack > LastStack:					return "! Stack Too Large"
		|| Up = stack.GoUp	#require
		Stack += Up+1
		Depth++
		if (Up > 32):							return "! Stack Chain Invalid"
		if stack.Depth!=Depth:					return "! Stack Depth Invalid"
	return nil


