
// we need to respond to a few things:
	// pause
	// run
	// step over
	// step in
	// step out
	// ask for vars
	// ask for stack
	// hit breakpoints and stop!
	// deal with crashes.

// of course... we can't actually do these.
// not without the cake file
// So... lets say they press pause. what do we do? well... we can't do anything
// so what are we doing? Testing?
// planning?
// preparing?
// lets pretend we paused. then send back some messages.
// send back... variables, and stack

// what about asking for ASM? That goes through speedie.
// So might as well do that first?


module debugger
	|message|		Root
	|Message|		Globs
	|[string]|		Files
	|string|		SrcMap
	|&uint|			Base
	|int|			Length
	|bool|			GotBreaks
	|bool|			WantDebug
	|uint|			OverFlowTrack
	
	function Start
		opt norefcounts
		|| p = cake.perry
			debugger.Read(p, 5.0)
			if !.GotBreaks
				p <~ "error: nobreakpoints"

		
	function Read (|SpdProcess| Perry, |float| Delay)
		while (|| m = perry.Get(delay))
			.HandleRead(m)
		

	function HandleRead (|message| M)
		require m.expect(@tmp)
		if m == "breakpoints"
			.GetBreaks(m)
	
	
	function GetBreaks (|message| B)
		.GotBreaks = true
		for F.fast in b[@arg]
			if f.expect(@tmp)
				printline f
	
	
	function StartUp (|&int|)
		cake.vm.__View__ = __Viewer__
		return cake.VM.IsDebugging(debugger.WantDebug or cake.perry)
	
	
	function Path (|int| i, |filewithdata|)
		opt norefcounts
		|| Path = .files[i]
		expect Path!=nil ("Missing file at index: " + i)
		if path isa FileWithData
			return path

		|| p = FileWithData(path)
		debugger.files[i] = p
		return p
	
	
	function __Viewer__ (cakevm.CakeChef)
		opt norefcounts
		if index < 0 // stack overflow  or crash
			return .PrintCrashTrace(Index, Reg0|&CakeStack|)

		if index >= debugger.Length
			check (!stderr.ok) ("Code map too short: " + index)
			return 0
		
		|| Where = debugger.Base![index]
		|| Path = debugger.path(where & (11~bits))
		|| fn = spdtable.Find(index)
		if path
			|| TabTo = .PrintCodeLocation(Path, fn, Where>>11 )
			if fn and fn.HasVar(index)
				.PrintStackVars(index, fn, Reg0, TabTo)


	function spdfunc.HasVar (|int| Index, |bool|)
		opt norefcounts
		for v in .obj|&nil||[xvar]|
			if v contains index
				return true
	
		
	function Load (|bool|)
		opt norefcounts
		|| R = .root
		if !R
			expect (!debugger.WantDebug)	("Program file doesn't contain debug info. Remove -d to run it.")
			return true

		|| L = .LoadDebug(R)
		|| L2 = SpdTable.CodeLength
		
		expect (L < 1MB)					("Oversized source-map: " + L)
		expect (L2 == L)					("Map-length is: " + L) + (" but code-length is: " + L2)
		
		if Platform.IsDebug or debugger.wantdebug
			.BreakAll
		
		for fn in SpdTable.funcs
			fn.loadvars
		return StdErr.ok
		

	helper LoadDebug (|message| R, |int|)
		opt norefcounts
		xtype.loadtypes R["class"]
		.Globs = R["glob"]
		.Files = R["files"].value.decompress.Split
		.SrcMap = R["pos"]
		.base = .SrcMap.Addr|&uint|
		rz = .SrcMap.Length >> 2
		.Length = rz					// just for speed


	function BreakAll
		|| s = cake.BreakPoints
			for i in spdtable.CodeLength
				s[i] = 1<<31

		
		
function CakeVM.PrintCodeLocation (|FileWithData| File,  |spdfunc| fn,  |uint| Position, |int|)
	print "\t\t\t\t\t\t"
	if TerminalColor.Enabled
		print terminalcolor.green.render
	
	print file.filename
	print " "
	if fn
		print fn.name
		print ": "
	
	if TerminalColor.Enabled
		print TerminalColor.normal

	|| Code = File.GetLine(position)
	|| comment = Code.find("//") // whoop!
		Code = Code[0, comment]
	Code = Code.trim

	printline Code
	return 7 + file.filename.Length + fn.Name.Length


function CakeVM.PrintStackVars (|int| Index, |spdfunc| Fn, |&ivec4| Reg0, |int| TabTo)
	opt norefcounts 
	index -= fn.Position
	for v in fn.obj|[xvar]|
		if v contains index
			print "\t\t\t\t\t\t"
			v.Print(reg0, TabTo)
	printline



/*
	OK... so how does... the code get stored?
	At the start... the start stack contains .Code of the END of the VM
	so thats no use.

	Lets say we go to the next stack... OK fine.
	So... whats the code return point? Well... its the calling function?
	So... lets say we call a func from main. The .code of the second one...
	Would be "main" but its not where we jumped TO.
	
	It might be useful, tho. I mean... 
	
	We COULD store the latest jump point, but its not very useful.
	
	We COULD... do the checking (without crashing) in bumpstack? I mean...
	its better, right?

	What if main had a HALT instruction? then we don't need a HALT when main returns
	
	It kinda makes sense? I think its the only way to test this anyhow.
*/


function CakeVM.PrintCrashTrace (|int| Err, |?&CakeStack| LastStack,  |int64|)
	opt norefcounts
	"****** CRASHED ******"
	|| BadMsg = .PrintStackTrace(err, laststack)
		print "\t"
		printline BadMsg
	"---------------------"


function CakeVM.PrintStackTrace (|int| Err, |?&CakeStack| LastStack,  |?string|)
	opt norefcounts
	require LastStack and (err == ErrStillInRange or ErrOverFlow)
	require !debugger.OverFlowTrack++

// Still need this to be printed AND we need it to be capturable
// into FastString... maybe with the new JB_FS_AppendVArg idea?
// its possible? I think so! Even the date!

//Tue Feb 10 23:49:23 2026
//Signal 11 in /tmp/SpeedieApps/6074286623726617078/hello_world [
//]
//
//0   JB_App__BackTrace + 28
//1   JB_CrashTracer + 56
//2   JB_CrashHandler + 352
//3   _sigtramp + 56
//4   JB_App__Crash + 60
//5   JB_Main + 20
//6   JB_SP_Run + 344
//7   main + 28
//8   start + 7184


	error.KeepStackTrace = false
	|| Stack = (.Registers(false)-2)|&CakeStack|
	|| Count = 0
	while Memory.Test(Stack, 16)
		if (Count >= 1K):						return "..." // huge stacks aren't that useful...
			
		|| CodePtr = Stack.Code
		if !CodePtr:							return "Missing CodePtr"
		if Count								// the first code isn't anything useful, its main anyhow.
			print "\t"
			|| index = .index(CodePtr)
			|| fn = spdtable.Find(index)
				print fn.Name
			  else
				print "[Unknown]"				// Avoid string/memory alterations by using faststring...
			printline "()"
//		  else									// Could upgrade JB_FS_AppendVArg to print directly. No objects.
//			print "main"
//		printline "()"
		if stack== LastStack:					return nil
		if stack > LastStack:					return "Stack Too Large"
		Count++
		Stack += Stack.GoUp+1
		if stack.Depth!=Count+1
			if stack.Depth
				return "Stack Depth Invalid"
			 // allow... as last one
			LastStack = stack
	return nil


