

module SpdTable 
	|int|			LinksOK
	|int|			CodeLength
	|bool|			FailedIndex
	|[SpdFunc]|		Funcs
	|spdfunc--|		CurrFunc
	|&&nil|			LibFuncs = cakerun.LibFuncs
	
	function Find (|int| index, |spdfunc|)
		opt norefcounts
		for f in .funcs
			|| P = f.Position
			if  index >= P  and  index < P + f.RangeLength
				return f
		
		if !.FailedIndex
			.FailedIndex = true
			error "Can't find code index: " + index
	
	
	function RunMain (|ind|)
		opt norefcounts
		|| main = .funcs[2]					#expect ("Missing main")
		|| init = .funcs[1]!
		debugger.Start
		if (init.Run|&int64|[] == 0)
			return main.Run|&int64|[]
		error "Init failed"
	
	
	function Message.CodeLength (|int|)
		opt norefcounts
		if .func != @tmp
			return .Length
		|| f = .first
			return f.Length
		
	function PreLoad (|message| code)
		opt norefcounts
		.funcs <~ SpdFunc()							// null func
		|| CodeLength = 0
				
		for spd.fast in code
			if spd == @num
				for spd.int
					.funcs <~ .funcs[0]
			  else
				spd.tag = .funcs.Length
				spd.Position = CodeLength
				.funcs <~ spd
				CodeLength += spd.CodeLength>>2
			expect (.funcs < 32K)		(spd, "Too many functions. An entire compiler would only need 3K funcs!")

		.Funcs.Shrink		
		check  (CodeLength < 1MB)					(code, "Oversized code: " + CodeLength)
		check  (.funcs >= 3)						(code, "Missing 'main'")
		
		.CodeLength = CodeLength


	function CopyToVM (|message| code)
		opt norefcounts
 
		.PreLoad(code)
		for spd.fast in code
			spd.CopyToVM
	

	function SpdFunc.ASMStart (|&ASM|)
		|| i = .Position
			return cake.BeginCode + i
	
	
	function Link (|&asm|)
		opt norefcounts
		for f in .funcs
			f.Link❗


	function spdfunc.Link❗
		// could be multi-threaded... doesn't allocate / alter ptrs :] // no need for now.
		|| Code = .position$
		spdtable.CurrFunc = self
		|| Base = Cake.BeginCode + Code
		|| after = base + .Length

		while base < after
			|| asm = base[]
			|| Op = asm.op
			if op.IsSPDFunc
				base.PutCandlesOnCake(asm)
			  elseif op.IsGlob and asm.IsLibGlob
				base.LibGlob(asm)
			base += asm.size


function asm.PutCandlesOnCake (|&asm| self, |asm| Old) // SPDLink, LinkFunction, linkall
	opt norefcounts
	|| ID = ((Old << 13) >> 13) - 31
	require ID > 0 // not a register!
	
/	|| fn = SpdTable.Funcs[id]
		|| Pos = fn.ASMStart						// Fast-branch for speed.
			|| Jump = self - Pos					// 19-bits // later we can upgrade to 21-bit
			if  Jump  ==  (Jump << 13) >> 13
				|| Final = (Jump|uint| << 13) >> 13
				Final |= (Old>>24) << 24
				self[] = Final
//				fn.DebugSuccess(id)
				return
			expect (false) (spdtable.Currfunc, "Executable too large to link: " + fn.name )
		expect (false) (spdtable.Currfunc, "Function was trimmed: " + fn.name )
	error (spdtable.Currfunc, "Bad function ID: "  + id )


function asm.LibGlob (|&asm| self, |asm| Old) // Globlink, DoGlobs
	opt norefcounts
/	|| ID = (Old << 15) >> 15
	expect (ID > 0 and ID < globals.LibMax)					(spdtable.Currfunc, "Bad LibGlob ID: " + ID )
	
	ID = globals.LibLink![ID]
	if (old.op == asm.GOBJ)
		old = (Old >> 17) << 17
		old |= ID >> 3
	  else			//GTAB
		old = (Old >> 18) << 18
		old |= ID
	self[] = old

