

module SpdTable 
	|int|			LinksOK
	|int|			CodeLength
	|bool|			FailedIndex
	|[SpdFunc]|		Funcs
	|spdfunc--|		CurrFunc
	|&&nil|			LibFuncs = cakerun.LibFuncs
	
	function Find (|int| index, |spdfunc|)
		opt norefcounts
		for f in .funcs
			|| P = f.Position
			if  index >= P  and  index < P + f.RangeLength
				return f
		
		if !.FailedIndex
			.FailedIndex = true
			error "Can't find code index: " + index
	
	
	function RunProgram (|int|)
		debugger.Start
		|| Err = .RunFunc(1)
			return Err
		Err = .RunFunc(2)
		if err
			return err
	
	
	function RunFunc (|int| i, |int|)
		opt norefcounts
		|| fn = .funcs[i]					#expect ("Missing function: " + i)
		|| ExitReg = fn.Run
			|| Err = ExitReg|&int64|[]
			|uint| MiniErr = Err
			if err and !MiniErr
				MiniErr = -1 // sigh
			return MiniErr
		return Cake.vm.CakeFail&255 ?? -1

	
	function Message.PreLoadLength (|int|)
		opt norefcounts
		if .func != @tmp
			return .Length
		|| f = .first
			return f.Length
	
	
	function PreLoad (|message| code)
		opt norefcounts
		.funcs <~ SpdFunc()							// null func
		|| CodeLength = 0
				
		for spd.fast in code
			if spd == @num
				for spd.int
					.funcs <~ .funcs[0]
			  else
				spd.tag = .funcs.Length
				spd.Position = CodeLength
				.funcs <~ spd
				CodeLength += spd.PreLoadLength>>2
			expect (.funcs < 32K)		(spd, "Too many functions. An entire compiler would only need 3K funcs!")

		.Funcs.Shrink		
		check  (CodeLength < 1MB)					(code, "Oversized code: " + CodeLength)
		check  (.funcs >= 3)						(code, "Missing 'main'")
		
		.CodeLength = CodeLength


	function CopyToVM (|message| code)
		opt norefcounts
 
		.PreLoad(code)
		for spd.fast in code
			spd.CopyToVM
	

	function SpdFunc.ASMStart (|&ASM|)
		|| i = .Position
			return cake.BeginCode + i
	
	
	function spdfunc.length
		disabled "Do you mean message.length or spdfunc.rangelength?"
		
		
	function spdfunc.Link‚ùó
		// could be multi-threaded... doesn't allocate / alter ptrs :] // no need for now.
		|| Code = .position$
		spdtable.CurrFunc = self
		|| Base = Cake.BeginCode + Code
		|| after = base + .RangeLength

		while base < after
			|| asm = base[]
			|| Op = asm.op
			if op.IsSPDFunc
				base.PutCandlesOnCake(asm)
			  elseif op.IsGlob and asm.IsLibGlob
				base.LibGlob(asm)
			base += asm.size



function asm.PutCandlesOnCake (|&asm| self, |asm| JumpAndReg) // SPDLink, LinkFunction, linkall
	opt norefcounts
	// JumpAndReg(FNC) == Op(8), Reg(5), Jump(19)
	
	|| Op = JumpAndReg >> 24								// FNC or FNC3
	|| Reg = (JumpAndReg >> 19) & 31
	|| ID = (JumpAndReg & 19~bits) - 31
	require  ID > 0											// IDs 0-31, are registers. The first 32-funcs are empty.
	
	|| fn = SpdTable.Funcs[id]
		|| Pos = fn.ASMStart								// Fast-branch for speed.
			|| Jump = (Pos - Self)|int|						// 19-bits
			Jump -= 2
			Jump -= op&1
			|| EncodedJump = Jump&19~bits
			if  (EncodedJump<<13)>>13  ==  Jump
				self[] = (EncodedJump) ||| (Reg << 19) ||| (Op<<24)
				return

			error (SpdTable.CurrFunc, "Executable too large to link: " + fn.name )
			return
		error (SpdTable.CurrFunc, "Function was trimmed: " + fn.name )
		return
	error (SpdTable.CurrFunc, "Bad function ID: " + id )



function asm.LibGlob (|&asm| self, |asm| Old) // Globlink, DoGlobs
	opt norefcounts
/	|| ID = (Old << 15) >> 15
	expect (ID > 0 and ID < globals.LibMax)					(spdtable.Currfunc, "Bad LibGlob ID: " + ID )
	
	ID = globals.LibLink![ID-1]
	expect (ID != 16~bits)									(spdtable.currfunc, "Global missing in libarry")
	if (old.op == asm.GOBJ)
		old = (Old >> 17) << 17
		old |= ID >> 3
	  else			//GTAB
		old = (Old >> 18) << 18
		old |= ID
	self[] = old

