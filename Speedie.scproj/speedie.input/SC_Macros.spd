
/*
	Speedie Internals. By Theodore H. Smith...
*/

module Macros {
//|| FS = "|| fs = faststring()".macro

|| InitExpand = "({
	|| _X = _0
	if _X == nil // useful for initing arrays... which could start as nil
		_X = _1
		_0 = _X
	rejoin _X
})".macro

|| WhileDecl = "if (!_0) {
	exit
}".macro



|| MultiDecr = `JB_DecrMulti(_0, _1)`.macro

|| ConstructorNew = `if self == nil {
	self = JB_NewClass(_0)|_0|}`.macro
|| ConstructorNewTask = `if self == nil {
	self = task(â€“taskvars, &run)|_0|
}`.macro
|| MainArgBasic      = `|| _0 =  _1.MainArg(_2+1, "_0"),           `.macro
|| MainArgBasicReq   = `|| _0 =  _1.MainArg(_2+1, "_0") #require,  `.macro
|| MainArgDefault    = `|| _0 =  _1.MainArg(-(_2+1), "_0"),  _0 ?= _3 `.macro
|| MainArgArray      = `
|[_1]| _0
|| __ArgCurr = _2
while __ArgCurr < __ArgCount
	_0 <~ _1.MainArg(++__ArgCurr, "_0")
`.macro

|| MainArgNoNE = `
	check (__ArgCount <= _0) ("Unexpected argument: " + app.args[_0]!)
`.macro
}



function macro.clean (|macro|)
	if !.Cleaned
		.cleaned = true
		|| s = .source
			s.clean
	return self



function message.TargetTestOp (|message| C, |int|)
	opt norefcounts
	if C
		|| n = .name
		if n == "or"
			return 1
		if n == "and"
			return 2
	.SyntaxExpect // failed

	
function message.TargetTest (|bool|) // target true, target false,
	opt norefcounts
	real self
	while .func == @bra
		self = .first!

	|| fn = .func
	if fn == @rel
		|| C = .last
		|| op = .second!.TargetTestOp(C)$
		|| AOK = .first!.TargetTest
		if (op == 1) == AOK
			return AOK
		return C!.TargetTest		
	
	if (fn == @brel) and (self == "!")
		return !.first!.TargetThg
	
	if .expect(@thg)
		return .TargetThg


function message.TargetThg (|bool|) // target true, target false,
	expect (self ~!= "mac" or "macos")     (self, "Use OSX")
	expect (self ~!= "linux")   (self, "Use lin")
	expect (self ~!= "windows") (self, "Use win")
	expect (self ~!= "import")  (self, "Use imported")
	if self ~= "cake"
		return options.mode == options.cake
	if self ~= "cpp"
		return options.mode == options.cpp
	if self ~= "debug"
		return options.TargetDebug
	if self ~= "perry"
		return options.perryoutput
	if self ~= "imported"
		return scimport.CurrIsManuallyImported
	if self ~= "osx"
		return Platform.osx
	if self ~= "win"
		return Platform.win
	if self ~= "lin"
		return Platform.lin
	if self ~= "vm"
		return Linkage.vm
	if self ~= "exec"
		return Linkage.interpreter
	if self ~= "direct"
		return options.IsDirectTest
	if self ~= "true"
		return true
	if self ~= "library"
		return Options.ProjectisLibrary
	if self ~= "minilib"
		return options.ProjectIsMiniLib
		
	return SC_Targets[.name]



function message.Tran_Target (|message|)
	.tran_targetsub
	rz  = .next
	rz ?= .flatafter
	.Remove


function message.TranAllTargets
	opt norefcounts
	for s.flat in self
		if s == "target"
			continue_with s.tran_target


function message.Tran_TargetSub
	opt norefcounts
	|| value = self.needfirst					#require
	|| arg = self[@arg, 1]						#require
	if !value.TargetTest
		arg = self[2][@arg]

// can't handle target false
	while arg.hasany
		.next = arg.pop


function message.BecomeTarget
	opt norefcounts
	|| s = self[@nil,1]$
	|| b = s.TargetTest.string
	.become(@thg, b)
		
	
	
