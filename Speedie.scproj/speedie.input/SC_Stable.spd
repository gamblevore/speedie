

module Stability
	|| LastLibID = 0

	function StabiliseFuncs
		if !packmaker.libfuncs
			PackMaker.AddAll
		.StabiliseSub("stable_id_bank.txt", packmaker.libfuncs)
		.Debug
	
	
	function StabiliseGlobs 
/		return .StabiliseSub("stable_glob_bank.txt", packmaker.libglobs)
	
	
	function StabiliseSub (|string| name, |[scobject]| list)
		.LastLibID = 0
		|| funcs = Compiler.library[name]
		|| Data = funcs.ReadAll.trim
		stability.UseFuncBank(data)
		|| fs = (faststring(), nil)(options.MakeExec)
			fs <~ data ?? "// beta-file. Unstable."
		.StabliseFuncsSub(fs, list)
		if fs
			funcs.SmartData = fs|string|
		
	
	function scobject.NeedsID (|bool|)
		require self isnt private
		if self isa SCFunction
			if !.IsLibrary// huh?
				"ooof"
				debugger 
			require !.IsMacro and .IsLibrary
			require self isnt disabled and AlwaysInline
		return true
	
	
	function Debug 
		target debug
			for f in packmaker.libfuncs
				print f.packid|int|
				print " "
				printline f.exportname

	
	function StabliseFuncsSub (|faststring| fs, |[scobject]| list)
		opt norefcounts
		|&&nil| Table		// just pass 4096. Saves all the fÃ¼cking around with calculating sizes.
		|| frogs = packmaker.PackGlobSize, (frogs)
		target debug
			if frogs and !options.MakeExec
				Table = jb_vm.vm.InitTable(4096, frogs)

		list.Sort(&CodeSorter.PackIDAndExportName)
		
		for fn in list
			if fn.NeedsID
				fn.MakeID(fs, table)
			
	
	function BuildLibGlobTable (|message| T, |dictionary of scdecl| table = dictionary())
		opt norefcounts
		for d in PackMaker.LibGlobs
			table[d.ExportName] = d
			if d.ExportPosition					// hmmm... shouldn't happen

		for row in T
			|| d = table[row.name]
				|| pos = row[@num]
					d.ExportPosition = pos.int	
	
	
	function DumpGlobs (|faststring| fs=faststring(), |file| f)
		opt norefcounts
		for d in PackMaker.LibGlobs
			fs <~ "${d.exportname} ${D.exportposition}\n"
		f.SmartData = fs
	
	
	function packmaker.OrderLibGlobs // why is it done from the main compile func and not in the execmaker?
		opt norefcounts
		.LibGlobs.Sort(SimplestFirst)			// sort them so empty values come after
		._LibGlobSize = .GlobalsSize(.libglobs) // rebuild size
	
		
	function scobject.MakeID (|faststring| fs, |?&&nil| table)
		|| id = .PackID
		if !id
			if fs
				fs <~ "\n$.ExportName"
			id = Stability.LastLibID++
			.PackID = id
		
		if table
			|| fn = jb_vm.Load(.exportname) // an actual function pointer for testing
				Table[id+31] = fn

	
	function UseFuncBank (|string| Data)
		// what about globs?
		|| ID = .LastLibID
		for str.lines in data
			id++
			|scbetternode--| fn = Compiler.ExportNames[str]
			if fn isa SCFunction
				if !fn.islibrary // huh? 
				
				check (!fn.PackID) (str + " replicated ID.")
				fn.PackID = id
		.LastLibID = ID	
	
