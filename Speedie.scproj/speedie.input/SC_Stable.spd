

module Stability
	|| LastID = 1

	function StableLoad (|bool|)
		|| frogs = packmaker.PackGlobSize
		|| bank = Compiler.library["stable_id_bank.txt"]
		if bank.Open(true)
			.UseBank(bank)
			|faststring| fs
			if options.UpdateStability
				fs = faststring()
				if !bank.Size
					bank <~ "// This file is not stable till 'release'. Libfuncs will get removed."
			.FillMissingLibFuncs(fs, frogs)
			if fs and fs.Length
				bank <~ "\n"
				bank <~ fs|string| // hehe
			rz = true

	

	function FillMissingLibFuncs (|faststring?| fs, |int| frogs)
		opt norefcounts
		for cl in Compiler.ClassList
			if cl.NeedID
				cl.MakeID(fs, nil)
		
		|&&nil| Table
		if platform.isdebug
			// I could just figure out the correct size, using the highest-number found in the table
			// plus space for all missing items, plus 31, plus perhaps some sentinel space. And hope its right
			// or just pass 4096
			Table = jb_vm.vm.InitTable(4096, frogs)

		for fn in Compiler.FuncList
			if fn.NeedsID
				fn.MakeID(fs, table)
		
	
	function scfunction.NeedsID (|bool|)
		require !.IsMacro and .IsLibrary
		require self isnt disabled
		require self|scnode| isnt private
		return true
		
	function scclass.NeedID (|bool|)
		return .IsLibrary and (!.isrole and .IsObject)
	
	
	function scbetternode.MakeID (|faststring| fs, |?&&nil| table)
		|| id = .PackID
		if !id
			if fs
				if fs.Length
					fs <~ "\n"
				fs <~ .ExportName
			id = Stability.LastID++
			.PackID = id
		if table
			|| fn = jb_vm.Load(.exportname) // an actual function pointer for testing
				Table[id+31] = fn
				"id: ${id}(${id+31}) = $.exportname"
				

	function UseBank (|file| bank)
		|| data = bank.ReadAll(1MB)
			|| ID = LastID
			for str.lines in data
				id++
				|| fn = Compiler.ExportNames[str]
					check (!fn.PackID) (str + " replicated ID.")
					fn.PackID = id
			// now we have all the IDs set. But what if we have some not inside? we need to handle those too
			LastID = ID	
		
