

module Stability
	|| LastID = 1

	function Load
		|| frogs = packmaker.PackGlobSize
		|| bank = Compiler.library["stable_id_bank.txt"]
		if bank.Open(true)
			.UseBank(bank)
			if options.UpdateStability
				|| fs = FastString()
				.FillMissingLibFuncs(fs, frogs)
				if fs.Length
					if bank.size > 0
						bank <~ "\n"
					bank <~ fs|string| // hehe

	

	function FillMissingLibFuncs (|faststring| fs, |int| frogs)
		opt norefcounts
		for cl in Compiler.ClassList
			if cl.NeedID
				cl.MakeID(fs)
		
		|&&nil| Table
		if platform.isdebug
			Table = jb_vm.vm.InitTable(packmaker.libfuncs.length+31, frogs)

		for fn in PackMaker.LibFuncs
			if !fn.IsMacro and fn isnt disabled
				|| id = fn.MakeID(fs)
				if table
					Table[id+31] = jb_vm.Load(fn.exportname) // an actual function pointer for testing
		
		
	function scclass.NeedID (|bool|)
		return .IsLibrary and (!.isrole and .IsObject)
	
	
	function scbetternode.MakeID (|faststring| fs, |int|)
		|| id = .PackID
			return id
		if fs.Length
			fs <~ "\n"
		fs <~ .ExportName
		id = Stability.LastID++
		.PackID = id
		return id
				

	function UseBank (|file| bank)
		|| data = bank.ReadAll(1MB)
			|| ID = LastID
			for str.lines in data
				id++
				|| fn = Compiler.ExportNames[str]
					check (!fn.PackID) (str + " replicated ID.")
					fn.PackID = id
			// now we have all the IDs set. But what if we have some not inside? we need to handle those too
			LastID = ID	
		
