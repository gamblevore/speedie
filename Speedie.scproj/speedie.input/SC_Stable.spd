

module Stability
	|| LastID = 1

	function Load (|bool|)
		|| frogs = packmaker.PackGlobSize
		|| bank = Compiler.library["stable_id_bank.txt"]
		if bank.Open(true)
			.UseBank(bank)
			|faststring| fs
			if options.UpdateStability
				fs = faststring()
			.FillMissingLibFuncs(fs, frogs)
			if fs and fs.Length
				if bank.size > 0
					bank <~ "\n"
				bank <~ fs|string| // hehe
			rz = true

	

	function FillMissingLibFuncs (|faststring?| fs, |int| frogs)
		opt norefcounts
		for cl in Compiler.ClassList
			if cl.NeedID
				cl.MakeID(fs, nil)
		
		|&&nil| Table
		if platform.isdebug
			Table = jb_vm.vm.InitTable(packmaker.libfuncs.length+31, frogs)

		for fn in PackMaker.LibFuncs
			if !fn.IsMacro and fn isnt disabled
				fn.MakeID(fs, table)
		
		
	function scclass.NeedID (|bool|)
		return .IsLibrary and (!.isrole and .IsObject)
	
	
	function scbetternode.MakeID (|faststring| fs, |?&&nil| table)
		|| id = .PackID
		if !id
			if fs
				if fs.Length
					fs <~ "\n"
				fs <~ .ExportName
			id = Stability.LastID++
			.PackID = id
		if table
			|| fn = jb_vm.Load(.exportname) // an actual function pointer for testing
				Table[id+31] = fn
				"id: ${id}(${id+31}) = $.exportname"
				

	function UseBank (|file| bank)
		|| data = bank.ReadAll(1MB)
			|| ID = LastID
			for str.lines in data
				id++
				|| fn = Compiler.ExportNames[str]
					check (!fn.PackID) (str + " replicated ID.")
					fn.PackID = id
			// now we have all the IDs set. But what if we have some not inside? we need to handle those too
			LastID = ID	
		
