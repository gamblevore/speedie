
module Stability
	|| LastID = 1
	
	// todo: empty spots need to be replaced with dummy decls
	function StabliseFuncs (|file| funcs)
		|faststring| fs
		if options.UpdateStability
			fs = faststring()
			if !funcs.Size
				fs <~ "// This file is not stable till 'release'."
			fs <~ "\n"
			fs.file = funcs
		.FillMissingLibFuncs(fs, packmaker.PackGlobSize)
		if fs and fs.Length > 1
			fs <~ "\n"
			fs.flush
	
	
	function BuildLibGlobTable (|message| T, |dictionary of scdecl| table = dictionary())
		opt norefcounts
		for d in PackMaker.LibGlobs
			table[d.ExportName] = d
			if d.ExportPosition // hmmm... shouldn't happen

		for row in T
			|| d = table[row.name]
				|| pos = row[@num]
					d.ExportPosition = pos.int	
	
	
	function DumpGlobs (|faststring| fs=faststring(), |file| f)
		opt norefcounts
		for d in PackMaker.LibGlobs
			fs <~ "${d.exportname} ${D.exportposition}\n"
		f.SmartData = fs
	
	
	function packmaker.OrderLibGlobs
		opt norefcounts
//		stability.DumpGlobs
		.LibGlobs.Sort(SimplestFirst)	// sort them so empty values come after
//		stability.DumpGlobs

		target debug
			|| EmptyFound = false
			for d in .libglobs
				if !EmptyFound and !d.exportposition
					EmptyFound = true
				  elseif emptyfound and d.exportposition
					debugger // argh?
		
/		._LibGlobSize = .GlobalsSize(.libglobs) // rebuild size


	function StabliseGlobs
		|| globs = Compiler.library["stable_glob_bank.txt"]
		|| str = globs.readall(64K)
		// need to NOT remove unfound items
		// so now we know the order is OK... now what?
		.BuildLibGlobTable(str.parse)			// fill table with old values
		packmaker.OrderLibGlobs
		if options.updatestability
/			.DumpGlobs(	globs)


	function FillMissingLibFuncs (|faststring?| fs, |int| frogs)
		opt norefcounts		
		|&&nil| Table		// just pass 4096. Saves all the fÃ¼cking around with calculating sizes.
		if platform.isdebug
			Table = jb_vm.vm.InitTable(4096, frogs)

		|| lst = Compiler.FuncList.CopySort(&CodeSorter.exportnames)
		for fn in lst
			if fn.NeedsID
				fn.MakeID(fs, table)
		
	
	function scfunction.NeedsID (|bool|)
		require !.IsMacro and .IsLibrary
		require self isnt disabled and AlwaysInline
		require self|scnode| isnt private
		return true
	
		
	function scfunction.MakeID (|faststring| fs, |?&&nil| table)
		|| id = .PackID
		if !id
			if fs
				if fs.Length
					fs <~ "\n"
				fs <~ .ExportName
			id = Stability.LastID++
			.PackID = id
		
		if table
			|| fn = jb_vm.Load(.exportname) // an actual function pointer for testing
				Table[id+31] = fn

	
	function UseFuncBank (|file| bank)
		|| data = bank.ReadAll(1MB)
			|| ID = LastID
			for str.lines in data
				id++
				|| fn = Compiler.ExportNames[str]
				if fn isa SCFunction
					check (!fn.PackID) (str + " replicated ID.")
					fn.PackID = id
			LastID = ID	
		
