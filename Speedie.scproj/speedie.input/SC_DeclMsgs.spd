


function DeclsDefault (|Message| def, |Message|)
	opt norefcounts
	if def.issetrel
		|| f = def.first
		|| l = def.Last
		if l == @thg
			expect !(f.name ~= l.name) (def, "Same name!")
		Return l


function MakeDecl (|string| Type, |string| Name, |Message| Value, |Message|)
	rz = «decl »
	if (Type)
		|| arg = rz.msg(@arg)
		(arg is style2)
		arg <~ (@thg, type)
	  else 
		rz <~ @emb
	
	|| NameMsg = «thg name »
	if value
		|| Rel = «rel
			NameMsg
			@opp+"="
			value
		»
		NameMsg.obj = CopyDecl( value, name )
		Rel.obj = NameMsg.obj
		NameMsg = Rel
	
	rz <~ NameMsg


function MakeDeclOrRel (|Message| Into, |message| namemsg, |Message| value, |Message|)
	require into
	rz = «decl
		«emb »
	»
	
	if value
		Value = NeweqRel( NameMsg, value )
	  else
		Value = NameMsg
	rz <~ value
	into.First = rz



function SCDecl.NoFloat (|Message| exp, |bool|)
	|| T = .type.TypeInfo
	expect (T != DataTypeCode.UnusedType)	(exp, "Can’t do bit ops on this")
	expect (!T.isfloat)						(exp, "Can’t do bit ops on floats")
	return true



function DefaultStitch (|Message| Default, |Message| args)
	opt norefcounts
	|| name = args.second
	using (args)
	|| rel = «rel »
	name.next = rel
	rel <~ name
	rel.msg(@Opp,"=")
	rel <~ Default




// these can remain...
function scfunction.CollectDeclsFuncArgs (|Message| prms, |SCBase| AddToSpace, |bool|)
	opt norefcounts
	|| cls = .Cls
		if !prms.HasSelfAsFirst
			cls.AddSelfToFunc(addtospace)
			.args <~ cls.SelfDecl
	  else
		cls = (.lookup as SCModule).Cls

	for item in prms
		// can remove some shit thats only applicable here... :D
		require item.collectdecl(self, AddToSpace, 4, .args, cls)
	return true


function SCClass.CollectDeclsProperties (|bool|)
	return CollectDeclsMulti( .sourcearg, .Modul, self, 3, .properties, self)


function CollectDeclsGlobals (|Message| arg, |SCBase| scarg)
	CollectDeclsMulti(arg, scarg, scarg, 1, nil)


// remove these... but later.
function CollectDeclsFuncBodyJustWhatWeNewlyMade (|Message| arg, |SCBase| scarg) 	// remove later... :)
	CollectdeclsMulti(arg, scarg, scarg, 8, nil)			// basically... the caller needs fixing.


function CollectDeclsFuncBodyUnsureHowToRemove (|Message| arg, |SCBase| scarg)
	CollectDeclsFuncBodyJustWhatWeNewlyMade(arg, scarg)


// definitely remove this!
function CollectDeclsFuncBody (|Message| arg, |SCBase| scarg)
	CollectdeclsMulti(arg, scarg, scarg, 8, nil)


function CollectDeclsMulti (|Message| List, |SCBase| P, |SCBase| Recv, |int| Mode, |[SCDecl]| out, |scclass| cls=nil, |bool|)
	opt norefcounts
	for item in list
		require item.collectdecl(p, recv, mode, out, cls)
	return true


function Message.CollectDecl (|SCBase| P, |SCBase| Recv, |int| Mode, |[SCDecl]| out, |scclass| cls, |bool|)
	|SCFunction--|	Func = (P|scfunction|, nil)(Mode == 4)

	if (func and func.isassigns == 2) and .islast
		if !cls
			error (self, "Can’t use this here." )
		  else
			// fn x (|int|) --> fn x (|int| value)
			func.IsAssigns = 3
			if cls.IsDataType
				.next = .copy // fn x (|int|) --> fn x (|int| value, |int|)
			.addvalue(func)
		
	if self == @Item
		expect  (Func)  (self, "Can’t use this here." )
		if .first == "assigns" // remove this after fixing galaxxies :(
			self = .Last
			func.IsAssigns = 1
			.addvalue(func)

	if self != @Decl
		return (!Func) #expect ( self, "Not a declaration." )

	|| Types = .first
	|| Names = types.Next				

	expect (Func or Names)  (self, "No name found.")
	if (Mode & 2)
		expect (names == @thg) (names, "Must be a proper name (a-z or unicode-letters)")

	|| Default = DeclsDefault( names )
	|| Sdcl = ExtractDecl( Types, P )
	if (!sdcl and !default and (P isa SCArg))
		sdcl = P.ParentFunc.ReturnType

	
	|SCDecl--| DefaultDcl
	if func
		0
	  elseif (Default)
		DefaultDcl = TypeOfExprNeeded( Default, P ) #require
		if (sdcl)   // make sure it matches.
			default = sdcl.ExpectMatch( DefaultDcl, kTypeCastTrue, default )
		
	  elseif (cls)
		0 // no defaults... its a property
		
	  elseif (sdcl) and ( !Default ) and (sdcl.CanUseDefault)
		Default = sdcl.CreateDefault(types, Recv isa SCArg)
		if (Default)
			TypeOfExpr( default, P )
			DefaultStitch( Default, self )
	
//		require (stderr.errorcount == OriginalErrCount)
	
	|bool| NoOriginalDcl = !Sdcl
	if (NoOriginalDcl)
		if (cls) and (cls.Contained)
			sdcl = cls.Contained // (|| x = Y), (|object| x = Y)
		  else
			expect (!Func and defaultdcl) ( self, ("Function declarations need a type. (Unless it's in a container class.)", "Missing type, or default value.")(!func) )
			sdcl = DefaultDcl
	
	expect !(func and sdcl is Borrowed) (self, "Variables can’t be borrowed in function parameters or return")
	
	if sdcl.NeedsContainedfix
		sdcl = sdcl.Containedfix
	
	if !names		// a return value, how to return the return value?
		expect ((Func and !func.ReturnType) and (!.Next)) ( self, "Parameter is missing a name." )
		if (Func)
			debugger (!sdcl.Default and sdcl isnt Borrowed)
			func.ReturnType = sdcl
		return true
	
	
	|| NameItm = .GetDclName #require
	|| dcl = Sdcl.copy
	
	if (Mode & 8) and NoOriginalDcl // functionbody
		if sdcl isnt StayBorrowed
			(Dcl Isnt Borrowed)
		dcl.nildeclared = NilState.Either // can be freely changed!
	
	nameitm.obj = dcl
	if (nameitm in @Rel)
		nameitm.Parent.obj = dcl
	
	dcl.Default = Default
	dcl.Name = nameitm.name
	(dcl Isnt Const) // erase IsConst, happens if we parse "|| bla = true"
	if func
		(dcl is param)
		(dcl isnt altered)

	if names and !Default
		if names.next == @list
			error names
		  else
			names.expectlast
			
	if (Mode&1)
		(dcl is property)
		if Mode == 1
			(dcl is onmodule)
		  else
			dcl.becomereal
		
	if out!=nil
		out <~ dcl
	nameitm.obj = dcl
	dcl.Source = self
	if default and defaultdcl
		dcl.ConstCheck(nil, default, DefaultDcl)
	
	if (Recv)
		Recv.TryAdd( nameitm, dcl, dcl.Name )
	return true



function Message.CollectFuncTableName (|string|)
	//	@msg.ID-->"msg"
	//	"abc"-->"abc"
	//	why? why not?
	if self == @name
		return .name.UpperCase
	if .name and self != @dot
		Return .Name

	Return .First.Name 
	

function scdecl.NeedsContainedfix (|bool|)
	opt NoRefCounts
	if !.AllocSource and !.contains
		return .ReallyContains


function scdecl.Containedfix (|scdecl|)
	opt norefcounts
	|| t = .type
	rz = (.copy, self)(T.typenormal == self)
	rz.contains = t.SelfDecl.Contains


function message.addvalue (|scfunction| f)
	opt norefcounts
	pragma inline
	if !.HasChildCount(2)
		using f.source
			self <~ «thg "Value"»
