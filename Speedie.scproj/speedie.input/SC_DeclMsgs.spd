


function DeclsDefault (|Message| def, |Message|)
	opt norefcounts
	if def.issetrel
		|| f = def.first
		|| l = def.Last
		if l == @thg
			expect !(f.name ~= l.name) (def, "Same name!")
		Return l


function MakeDecl (|string| Type, |string| Name, |Message| Value, |Message|)
	rz = «decl »
	if (Type)
		|| arg = rz.msg(@arg)
		(arg is style2)
		arg <~ (@thg, type)
	  else 
		rz <~ @emb
	
	|| NameMsg = «thg name »
	if value
		|| Rel = «rel
			NameMsg
			@opp+"="
			value
		»
		NameMsg.obj = CopyDecl( value, name )
		Rel.obj = NameMsg.obj
		NameMsg = Rel
	
	rz <~ NameMsg


function MakeDeclOrRel (|Message| Into, |message| namemsg, |Message| value, |Message|)
	require into
	rz = «decl
		«emb »
	»
	
	if value
		Value = NeweqRel( NameMsg, value )
	  else
		Value = NameMsg
	rz <~ value
	into.First = rz



function SCDecl.NoFloat (|Message| exp, |bool|)
	|| T = .type.TypeInfo
	expect (T != DataTypeCode.UnusedType)	(exp, "Can’t do bit ops on this")
	expect (!T.isfloat)						(exp, "Can’t do bit ops on floats")
	return true



function DefaultStitch (|Message| Default, |Message| args)
	opt norefcounts
	|| name = args.second
	using (args)
	|| rel = «rel »
	name.next = rel
	rel <~ name
	rel.msg(@Opp,"=")
	rel <~ Default




// these can remain...
function scfunction.CollectDeclsFuncArgs (|Message| prms, |SCBase| AddToSpace)
	opt norefcounts
	|| cls = .Cls
		if !prms.HasSelfAsFirst
			cls.AddSelfToFunc(addtospace)
			.args <~ cls.SelfDecl
	  else
		cls = .lookup|SCModule|.Cls

	for item in prms
		// can remove some shit thats only applicable here... :D
		require item.CollectFuncArg(self, AddToSpace, cls)


function Message.CollectFuncArg (|scfunction| func, |SCBase| Recv, |scclass| cls, |bool|)
	opt norefcounts
	if (func.isassigns == 2) and .islast
		if !cls
			error (self, "Can’t use this here." )
		  else
			// setter x (|int|) --> fn x (|int| value)
			func.IsAssigns = 3
			if cls.IsDataType
				.next = .copy // fn x (|int|) --> fn x (|int| value, |int|)
			.addvalue(func)
		
	if self == @Item and .first == "assigns"
		self = .Last
		func.IsAssigns = 1
		.addvalue(func)

	if .Expect(@decl)
		|| dcl = .CollectDecl(func, recv, 4, func.args, cls, func)
			(dcl is param)
			(dcl isnt altered)
			return true




function SCClass.CollectDeclsProperties (|bool|)
	opt norefcounts
	for item in .SourceArg
		if item == @decl
			require item.CollectProp( self)
	return true

function Message.CollectProp (|scclass| cls, |bool|)
	opt norefcounts
	|| dcl = .collectdecl( cls.modul, cls, 3, cls.properties, cls, nil)
		(dcl is property)
		dcl.becomereal
		return true



// remove these... but later.
function CollectDeclsGlobals (|Message| arg, |SCBase| scarg)
	opt norefcounts
	for item in arg
		if item == @decl
			require item.CollectAGlobalDecl(scarg)

function Message.CollectAGlobalDecl (|SCBase| scarg, |bool|)
	opt norefcounts
	|| dcl = .CollectDecl(scarg, scarg, 1, nil, nil, nil)	
		(dcl is property)
		(dcl is onmodule)
		return true
		



function CollectDeclsFuncBodyJustWhatWeNewlyMade (|Message| arg, |SCBase| scarg) 	// remove later... :)
	opt norefcounts	// basically... the caller needs fixing.
	for item in arg
		if item == @decl
			require item.CollectFromBody(scarg)

function Message.CollectFromBody (|SCBase| scarg, |bool|)
	opt norefcounts
	return .CollectDecl(scarg, scarg, 8, nil, nil, nil)



function CollectDeclsFuncBodyUnsureHowToRemove (|Message| arg, |SCBase| scarg)
	CollectDeclsFuncBodyJustWhatWeNewlyMade(arg, scarg)



// definitely remove this!
function CollectDeclsFuncBody (|Message| arg, |SCBase| scarg)
	CollectDeclsFuncBodyJustWhatWeNewlyMade(arg, scarg)


function Message.CollectDecl (|SCBase| P, |SCBase| Recv, |int| Mode, |[SCDecl]| out, |scclass| cls, |scfunction| func,  |scdecl|)
	// cna remove Recv also! only used at end or for modetesting (Funcarg)
	|| Types = .first
	|| Names = types.Next				

	expect (Func or Names)  (self, "No name found.")
	if (Mode & 2)
		expect (names == @thg) (names, "Must be a proper name (a-z or unicode-letters)")

	|| Default = DeclsDefault( names )
	|| Sdcl = ExtractDecl( Types, P )
	if (!sdcl and !default and (P isa SCArg))
		sdcl = P.ParentFunc.ReturnType

	
	|SCDecl--| DefaultDcl
	if recv isa SCArg
		if mode != 4 and 8
			"oof $mode"
	if func
		0
	  elseif (Default)
		DefaultDcl = TypeOfExprNeeded( Default, P ) #require
		if (sdcl)   // make sure it matches.
			default = sdcl.ExpectMatch( DefaultDcl, kTypeCastTrue, default )
		
	  elseif (!cls) and (sdcl) and ( !Default ) and (sdcl.CanUseDefault)
		Default = sdcl.CreateDefault(types, Recv isa SCArg)
		if (Default)
			TypeOfExpr( default, P )
			DefaultStitch( Default, self )
	
	|bool| NoOriginalDcl = !Sdcl
	if (NoOriginalDcl)
		if (cls) and (cls.Contained)
			sdcl = cls.Contained // (|| x = Y), (|object| x = Y)
		  else
			expect (!Func and defaultdcl) ( self, ("Function declarations need a type. (Unless it's in a container class.)", "Missing type, or default value.")(!func) )
			sdcl = DefaultDcl
	
	expect !(func and sdcl is Borrowed) (self, "Variables can’t be borrowed in function parameters or return")
	
	if sdcl.NeedsContainedfix
		sdcl = sdcl.Containedfix
	
	if !names		// a return value, how to return the return value?
		expect (.islast) ( self, "Parameter is missing a name." )
		func.ReturnType = sdcl
		return nil
	
	
	|| NameItm = .GetDclName #require
	|| dcl = Sdcl.copy
	
	if (Mode & 8) and NoOriginalDcl // functionbody
		if sdcl isnt StayBorrowed
			(Dcl Isnt Borrowed)
		dcl.nildeclared = NilState.Either // can be freely changed!
	
	nameitm.obj = dcl
	if (nameitm in @Rel)
		nameitm.Parent.obj = dcl
	
	dcl.Default = Default
	dcl.Name = nameitm.name
	(dcl Isnt Const) // erase IsConst, happens if we parse "|| bla = true"

	if names and !Default
		if names.next == @list
			error names
		  else
			names.expectlast
		
	if out!=nil
		out <~ dcl
	nameitm.obj = dcl
	dcl.Source = self
	if default and defaultdcl
		dcl.ConstCheck(nil, default, DefaultDcl)
	
	if (Recv) // this is never nil??? where is nil?
		Recv.TryAdd( self, dcl, dcl.Name )
	return dcl



function Message.CollectFuncTableName (|string|)
	//	@msg.ID-->"msg"
	//	"abc"-->"abc"
	//	why? why not?
	if self == @name
		return .name.UpperCase
	if .name and self != @dot
		Return .Name

	Return .First.Name 
	

function scdecl.NeedsContainedfix (|bool|)
	opt NoRefCounts
	if !.AllocSource and !.contains
		return .ReallyContains


function scdecl.Containedfix (|scdecl|)
	opt norefcounts
	|| t = .type
	rz = (.copy, self)(T.typenormal == self)
	rz.contains = t.SelfDecl.Contains


function message.addvalue (|scfunction| f)
	opt norefcounts
	pragma inline
	if !.HasChildCount(2)
		using f.source
			self <~ «thg "Value"»
