


function DeclsDefault (|Message| def, |Message|)
	opt norefcounts
	if def.issetrel
		|| f = def.first
		|| l = def.Last
		if l == @thg
			expect !(f.name ~= l.name) (def, "Same name!")
		Return l


function MakeDecl (|string| Type, |string| Name, |Message| Value, |Message|)
	rz = «decl »
	if (Type)
		|| arg = rz.msg(@arg)
		(arg is style2)
		arg <~ (@thg, type)
	  else 
		rz <~ @emb
	
	|| NameMsg = «thg name »
	if value
		|| Rel = «rel
			NameMsg
			@opp+"="
			value
		»
		NameMsg.obj = CopyDecl( value, name )
		Rel.obj = NameMsg.obj
		NameMsg = Rel
	
	rz <~ NameMsg


function MakeDeclOrRel (|Message| Into, |message| namemsg, |Message| value, |Message|)
	require into
	rz = «decl
		«emb »
	»
	
	if value
		Value = NeweqRel( NameMsg, value )
	  else
		Value = NameMsg
	rz <~ value
	into.First = rz



function SCDecl.NoFloat (|Message| exp, |bool|)
	|| T = .type.TypeInfo
	expect (T != DataTypeCode.UnusedType)	(exp, "Can’t do bit ops on this")
	expect (!T.isfloat)						(exp, "Can’t do bit ops on floats")
	return true



function DefaultStitch (|Message| Default, |Message| args)
	opt norefcounts
	|| name = args.second
	using (args)
	|| rel = «rel »
	name.next = rel
	rel <~ name
	rel <~ «Opp "="»
	rel <~ Default


function CollectDecls (|Message| DeclList, |SCBase| Name_Space, |SCBase| AddToSpace, |int| PropertyMode=0, |[SCDecl]|)
	if (!DeclList)
		return []
	expect  (DeclList == @prm or @Arg)  (DeclList)
	
	
	|| OriginalErrCount = stderr.errorcount
	|SCFunction--|	Func
	|SCClass--|		Cls
	
	if (DeclList == @prm)
		func = Name_Space|scfunction|
		cls = func.Cls
		if (!cls)
			|| L = func.lookup
			if (L isa SCModule)
				cls = L.Cls
		  elseif !DeclList.HasSelfAsFirst
			cls.AddSelfToFunc(addtospace)
			rz <~ cls.SelfDecl
	  elseif (AddToSpace isa SCClass)
		cls = AddToSpace
	
	|| IsFunctionBody  =  (AddToSpace isa SCArg)

	for item in DeclList
		if (func and func.isassigns == 2) and item.islast
			if !cls
				error (item, "Can’t use this here." )
			  else
				// fn x (|int|) --> fn x (|int| value)
				func.IsAssigns = 3
				if cls.IsDataType
					item.next = item.copy // fn x (|int|) --> fn x (|int| value, |int|)
				if !item.HasChildCount(2)
					using func.source
						item <~ «thg "Value"»
			
		if item == @Item
			expect  (Func)  (item, "Can’t use this here." )
			if item.first == "assigns" // remove this after fixing galaxxies :(
				item = item.Last
				func.IsAssigns = 1
				if !item.haschildcount(2)
					using func.source
						item <~ «thg "Value"»

		if item != @Decl
			expect (!Func)  ( item, "Not a declaration." )
			continue

		|| Types = item.first
		|| Names = types.Next				

		expect (Func or Names)  (item, "No name found.")
		if (PropertyMode & 2)
			expect (names == @thg) (names, "Must be a proper name (a-z or unicode-letters)")

		|| Default = DeclsDefault( names )
		|| Sdcl = ExtractDecl( Types, name_Space )
		if (!sdcl and !default and (Name_space isa SCArg))
			sdcl = name_space.ParentFunc.ReturnType

		
		|SCDecl| DefaultDcl
		if func
			0
		  elseif (Default)
			DefaultDcl = TypeOfExprNeeded( Default, name_space ) #require
			if (sdcl)   // make sure it matches.
				default = sdcl.ExpectMatch( DefaultDcl, kTypeCastTrue, default )
			
		  elseif (cls)
			0 // no defaults... its a property
			
		  elseif (sdcl) and ( !Default ) and (sdcl.CanUseDefault)
			Default = sdcl.CreateDefault(types, AddToSpace isa SCArg)
			if (Default)
				TypeOfExpr( default, Name_Space )
				DefaultStitch( Default, item )
		
		require (stderr.errorcount == OriginalErrCount)
		
		|bool| NoOriginalDcl = !Sdcl
		if (NoOriginalDcl)
			if (cls) and (cls.Contained)
				sdcl = cls.Contained // (|| x = Y), (|object| x = Y)
			  else
				expect (!Func and defaultdcl) ( item, ("Function declarations need a type. (Unless it's in a container class.)", "Missing type, or default value.")(!func) )
				sdcl = DefaultDcl
		
		expect !(func and sdcl is Borrowed) (item, "Variables can’t be borrowed in function parameters or return")
		
		if sdcl.NeedsContainedfix
			sdcl = sdcl.Containedfix
		
		if !names		// a return value, how to return the return value?
			expect ((Func and !func.ReturnType) and (!item.Next)) ( item, "Parameter is missing a name." )
			if (Func)
				debugger (!sdcl.Default and sdcl isnt Borrowed)
				func.ReturnType = sdcl
			Continue
		
		
		|| NameItm = item.GetDclName #require
		|| dcl = Sdcl.copy
		
		if NoOriginalDcl
			if IsFunctionBody 
				if sdcl isnt StayBorrowed
					(Dcl Isnt Borrowed)
				dcl.nildeclared = NilState.Either // can be freely changed!
		  elseif func and func isa kExpectsRealVars
			if dcl.NilDeclared isnt Stated
				dcl.NilDeclared = NilState.real
				// So... we got a func with a decl... lets check it.
		
		nameitm.obj = dcl
		if (nameitm in @Rel)
			nameitm.Parent.obj = dcl
		
		dcl.Default = Default
		dcl.Name = nameitm.name
		(dcl Isnt Const) // erase IsConst, happens if we parse "|| bla = true"
		if func
			(dcl is param)
			(dcl isnt altered)

		if names and !Default
			if names.next == @list
				error names
			  else
				names.expectlast
				
		if (PropertyMode&1)
			(dcl is property)
			if PropertyMode == 1
				(dcl is onmodule)
			  else
				dcl.becomereal
			
		
		rz <~ dcl
		nameitm.obj = dcl
		dcl.Source = item
		if default and defaultdcl
			dcl.ConstCheck(nil, default, DefaultDcl)
		
		if (AddToSpace)
			AddToSpace.TryAdd( nameitm, dcl, dcl.Name )



function Message.CollectFuncTableName (|string|)
	//	@msg.ID-->"msg"
	//	"abc"-->"abc"
	//	why? why not?
	if self == @name
		return .name.UpperCase
	if .name and self != @dot
		Return .Name

	Return .First.Name 
	

function scdecl.NeedsContainedfix (|bool|)
	opt NoRefCounts
	if !.AllocSource and !.contains
		return .ReallyContains


function scdecl.Containedfix (|scdecl|)
	opt norefcounts
	|| t = .type
	rz = (.copy, self)(T.typenormal == self)
	rz.contains = t.SelfDecl.Contains
		
