


function DeclsDefault (|Message| def, |Message|)
	opt norefcounts
	if def.issetrel
		return def.Last


function MakeDecl (|string| Type, |string| Name, |Message| Value, |SCDeclInfo| Purpose=0, |Message!|)
	opt norefcounts
	rz = «decl »
	|| f = rz.msg(@arg),    todo "this should change... I don't like @arg types."
	
	if (Type)
		(f is style2)
		f <~ (@thg, type)
	  else
		f.func = @emb
	
	if !Value
		rz <~ (@thg, name)
		return rz
	
	|| Rel = rz.msg(@rel)
	|| NameMsg = rel.msg(@thg, name)
	rel <~ (@opp, "=")
	rel <~ value
	
	|| o = value.obj as scdecl
		|| dcl = o.copydecl(true)
		dcl.info |= purpose
		dcl.Name = name
		dcl.Default = value
		NameMsg.obj = dcl		
		Rel.obj = dcl
		rz.obj = dcl
		f.obj = dcl
	

function MakeDeclOrRel (|Message| Into, |message| namemsg, |Message| value, |Message|)
	require into
	rz = «decl
		«emb »
	»
	
	if value
		Value = NeweqRel( NameMsg, value )
	  else
		Value = NameMsg
	rz <~ value
	into.First = rz



function SCDecl.NoFloat (|Message| exp, |bool|)
	|| T = .type.TypeInfo
	expect (T != DataTypeCode.UnusedType)	(exp, "Can’t do bit ops on this")
	expect (!T.isfloat)						(exp, "Can’t do bit ops on floats")
	return true



function DefaultStitch (|Message| Default, |Message| dcl, |message|)
	opt norefcounts
	using (dcl)
	rz = dcl.msg(@rel)
	rz <~ dcl.second
	rz <~ (@Opp, "=")
	rz <~ Default


function scfunction.CollectDeclsParams (|Message| prms, |SCNode| AddToSpace)
	opt norefcounts
	scmodule.curr = .parent|scmodule|
	|| cls = .Cls
	if !cls
		cls = .parent|SCModule|!.Cls
	  elseif !prms.HasSelfAsFirst
		expect (addtospace) (prms)
		.AddSelfToFunc(cls, AddToSpace)

	for item in prms
		item.CollectOneParam(self, AddToSpace, cls)

	|| ns = .nilself
		.WantAs(ns)
	|| r = .returntype
	if r and .HidesProperties
		.returntype = r.makereal
			


function Message.CollectOneParam (|scfunction| func, |SCNode| Recv, |scclass| cls, |bool|)
	opt norefcounts
	real self
	if (func.isassigns == 2) and .islast
		if !cls
			error (self, "Can’t use this here." )
		  else
			// setter x (|int|) --> fn x (|int| value)
			func.IsAssigns = 3
			if cls.IsDataTypeOrFP
				.next = .copy // fn x (|int|) --> fn x (|int| value, |int|)
			.AddValue(func)
		
	if  self == @Item  and  .first == "assigns"
		self = .Last
		func.IsAssigns = 1
		.addvalue(func)

	require .Expect(@decl)
	|| dcl = .CollectDecl(func, recv, declmode.FuncParam, cls, func) #require
	if dcl.default isthing "nil"
		dcl.nildeclared = nilstate.optional
	func.args <~ dcl
	(dcl isnt DataConst)
	if dcl.name
		(dcl is Param)
		(dcl isnt Altered)
	  else
		(dcl is return)
	
	return true



function scclass.CollectProp (|Message| msg, |bool|)
	opt norefcounts
	|| dcl = msg.CollectDecl( .modul, self, declmode.properties, self, nil)
		.properties <~ dcl
		(dcl is property)
		dcl.becomereal
		return true



// remove these... but later.
function CollectDeclsGlobals (|Message| arg, |SCNode| scarg)
	opt norefcounts
	for item in arg
		if item == @decl
			require item.CollectAGlobalDecl(scarg)


function Message.CollectAGlobalDecl (|SCNode| scarg, |bool|)
	opt norefcounts
	
	|| dcl = .CollectDecl(scarg, scarg, declmode.Globals, nil, nil)
		|| def = dcl.Default
		if def and !dcl.nilstated
			|| d = def.msgdecl
			if d and d.StatedReal
				dcl.nildeclared = nilstate.real // in case of something like |object| x = real()
		(dcl is property)
		(dcl is Global)
		
		if (.Indent == 255) or ('_' == dcl.name.first or dcl.name.Last)
			(dcl is hidden)
		  elseif Options.MakeInterpreter
			PackMaker.LibGlobs <~ dcl

		return true


function CollectDeclsFuncBodyJustWhatWeNewlyMade (|Message| arg, |SCNode| scarg) 	// remove later... :)
	opt norefcounts	// basically... the caller needs fixing.
	for item in arg
		if item == @decl
			item.CollectFromBody(scarg) // keep on going even if one failed. good for autocomplete


function Message.CollectFromBody (|SCNode| scarg, |bool|)
	opt norefcounts
	|| dcl = .CollectDecl(scarg, scarg, declmode.FunctionBody, nil, nil)
		(dcl is body)
		(dcl isnt dataconst)
		|| def = dcl.Default
			check (def != @thg or def.name ~!= dcl.name) (def, "Same name!")
		return true



function CollectDeclsFuncBodyUnsureHowToRemove (|Message| arg, |SCNode| scarg)
	CollectDeclsFuncBodyJustWhatWeNewlyMade(arg, scarg)



// definitely remove this!
function CollectDeclsFuncBody (|Message| arg, |SCNode| scarg)
	CollectDeclsFuncBodyJustWhatWeNewlyMade(arg, scarg)


function Message.CollectDecl (|SCNode| P, |SCNode| Recv, |int| Mode, |scclass| cls, |scfunction| FuncPrms,  |scdecl|)
	|| Types = .first!
	|| Names = types.Next

	expect (FuncPrms or Names)  (self, "No name found.")
	//if (Mode & 2)
	//	expect (names == @thg) (names, "Must be a proper name (a-z or unicode-letters)")

	|| Default = DeclsDefault( names )
	|| Sdcl = ExtractDecl( Types, P, mode )
	if !sdcl  and  !default  and  (P isa SCArg)
		sdcl = P.ParentFunc!.ReturnType

	|| NameItm = names.CollectDclName
	|SCDecl--| DefaultDcl
	if FuncPrms
		0
	  elseif (Default and mode != declmode.Properties)
		DefaultDcl = TypeOfExprNeeded( Default, P ) #require
		DefaultDcl = DefaultDcl.Downgrade
		if (sdcl)   // make sure it matches.
			default = sdcl.ExpectMatch( DefaultDcl, kTypeCastTrue, default )
		
	  elseif (!cls) and (sdcl) and (sdcl.CanUseDefault)
		Default = sdcl.CreateDefault(types, mode >= 4)
		if (Default)
			TypeOfExpr( default, P )
			names = DefaultStitch( Default, self )
	
	|| NoOriginalDcl = false
	if !Sdcl
		NoOriginalDcl = true
		if (cls) and (cls.Contained)
			sdcl = cls.Contained! // (|| x = Y), (|object| x = Y)
		  else
			expect (!FuncPrms and defaultdcl) ( self, ("Missing type", "Missing type, or default value.")(!FuncPrms) )
			sdcl = DefaultDcl
	
	if sdcl.NeedsContainedfix
		sdcl = sdcl.Containedfix
	
	// TODO: if sdcl's refcount is 1... just keep it? its obviously just been created.
	// like: |dictionary of string| x
	|| dcl = Sdcl.copydecl
	if !NameItm
		check (.islast) ( self, "Parameter is missing a name." )
		if funcprms
			if FuncPrms.CollectReturnAsReal // allocs dont fail (assumed so)
				dcl.nildeclared = nilstate.real
			FuncPrms.ReturnType = dcl // we need the copy
		return nil

	if !Default
		names.expectlast
	
	if mode != declmode.Properties // the old .obj is needed
		nameitm.obj = dcl
	
	if (Mode & 8) and NoOriginalDcl // functionbody
		if sdcl isnt StayBorrowed
			(Dcl Isnt Borrowed)
		dcl.nildeclared = NilState.real >> dcl.TypeSuffers 
	
	if (nameitm in @Rel)
		nameitm.Parent!.obj = dcl
	
	.obj = dcl
	types.obj = dcl // might as well set it everywhere.
	dcl.Default = Default
	dcl.Name = nameitm.name
	dcl.Source = self
	(dcl Isnt Const) // on "|| bla = true", make "bla" editable.

	if default and defaultdcl
		dcl.ConstCheck(nil, default, DefaultDcl)

	if Recv // nil for prototypes
		Recv.TryAdd( self, dcl, dcl.Name )
	return dcl



function Message.CollectFuncTableName (|string|)
	//	@msg.ID-->"msg"
	//	"abc"-->"abc"
	//	why? why not?
	if self == @name
		return .name.UpperCase
	if .name and self != @dot
		Return .Name

	Return .Firstname 
	

function scdecl.NeedsContainedfix (|bool|)
	opt NoRefCounts
	if !.AllocSource and !.contains
		return .ReallyContains


function scdecl.Containedfix (|scdecl|)
	opt norefcounts
	|| t = .type
	rz = (.copydecl, self)(T.typenormal == self)
	rz.contains = t.SelfDecl.Contains


function scdecl.DownGrade (|scdecl|)
	opt norefcounts
	if !.IsNormalObject
		return self
	|| y = .type.DowngradeTo
		return y.TypeNormal
	return self
	
	
function message.AddValue (|scfunction| f)
	opt norefcounts
	pragma inline
	if !.HasChildCount(2)
		using f.source!
			self <~ «thg "Value"»


datatype DeclMode (uint)
	constants
		|DeclMode|
		FuncParam	= 4
		Properties	= 3
		Globals		= 1
		FunctionBody = 8
		Local = FuncParam+FunctionBody
		Proto		= 16
		TypeCast	= 32
		ProtoParam	= FuncParam + Proto
		Always		= 64

	syntax is (|DeclMode|o, |bool|)
		return self == o

