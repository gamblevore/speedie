

constants
	kSelfReplace 	= 1
	kSelfDebug   	= 2


module Options
	flags: native,pack
	
	function StrNil (assigns:|int|)
		.NilStrength = value.clamp(errorseverity.hint, errorseverity.error)

		
	||		NilStrength				= ErrorSeverity.Hint // collect via options... ErrorSeverity.problem
	
	||		BannedClasses			= nil|dictionary|
	||		output_path				= ""
	||		SingleFileInput			= ""
	||		Variant					= ""
	|| 		Arch					= "" // targetarchitecture
	||		SingleCppOutput			= true
	||		HideMultipleErrors		= true
	|| 		NilTestAllocNeverFails	= true
	||		Cpp						= true
	||		Compile					= true
	|| 		UnusedFunctions			= false
	||		MakeASM					= false
	||		TargetDebug				= false
	||		PrintLibraries			= false
	||		GenFlowControlCode		= false
	||		KeepAllErrors			= false
	||		Scripting				= false
	||		MakeLib					= false // for now
	||		CheckMaxVars			= false
	||		ListAllLib				= false
	||		ForceRecompile			= false
	||		Silent					= false
	||		IsDirectTest			= false
	||		ProjectIsLibrary		= false
	||		ProjectIsMiniLib		= false
	||		IgnoreCantSaveErrors	= false
	||		ArgStats				= false
	||		PrintCompileString		= false
	||		PrintFiles				= false
	||		PrintStages				= false
	||		Warnings				= false
	||		UseFuncCallCount		= false
	||		ExternalCompile			= false
	||		Final					= false // won't call gcc.
	||		Products				= native
	||		Compile32Bit			= maybebool(false)
	|byte|	Optimise				= 1
	|byte|	SelfReplacement			= 0
	|byte|	OperationCount			= 0
	|byte|	Perry					= 0
	
	function Color (assigns:|bool|)
		ErrorColors.enabled = Value

	function Color (|bool|)
		return ErrorColors.enabled
	



module Feedback 
	linkage
		cpp_part FB
	
	
	function CheckSelfModifying
		|| t2 = .CheckSelfModifying2
		if t2 == 1
			Options.SelfReplacement = kSelfReplace
			Options.ExternalCompile = true
			options.ForceRecompile = true
			Options.GenFlowControlCode = app.prefs["self_flow"].yes
			Targets["flow"] = options.GenFlowControlCode
			targets["self"] = true
		  elseif t2 == 2
			Options.ProjectIsMiniLib = true


	function CheckSelfModifying2 (|int|)
		require !options.singlefileinput
		
		|| p = compiler.BaseProjectPath.TrimSlashes(true)
		|| spd = compiler.speedie.TrimSlashes(true)
		|| jb = compiler.jeebox.TrimSlashes(true)
		if p ~= spd
			if Options.SelfReplacement // this check should be done in the caller
				rz = 0
			  else
				rz = 1
		  elseif p ~= jb
			rz = 2


	function ParseArgs (|bool|)
		return ParseArgsSub(app.rawargs)


	function StopStripping
		if ("".length == 1)
			"".debugprint // stop from being stripped
			nil|message|.jdb2
			nil|message|.LocateAll
			nil|scfunction|.NilDebug
			nil|scdecl|.NilDebug
	
	
	function ParseArgsSub (|[]| args, |bool|) 
		.StopStripping
		
		if !Args
			.CompilerInfo
			.Help
			return false

		for (S in args)
			.ParseOption(S)
		
		if options.OperationCount <= 0
			StdErr.newerror( "\nError: No operations requested.\n" )
		  elseif options.OperationCount >= 2
			StdErr.newerror( "\nToo many operations requested.\n" )

		return StdErr.OK and Compiler.BaseProjectPath.Exists


	function string.IsSpeedieSrc (|bool|)
		return (self isa "spd")

	function string.ResolveSpd (|string|)
		if self[0, "@spd/"]
			return (compiler.FindSpeedieRoot+self[5...]).resolve(fileResolveMode.allowmissing)
		return .resolve(fileResolveMode.allowmissing)

	function TryUseProject (|String| path, |bool| IsScript=false, |string|)
		ifn (path contains '/' or '.' or '~')
			Path = compiler.FindProjNoSuffix(Path)
		
		|| path2 = path.ResolveSpd
		if path2: path = path2
		|| F = Path.File
		expect !(f inside compiler.library or compiler.jeebox) (f, "Don't compile Library files") 
			
		compiler.OriginalInputPath = path // altered below at: F.path = F.path.parent
		Compiler.BaseProjectPath = F
		compiler.projectname = f.trimextandpath
		compiler.reportedname = compiler.projectname
		
		|| exists	= f.exists
		|| IsSpd	= f.name.IsSpeedieSrc or IsScript
		if (exists and !F.isdir) or (!exists and IsSpd)
			options.SingleFileInput = f.path
			require f.mustexist
			F = f.parent
			Compiler.BaseProjectPath = f

		.CheckSelfModifying

		if !options.SingleFileInput
			F.mustexist

		if exists and isspd and stderr.ok
			return path
	
	
	function ParseOption (|AppArgument| Obj)
		// something like that?
		|| Name  = obj.Name
		|| Value = obj.Value

		if Name
			|| opt = AppOptions[name]
				options.OperationCount += ((*opt)(name, value, nil))
			  else
				app.quit("Unknown switch '$Name'\n")
		  elseif value.isjbin // ignore it
			0 // probably a restart compile option
		  elseif (options.OperationCount == 1) and !options.output_path
			feedback.AppOptions_output_path("output_path", value) // change to output_path
		  else
			.TryUseProject(Value)
			options.OperationCount++

		
	function Explain (|faststring| Purpose, |string| name="", |bool|) 
		ifn purpose: return true
		purpose <~ name


	function AppTransCompile (ShellOption) 
		explain(purpose, "Places the .cpp and header files locally")$
		Options.ExternalCompile = true
		Options.Color = false // makes sense... we want to do this using xcode


	function AppVersionNumber (ShellOption) 
		Explain(Purpose, "Print version number.")$
		return CompilerInfo()


	function AppTalk (ShellOption) 
		Explain(Purpose, "")$
		interact.ShouldEnter = 1
		ErrorColors.enabled = false


	dispatch AppOptions (ShellOption)
		nocompile // remove this later
			Explain(Purpose, "Will not compile any .cpp generated.")$
			Options.Compile = false
			options.products &=~ (options.pack+options.native)
			
		breakonerr 
			Explain(Purpose, "")$
			error.AutoPrint = value.optionint
		
		path
			Explain(Purpose, "")$
			printline app.exepath
		
		keepallerrors
			explain(purpose, "Show more errors that were hidden.")$
			options.KeepAllErrors = value.optionbool

		env
			explain(purpose, "Print environment variables")$
			for (s in app.env) (k)
				printline k + ": " + s
			return true
			
		externalcompile (AppTransCompile) // deprecated. remove
		x (AppTransCompile)
		
		+"arch"
			|| str = "intel/arm/ppc/spd"
			explain(Purpose, "Set to "+str)
			for v in str / '/'
				if v~=value
					options.arch = v
				
		+"gcc"
			explain(Purpose, "Replace gcc with something else")$
			TransCompiler.CppCompilerPath=value
				
		+"perry"
			Explain(Purpose, "")$
			options.perry = 1
			|| RealPerry = value~="bin"
			options.perry += RealPerry // argvalue not needed? jsut value, right?
			//error.AutoPrint = (!RealPerry)|int|
			compiler.insecurewords = file.PrefsFolder["klinkerhoppen.banned"].readall.dict
		
		+"check"
			Explain(Purpose, "Check only. same as --nocompile --cpp=0")$
			Options.Compile = false
			Options.Cpp = false
			options.products = 0
		
		+"errortest" 
			explain(purpose, "Tests if error handling works OK.")$
			PrintError "Errors print successefully\n"
			return true // does something, counts towards operationCount
		
		+"argstats"
			Explain(Purpose, "")$
			options.argstats = true
		
		+"flow"
			explain(Purpose, "Adds control-flow logging to generated compiles")$
			|| b = value.optionbool
			Options.GenFlowControlCode = b 
			targets["flow"] = b

		+"log"
			explain(Purpose, "Logs the compiler's internal behaviour.  0 = off,  1 =  log,  2 = log+validate")$
			if value!="true"
				FlowControl.FlowMode = value.int
			  else
				FlowControl.FlowMode = FlowControl.Validate
		
		+"noisy"
			Explain(Purpose, "Prints more stuff.")$
			Options.PrintCompileString = true
			file.DebugExecute = true
			options.PrintLibraries = true
		
		+"alive"
			Explain(purpose)$
			"We seems alive :)" // used by perry
			return true
		
		+"products"
			Explain(purpose, `Acceptable values: pack, cpp, native. Combine like pack/native. 'native' = compiled via GCC. 'pack' = interpreted.`)$
			|| P = 0
			for item in (value / '/')
				if item ~= "native"
					P |= options.native // these two seem the same?
				if item ~= "cpp"
					P |= options.cpp
				if item ~= "pack"
					P |= options.pack
			options.products = P
			

		ignorecantsave 
			Explain(Purpose)$
			options.IgnoreCantSaveErrors = true
		

		quiet 
			Explain(Purpose, "Prints less stuff")$
			Options.PrintCompileString = false
		
		
		stages
			Explain(Purpose, "Prints the stages")$
			options.printstages = value.optionbool
		
		
		print 
			Explain(Purpose)$
			print Value
			return true // does something, counts towards operationCount
		
		
		directtest 
			explain(Purpose, "Allows me to test certain compiler features more easily.")
			options.isdirecttest = value.OptionBool
			targets["direct"] = options.isdirecttest
		
		
		+"single" 
			Explain(Purpose, "")$
			options.SingleCppOutput = value.optionbool
		
		
		+"self" 
			Explain(Purpose, "Compiles and installs new Speedie, after self-test.")$
			feedback.TryUseProject( Compiler.SpeedieProj )
			return true // does something, counts towards operationCount
		
		+"nil"
			Explain(Purpose, "Changes how bad nil-errors are.")$
			options.strnil = value.int
			
		+"crash"
			explain(purpose, "Crashes speedie to test it's crash handlers.")$
			app.crash
		+"__talk__" (AppTalk)
			
		+"talk" (AppTalk)
		+"asm" // nothing... for now.
			options.MakeASM = value.optionbool
		
		+"targetdebug" // basically
			Explain(Purpose, "")$
			options.targetdebug = value.optionbool
		
		+"target"
			Explain(Purpose, "Set names used by preprocessor. --target=AnyName")$
			if value == "debug"
				error "Use 'targetdebug' instead."
			targets[value]=true
			
		m64
			Explain(Purpose, "64-bit compile")$
			options.Compile32Bit = 0
		
		funccount
			Explain(Purpose, "Spams each func with a static int, to count the number of times it's called. Useful debugging feature.")$
			options.UseFuncCallCount = value.optionbool


		m32
			Explain(Purpose, "32-bit compile")$
			options.Compile32Bit = 1

		
		warn
			Explain(Purpose, "Show warnings.")$
			Options.Warnings = value.optionbool

		
		maxvars
			Explain(Purpose, "Reports maximum number of vars/funcs/args used in program.")$
			Options.checkmaxvars = value.optionbool
		
		nocolor
			Explain(Purpose, "Don't print text coloring symbols for terminals.")$
			Options.Color = false
		
		selfdebug
			Explain(Purpose, "Self-test only.")$
			Options.SelfReplacement = kSelfDebug
			options.targetdebug = true
			Options.Compile = false // remove this later
			options.products &= (~options.pack+options.native) 
			Options.ExternalCompile = true
			feedback.TryUseProject( Compiler.SpeedieProj )
			return true // does something, counts towards operationCount
		
		optimise
			Explain(Purpose, "Optimisation level. (0 to 3... EG: '--Optimise=1')")$
			Options.Optimise = Value.parseint

		cpp
			explain(purpose, "Compiles to cpp. Default true")$
			options.cpp = value.optionbool
		
		output_path
			explain(purpose, "Specifies the build product path")$
			options.output_path = value.pathfix
			options.output_path.parent.file.mustexist
			options.ForceRecompile = true // it's what we expect
		
		force
			explain(purpose, "Forces recompilation even if the output is newer than the input files.")$
			options.ForceRecompile = true

		variant
			Explain(Purpose)$
			Options.Variant = (Value.parseInt|int|).Render
			options.perry = 1
			Options.Color = false
			if options.optimise < 0
				options.optimise = 1

		
		final
			Explain(Purpose)$
			Options.Final = true
		
		codesign
			Explain(Purpose, "Gets/Sets the codesign certificate")$
			if value == ""
				printline app.prefs(codesign_native)
				return true
			
			if value == "none" or "nil" or "-"
				value = ""
			app.prefs(codesign_native) = value
			app.saveprefs
			printline "Codesign set to " + value
			return true
		
		dosign
			Explain( Purpose, "Code signs an app." )
			
			return true

		
		+"clean"
			Explain(Purpose, "Remove temp files.")$
			if TransCompiler.Clean
				"Cleaned"
			return true // does something, counts towards operationCount
		
		version (AppVersionNumber)
		
		v		(AppVersionNumber)
		
		help
			Explain(Purpose, "This.")$
			Help()
			return true


	function string.OptionBool (|bool|)
		return (self ~= "" or "true" or "yes")
	function string.OptionInt (|int|)
		if .optionbool
			return 1
		return .int


	function CompilerInfo (|bool|)
		"spd $__time_id__"
		return true


	function Help 
		|| fs		 = faststring.new
		|| fs_tester = faststring.new
		fs <~ "Usage: "
		fs <~ app.filename
		fs <~ " /path/to/project\n"
		fs <~ "Installation: ${compiler.SpeedieProj.parent}"
		fs <~ "  Platform: ${platform.Name}+${platform.cpu_name}"
		fs <~ "  SelfFlow: " 
		fs <~ app.prefs["self_flow"]
		for (v in appoptions) (k) 
			(*v)("", "", fs_tester)
			if (fs_tester.length) 
				fs_tester.length = 0
				fs <~ "\n--"
				fs <~ k
				fs <~ (' ', 17-k.length)
				(v.value|shelloption|)("", "", fs)
		printline fs.getresult


prototype ShellOption			(|string| Name, |string| Value, |faststring| purpose=nil, |bool|)
