

module Options
	flags: native,pack
	
		
	||		NilStrength				= errorseverity.error	
	||		BannedClasses			= nil|dictionary|
	||		output_path				= ""
	||		SingleFileInput			= ""
	||		Variant					= ""
	|| 		Arch					= "" // targetarchitecture
	||		SingleCppOutput			= true
	||		HideMultipleErrors		= true
	|| 		NilTestAllocNeverFails	= true
	|| 		Beep					= false

	||		ModeCpp					= true
	||		ModePack				= false
	||		MakeInterpreter			= false
	||		MakeLib					= false // for now

	||		Compile					= true
	||		TargetDebug				= false
	||		PrintLibraries			= false
	||		GenFlowControlCode		= false
	||		KeepAllErrors			= false
	||		Scripting				= false
	||		CheckMaxVars			= false
	||		ForceRecompile			= false
	||		Silent					= false
	||		IsDirectTest			= false
	||		ProjectIsLibrary		= false
	||		ProjectIsMiniLib		= false
	||		IgnoreCantSaveErrors	= false
	||		ArgStats				= false
	||		PrintCompileString		= false
	||		PrintFiles				= false
	||		PrintStages				= false
	||		Warnings				= false
	||		UseFuncCallCount		= false
	||		ExternalCompile			= false
	||		Final					= false // won't call gcc.
//	||		Products				= native
	|byte|	Optimise				= 1
	|bool|	SelfReplacement			= 0
	|byte|	OperationCount			= 0
	|byte|	PerryOutput				= 0
	|byte|	UseScriptLoc			= 0
	
	function Color (assigns:|bool|)
		ErrorColors.enabled = Value

	function Color (|bool|)
		return ErrorColors.enabled
	



module Feedback 
	linkage
		cpp_part FB
	
	
	function CheckSelfModifying
		|| t2 = .CheckSelfModifying2
		if t2 == 1
			Options.SelfReplacement = true // isselfaltering, isselfmodifying, alteringself, modifyingself
			Options.ExternalCompile = true
			options.ForceRecompile = true
			Options.GenFlowControlCode = app.pref("self_flow").yes
			SC_Targets["flow"] = options.GenFlowControlCode
			SC_Targets["self"] = true
		  elseif t2 == 2
			Options.ProjectIsMiniLib = true


	function CheckSelfModifying2 (|int|)
		require !options.singlefileinput
		
		|| bpp = compiler.BaseProjectPath$
		|| p = bpp.TrimSlashes(true)
		|| spd = compiler.speedie.TrimSlashes(true)
		|| jb = compiler.jeebox.TrimSlashes(true)
		if p ~= spd
			if Options.SelfReplacement // this check should be done in the caller
				rz = 0
			  else
				rz = 1
		  elseif p ~= jb
			rz = 2


	function ParseArgs (|bool|)
		return ParseArgsSub(app.rawargs)


	function StopStripping
		if ""
			"".debugprint // stop from being stripped
			nil|message|.jdb2
			fdb(nil|[scfunction]|)
	
	
	function ParseArgsSub (|[]| args, |bool|) 
		.StopStripping
		
		if !Args
			.CompilerInfo
			.Help
			return false

		for (S in args)
			.ParseOption(S)
		
		if options.OperationCount <= 0
			errorreceiver.newerror( "\nError: No operations requested.\n" )
		  elseif options.OperationCount >= 2
			errorreceiver.newerror( "\nToo many operations requested.\n" )

		return StdErr.OK and Compiler.BaseProjectPath.Exists


	function string.IsSpeedieSrc (|bool|)
		return (self isa "spd")

	function string.ResolveSpd (|string|)
		if self[0, "@spd/"]
			return (compiler.FindSpeedieRoot+self[5...]).resolve(fileResolveMode.allowmissing)
		return .resolve(fileResolveMode.allowmissing)

	function TryUseProject (|String| path, |bool| IsScript=false, |string|)
		ifn (path contains '/' or '.' or '~')
			Path = compiler.FindProjNoSuffix(Path)
		
		|| path2 = path.ResolveSpd
		if path2: path = path2
		|| F = Path.File
		expect !(f inside compiler.library or compiler.jeebox) (f, "Don't compile Library files") 
			
		compiler.OriginalInputPath = path // altered below at: F.path = F.path.parent
		Compiler.BaseProjectPath = F
		compiler.projectname = f.trimextandpath
		compiler.reportedname = compiler.projectname
		
		|| exists	= f.exists
		|| IsSpd	= f.name.IsSpeedieSrc or IsScript
		if (exists and !F.isdir) or (!exists and IsSpd)
			options.SingleFileInput = f.path
			require f.mustexist
			F = f.parent
			Compiler.BaseProjectPath = f

		.CheckSelfModifying

		if !options.SingleFileInput
			F.mustexist

		if exists and isspd and stderr.ok
			return path
	
	
	function ParseOption (|AppArgument| Obj)
		// something like that?
		|| Name  = obj.Name
		|| Value = obj.Value

		if Name
			|| opt = AppOptions[name]
				options.OperationCount += ((*opt)(name, value, nil))
			  else
				app.quit("Unknown switch '$Name'\n")
		  elseif value.isjbin // ignore it
			0 // probably a restart compile option
		  elseif (options.OperationCount == 1)
			error ("Can't compile multiple projects: " + value)
		  else
			.TryUseProject(Value)
			options.OperationCount++

		
	function Explain (|faststring| Purpose, |string| name="", |bool|) 
		ifn purpose: return true
		purpose <~ name


	function AppTransCompile (ShellOption) 
		explain(purpose, "Places the .cpp and header files locally")$
		Options.ExternalCompile = true
		Options.Color = false // makes sense... we want to do this using xcode


	function AppVersionNumber (ShellOption) 
		Explain(Purpose, "Print version number.")$
		return CompilerInfo()


	dispatch AppOptions (ShellOption)
		+"nocompile" // remove this later
			Explain(Purpose, "Will not compile any .cpp generated.")$
			Options.Compile = false
//			options.products &=~ (options.pack+options.native)
			
		+"breakonerr" 
			Explain(Purpose, "")$
			error.AutoPrint = value.optionint
		
		+"path"
			Explain(Purpose, "")$
			printline app.exepath
			
		+"beep"
			Explain(Purpose, "Beeps after compile is complete")$
			options.beep = value.optionbool
		
		+"keepallerrors"
			explain(purpose, "Show more errors that were hidden.")$
			options.KeepAllErrors = value.optionbool

		+"env"
			explain(purpose, "Print environment variables")$
			for (s in app.env) (k)
				printline k + ": " + s
			return true
		
		+"x" (AppTransCompile)
		
		+"arch"
			|| str = "intel/arm/ppc/spd"
			explain(Purpose, "Set to "+str)
			for v in str / '/'
				if v~=value
					options.arch = v
				
		+"gcc"
			explain(Purpose, "Replace gcc with something else")$
			TransCompiler.CppCompilerPath=value
				
		+"perry"
			Explain(Purpose, "")$
			options.perryoutput = 1
			|| RealPerry = value~="bin"
			options.perryoutput += RealPerry // argvalue not needed? jsut value, right?
			compiler.insecurewords = file.PrefsFolder["klinkerhoppen.banned"]!.readall.dict

		+"usescriptloc"
			Explain(Purpose, "")$
			options.usescriptloc = true

		+"check"
			Explain(Purpose, "Check only. same as --nocompile --cpp=0")$
			Options.Compile = false
			Options.ModeCpp = false
//			options.products = 0
		
		+"errortest" 
			explain(purpose, "Tests if error handling works OK.")$
			PrintError "Errors print successefully\n"
			return true // does something, counts towards operationCount
		
		+"argstats"
			Explain(Purpose, "")$
			options.argstats = true
		
		+"flow"
			explain(Purpose, "Adds control-flow logging to generated compiles")$
			|| b = value.optionbool
			Options.GenFlowControlCode = b 
			SC_Targets["flow"] = b

		+"log"
			explain(Purpose, "Logs the compiler's internal behaviour.  0 = off,  1 =  log,  2 = log+validate")$
			if value!="true"
				FlowControl.FlowMode = value.int
			  else
				FlowControl.FlowMode = FlowControl.Validate
		
		+"noisy"
			Explain(Purpose, "Prints more stuff.")$
			"NoiseActivated"
			Options.PrintCompileString = true
			file.DebugExecute = true
			options.PrintLibraries = true
		
		+"alive"
			Explain(purpose)$
			"We seems alive :)" // used by perry
			return true
		
		+"products"
			0 // does nothing

		+"ignorecantsave" 
			Explain(Purpose)$
			options.IgnoreCantSaveErrors = true
		

		+"quiet" 
			Explain(Purpose, "Prints less stuff")$
			Options.PrintCompileString = false

		+"silent"
			Explain(Purpose, "Prints much less")$
			Options.PrintCompileString = false
			options.silent = true
		
		
		+"stages"
			Explain(Purpose, "Prints the stages")$
			options.printstages = value.optionbool
		
		
		+"print" 
			Explain(Purpose)$
			print Value
			return true // does something, counts towards operationCount
		
		
		+"directtest" 
			explain(Purpose, "Allows me to test certain compiler features more easily.")
			options.isdirecttest = value.OptionBool
			SC_Targets["direct"] = options.isdirecttest
		
		
		+"single" 
			Explain(Purpose, "")$
			options.SingleCppOutput = value.optionbool
		
		
		+"self" 
			Explain(Purpose, "Compiles and installs new Speedie, after self-test.")$
			if app.no("nocompile")
				options.perryoutput = 1
			feedback.TryUseProject( Compiler.SpeedieProj )
			return true // does something, counts towards operationCount
		
		+"nil"
			Explain(Purpose, "Enable/disable nil-errors.")$
			if value.yes
				options.nilstrength = errorseverity.error
			  else
				options.nilstrength = 0
			
		+"crash"
			explain(purpose, "Crashes speedie to test it's crash handlers.")$
			app.crash
		
		+"pack" // nothing... for now.
			options.ModePack = value.optionbool
		
		+"targetdebug" // basically
			Explain(Purpose, "")$
			options.targetdebug = value.optionbool
		
		+"target"
			Explain(Purpose, "Set names used by preprocessor. --target=AnyName")$
			if value == "debug"
				error "Use 'targetdebug' instead."
			SC_Targets[value] = true
			
//		+"m64"
//			Explain(Purpose, "64-bit compile")$
//			options.Compile32Bit = false
		
		+"funccount"
			Explain(Purpose, "Spams each func with a static int, to count the number of times it's called. Useful debugging feature.")$
			options.UseFuncCallCount = value.optionbool


//		+"m32"
//			Explain(Purpose, "32-bit compile")$
//			options.Compile32Bit = true

		
		+"warn"
			Explain(Purpose, "Show warnings.")$
			Options.Warnings = value.optionbool

		
		+"maxvars"
			Explain(Purpose, "Reports maximum number of vars/funcs/args used in program.")$
			Options.checkmaxvars = value.optionbool
		
		+"nocolor"
			Explain(Purpose, "Don't print text coloring symbols for terminals.")$
			Options.Color = false
				
		+"optimise"
			Explain(Purpose, "Optimisation level. (0 to 3... EG: '--Optimise=1')")$
			Options.Optimise = Value.parseint

		+"cpp"
			explain(purpose, "Compiles to cpp. Default true")$
			options.ModeCpp = value.optionbool
				
		+"output_path"
			explain(purpose, "Specifies the build product path")$
			options.output_path = value.pathfix
			options.output_path.parent.file.mustexist
			options.ForceRecompile = true // it's what we expect
		
		+"force"
			explain(purpose, "Forces recompilation even if the output is newer than the input files.")$
			options.ForceRecompile = true

		+"variant"
			Explain(Purpose)$
			Options.Variant = (Value.ParseInt|int|).Render
			options.perryoutput = 1
			Options.Color = false
			if options.optimise < 0
				options.optimise = 1

		+"final"
			Explain(Purpose)$
			Options.Final = true
		
		+"codesign"
			Explain(Purpose, "Gets/Sets the codesign certificate")$
			if value == ""
				printline app.pref(codesign_native)
				return true
			
			if value == "none" or "nil" or "-"
				value = ""
			app.pref(codesign_native) = value
			app.saveprefs
			printline "Codesign set to " + value
			return true
		
		+"dosign"
			Explain( Purpose, "Code signs an app." )
			
			return true

		
		+"clean"
			Explain(Purpose, "Remove temp files.")$
			if TransCompiler.Clean
				"Cleaned"
			return true // does something, counts towards operationCount
		
		+"version" (AppVersionNumber)
		
		+"v"		(AppVersionNumber)
		
		+"help"
			Explain(Purpose, "This.")$
			Help()
			return true


	function string.OptionBool (|bool|)
		return (self ~= "" or "true" or "yes")
	
	
	function string.OptionInt (|int|)
		if .OptionBool
			return 1
		return .int


	function CompilerInfo (|bool|)
		"spd $__time_id__"
		return true


	function Help 
		|| fs		 = faststring.new
		|| fs_tester = faststring.new
		fs <~ "Usage: "
		fs <~ app.filename
		fs <~ " /path/to/project\n"
		fs <~ "Installation: ${compiler.SpeedieProj.parent}"
		fs <~ "  Platform: ${platform.Name}+${platform.cpu_name}"
		fs <~ "  SelfFlow: ",  fs <~ app.pref("self_flow")
		fs <~ "  @max: ${@max|int|}"
		for (v in AppOptions) (k) 
			(*v)("", "", fs_tester)
			|| val = v.Value|shelloption|
			if (val and fs_tester.length) 
				fs_tester.length = 0
				fs <~ "\n--"
				fs <~ k
				fs <~ (' ', 17-k.length)
				(val)("", "", fs)
		printline fs.GetResult


prototype ShellOption			(|string| Name, |string| Value, |faststring| purpose=nil, |bool|)
