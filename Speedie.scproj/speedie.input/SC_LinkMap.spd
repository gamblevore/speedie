

module LinkMap 
	
	function SCObject.CanLinkFrom (|scfunction| Fn, |bool|)
		opt norefcounts 
		if .CurrFuncLink == fn.LinkID
			return false
		.CurrFuncLink = fn.LinkID
		return true


	function SCFunction.DoLinkToNode (|SCNode| To)
		opt norefcounts
		require to isnt InBuilt
		require to.CanLinkFrom(self)
		(.linkto init []) <~ to
		
		if Compiler.InPerry
			(to.linkfrom init []) <~ self


	function SCFunction.DoLinkToDecl (|SCDecl| Decl)
		opt norefcounts
		.DoLinkToNode(Decl.Type)

		if decl.CanLinkFrom(self)
			(decl.linkfrom init []) <~ self

	

	function CollectAll
		opt norefcounts
		for (s in compiler.funclist) (i)
			s.LinkID = i + 1		 // tableid is set later after sort...
			.CollectLinksInOne(s)	 // so we use linkid instead
		scfunction.currfunc = nil


	function CollectLinksInOne (|scfunction| self)
		opt NoRefCounts
		scfunction.currfunc = self
		for l in .linkto
			l.CurrFuncLink = .LinkID
	
		for d in .args
			.CollectLinks( d )
		|| r = .ReturnType
			.CollectLinks( r )
		CollectFromSource(self, .sourcearg, false)
	
	
	function CollectFromSource (|scfunction| self, |message| src, |bool| InBranch)
		opt norefcounts
		for msg in src
			|| o = msg.obj
				.CollectLinks( o )
			if msg.HasAny
				if !InBranch
					|| T = msg.ASMType
					InBranch = (t == ASMType.kIf or ASMType.kwhile or ASMType.ktern)
				CollectFromSource(Self, msg, inbranch)
		


extend SCFunction {

function CollectLinks (|object!| obj)
	opt norefcounts
	if obj isa SCBetterNode
		return .DoLinkToNode(Obj)
	
	if obj isa SCDecl
		.DoLinktoDecl( obj )
		obj = obj.IsLookupOnly|SCDecl|
		if obj
			return .CollectLinks(obj)


function Reach
	.ReachFunc(Compiler.VisibleFuncs!)


function ReachFunc (|SCNode| from)		// reachedfunc, funcreached, reach 
	opt norefcounts
	flow off // memory order dependant!
	
	|| MR = .MyReacher
		if mr == Compiler.VisibleFuncs
			.MyReacher = from
		return

	if .borked
		error (.source,    "Borked function reached!")
		error (from.source, from.ReachedName)

	.MyReacher = from
		
	Compiler.stReachedFunc++
	if .IsLibrary
		Compiler.stLibFuncs++

	.cls.Reach(self)?
		
	for o in .LinkTo
		if (o isa SCFunction)
			o.ReachFunc(self)
		  elseif (o isa SCClass)
			o.Reach(self)
	
	
function IsUnused (|bool|)
	opt norefcounts
	|| p = .project
		require p.WarnUnusedFuncs

	if self == Compiler.mainfunc
		return false
	
	|| MR = .MyReacher
	if MR and MR != Compiler.VisibleFuncs
		return false
	
	if .isvisible and .islibrary
		return false

	return (self isnt ConOrDes) and !.IsAllocOrNew

}


function message.HateUnusedFuncs
	opt norefcounts
	|| imp = scimport.FindImport(.name)
		imp.WarnUnusedFuncs = true
	  else
		.expect(.func, "Can't find project")


function scclass.Reach (|SCNode| from, |message| src=nil)
	opt norefcounts
	flow off
	require !.MyReacher
	.MyReacher = from
	Compiler.stReachedClass++
	
	if Options.BannedClasses
		.BannedCheck(src)
	|| s = .super
		s.Reach(self)
	|| b = .Behaviour
		b.FuncTable!.cls!.reach(self)
	
	|| df = .DestructorFunc
		df.ReachFunc(self)
	
	for d in .Properties
		d.TypeReach(self, d.source!)
		d.contains!.TypeReach(self, d.source!)
	
	.ReachBehaviours


function scclass.ReachBehaviours
	flow off
	for f in .Access
		if f isa SCFunction
			if f.IsBehaviour
				f.ReachFunc(self)


function SCDecl.Reach
	opt norefcounts
	.type.Reach(compiler.VisibleFuncs)


function compiler.DeadStrip
	opt norefcounts
	compiler.MainFunc.ReachedDetect?
	
	for f in .FuncList
		f.ReachedDetect
		
	for f in packmaker.libglobs
		f.reach
	
	for f in packmaker.PackGlobs
		f.reach

	if options.MakeInterpreter		// must come before the next loop
		for c in .classlist
			c.reach(Compiler.Interpreter)
	
	for c in .classlist
		if c.MyReacher				// shorten-discovery-chains, 
			c.ReachBehaviours		// behaviour chains tend to be long.

	CodeSorter.LeafsFirst			// super-refcounter wants this
	

function scdecl.TypeReach (|SCNode| from, |message| src)
	opt norefcounts, flow off
	if self
		return .type.reach(from, src)

	
