

// some kinda function table... saved to a file

module PackMaker
	|[scfunction]|			LibFuncs
	|[SCDecl]|				LibGlobs
	|[scfunction]|			PackFuncs
	|[SCDecl]|				PackGlobs

	
	function AddAll
		opt norefcounts
		for f in Compiler.FuncList
			if !f.CanLibLoad
				0
			  elseif (f.IsStdLib)
				.libfuncs <~ f
			  else
				.packfuncs <~ f
		
	
	function DoLibGlobs (|jbin| pack)
		LibGlobs.sort(SCNodeSorter)
		
		for (f in LibGlobs)
			pack.Add(@thg, f.exportname)


	function SortAndPackFuncs (|[scfunction]| r, |jbin| pack)
		opt norefcounts
		r.sort(SCNodeSorter)
		
		for (f in r) (i)
			f.TableID = i
			if pack
				pack.Add(@thg, f.exportname)


	function Run (|string|)
		.AddAll
		.SortAndPackFuncs(.PackFuncs, nil)
		if Options.MakeInterpreter
			return .RunLib

	function RunLib (|string|)
		|| pack = jbin()
		pack.enter(@prm) // our funcs
		.SortAndPackFuncs(.libfuncs, pack)
		pack.exit

		pack.enter(@arr) // our globs
		.DoLibGlobs(pack)
		pack.exit
		return pack


function scfunction.WrappedName (|string|)
	if .iscppinbuilt
		return .exportname + "Wrap"
	  else
		return .exportname


helper SCNodeSorter (sortercomparer)
	// just to help compression. otherside will use a dictionary anyhow.
	return (a|scnode|).exportname < (b|scnode|).exportname


function scfunction.CanLibLoad (|bool|)
	require !.ismacro and !.isdisabled and .iscppinbuilt != 2
	return true
