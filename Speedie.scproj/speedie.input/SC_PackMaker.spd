

// some kinda function table... saved to a file

module PackMaker
	|[scfunction]|			LibFuncs
	|[SCDecl]|				LibGlobs
	|[scfunction]|			PackFuncs
	|[SCDecl]|				PackGlobs

	
	function AddAll
		opt norefcounts
		for f in Compiler.FuncList
			if !f.CanLibLoad
				0
			  elseif (f.IsStdLib)
				.libfuncs <~ f
			  else
				.packfuncs <~ f
		
	
	function DoLibGlobs (|jbin| pack)
		LibGlobs.sort(SCNodeSorter)
		
		for (f in LibGlobs)
			pack.Add(@thg, f.exportname)


/*
	instead of this... SortAndPackFuncs could create some cpp... like
	
struct LibPack
	|int|			FuncCount
	|int|			GlobCount
	|LibEntry[1]|	Item

struct LibEntry
	|&nil|		Where
	|cstring|	Name

then we just return a LibPack* from C++.

Then exec can just... use the table directly, as it is already sorted. :)
*/

	function SortAndPackFuncs (|[scfunction]| r, |jbin| pack)
		opt norefcounts
		todo "Write the data as c++ instead of a pack"
		r.sort(SCNodeSorter)
		
		for (f in r) (i)
			f.TableID = i
			if pack
				pack.Add(@thg, f.exportname)


	function Run (|string|)
		.AddAll
		.SortAndPackFuncs(.PackFuncs, nil)
		if Options.MakeInterpreter
			return .RunLib


	function RunLib (|string|)
		|| pack = jbin()
		pack.enter(@prm) // our funcs
		.SortAndPackFuncs(.libfuncs, pack)
		pack.exit

		pack.enter(@arr) // our globs
		.DoLibGlobs(pack)
		pack.exit
		return pack


function scfunction.WrappedName (|string|)
	if .iscppinbuilt
		return .exportname + "Wrap"
	  else
		return .exportname


helper SCNodeSorter (sortercomparer)
	// just to help compression. otherside will use a dictionary anyhow.
	return (a|SCNode|).ExportName < (b|SCNode|).ExportName


function scfunction.CanLibLoad (|bool|)
	if !.ismacro and !.isdisabled and .iscppinbuilt != 2
		return true
