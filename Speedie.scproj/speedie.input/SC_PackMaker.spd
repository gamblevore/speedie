

// some kinda function table... saved to a file

module PackMaker
	|[scfunction]|			LibFuncs
	|[SCDecl]|				LibGlobs
	|[scfunction]|			PackFuncs
	|[SCDecl]|				PackGlobs

	function AddAll
		opt norefcounts
		|| MakeExec = options.MakeInterpreter
		for f in Compiler.FuncList
			if !f.CanLibLoad
				0
			  elseif f.IsStdLib
				if MakeExec or f.needsexport
					.LibFuncs <~ f
			  elseif f.NeedsExport
				.PackFuncs <~ f
		.SortAll
		
	
	function DoLibGlobs (|jbin| pack)
		opt norefcounts
		LibGlobs.sort(SCNodeSorter)
		
		pack.enter(@arr)
		for (f in LibGlobs)
			pack.Add(@thg, f.ExportName)
		pack.exit


	function SortAll
		opt norefcounts
		|| FnInit = compiler.xfunc("JB_Init_")
		|| FnMain = compiler.xfunc("JB_Main")
		require fninit and fnmain
		
		fninit.tableid = 0 // put init and main first!
		fnmain.tableid = 1

		.SortSub(.libfuncs)
		.SortSub(.Packfuncs)
	
	
	helper SortSub (|[scfunction]| list)
		opt norefcounts
		list.sort(SCFuncSorter)
		for (f in list) (i)
			f.TableID = i

	
	function WriteLibFuncs (|jbin!| j)
		opt norefcounts
		todo "Write the data as c++ instead of a pack"
		
		j.Enter(@prm)
		for f in .libfuncs
			j.Add(@thg, f.exportname)
		j.Exit


	function MakePack 
		|| pack = jbin(@tmp, "xpd")
		pack.enter
		.MakePackSub(pack)
		|| str = pack.getresult
		Compiler.ProductFile.SmartData = str
		//printline str.parse
	
	
	helper MakePackSub (|jbin| j)
		opt norefcounts
		j.enter(@tmp, "app")


		|| upon = TreeAssembler.CollectFuncs("asm_test,asm_test_sub")
		|| fn1 = upon.first$

		|| args = {8725l, 275l}
		|| mu   = fn1.asm
			|| Result = mu.finish.run( &args[0], â€“count args )
			if result != 9000
		
		|| GlobSize = TreeAssembler.VacuumPack(upon)
		j.addint(GlobSize)
		j.enter


		j.tmp("fncs")
		for f in upon
			j.Add(@tmp, f.exportname, true)
			j.add(f.asm #expect)
			j.exit
		j.Exit(2)
		
		// OK... so what do we have? 3 kinds of lists
		// 1) whole-program lists. No pack involved. Code works as-is.
			// 2) interpreter lists. No pack-strings involved. This is also whole-program.
		// 3) pack-lists. No lib stuff.
		// so basically... only collect, (newid), if its whole-program or its a non-stdlib
		
		j.tmp("strs")
		for s in StringCorrector.list
			j.add(@str, s)
		j.exit(2)


		j.enter(@tmp, "clss")
		typeobject!.PackClassChildren(j)
		j.exit
		
		
		j.tmp("link")
		for linked in .libfuncs
			j.add(@thg, linked.ExportName)
		j.exit(2)


	function SCClass.HasPackChildren (|bool|)
		opt norefcounts
		for c in .children
			if !c.isrole and !c.isstdlib
				return true
			if c.HasPackChildren
				return true

	function SCClass.PackClassChildren (|jbin| j)
		opt norefcounts
		require .HasPackChildren
		j.enter
		for c in .children
			if !c.isrole
				c.packexport(j)
		j.exit
	
	
	function SCClass.PackExport (|jbin| j)
		opt norefcounts
		require .HasPackChildren or !.isstdlib

		j.enter(@tmp, .name)
		if !.IsSTDLib
			.DescribeInPack(j)
		.PackClassChildren(j)
		j.exit
		
		
	function SCClass.DescribeInPack (|jbin| j)
		opt norefcounts
		|| sz = (0, .size)(.iswrapper)
		j.addint(sz)
		
		|| fn_list = .behaviour!.WrapperFuncs
		j.enter(@list)
	
		|| name = "0"
		|| df = .DestructorFunc
			name = df.exportname
		j.add(@thg, name)
	
		|| b = .behaviour
		while (b)
			for (M in b.interfaces)
				|| fn = .BestBehaviourFor(m.name.InterfaceToBehaviour)
					|| BaseClass = .InterfaceForBehaviour(fn)
						j.add(@thg, fn.exportname)
			b = b.upwards
		
		j.exit

		
	function BuildInterpreter (|string|)
		|| pack = jbin()
		.WriteLibFuncs(pack)
		.DoLibGlobs(pack)
		return pack


function scfunction.WrappedName (|string|)
	if .iscppinbuilt
		return .exportname + "Wrap"
	  else
		return .exportname


helper SCFuncSorter (sortercomparer)
	// just to help compression. otherside will use a dictionary anyhow.
	|| fA = (a|scfunction|).Tableid|int|
	|| fB = (b|scfunction|).Tableid|int|
	if fA != fB // we need init and main first
		return fa < fb
	return (a|scfunction|).ExportName < (b|scfunction|).ExportName


helper SCNodeSorter (sortercomparer)
	return (a|scfunction|).ExportName < (b|scfunction|).ExportName


function scfunction.CanLibLoad (|bool|)
	if !.ismacro and !.isdisabled and .iscppinbuilt != 2
		return true


/* Instead of this... SortAndPackFuncs could create some cpp... like
struct LibPack
	|int|			FuncCount
	|int|			GlobCount
	|LibEntry[1]|	Item

struct LibEntry
	|&nil|		Where
	|cstring|	Name

then we just return a LibPack* from C++.

Then exec can just... use the table directly, as it is already sorted. :)    */


function printfunc (|string| s)
	|| fn = compiler.xfunc(s)
		printline fn
