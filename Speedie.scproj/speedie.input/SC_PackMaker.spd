

// some kinda function table... saved to a file

module PackMaker
	|[messageID]|			PackStrings
	|[SCFunction]|			LibFuncs
	|[SCDecl]|				LibGlobs
	|[SCFunction]|			PackFuncs
	|[SCDecl]|				PackGlobs
	|int|					_PackGlobSize
	|int|					_LibGlobSize
	|HairyMan|				PackSaved
	|hairyman|				LibSaved
	|HairyMan|				LibGlobSaved


	function PackGlobSize (|int|)
		return ._PackGlobSize init .GlobalsSize(.PackGlobs, true)
	
	function LibGlobSize (|int|)
		return ._LibGlobSize init .GlobalsSize(.libGlobs, false)
		
	helper AddFunc (|scfunction| f)
		opt norefcounts
		if f.IsLibrary
			if f.MyReacher or options.MakeInterpreter
				.LibFuncs <~ f
		  elseif f.MyReacher
			.PackFuncs <~ f

		
	function AddAll (|int|)
		opt norefcounts
		for f in Compiler.FuncList
			if f.CanLibLoad
				.addfunc(f)
	
	
	function DoLibGlobs (|jbin| lib) // SortLibGlobs
		opt norefcounts
		.LibGlobs.sort(GlobalsSorter)
		
		lib.enter(@arr)
		for (f in LibGlobs)
			lib.Add(@thg, f.ExportName)
		lib.exit
	
	
	function GlobalsSize (|[scdecl]| List, |bool| Alter, |int|)     // SortGlobals, GlobalsSort
		opt norefcounts
		rz = 1				// rz = 1, so if .au.ExportPosition == 0 then something is wrong.
		for (d in list)
			|| s = d.CarraySize
			|| s16 = s min 16
			rz = rz align s16
			if alter
				d.ExportPosition = rz
			rz += s
	

	function BuildGlobs
		opt norefcounts
		|| FnInit = compiler.xfunc("JB_Init_") // we need app and pack inits separately
		|| FnMain = compiler.xfunc("JB_Main")
		require fninit and fnmain
		
		fninit.PackID = 1 // put init and main first!
		fnmain.PackID = 2
		
		|| Obj = TypeObject!.ClassType!
		packmaker.LibGlobs <~ Obj
		TypeObject!.PackClassChildren(nil)

		|&&nil| Table
		|| frogs = .PackGlobSize
		if platform.isdebug
			Table = jb_vm.vm.InitTable(.libfuncs.length+31, frogs)
		
		.SortASMFuncs(.LibFuncs, Table)
		.SortASMFuncs(.PackFuncs, nil)
		.PackGlobs.sort(GlobalsSorter)
		.LibGlobs.sort(GlobalsSorter)

		for (g in .LibGlobs) (i)		// lib globs are asked for, so we'll ask for them by name.
			g.ExportPosition = i + 1
	
	
	function message.InlineCount (|int| Remain, |int|)
		opt norefcounts
		|| fn = .func
		require fn != @thg and @char
		if fn == @num
			return 1 - .iszero
			
		if fn == @bra
			return .first!.InlineCount(Remain)

		|| Count = (fn != @list and @emb and @decl and @arg)|int|
		for s in self
			|| Found = s.InlineCount(Remain)
			Count += Found
			Remain -= Found
			loop Remain > 0
		return count
	
	
	helper SortASMFuncs (|[scfunction]| list, |?&&nil| Table)
		opt norefcounts
		(table)
		list.sort(&CodeSorter.ExportNames)

		|| ID = 0
		while (|| f = list[id])
			f.PackID = ++id			
			target debug
				if Table
					Table[id+31] = jb_vm.Load(f.exportname)
	
	
	function WriteLibFuncs (|jbin!| j)
		opt norefcounts
		todo "Write the LibFuncs via c++ structs, instead of jbin, like array of name/ptr pairs"
		
		j.Enter(@prm)
		for f in .libfuncs
			j.Add(@thg, f.exportname)
		j.Exit

	
	function FATCompile (|bool|)
		opt norefcounts
		(Compiler is Hungry)
		.Packfuncs.sort(&CodeSorter.Leafness)
		
		for (fn in .Packfuncs) (i)
			require Assembler.sh.GenerateASM(fn, i+1)

		.Packfuncs.sort(&CodeSorter.ExportNames)
		
		if !Compiler.InPerry
			.RunAFewTests
		
		|| main = Compiler.MainFunc
			(main is usedbyasm)
		return true
	
	
	function MakePack 
		opt norefcounts
		compiler.During = compilerstage.Packing
		Assembler.Sh.PackMakerInit
		PackMaker.AddAll
		.BuildGlobs // Sorts too
		.FinalPrepare
		if .FATCompile and options.ModePack		// options.ModePack can be false, if compiler.InPerry = true
			.WritePackToDisk
		compiler.During = 0
	
	
	function WritePackToDisk
		|| F = Compiler.ProductPath.SetExt("zpd").file
		require f.OpenEmpty
		
		|| j = jbin(@tmp, "zpd")
		j.file = f
		j.enter
		j.Enter(@tmp, "app")
		j.AddInt(.PackGlobSize + 16)
		j.enter
		
		|| Stack_Trace = FastString()
		.RenderASM(j, stack_trace)
		.DumpStrings(j)
		.PackClasses(j)
		.FuncLink(j)
		.GlobLink(j)
		.AddDebugStuff(j, stack_trace)
		j.ExitAll
	
	
	function AddDebugStuff (|jbin| j, |string| func_names)
		j.tmp("debug")
		j.Enter(@tmp, "func")
		|CompressionStats| st
		|| f3 = func_names.compress(st)
		print "Stack-trace Compression: "
		st.print
		j.AddStr(f3)
		j.exit(3)

	
	function RenderASM (|jbin| j, |faststring| func_names)
		opt norefcounts
		j.enter(@tmp, "code")
		for f in .PackFuncs
			if (PackSaved)(j, f is UsedByASM)
				j.AddFunction(f)
				func_names <~ f.exportname
				func_names <~ '\n'
		j.Exit
		
		
	function DumpStrings (|jbin| j)
		|| strs = FastString()
		.DumpStringsSub(strs)
		strs <~ 0|byte|			// will all be cstrings... Overwrite lengths during load
		j.enter(@tmp, "strs")
		j.Add(@str, strs)
		j.exit
	
	
	helper DumpStringsSub (|jbin| strs)
		opt norefcounts
		for s in .PackStrings
			strs.AppendStrLength(s.length)
			strs <~ s


	function PackClasses (|jbin| j)
		j.enter(@tmp, "clss")
		typeobject!.PackClassChildren(j)
		j.exit
	
	
	function FuncLink (|jbin| j)
		opt norefcounts
		j.tmp("flnk")
		
		for linked in .libfuncs
			if (LibSaved)(j, linked is UsedByASM)
				j.add(@thg, linked.ExportName)
		j.exit(2)

	
	
	function GlobLink (|jbin| j)
		opt norefcounts
		j.tmp("glnk")
		for linked in .LibGlobs
			if (LibGlobSaved)(j, linked is usedbyasm)
				j.add(@thg, linked.ExportName)
		j.exit(2)


	function SCClass.HasPackChildren (|bool|)
		opt norefcounts
		for c in .children
			if !c.isrole and !c.IsLibrary
				return true
			if c.HasPackChildren
				return true
	
	
	function SCClass.PackClassChildren (|jbin?| j)
		opt norefcounts
		if j
			require .HasPackChildren
			j.enter
		for c in .children
			if c.isrole
				c.PackClassChildren(j)
			  else
				c.packexport(j)
		if j
			j.exit
	
	
	function SCClass.PackExport (|jbin?| j)
		opt norefcounts
		if j
			require .MyReacher or .IsLibrary or .HasPackChildren
			j.enter(@tmp, .name)
			if !.IsLibrary
				.DescribeInPack(j)
			.PackClassChildren(j)
			j.exit
		  else
			|| T = .ClassType!
			if .IsLibrary
				packmaker.libglobs <~ T
				if t isnt Library// what?
					/0
				(T is Library)
			  elseif .MyReacher
				packmaker.packglobs <~ T
			.PackClassChildren(j)
		
		
	function SCClass.DescribeInPack (|jbin| j)
		opt norefcounts
		|| sz = (0, .size)(.iswrapper)
		j.addint(sz)
		j.enter(@list)
	
		|| name = "0"
		|| df = .DestructorFunc
			name = df.exportname
		j.add(@thg, name)
	
		|| b = .behaviour
		while (b)
			for (M in b.interfaces)
				|| fn = .BestBehaviourFor(m.name.InterfaceToBehaviour)
					|| BaseClass = .InterfaceForBehaviour(fn)
						j.add(@thg, fn.exportname)
			b = b.upwards
		
		j.exit

		
	function BuildInterpreter (|string|)
		|| pack = jbin()
		.WriteLibFuncs(pack)
/		.DoLibGlobs(pack)
		return pack


function SCFunction.WrappedName (|string|)
	if !.iscppinbuilt
		return .ExportName
	return .ExportName + "Wrap"


function SCFunction.CanLibLoad (|bool|)
	if !.ismacro and (self isnt disabled) and (.iscppinbuilt != 2)
		return true


/*
	Globals used by speedie: (legit, not removeable)
	|Array of Message!| TmpPrms_(1) --> VM_Builder__FinishAcc
	|Random| Shared(2)				--> SCGame3D__Love // remove!
	|ErrorReceiver!| StdErr(3)		--> nil__LaunchMothership
	|MessagePosition| Using(4)		--> AC__ParserRestore
	|SpdProcess| Parent(5)			--> AC__EnterAutoComplete
	|bool| _DotInsertAllow(6)		--> AC__GetFunc
	|Dict of SyntaxObj| _SyxDict(7) --> Cpp_WriteAPIHeader
	|byte| Active(8)				--> Func__CurrFuncSet
	|Charset!| CSLine(9)			--> Ext__Clean
	|bool| Enabled(10)				--> Options__ColorSet
	|byte| AutoPrint(11)			--> FB__AppOptions_breakonerr
	|bool| DebugExecute(12)			--> FB__AppOptions_noisy
	|Charset!| CSWordStart(13)		--> Str_IsOKForImport
	
	The self-compile seems to be filled with littered with wasteful globals? WHY? all sorts of functions called from glnk
*/

/*
	We can make a link-compression scheme!
	JB_File__Prefs
	JB_File__SpeedieDir -->
	JB_File__Prefs
	xxxxxxxxxSpeedieDir -->
	
	just mark how many bytes backwards and forwards. Can do in 1 byte. 4 bits for down 4 bits for up.
	
	If we go 0 up... it means a special code. For extra-long stuff.
	
	0 down and 0 up means... skip! for placeholders
*/



function SCFunction.CanPrepareInline (|bool|)
	opt norefcounts
	require (self isnt cpp) and .HasProperSpeedieCode
	|| Allowed = 15 + (self is inline)<<4
	|| Count = .SourceArg!.InlineCount(Allowed)
	if Count <= Allowed
		return true


function packmaker.FinalPrepare
	opt norefcounts
	Assembler.jsm.length = 0

	for c in Compiler.ClassList
		if c.IsRole
			|| t = c.ClassType!
			|| t2 = c.RealClass.ClassType!
			t.ExportPosition = t2.ExportPosition
	// the file-size goes up if we enable this. More inlining?
	// we need to find out why.

	require Options.InlineLib

	for (fn in .LibFuncs) (i)
		if fn.CanPrepareInline
			require Assembler.sh.GenerateASM(fn, -(i+1))
			Assembler.jsm.length = 0


struct HairyMan 
	|uint16| Savings
	|uint16| Curr
	|uint|	 Total

	syntax Call (|jbin| j, |bool| b, |bool|)
		.Total++
		if b
			|| c = .curr
				j.addint(c)
			.curr = 0
			return true
		.curr++
		.Savings++
		return false
			
	function Churn (|faststring| fs)
		fs <~ "$.Savings / $.Total"


