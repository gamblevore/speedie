


module Linkage
	|| OSXFrameworks = message()
	|| Flagz = message()		// for the linker i guess...
	
	syntax access (|string| name, |bool|)
		opt norefcounts
		return linkage.GetFlag(name).yes
	
	function Interpreter (|bool|)
		return self["interpreter"]
	
	function VM (|bool|)
		return self["vm"]
	
	function CombineFlags (|string| name,, |string|)
		|| fs = faststring()
		.getflag(name, fs)
		return fs
	
	function GetFlag (|string| name, |faststring| fs=nil, |string|)
		opt norefcounts
		for ch in .Flagz
			if ch ~= name
				if !fs
					return ch.firstname
				|| str = ch.firstname
					if fs.length
						fs <~ ' '
					fs <~ str


	function message.ConfTake (|message| dest, |string| name)
		opt norefcounts
		|| F = self[name]
			dest.PrependAll(F) // shouldn't this be appendall?
			F.parent!.remove


	function CompilerCollect (|message| s)
		opt norefcounts
		Linkage.LinkCollect(s, Compiler.Program, nil)
		options.MakeExec = linkage.interpreter
		|| Combo = options.MakeExec + options.modepack
		check (Combo <= 1) ("Can't bake exec!")
		s.remove
	

	function LinkCollect (CollectFunc)
		opt norefcounts
		expect  (name_space == Compiler.Program)  (node, "This must be at root.")
		|| arg = node[@arg]						#expect (ErrPlace, `Supposed to be like: linkage { osx = "linker flags", win = "linker flags2" }` )
		
		|| path = arg["flags"]["output_path"]
			if !options.silent
				print "output_path here: "
				printline node.OriginalFilePath
			feedback.SetOutputPath path

		arg.ConfTake(.flagz, "flags")
		arg.ConfTake(.osxframeworks, "frameworks")

		arg.expectempty
		return Compiler.program




//module InbuiltShellArgs
//	function Collect (CollectFunc)
//		expect  (name_space == Compiler.Program)  (node, "This must be at root.")
//
//		|| ShellArgs = node[@list].listall
//		feedback.ParseArgsSub(shellargs)
//		
//		return Compiler.program




dispatch FuncLinkageTable (TranFunc)
	+'cpp_wrapper'			{}
	+'cpp_part'				{
		SCNode.LoadCppPart(node, name_space, node)
	}
	+'cpp_refs'				SCFunction.tran_cpprefs //(fn, node, name_space), return true}
	+'visible'				{} // (SCFunction.Tran_Visible)
	+'ignore'				{}

	+'maxasm'
		opt norefcounts
		if fn
			|| n = node[@num]
				n.expectlast
				fn.maxasm = n.int
		return true


dispatch ClassOrModuleLinkage (TranFunc)
	// these items with {} are processed elsewhere...
	// it would have been better to process them all here. but I wrote this after
	// So the older code still needs removing and using this instead.
	+'cpp_wrapper'			{}
	+'cpp_part'				{SCNode.LoadCppPart(node, name_space, node)}
	+'cpp_refs'				scfunction.tran_cpprefs
	+'cpp_class'			{}
	+'visible'				{} // (SCFunction.Tran_Visible)
	+'ignore'				{}
	+'noearlyfree'			{}

//	+'internal'
//		name_Space.setinternal(node, scnodeinfo.internalonly)
		
	+'embedded'
		name_Space.setinternal(node, scnodeinfo.embeddedonly)
		
	+'libinternal'
		|| v = node.first.yes(true)
		(name_space is libonlyall) = v

	+'sort_properties'
		if name_space.mustbe(scclass, node)
			(name_Space is SortsProperties) = node.first.yes(true)
	
	
	+'tighten'
		opt norefcounts
		if name_space.mustbe(scclass, node)
			expect (name_Space.isobject or name_Space.isstruct) (name_space, "Only applies to structs or objects")
			expect !(name_space.iswrapper) (name_space, "Can't tighten wrapper classes")
			|| yes = node.first.yes(true)
			(name_space is sortsproperties) = yes

	+'wrapper'
		opt norefcounts
		if name_space.mustbe(scclass, node)
			name_space.IsWrapper = 1
			|| f = node.first
				f.expect(@thg)
				f.expectlast
				if f == "union"
					name_space.iswrapper = 2
				  else
					error (f)
	
	+'stateless'
		if name_space.mustbe(scclass, node)
			(name_space is stateless)
			name_space.CheckStateful(node)

	+'stateful'
		if name_space.mustbe(scclass, node)
			(name_space is stateful)
			name_space.CheckStateful(node)
		

	+'datatype'
		if name_space.mustbe(scclass, node)
			expect (name_space.isstruct) (node, "Expected this for a struct")
			|| value = node[@thg]
				value.expectlast

	+'numeric'
		opt norefcounts
		if name_space.mustbe(SCClass, node)
			expect (name_space.isdatatypeOnly) (node, "Expected this for a datatype")
			|| type = node[@thg]$
			name_space.typeinfo = 0
			if type == "false" or "symbol"
				(name_space is symbol)
			  elseif type == "flags"
				(name_space is flags)
			  else
				error type


// now we have a numeric reduction... how to disable it nicely?
// we need a test function

function SCNode.ProcessLinkage (|message| node,  |dictionary of tranfunc| Table,  |bool| Strict,  |SCNode|)
	opt norefcounts
	|| fn = .owningfunc
	for ch in node
		if ch == @tmp
			|| linker = Table[ch.name]
				if (linker[])(fn, ch, self)
					ch.remove
			  elseif strict
				error ch
		  elseif strict
			if ch!=@sheb
				ch.Expect(@tmp)
		  else
			return nil

	return compiler.program


function scclass.CheckStateful (|message| node)
	expect (self isnt stateful or self isnt stateless) (node, "Can't be both stateful and stateless")


function Scnode.SetInternal	(|message| node, |classinfo| info)
	opt norefcounts
	|scmodule| M
	if self isa scclass
		M = .modul
	  elseif self isa scmodule
		M = self
	  else
		error node
		return
	expect (!(M.nodeinfo&info)) (node, "internal/embedded conflict")
	M.nodeinfo |= info

