
/*	
	
	Todo:
		* Collectdecls: Pointers still need separate treatment... and getting the address/dereffing might be different too?

		* NilCheck:
			Create problems / errors if not used properly
		
		* Init Vars Sweep: 
			We need to go through the entire program, and give each item found, a "timecode". That
			is... it has an "earliest time" that it COULD occur.
			So for branches, thats easy, both sides get the same time. We can do some simple logic like:
			
			function abc
				if !inited
					inited = true
					var1 = .CreateVar
					var2 = .CreateVar
				var1.explode
				var2.die
			
			If its only set in one place... that can help.
			
			So var1.explode actually has a "higher time" than var1 = .createvar. So its OK.
			
			Like this... we can make it work!
			
			POSSIBLY we could allow reordering.
			
			while looops are easier, unless they might not fire at all.
			
			function pointers... are a bit trickier?
			
			if (random[])
				a lot of code
				(.func)()
			  else
				small code
				(.func)()

			we have to check the time twice? But thats true of function calls in general???
			We could do it differently... "at each second in time..." there can be an array (or list whatever) of possible code we could be executing. The problem with that, is that it would explode exponentially :)
			
			Perhaps not? if we exclude times that not newer?
			
			PROBABLY MAKE SOMETHING SIMPELR THAN THIS
							
						
		* Strength:
			Setting to a definite nil is ALWAYS an error... like: nil|msg|.pos=0
			Strength is settable in the project if its an error or problem
			For now it defaults to problem
*/




module NilChecker
	function CheckAll
		opt norefcounts
		using options.NilStrength
	
		for f in compiler.funclist
			if !f.IsMacro and !f.IsWrapper
				f.NilCheck
		
		scfunction.currfunc = nil
		.Sweep

	
	function Sweep
		|| main = compiler.getmainfunc(nil)
		// what about "init_"?
	


function SCfunction.NilCheck
	scfunction.currfunc = self
	|SCNilLister| nel
	.sourcearg.NilCheckArg(nel, 0)
	nel.Tighten(self)
	nel.Restore // nice!
	// need to restore the .nilused all types altered? and alter the params...
	// we'll need a decllister... something to just keep track of the decls...
	
	
function message.NilCheckProperty (|&scnillister| nel)
	pragma inline
	|| Prop = .DotMustBeProperty
	require prop and (prop isnt OnModule)
	|| f = .first
	|| ObjDecl = TypeOfExpr(f, nil)
	if !ObjDecl
		target debug
			printline scfunction.currfunc
			"nil type: $f ${prop.objectid}"
			debugger 
		return nil

	|| u = ObjDecl.NilUsed
	expect (u is exists) (self, "Nillable var accessed.")
	ObjDecl.NilUsed &= ~NilState.Optional
//	This definitely exists now! We tested it!
//  Alter the declaration later!

/*
Issues:
 what if this is a shared decl? we'll have to unshare it.
	When? After Func is finished

We'll need to refrsh the nullable states on function start... and on any decls found

if/while blocks need to keep a stack of multiple variables
	if a and b and c
		a.a(b.b(c.c))


*/


function message.NilCheckAccess (|&scnillister| nel)
	pragma inline
//	"Mem: $self"


function message.NilCheckFP (|&scnillister| nel)
	pragma inline


function message.NilCheckCond (|&scnillister| nel, |int| Time, |int|)
	pragma inline

// 
//	if msg
//		// msg is now optional
//		if msg > nil, if msg != nil // same
//		// msg is now optional and NOT nil within this branch
//	
//	if msg == nil // msg is now optional... but nil within that branch
//	if msg >= nil, msg <= nil // what? just fail!
//	


function Message.NilCheckFlat (|&scnillister| nel, |int| Time, |int|)
	opt norefcounts
	for s.flat in self
		Time++
		if s == @arg
			s.NilCheckArg(nel, Time)
		  else
			s.NilCheckMemory(nel)
			// so what do we have to test?
			// if (a)
				// || x = *a
					// if x
			// *a = y


function Message.NilCheckMemory (|&scnillister| nel)
	opt norefcounts
	|| f = .func
	if f == @dot
		.NilCheckProperty(nel)								// abc.var
	  elseif (f == @brel and self == "*") or f == @acc
		.NilCheckAccess(nel)									// *abc / abc[0]
	  elseif (f == @func and .first == @bra)
		.NilCheckFP(nel)										//  (abc)()



function Message.NilCheckArg (|&scnillister| nel, |int| Time)
	opt norefcounts
	for s in self
		#! We have ASM if/while flags set! Just use them???
		Time++
		if s.func == @tmp and (s == "if" or "while")
			time = s.NilCheckCond(nel, Time)
		  else
			time = s.nilcheckflat(nel, Time)
			

