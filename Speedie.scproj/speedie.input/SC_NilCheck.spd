
/*	
	
	Todo:
		* Collectdecls: Pointers still need separate treatment... and getting the address/dereffing might be different too?
					
		* Transform:	This modifies the nilness of params and vars... depending on if they are tested or not
						if/while/ternary/??/?/and/or/expandtobool?
						wrapper-funcs (i guess just declare them as testers)

						if msg
							// msg is now optional
							if msg > nil, if msg != nil // same
							// msg is now optional and NOT nil within this branch
						
						if msg == nil // msg is now optional... but nil within that branch
						if msg >= nil, msg <= nil // what? just fail!
						
						My loops will need some altering! Like for arrays... we'll have to check if an
						item is nil... to exit the loop instead of checking the int value. Faster actually!
						
						
						
		* NilCheck:		This will create problems or even errors if not used properly
						Do this after transform and before refcount!
						We need to go through the entire program, and give each item found, a "timecode". That
						is... it has an "earliest time" that it COULD occur.
						So for branches, thats easy, both sides get the same time. We can do some simple logic like:
						
						function abc
							if !inited
								inited = true
								var1 = .CreateVar
								var2 = .CreateVar
							var1.explode
							var2.die
						
						If its only set in one place... that can help.
						
						So var1.explode actually has a "higher time" than var1 = .createvar. So its OK.
						
						Like this... we can make it work!
						
						POSSIBLY we could allow reordering.
						
						while looops are easier, unless they might not fire at all.
						
						function pointers... are a bit trickier?
						
						if (random[])
							a lot of code
							(.func)()
						  else
							small code
							(.func)()

						we have to check the time twice? But thats true of function calls in general???
						We could do it differently... "at each second in time..." there can be an array (or list whatever) of possible code we could be executing. The problem with that, is that it would explode exponentially :)
						
						Perhaps not? if we exclude times that not newer?
							
						
		* Strength:		Setting to a definite nil is ALWAYS an error... like: nil|msg|.pos=0
						Strength is settable in the project if its an error or problem
						For now it defaults to problem
*/



datatype NilState (byte)
	constants
		|nilstate|
		nil		= 1
		exists	= 2
		unknown = 3
		optional = 3
	syntax is (|nilstate| type, |bool|)
		return self == type
	syntax isnt (|nilstate| type, |bool|)
		return self != type



module NilChecker

	function Check
		//(all~compiler.FuncList).FindDepths
		for f in compiler.FuncList
			f.FindDepths
	
		.Sort
	
		for f in compiler.funclist
			f.NilCheck
		
		.Sweep
	
	function Sweep
		|| main = compiler.getmainfunc(nil)
		// what about init?
	
		
	function Sort
		compiler.funclist.sort(NilCheckerOrder)



// recursive is a bit akward...
	// x --> a
	// a --> b
	// b --> c
	// b --> a



function scfunction.MarkRecursive (|scfunction| EndAt)
	opt norefcounts
	if (endat == self)
		.alloccode |= kIsRecursive
		return
	
	|| f = self
	while f
		f.alloccode |= kIsRecursive
		f = f.DepthFinder
		if f == EndAt
			exit


// probably should handle recursion better
// but this will do for now!
function scfunction.FindDepths (|int|)
	if .depth
		return .depth
	
	rz = 1
	for f in .LinkTo
		if f isa SCFunction
			if f.DepthFinder
				.MarkRecursive(f)
			  else
				f.DepthFinder = self
				|| D = f.FindDepths+1
				(rz max= D)
				f.DepthFinder = nil

	.depth = rz
	
	
function NilCheckerOrder (sortercomparer)
	opt norefcounts
	|| fa = a|scfunction|
	|| fb = b|scfunction|
	return fa.depth < fb.depth



function scfunction.nilcheck
	opt norefcounts
	for s.flat in .source
		|| f = s.func
		//if f == @dot // a property?
			
			
//		* its just about properties, really? properties and pointers? anyhting that counts as a pointer and then accessing it...
//		* like *abc or abc[0] or abc.var
	


