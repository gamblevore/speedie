

// vm.box


class µForm 
	|int|			Count
	|string|		Name
	|µParam[6]|		Params
	|int|			TotalBits
	|int|			Index
	
	
	render
		fs <~ .name
		for i in .count
			fs <~ " "
			fs <~ .params[i].BitSize
		
	constructor (|string| data, |message?| tmp)
		opt norefcounts
		.name = tmp.name
		for i in 6
			.params[i] = 0
		if tmp
			for line in tmp.last(@arg)
				|| f = line.needfirst
				.loadparam(f.name, f)
		  else
			for param in data
				.loadparam( string.byte(param), nil )
		
		.index = ++µform.count


	function AddP (|int| Size, |µParam| P)
		if size <= 0 or size > 32 // hmm??
		|| i = .count++
		.totalbits += size
		expect (i < 6) ("Too many params.")
		p |= size-1
		.params[i] = p
			

	function LastField (|µParam|)
		return self[.Count-1]
	
	syntax Access (|int| i, |µParam|)
		cpp_part AccessInt
		return .params[i]
	
	syntax Access (|int| i, assigns: |µParam|)
		.params[i] = Value
	
	
	iterator
		|| i = 0
		while (i < .count)
			yield self[i] (i)
			i++

	function AddRemainder (|uint| U)
		.addp( 32 - .TotalBits, asm.num ||| U)
	
	function LoadParam (|string| pl, |message| place)
		if (pl.isint)
			|| i = pl.int
			check (i > 0 and i <= 24) (place, "Number out of range (1-24)")
			.addp(i, asm.num)
			return
		expect (pl == 1) (self)
		|| p = *pl
		if  p == 'r'
			.addp(5, 0)
		  elseif p == 'x'
			.addp(32, 0)
		  elseif p == 'n'
			.addp(5, asm.num)
		  elseif p == 'l'
			.addremainder(0)
		  elseif p == 'L'
			.addremainder( asm.NoExpect )
		  elseif p == 's'
			.addremainder( asm.signed )
		  elseif p == 'S'
			.addremainder( asm.signed + asm.NoExpect )
		  elseif p == 'j'
			.addremainder( asm.signed + asm.jump )
		  elseif place
			error (place)
		  else
		    error (self)
	

	module
		|dictionary of µForm|				Forms = dictionary()
		|int| Count
		function Needform (|string| Form, |µform|)
			opt norefcounts
			return forms.valuelower(form) init µform(form, nil)
