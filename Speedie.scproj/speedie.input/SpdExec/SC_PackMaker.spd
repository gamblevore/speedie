

// some kinda function table... saved to a file

module PackMaker
	|[messageID]|			PackStrings
	|[SCFunction]|			LibFuncs
	|[SCDecl]|				LibGlobs
	|[SCFunction]|			PackFuncs
	|[SCDecl]|				PackGlobs
	|int|					PackFuncIndex
	|int|					PackGlobSize
	|int|					LibGlobSize
	|HairyMan|				PackSaved
	|hairyman|				LibSaved
	|string|				LName
	
	
	function scclass.LName (|string|)
		PackMaker.lname = .name.lowercase
		return PackMaker.lname
	
	
	helper scfunction.NeedsLibExport (|bool|)
		require (.MyReacher or options.MakeExec)
		require (self isnt NoExport) and !.ismacro
		require self|scnode| isnt Private
		return (.IsCppInBuilt < 2)
	
	
	helper AddFunc (|SCFunction| f)
		opt norefcounts
		if f.IsLibrary
			if f.NeedsLibExport
				.LibFuncs <~ f
		  else
			|| R = f.MyReacher
				check (f isnt ExternalLib) (R.Source, "External library functions can't yet be used in cake files.")
				.PackFuncs <~ f
	
	
	function AddAll
		opt norefcounts
		for f in Compiler.FuncList
			if f.CanLibLoad
				.addfunc(f)
	
	
	function GlobalsSize (|[scdecl]| List, |int|)	// SortGlobals, GlobalsSort
		opt norefcounts
		|| Globals = 1								// always positive.
		for d in list
			|| s = d.CarraySize
			|| s16 = s min 16
			globals = globals align s16
			|| X = d.ExportPosition
			if !X or X == globals
				d.ExportPosition = globals			// its ok
			  elseif (options.MakeExec)
				error (d.source, d.name + "'s ExportPosition doesn't match. Please revert export-table. To remove an item, replace it with a carray of bytes.")
			  else
				|| Backwards = x - globals
				if backwards > 0					
					0 // keep old value				// Something missing. EG: Compiling non-gui app.
				  else
					error (d.source, d.name + " exportposition seems inserted? Regen export-table?")
			globals += s

		return Globals.AlignUp(8)					// for strings, which come directly after


	function UseMain (|string| Name, |int| id, |bool|)
		opt norefcounts
		|| Fn = compiler.xfunc(name)				// we need app and pack inits separately
			fn.fpackid = id
			(fn is usedbyasm)
			return true

	function BuildGlobs (|bool|)
		opt norefcounts
		require .UseMain("JB_SP_AppInit", 1) and  .UseMain("JB_Main", 2)

		LibStability.StabiliseFuncs	
		LibStability.StabiliseGlobs
		
		.PackIDFuncs(.PackFuncs)
		.PackGlobs.sort
		.PackGlobSize = .GlobalsSize(.PackGlobs)
	
		return true
	
	
	function message.InlineCount (|int| Remain, |int|)
		opt norefcounts
		|| fn = .func
		require fn != @thg and @char
		if fn == @num
			return 1 - .IsZero
			
		if fn == @bra
			return .first!.InlineCount(Remain)

		|| Count = (fn != @list and @emb and @decl and @arg)|int|
		for s in self
			|| Found = s.InlineCount(Remain)
			Count += Found
			Remain -= Found
			loop Remain > 0
		return count
	

	helper PackIDFuncs (|[scfunction]| list)
		opt norefcounts
		list.sort(&CodeSorter.fPackID)
		|| ID = 0
		while (|| f = list[id])
			f.fPackID = ++id

	
	function FATCompile (|bool|)
		opt norefcounts
		.FinalPrepare
		(Compiler is Hungry)
		.Packfuncs.sort(&CodeSorter.Leafness)
		
		.PackFuncIndex = 0
		while (|| fn = .packfuncs[.PackFuncIndex])
			.PackFuncIndex++
			require Assembler.sh.ASMCompile(fn)

		.Packfuncs.sort(&CodeSorter.fPackID)
		
		target debug
			if !Compiler.InPerry
				.RunAFewTests
		return true
	
	
	function assembler.FullInit
		.packmakerinit
		if options.TargetDebug
			.debuginfo = .FillDebugInfo
	
	
	function MakePack 
		opt norefcounts
		compiler.During = compilerstage.Packing
		.OrderLibGlobs
		Assembler.Sh.Fullinit
		PackMaker.AddAll
		if stderr.ok and .BuildGlobs 
			if .FATCompile and options.ModePack		// options.ModePack can be false, if compiler.InPerry
				.WritePackToDisk
		compiler.During = 0
	
	
	function WritePackToDisk
		|| F = Compiler.ProductPath.SetExt("cake").file // what about .app instead of .zpd?
		require f.OpenEmpty
		
		|| j = jbin(@tmp, "cake")
		j.file = f
		j.enter
		j.Enter(@tmp, "app")
		j.AddInt(.PackGlobSize + 16)
		j.enter
		
		.RenderASM(j)
		.DumpStrings(j)
		.PackAllClasses(j)
		.AddDebugStuff(j)
		j.ExitAll
	
	
	function AddDebugStuff (|jbin| j)
		|| dbg = assembler.sh.debuginfo			#require

		j.tmp("debug")
		|| str = dbg.GetResult.Compress
		assembler.sh.debuginfo = nil
		compiler.stDebugInfo += str.length
		j.AddStr(str)
		j.exit(2)

	
	function RenderASM (|jbin| j)
		opt norefcounts
		j.enter(@tmp, "code")
		j.Enter
		.PackAllFuncs(j)
		j.exit(2)
		scfunction.currfunc = nil
		
		
	function DumpStrings (|jbin| j)
		|| strs = FastString()
		.DumpStringsSub(strs)
		strs <~ 0|byte|			// will all be cstrings... Overwrite lengths during load
		j.enter(@tmp, "strs")
		j.Add(@str, strs)
		j.exit
	
	
	helper DumpStringsSub (|jbin| strs)
		opt norefcounts
		strs.AppendHInt(.packstrings.length)
		for s in .PackStrings
			strs.AppendHInt(s.length)
			strs <~ s


	function PackClasses (|jbin| j, |bool| Pack)
		opt norefcounts
		for c in Compiler.ClassList
			if (c.islibrary != pack) and c.NeedsPackExport
				C.DescribeInPack(j)


	function PackAllClasses (|jbin| j)
		j.tmp("clss")
		.PackClasses(j, false)
		.PackClasses(j, true)
		j.exit(2)
	
	
	function SCClass.NeedsPackExport (|bool|)
		opt norefcounts
		//  "stringzeroterminated" is being reached
		// for what reason could we want it?
		// if we reach it's decl.
		// how does the decl know that it was reached?
		// well... if it got added to the packglobs??
		// or is it always there?
		// its always there. Well... we could check for reachedness?
		// and manually mark it?
		// how do we check for reachedness?
		
		// ASMReached
		
		require .isobject and !.IsRole
		|| R = .MyReacher
		require r and !r.IsLibrary
		
		if .IsLibrary
/			|| T = .ClassType
			require T is ASMReached
			
		return true

	
	function scclass.CollectBehaviours (|jbin| j, |scbehaviour!| B)
		opt norefcounts
		|| up = b.upwards
			.CollectBehaviours(j, up)

		|| ft = b.functable$
		|| ftc = ft.cls!
		for (M in ftc.properties)				// could I change the cpp exporter to use this same approach?
			|| fn = .BestBehaviourFor(m.name)	// might as well?
				|| BaseClass = .InterfaceForBehaviour(fn)
					j.Cakeify(fn)
					continue
			.missingvirtual(m.name)

	
	function jbin.Cakeify (|scfunction| fn)
		if !fn
			.addint 0
			return
		.Enter(@unit, fn.name)
		|| id = fn.fPackID							#check ( fn.source,  "Missing PackID[2]" )
		id = (id << 1) + fn.IsLibrary
		.AddInt(id)
		.exit

	
	function SCClass.DescribeInPack (|jbin| j)
		|scbehaviour--| B = .behaviour				#expect ( .source,  "Missing behaviour" )
		|| sz = .clssize
		j.enter(@tmp, .name.lowercase)
		
		j.Enter(@list)     //////     //////     //////
		j.AddInt(.classtype!.ExportPosition)
		if !.IsLibrary
			j.Add(@thg, .super!.name.lowercase)
			j.addint(sz)
		j.exit     		   ///
		
		if !.IsLibrary     //////     //////     //////
			j.enter(@list)
			j.Cakeify(.destructorfunc)
			.CollectBehaviours(j, B)
			j.exit    	  ///
		j.exit


function SCFunction.WrappedName (|string|)
	if !.iscppinbuilt
		return .ExportName
	return .ExportName + "Wrap"


function SCFunction.CanLibLoad (|bool|)
	if !.ismacro and (self isnt disabled) and (.iscppinbuilt != 2)
		return true


function SCFunction.CanPrepareInline (|bool|)
	opt norefcounts
	require (self isnt cpp) and .HasProperSpeedieCode
	|| Allowed = 15 + (self is OptInline)<<4
	|| Count = .SourceArg!.InlineCount(Allowed)
	if Count <= Allowed
		return true


function packmaker.FinalPrepare
	opt norefcounts
	Assembler.jsm.length = 0

	for c in Compiler.ClassList
		if c.IsRole
			|| t = c.ClassType!
			|| t2 = c.RealClass.ClassType!
			t.ExportPosition = t2.ExportPosition

	require Options.InlineLib

	// These lib funcs are not actually going into the pack.
	// We just want to see the size of the libfunc, if it were inlined.
	for (fn in .LibFuncs) (i)
		if fn.CanPrepareInline
			require Assembler.sh.ASMCompile(fn)
			Assembler.jsm.length = 0


struct HairyMan 
	|uint16| Savings
	|uint16| Curr
	|uint|	 Total

	function AddOrShrink (|jbin| j, |bool| b, |bool|)
		.Total++
		if b or Options.TargetDebug
			|| c = .curr
				j.addint(c)
			.curr = 0
			return true
		.curr++
		.Savings++
		return false
			
	function Churn (|faststring| fs)
		fs <~ "$.Savings / $.Total"


