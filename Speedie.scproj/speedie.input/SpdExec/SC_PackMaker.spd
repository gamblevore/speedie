

// some kinda function table... saved to a file

module PackMaker
	|[messageID]|			PackStrings
	|[SCFunction]|			LibFuncs
	|[SCDecl]|				LibGlobs
	|[SCFunction]|			PackFuncs
	|[SCDecl]|				PackGlobs
	|int|					_PackGlobSize
	|int|					_LibGlobSize
	|HairyMan|				PackSaved
	|hairyman|				LibSaved
	|HairyMan|				LibGlobSaved


	function PackGlobSize (|int|)
		return ._PackGlobSize init .GlobalsSize(.PackGlobs)
	
	function LibGlobSize (|int|)
		return ._LibGlobSize
		
	helper scfunction.NeedsLibExport (|bool|)
		require (.MyReacher or options.MakeInterpreter)
		require self isnt NoExport
		require self|scnode| isnt Private
		return (.IsCppInBuilt < 2)
	
	helper AddFunc (|scfunction| f)
		opt norefcounts
		if f.IsLibrary
			if f.NeedsLibExport
				.LibFuncs <~ f
		  else
			if f.MyReacher
				.PackFuncs <~ f
	
	function AddAll (|int|)
		opt norefcounts
		for f in Compiler.FuncList
			if f.CanLibLoad
				.addfunc(f)
	
	
	function GlobalsSize (|[scdecl]| List, |int|)	// SortGlobals, GlobalsSort
		opt norefcounts
		|| Globals = 1								// always positive.
		for (d in list)
			|| s = d.CarraySize
			|| s16 = s min 16
			globals = globals align s16
			|| X = d.ExportPosition
			if !X or X == globals
				d.ExportPosition = globals			// its ok
			  elseif (options.makeinterpreter)
				error (d.source, d.name + "'s ExportPosition doesn't match. Please revert export-table. To remove an item, replace it with a carray of bytes of same size.")
			  else
				|| Backwards = x - globals
				if backwards > 0					
					0 // keep old value				// Something missing. EG: Compiling non-gui app.
				  else
					error (d.source, d.name + " exportposition seems inserted? Regen export-table?")
			globals += s

		return Globals.AlignUp(8) // for strings, which come directly after


	function BuildGlobs (|bool|)
		opt norefcounts
/		|| FnInit = compiler.xfunc("JB_Init_") // we need app and pack inits separately
		|| FnMain = compiler.xfunc("JB_Main")
		require fninit and fnmain
		
		fninit.PackID = 1 // put init and main first!
		fnmain.PackID = 2

		stability.Stabilise				
		.PackIDFuncs(.PackFuncs)
		.PackGlobs.sort

		.FinalPrepare
		return true
	
	
	function message.InlineCount (|int| Remain, |int|)
		opt norefcounts
		|| fn = .func
		require fn != @thg and @char
		if fn == @num
			return 1 - .IsZero
			
		if fn == @bra
			return .first!.InlineCount(Remain)

		|| Count = (fn != @list and @emb and @decl and @arg)|int|
		for s in self
			|| Found = s.InlineCount(Remain)
			Count += Found
			Remain -= Found
			loop Remain > 0
		return count
	

	helper PackIDFuncs (|[scfunction]| list)
		opt norefcounts
		list.sort(&CodeSorter.ExportNames)
		|| ID = 0
		while (|| f = list[id])
			f.PackID = ++id

	
	function FATCompile (|bool|)
		opt norefcounts
		(Compiler is Hungry)
		.Packfuncs.sort(&CodeSorter.Leafness)
		
		for (fn in .Packfuncs) (i)
			require Assembler.sh.ASMCompile(fn, i+1)

		.Packfuncs.sort(&CodeSorter.ExportNames)
		
		if !Compiler.InPerry
			.RunAFewTests
		
		|| main = Compiler.MainFunc
			(main is usedbyasm)
		return true
	
	
	function assembler.FullInit
		.packmakerinit
		if options.TargetDebug
			.debuginfo = .FillDebugInfo
	
	
	function MakePack 
		opt norefcounts
		compiler.During = compilerstage.Packing
		Assembler.Sh.Fullinit
		PackMaker.AddAll
		if .BuildGlobs and .FATCompile and options.ModePack	// options.ModePack can be false, if compiler.InPerry
			.WritePackToDisk
		compiler.During = 0
	
	
	function WritePackToDisk
		|| F = Compiler.ProductPath.SetExt("cake").file // what about .app instead of .zpd?
		require f.OpenEmpty
		
		|| j = jbin(@tmp, "zpd")
		j.file = f
		j.enter
		j.Enter(@tmp, "app")
		j.AddInt(.PackGlobSize + 16)
		j.enter
		
		|| Stack_Trace = FastString()
		.RenderASM(j, stack_trace)
		.DumpStrings(j)
		.PackClasses(j)
		.AddDebugStuff(j, stack_trace)
		j.ExitAll
	
	
	function AddDebugStuff (|jbin| j, |string| func_names)
		j.tmp("debug")
		|| f3 = func_names.compress
		j.Add(@str, f3)
		|| dbg = assembler.sh.debuginfo
			|| str = dbg.GetResult.Compress
			assembler.sh.debuginfo = nil
			compiler.stDebugInfo += str.length
			j.AddStr(str)
		j.exit(2)

	
	function RenderASM (|jbin| j, |faststring| func_names)
		opt norefcounts
		j.enter(@tmp, "code")
		for f in .PackFuncs
			if PackSaved.AddOrShrink(j, f is UsedByASM)
				scfunction.currfunc = f
				j.JRenderASM(f)
				func_names <~ f.exportname
				func_names <~ '\n'
		j.Exit
		scfunction.currfunc = nil
		
		
	function DumpStrings (|jbin| j)
		|| strs = FastString()
		.DumpStringsSub(strs)
		strs <~ 0|byte|			// will all be cstrings... Overwrite lengths during load
		j.enter(@tmp, "strs")
		j.Add(@str, strs)
		j.exit
	
	
	helper DumpStringsSub (|jbin| strs)
		opt norefcounts
		for s in .PackStrings
			strs.AppendHInt(s.length)
			strs <~ s


	function PackClasses (|jbin| j)
		j.enter(@tmp, "clss")
		typeobject!.PackClassChildren(j)
		j.exit
	
	
	function FuncLink (|jbin| j)
		opt norefcounts
		j.tmp("flnk")
		
		for linked in .libfuncs
			if LibSaved.AddOrShrink(j, linked is UsedByASM)
				j.add(@thg, linked.ExportName)
		j.exit(2)

	
	
	function GlobLink (|jbin| j)
		opt norefcounts
		j.tmp("glnk")
		for linked in .LibGlobs
			if LibGlobSaved.AddOrShrink(j, linked is usedbyasm)
				j.add(@thg, linked.ExportName)
		j.exit(2)


	function SCClass.HasPackChildren (|bool|)
		opt norefcounts
		for c in .children
			if !c.isrole and !c.IsLibrary
				return true
			if c.HasPackChildren
				return true
	
	
	function SCClass.PackClassChildren (|jbin!| j)
		opt norefcounts
		require .HasPackChildren
/		j.enter
		for c in .children
			if c.isrole
				c.PackClassChildren(j)
			  else
				c.packexport(j)
		j.exit
	
	
	function SCClass.PackExport (|jbin| j)
		opt norefcounts
		require .MyReacher or .IsLibrary or .HasPackChildren
		j.enter(@tmp, .name)
		if !.IsLibrary
			.DescribeInPack(j)
		.PackClassChildren(j)
		j.exit
		
		
	function SCClass.DescribeInPack (|jbin| j)
		opt norefcounts
		|| sz = (0, .clssize)(.iswrapper)
		j.addint(sz)
		j.enter(@list)
	
		|| name = "0"
		|| df = .DestructorFunc
			name = df.exportname
		j.add(@thg, name)
	
		|| b = .behaviour
		while (b)
			for (M in b.interfaces)
				|| fn = .BestBehaviourFor(m.name.InterfaceToBehaviour)
					|| BaseClass = .InterfaceForBehaviour(fn)
						j.add(@thg, fn.exportname)
			b = b.upwards
		
		j.exit

	

function SCFunction.WrappedName (|string|)
	if !.iscppinbuilt
		return .ExportName
	return .ExportName + "Wrap"


function SCFunction.CanLibLoad (|bool|)
	if !.ismacro and (self isnt disabled) and (.iscppinbuilt != 2)
		return true


function SCFunction.CanPrepareInline (|bool|)
	opt norefcounts
	require (self isnt cpp) and .HasProperSpeedieCode
	|| Allowed = 15 + (self is inline)<<4
	|| Count = .SourceArg!.InlineCount(Allowed)
	if Count <= Allowed
		return true


function packmaker.FinalPrepare
	opt norefcounts
	Assembler.jsm.length = 0

	for c in Compiler.ClassList
		if c.IsRole
			|| t = c.ClassType!
			|| t2 = c.RealClass.ClassType!
			t.ExportPosition = t2.ExportPosition

	require Options.InlineLib

	// These lib funcs are not actually going into the pack.
	// We just want to see the size of the libfunc, if it were inlined.
	for (fn in .LibFuncs) (i)
		if fn.CanPrepareInline
			require Assembler.sh.ASMCompile(fn, -(i+1))
			Assembler.jsm.length = 0


struct HairyMan 
	|uint16| Savings
	|uint16| Curr
	|uint|	 Total

	function AddOrShrink (|jbin| j, |bool| b, |bool|)
		.Total++
		if b
			|| c = .curr
				j.addint(c)
			.curr = 0
			return true
		.curr++
		.Savings++
		return false
			
	function Churn (|faststring| fs)
		fs <~ "$.Savings / $.Total"


