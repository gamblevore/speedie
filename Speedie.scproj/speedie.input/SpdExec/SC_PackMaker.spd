

// some kinda function table... saved to a file

module PackMaker
	|[messageID]|			PackStrings
	|[SCFunction]|			LibFuncs
	|[SCDecl]|				LibGlobs
	|[SCFunction]|			PackFuncs
	|[SCDecl]|				PackGlobs
	|int|					_PackGlobSize
	|int|					_LibGlobSize
	|HairyMan|				PackSaved
	|hairyman|				LibSaved


	function PackGlobSize (|int|)
		return ._PackGlobSize init .GlobalsSize(.PackGlobs)
	
	function LibGlobSize (|int|)
		return ._LibGlobSize
	
	
	helper scfunction.NeedsLibExport (|bool|)
		require (.MyReacher or options.MakeExec)
		require (self isnt NoExport) and !.ismacro
		require self|scnode| isnt Private
		return (.IsCppInBuilt < 2)
	
	
	helper AddFunc (|SCFunction| f)
		opt norefcounts
		if f.IsLibrary
			if f.NeedsLibExport
				.LibFuncs <~ f
		  else
			|| R = f.MyReacher
				check (f isnt ExternalLib) (R.Source, "External library functions can't yet be used in cake files.")
				.PackFuncs <~ f
	
	
	function AddAll
		opt norefcounts
		for f in Compiler.FuncList
			if f.CanLibLoad
				.addfunc(f)
	
	
	function GlobalsSize (|[scdecl]| List, |int|)	// SortGlobals, GlobalsSort
		opt norefcounts
		|| Globals = 1								// always positive.
		for (d in list)
			|| s = d.CarraySize
			|| s16 = s min 16
			globals = globals align s16
			|| X = d.ExportPosition
			if !X or X == globals
				d.ExportPosition = globals			// its ok
			  elseif (options.MakeExec)
				error (d.source, d.name + "'s ExportPosition doesn't match. Please revert export-table. To remove an item, replace it with a carray of bytes of same size.")
			  else
				|| Backwards = x - globals
				if backwards > 0					
					0 // keep old value				// Something missing. EG: Compiling non-gui app.
				  else
					error (d.source, d.name + " exportposition seems inserted? Regen export-table?")
			globals += s

		return Globals.AlignUp(8)					// for strings, which come directly after


	function BuildGlobs (|bool|)
		opt norefcounts
		|| PackInit = compiler.xfunc("JB_Init_") // we need app and pack inits separately
		|| PackMain = compiler.xfunc("JB_Main")
		require PackInit and PackMain
		
		PackInit.PackID = 1 // put init and main first!
		PackMain.PackID = 2

		stability.StabiliseFuncs	
					
		.PackIDFuncs(.PackFuncs)
		.PackGlobs.sort
		return true
	
	
	function message.InlineCount (|int| Remain, |int|)
		opt norefcounts
		|| fn = .func
		require fn != @thg and @char
		if fn == @num
			return 1 - .IsZero
			
		if fn == @bra
			return .first!.InlineCount(Remain)

		|| Count = (fn != @list and @emb and @decl and @arg)|int|
		for s in self
			|| Found = s.InlineCount(Remain)
			Count += Found
			Remain -= Found
			loop Remain > 0
		return count
	

	helper PackIDFuncs (|[scfunction]| list)
		opt norefcounts
		list.sort(&CodeSorter.PackIDAndExportName)
		|| ID = 0
		while (|| f = list[id])
			f.PackID = ++id

	
	function FATCompile (|bool|)
		opt norefcounts
		.FinalPrepare
		(Compiler is Hungry)
		.Packfuncs.sort(&CodeSorter.Leafness)
		
		for (fn in .Packfuncs) (i)
			require Assembler.sh.ASMCompile(fn, i+1)

		.Packfuncs.sort(&CodeSorter.PackIDAndExportName)
		
		target debug
			if !Compiler.InPerry
				.RunAFewTests
		
		|| main = Compiler.MainFunc
			(main is usedbyasm)
		return true
	
	
	function assembler.FullInit
		.packmakerinit
		if options.TargetDebug
			.debuginfo = .FillDebugInfo
	
	
	function MakePack 
		opt norefcounts
		compiler.During = compilerstage.Packing
		Assembler.Sh.Fullinit
		PackMaker.AddAll
		if stderr.ok and .BuildGlobs 
			if .FATCompile and options.ModePack		// options.ModePack can be false, if compiler.InPerry
				.WritePackToDisk
		compiler.During = 0
	
	
	function WritePackToDisk
		|| F = Compiler.ProductPath.SetExt("cake").file // what about .app instead of .zpd?
		require f.OpenEmpty
		
		|| j = jbin(@tmp, "zpd")
		j.file = f
		j.enter
		j.Enter(@tmp, "app")
		j.AddInt(.PackGlobSize + 16)
		j.enter
		
		|| Stack_Trace = FastString()
		.RenderASM(j, stack_trace)
		.DumpStrings(j)
		.PackAllClasses(j)
		.AddDebugStuff(j, stack_trace)
		j.ExitAll
	
	
	function AddDebugStuff (|jbin| j, |string| func_names)
		j.tmp("debug")
		|| f3 = func_names.compress
		j.Add(@str, f3)
		|| dbg = assembler.sh.debuginfo
			|| str = dbg.GetResult.Compress
			assembler.sh.debuginfo = nil
			compiler.stDebugInfo += str.length
			j.AddStr(str)
		j.exit(2)

	
	function RenderASM (|jbin| j, |faststring| func_names)
		opt norefcounts
		j.enter(@tmp, "code")
		for f in .PackFuncs
			if PackSaved.AddOrShrink(j, f is UsedByASM)
				scfunction.currfunc = f
				j.JRenderASM(f)
				func_names <~ f.exportname
				func_names <~ '\n'
		j.Exit
		scfunction.currfunc = nil
		
		
	function DumpStrings (|jbin| j)
		|| strs = FastString()
		.DumpStringsSub(strs)
		strs <~ 0|byte|			// will all be cstrings... Overwrite lengths during load
		j.enter(@tmp, "strs")
		j.Add(@str, strs)
		j.exit
	
	
	helper DumpStringsSub (|jbin| strs)
		opt norefcounts
		for s in .PackStrings
			strs.AppendHInt(s.length)
			strs <~ s


	function PackClasses (|jbin| j, |bool| Pack)
		opt norefcounts
		for c in Compiler.ClassList
			if (c.islibrary != pack) and c.NeedsPackExport
				C.DescribeInPack(j)


	function PackAllClasses (|jbin| j)
		j.tmp("clss")
		.PackClasses(j, false)
		.PackClasses(j, true)
		j.exit(2)
	
	
	function SCClass.NeedsPackExport (|bool|)
		opt norefcounts
		require .isobject and !.IsRole
		|| R = .MyReacher
			return !r.IsLibrary

	
	function scclass.CollectBehaviours (|jbin| j, |scbehaviour!| B)
		opt norefcounts
		|| up = b.upwards
			.CollectBehaviours(j, up)

		|| ft = b.functable$
		|| ftc = ft.cls!
		for (M in ftc.properties) // could I change the cpp exporter to use this same approach?
			|| fn = .BestBehaviourFor(m.name) // might as well?
				|| BaseClass = .InterfaceForBehaviour(fn)
					j.Cakeify(fn)
					continue
			.missingbehaviour(m.name)

	
	function jbin.Cakeify (|scfunction| fn)
		if !fn
			.addint 0
			return
		if 1 or Options.TargetDebug // seems better to always get names, for debugging!
			.Enter(@unit, fn.name)
		|| id = fn.PackID							#check (fn.source, "Missing PackID")
		id = (id << 1) + fn.IsLibrary
		.AddInt(id)
		if 1 or Options.TargetDebug
			.exit

	
	function SCClass.DescribeInPack (|jbin| j)
		opt norefcounts
		|| B = .behaviour							#expect (.source, "Missing behaviour: " + .name)
		|| sz = .clssize
		j.enter(@tmp, .name)
		
		j.Enter(@list)     //////     //////     //////
		j.AddInt(.classtype!.ExportPosition)
		if !.IsLibrary
			j.Add(@thg, .super!.name)
			j.addint(sz)
		j.exit     		   ///
		
		if !.IsLibrary     //////     //////     //////
			j.enter(@list)
			j.Cakeify(.destructorfunc)
			.CollectBehaviours(j, B)
			j.exit    	  ///
		j.exit
	

function SCFunction.WrappedName (|string|)
	if !.iscppinbuilt
		return .ExportName
	return .ExportName + "Wrap"


function SCFunction.CanLibLoad (|bool|)
	if !.ismacro and (self isnt disabled) and (.iscppinbuilt != 2)
		return true


function SCFunction.CanPrepareInline (|bool|)
	opt norefcounts
	require (self isnt cpp) and .HasProperSpeedieCode
	|| Allowed = 15 + (self is inline)<<4
	|| Count = .SourceArg!.InlineCount(Allowed)
	if Count <= Allowed
		return true


function packmaker.FinalPrepare
	opt norefcounts
	Assembler.jsm.length = 0

	for c in Compiler.ClassList
		if c.IsRole
			|| t = c.ClassType!
			|| t2 = c.RealClass.ClassType!
			t.ExportPosition = t2.ExportPosition

	require Options.InlineLib

	// These lib funcs are not actually going into the pack.
	// We just want to see the size of the libfunc, if it were inlined.
	for (fn in .LibFuncs) (i)
		if fn.CanPrepareInline
			require Assembler.sh.ASMCompile(fn, -(i+1))
			Assembler.jsm.length = 0


struct HairyMan 
	|uint16| Savings
	|uint16| Curr
	|uint|	 Total

	function AddOrShrink (|jbin| j, |bool| b, |bool|)
		.Total++
		if b
			|| c = .curr
				j.addint(c)
			.curr = 0
			return true
		.curr++
		.Savings++
		return false
			
	function Churn (|faststring| fs)
		fs <~ "$.Savings / $.Total"


