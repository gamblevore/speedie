

module PackMaker
	|[messageID]|			PackStrings
	|[SCFunction]|			LibFuncs
	|[SCDecl]|				LibGlobs
	|[SCFunction]|			PackFuncs
	|[SCDecl]|				PackGlobs
	|int|					PackFuncIndex
	|int|					PackGlobSize
	|int|					LibGlobSize
	|HairyMan|				PackSaved
	
	
	helper scfunction.NeedsLibExport (|bool|)
		opt norefcounts
		require (.MyReacher or options.MakeExec)
		require (self isnt NoExport) and !.ismacro
		require self|scnode| isnt libonly
		require self|scnode| isnt embeddedonly
		return (.IsCppInBuilt < 2)
			
	// not sure why I have two versions of the same thing?
	// one is to allow a stableID generated
	// but surely... if we have no stable ID, we don't need lib-export?
	
	function scfunction.NeedsStableID (|bool|)
		opt norefcounts
		require (self|scnode| isnt EmbeddedOnly)
		if (!.IsMacro) and (self isnt disabled and LinkInline)
			if self|scnode| is libonly // hmm
			return true
	// why not use noexport instead? (NoExport = LinkInline + Disabled + InitFunc)
											

	
	helper AddFunc (|SCFunction| f)
		opt norefcounts
		if f.IsLibrary
			if f.NeedsLibExport
				.LibFuncs <~ f
		  else
			|| R = f.MyReacher
				check (f isnt ExternalLib) (R.Source, "External library functions can't yet be used in cake files.")
			if R or compiler.InPerry // otherwise we'll get missing packid[1] bugs...
				.PackFuncs <~ f
	
	
	function AddAll
		opt norefcounts
		for f in Compiler.FuncList
			if f.CanLibLoad
				.addfunc(f)
	
	
	function GlobalsSize (|[scdecl]| List, |int|)	// SortGlobals, GlobalsSort
		opt norefcounts
		|| Globals = 1								// always positive.
		
		for d in list
			|| s = d.CarraySize
			|| s16 = s min 16
			globals = globals align s16
			|| X = d.ExportPosition
			if !X or X == globals
				d.ExportPosition = globals			// its ok
			  elseif (options.MakeExec)
				error (d.source, d.name + "'s ExportPosition doesn't match. Please revert export-table. To remove an item, replace it with a carray of bytes.")
			  elseif (x <= globals)
				error (d.source, d.name + " exportposition seems inserted? Regen export-table?")
			
			globals += s

		return (Globals+7).AlignUp(8)				// add sentinel.


	function UseMain (|string| Name, |int| id, |bool|)
		opt norefcounts
		|| Fn = compiler.xfunc(name)				// we need app and pack inits separately
			fn.fpackid = id
			(fn is usedbyasm)
			return true


	function BuildGlobs (|bool|)
		opt norefcounts
		require .UseMain("JB_SP_AppInit", 1) and  .UseMain("JB_Main", 2)

		LibStability.StabiliseFuncs	
		LibStability.StabiliseGlobs
		
		.PackIDFuncs(.PackFuncs)
		.PackGlobs.sort
		.PackGlobSize = .GlobalsSize(.PackGlobs)
	
		return true
	
	
	function message.InlineCount (|int| Remain, |int|)
		opt norefcounts
		|| fn = .func
		require fn != @thg and @char
		if fn == @num
			return 1 - .IsZero
			
		if fn == @bra
			return .first!.InlineCount(Remain)

		|| Count = (fn != @list and @emb and @decl and @arg)|int|
		for s in self
			|| Found = s.InlineCount(Remain)
			Count += Found
			Remain -= Found
			loop Remain > 0
		return count
	

	helper PackIDFuncs (|[scfunction]| list)
		opt norefcounts
		list.sort(&CodeSorter.fPackID)
		|| ID = 0
		while (|| f = list[id])
			f.fPackID = ++id


	function FatCompileSub
		opt norefcounts
		.PackFuncIndex = 0
		while (|| fn = .packfuncs[.PackFuncIndex++])
			require Assembler.sh.FatterCompile(fn)

		
	function FATCompile (|bool|)
		opt norefcounts
		.FinalPrepare
		scfunction.currfunc = nil
		assembler.sh.FillDebugInfo

		(Compiler is Hungry)
		.Packfuncs.sort(&CodeSorter.Leafness)
		.FatCompileSub
		.Packfuncs.sort(&CodeSorter.fPackID)
		
		target debug and !perrydbg
			if !Compiler.InPerry
				.RunAFewTests
		return true
	
		
	function MakePack 
		opt norefcounts
		compiler.During = compilerstage.Packing
		.OrderLibGlobs
		assembler.sh.ASMInit
		PackMaker.AddAll
		if stderr.OK and .BuildGlobs 
			if .FATCompile and options.ModeCake		// ModeCake can be false, if compiler.InPerry
				.BakePackToDisk
		compiler.During = 0
	
	
	function BakePackToDisk 
		|jbin| j = Compiler.ProductPath.OutputStream$
		j.RunHeader("/usr/local/bin/cake")
		j.Enter(@tmp, "cake")
		j.AddInt(.PackGlobSize.AlignUp(8))
		j.enter
		
		if .BakeASM(j)
			.BakeStrings(j)
			.BakeClasses(j)
			.BakeDebug(j)
			j.ExitAll
	
		
	function BakeDebug (|jbin| j)
		|faststring--| p = SourceMap.Positions
			|| JL = J.Length
			j.tmparg("debug")
			assembler.DebugClassesAndGlobals(j)
			j.addrow("pos", @bin, p|string|)
			j.addrow("files", @str, SCImport.AllFiles.join("\n").Compress)
			j.exit(2)
			compiler.stDebugInfo += j.Length - JL
	
	
	function BakeASM (|jbin| j, |bool|)
		opt norefcounts
		j.enter(@tmp, "code")
		j.Enter
		require .BakeAllFuncs(j)
		j.exit(2)
		scfunction.currfunc = nil
		return true
		
		
	function BakeStrings (|jbin| j)
		|| strs = FastString()
		.DumpStringsSub(strs)
		strs <~ 0|byte|			// will all be cstrings... Overwrite lengths during load
		j.enter(@tmp, "strs")
		j.Add(@str, strs)
		j.exit
	
	
	helper DumpStringsSub (|jbin| strs)
		opt norefcounts
		strs.AppendHInt(.packstrings.length)
		for s in .PackStrings
			strs.AppendHInt(s.length)
			strs <~ s


	function PackClasses (|jbin| j, |bool| Pack)
		opt norefcounts
		for c in Compiler.ClassList
			if (c.islibrary != pack) and c.NeedsPackExport
				C.DescribeInPack(j)


	function AnyClassesNeeded (|bool|)
		opt norefcounts
		for c in Compiler.ClassList
			if c.NeedsPackExport
				return true


	function BakeClasses (|jbin| j)
		if .AnyClassesNeeded
			j.TmpArg("clss")
			.PackClasses(j, false)
			.PackClasses(j, true)
			j.exit(2)
	
	
	function SCClass.NeedsPackExport (|bool|) // needsexport, needexport, PackneedsExport
		opt norefcounts
		require .isobject and !.IsRole
		|| R = .MyReacher
		require r and !r.IsLibrary
		
		if .IsLibrary // what about lib only?
			require self|scnode| isnt EmbeddedOnly
			require .ClassType is ASMReached
			if self|scnode| is libonly // now what?
			
		return true

	
	function scclass.CollectBehaviours (|jbin| j, |scbehaviour!| B)
		opt norefcounts
		|| up = b.upwards
			.CollectBehaviours(j, up)

		|| ft = b.functable$
		|| ftc = ft.cls!
		for (M in ftc.properties)				// could I change the cpp exporter to use this same approach?
			|| fn = .BestBehaviourFor(m.name)	// might as well?
				|| BaseClass = .InterfaceForBehaviour(fn)
					j.Cakeify(fn)
					continue
			.missingvirtual(m.name)

	
	function jbin.Cakeify (|scfunction| fn)
		if !fn
			.addint 0
			return
		.Enter(@unit, fn.name)
		|| id = fn.fPackID							#check ( fn.source,  "Missing PackID[2]" )
		id = (id << 1) + fn.IsLibrary
		.AddInt(id)
		.exit

	
	function SCClass.DescribeInPack (|jbin| j)
		|scbehaviour--| B = .behaviour				#expect ( .source,  "Missing behaviour" )
		|| sz = .clssize
		j.enter(@tmp, .name.lowercase)
		
		j.Enter(@list)     //////     //////     //////
		j.AddInt(.classtype!.ExportPosition)
		if !.IsLibrary
			j.Add(@thg, .super!.name.lowercase)
			j.addint(sz)
		j.exit     		   ///
		
		if !.IsLibrary     //////     //////     //////
			j.enter(@list)
			j.Cakeify(.destructorfunc)
			.CollectBehaviours(j, B)
			j.exit    	  ///
		j.exit


function SCFunction.WrappedName (|string|)
	if !.iscppinbuilt
		return .ExportName
	return .ExportName + "Wrap"


function SCFunction.CanLibLoad (|bool|)
	if !.ismacro and (self isnt disabled) and (.iscppinbuilt != 2)
		return true


function SCFunction.CanPrepareInline (|bool|)
	opt norefcounts
	require (self isnt cpp) and .HasProperSpeedieCode
	|| Allowed = 15 + (self is OptInline)<<4
	|| Count = .SourceArg!.InlineCount(Allowed)
	if Count <= Allowed
		return true


function packmaker.FinalPrepare
	opt norefcounts
	Assembler.jsm.length = 0

	for c in Compiler.ClassList
		if c.IsRole
			|| t = c.ClassType!
			|| t2 = c.RealClass.ClassType!
			t.ExportPosition = t2.ExportPosition

	require Options.InlineLib

	// These lib funcs are not actually going into the pack.
	// We just want to see the size of the libfunc, if it were inlined.
	for fn in .LibFuncs
		if fn.CanPrepareInline
			require Assembler.sh.FatterCompile(fn)
			Assembler.jsm.length = 0



struct HairyMan 
// i just went a little insane while writing this code.
// What do you expect writing a compiler on your own?
// I might have been drunk too.
	|uint16| Savings
	|uint16| Curr
	|uint|	 Total

	function AddOrShrink (|jbin| j, |bool| b, |bool|)
		.Total++
		if b or Options.TargetDebug
			|| c = .curr
				j.addint(c)
			.curr = 0
			return true
		.curr++
		.Savings++
		return false
			
	function Churn (|faststring| fs)
		fs <~ "$.Savings / $.Total"



function Message.IsCake (|bool|)
	opt norefcounts
	real self
	if self == @arg
		self = .first
	require self == @tmp
	require .first.IsInt
	|| s = .second
	if s == @arg
		require s.first istmp "code"
		return true // ooof. its actually a cake file.

