

// some kinda function table... saved to a file

module PackMaker
	|[messageID]|			PackStrings
	|[SCFunction]|			LibFuncs
	|[SCDecl]|				LibGlobs
	|[SCFunction]|			PackFuncs
	|[SCDecl]|				PackGlobs
	|int|					PackFuncIndex
	|int|					PackGlobSize
	|int|					LibGlobSize
	|HairyMan|				PackSaved
//	|hairyman|				LibSaved
	
	
	libinternal scfunction.NeedsLibExport (|bool|)
		opt norefcounts
		require (.MyReacher or options.MakeExec)
		require (self isnt NoExport) and !.ismacro
		require self|scnode| isnt libonly
		require self|scnode| isnt embeddedonly
		return (.IsCppInBuilt < 2)
			
	// not sure why I have two versions of the same thing?
	// one is to allow a stableID generated
	// but surely... if we have no stable ID, we don't need lib-export?
	
	function scfunction.NeedsStableID (|bool|)
		opt norefcounts
		|| c = .Parent
		require (self|scnode| isnt EmbeddedOnly)
		if (!.IsMacro) and (self isnt disabled and LinkInline)
			if self|scnode| is libonly // hmm
			return true
	// why not use noexport instead? (NoExport = LinkInline + Disabled + InitFunc)
											

	
	libinternal AddFunc (|SCFunction| f)
		opt norefcounts
		if f.IsLibrary
			if f.NeedsLibExport
				.LibFuncs <~ f
		  else
			|| R = f.MyReacher
				check (f isnt ExternalLib) (R.Source, "External library functions can't yet be used in cake files.")
				.PackFuncs <~ f
	
	
	function AddAll
		opt norefcounts
		for f in Compiler.FuncList
			if f.CanLibLoad
				.addfunc(f)
	
	
	function GlobalsSize (|[scdecl]| List, |int|)	// SortGlobals, GlobalsSort
		opt norefcounts
		|| Globals = 1								// always positive.
		
		for d in list
			|| s = d.CarraySize
			|| s16 = s min 16
			globals = globals align s16
			|| X = d.ExportPosition
			if !X or X == globals
				d.ExportPosition = globals			// its ok
			  elseif (options.MakeExec)
				error (d.source, d.name + "'s ExportPosition doesn't match. Please revert export-table. To remove an item, replace it with a carray of bytes.")
			  elseif (x <= globals)
				error (d.source, d.name + " exportposition seems inserted? Regen export-table?")
			
			globals += s

		return (Globals+7).AlignUp(8)				// add sentinel.


	function UseMain (|string| Name, |int| id, |bool|)
		opt norefcounts
		|| Fn = compiler.xfunc(name)				// we need app and pack inits separately
			fn.fpackid = id
			(fn is usedbyasm)
			return true


	function BuildGlobs (|bool|)
		opt norefcounts
		require .UseMain("JB_SP_AppInit", 1) and  .UseMain("JB_Main", 2)

		LibStability.StabiliseFuncs	
		LibStability.StabiliseGlobs
		
		.PackIDFuncs(.PackFuncs)
		.PackGlobs.sort
		.PackGlobSize = .GlobalsSize(.PackGlobs)
	
		return true
	
	
	function message.InlineCount (|int| Remain, |int|)
		opt norefcounts
		|| fn = .func
		require fn != @thg and @char
		if fn == @num
			return 1 - .IsZero
			
		if fn == @bra
			return .first!.InlineCount(Remain)

		|| Count = (fn != @list and @emb and @decl and @arg)|int|
		for s in self
			|| Found = s.InlineCount(Remain)
			Count += Found
			Remain -= Found
			loop Remain > 0
		return count
	

	libinternal PackIDFuncs (|[scfunction]| list)
		opt norefcounts
		list.sort(&CodeSorter.fPackID)
		|| ID = 0
		while (|| f = list[id])
			f.fPackID = ++id

	
	function FATCompile (|bool|)
		opt norefcounts
		.FinalPrepare

		assembler.sh.FillDebugInfo

		(Compiler is Hungry)
		.Packfuncs.sort(&CodeSorter.Leafness)
		
		.PackFuncIndex = 0
		for fn in .packfuncs
			.PackFuncIndex++
			require Assembler.sh.ASMCompile(fn)

		.Packfuncs.sort(&CodeSorter.fPackID)
		
		target debug
			if !Compiler.InPerry
				.RunAFewTests
		return true
	
		
	function MakePack 
		opt norefcounts
		compiler.During = compilerstage.Packing
		.OrderLibGlobs
		assembler.sh.ASMInit
		PackMaker.AddAll
		if stderr.ok and .BuildGlobs 
			if .FATCompile and options.ModeCake		// options.ModePack can be false, if compiler.InPerry
				.WritePackToDisk
		compiler.During = 0
	
	
	function WritePackToDisk 
		|| F = Compiler.ProductPath
		|jbin| j = f.OutputStream
			j.RunHeader("/usr/local/bin/cake")
			j.Enter(@tmp, "cake")
			j.AddInt(.PackGlobSize.alignup(8))
			j.enter
			
			.RenderASM(j)
			.DumpStrings(j)
			.PackAllClasses(j)
			.StoreDebug(j)
			j.ExitAll
	
	
	function StoreDebug (|jbin| j)
		|| dbg = assembler.SafeDebugInfo
			compiler.stDebugInfo += dbg.length
			j.enter(@tmp, "debug")
			j.AddStr(dbg.Compress)
			j.exit

	
	function RenderASM (|jbin| j)
		opt norefcounts
		j.enter(@tmp, "code")
		j.Enter
		.PackAllFuncs(j)
		j.exit(2)
		scfunction.currfunc = nil
		
		
	function DumpStrings (|jbin| j)
		|| strs = FastString()
		.DumpStringsSub(strs)
		strs <~ 0|byte|			// will all be cstrings... Overwrite lengths during load
		j.enter(@tmp, "strs")
		j.Add(@str, strs)
		j.exit
	
	
	libinternal DumpStringsSub (|jbin| strs)
		opt norefcounts
		strs.AppendHInt(.packstrings.length)
		for s in .PackStrings
			strs.AppendHInt(s.length)
			strs <~ s


	function PackClasses (|jbin| j, |bool| Pack)
		opt norefcounts
		for c in Compiler.ClassList
			if (c.islibrary != pack) and c.NeedsPackExport
				C.DescribeInPack(j)


	function AnyClassesNeeded (|bool|)
		opt norefcounts
		for c in Compiler.ClassList
			if c.NeedsPackExport
				return true


	function PackAllClasses (|jbin| j)
		if .AnyClassesNeeded
			j.TmpArg("clss")
			.PackClasses(j, false)
			.PackClasses(j, true)
			j.exit(2)
	
	
	function SCClass.NeedsPackExport (|bool|) // needsexport, needexport, PackneedsExport
		opt norefcounts
		require .isobject and !.IsRole
		|| R = .MyReacher
		require r and !r.IsLibrary
		
		if .IsLibrary // what about lib only?
			require self|scnode| isnt EmbeddedOnly
			require .ClassType is ASMReached
			if self|scnode| is libonly // now what?
			
		return true

	
	function scclass.CollectBehaviours (|jbin| j, |scbehaviour!| B)
		opt norefcounts
		|| up = b.upwards
			.CollectBehaviours(j, up)

		|| ft = b.functable$
		|| ftc = ft.cls!
		for (M in ftc.properties)				// could I change the cpp exporter to use this same approach?
			|| fn = .BestBehaviourFor(m.name)	// might as well?
				|| BaseClass = .InterfaceForBehaviour(fn)
					j.Cakeify(fn)
					continue
			.missingvirtual(m.name)

	
	function jbin.Cakeify (|scfunction| fn)
		if !fn
			.addint 0
			return
		.Enter(@unit, fn.name)
		|| id = fn.fPackID							#check ( fn.source,  "Missing PackID[2]" )
		id = (id << 1) + fn.IsLibrary
		.AddInt(id)
		.exit

	
	function SCClass.DescribeInPack (|jbin| j)
		|scbehaviour--| B = .behaviour				#expect ( .source,  "Missing behaviour" )
		|| sz = .clssize
		j.enter(@tmp, .name.lowercase)
		
		j.Enter(@list)     //////     //////     //////
		j.AddInt(.classtype!.ExportPosition)
		if !.IsLibrary
			j.Add(@thg, .super!.name.lowercase)
			j.addint(sz)
		j.exit     		   ///
		
		if !.IsLibrary     //////     //////     //////
			j.enter(@list)
			j.Cakeify(.destructorfunc)
			.CollectBehaviours(j, B)
			j.exit    	  ///
		j.exit


function SCFunction.WrappedName (|string|)
	if !.iscppinbuilt
		return .ExportName
	return .ExportName + "Wrap"


function SCFunction.CanLibLoad (|bool|)
	if !.ismacro and (self isnt disabled) and (.iscppinbuilt != 2)
		return true


function SCFunction.CanPrepareInline (|bool|)
	opt norefcounts
	require (self isnt cpp) and .HasProperSpeedieCode
	|| Allowed = 15 + (self is OptInline)<<4
	|| Count = .SourceArg!.InlineCount(Allowed)
	if Count <= Allowed
		return true


function packmaker.FinalPrepare
	opt norefcounts
	Assembler.jsm.length = 0

	for c in Compiler.ClassList
		if c.IsRole
			|| t = c.ClassType!
			|| t2 = c.RealClass.ClassType!
			t.ExportPosition = t2.ExportPosition

	require Options.InlineLib

	// These lib funcs are not actually going into the pack.
	// We just want to see the size of the libfunc, if it were inlined.
	for (fn in .LibFuncs) (i)
		if fn.CanPrepareInline
			require Assembler.sh.ASMCompile(fn)
			Assembler.jsm.length = 0


struct HairyMan 
	|uint16| Savings
	|uint16| Curr
	|uint|	 Total

	function AddOrShrink (|jbin| j, |bool| b, |bool|)
		.Total++
		if b or Options.TargetDebug
			|| c = .curr
				j.addint(c)
			.curr = 0
			return true
		.curr++
		.Savings++
		return false
			
	function Churn (|faststring| fs)
		fs <~ "$.Savings / $.Total"



function Message.IsCake (|bool|)
	opt norefcounts
	real self
	if self == @arg
		self = .first
	require self == @tmp
	require .first.IsInt
	|| s = .second
	if s == @arg
		require s.first istmp "code"
		return true // ooof. its actually a cake file.


//cake 232 {
//	code {
//		"\00\00\00'"
//		"\00\00\08+\n\00\00K\01@\F8D\04\00\FCU\1E\00\10^\242\07\18\1A\00\$\00\00\03\00\00K\1F\00\10^\242\07\18\1A\00\$\00\00\01@\08-\F5'\08Q \00\F8^b\08\08\1A\00\364\01\00\00\00\00'"
//	}
//
//	strs "\03\0CHello world!\nbye world!\tend world\00"
//}
