


// how would I do  || x = a+b+c+d+e+f?
// lets see...     lets do it with tmps and regs
// first we get the register for x... thats easy.
// now we need to get the register for a, and for b+...
// the register for a is done, the register for b+... doesnt exist.
// so it allocates a temp.
// then tries to calculate it. well... to calculate it... , it needs the inner stuff
// We just do the inner stuff first, THEN allocate a result?
// we need to be able to allocate registers that we don't need anymore.
// Like "Here is your register... go fuck it if you want"
// basically a "Returned result" so... can we do that? lets try a simpler version
//          || x = a+b+c
// b+c


// we use IR first, then opt the IR, then turn it to ASM last.

struct IR // µfunc uses this. // "class IR"
	|byte|			Op
	|byte|			Label	// 255 labels per function
							// Can we remove the label? I don't like it. It seems OK though... unused bytes.
	|byte[6]|		r	
	|int|			Rest
	|uint|			Debug
	
	operator isa (|int| m, |bool|)
		return m == .op
		
	setter Debug (|message|)
		|| FilePos  = value.position & MsgDebugPosShift.bits
		.debug = CurrFileNum ||| FilePos
		
	function BytePos (|ind|)
		return .debug & MsgDebugPosShift.bits
	
	function FilePos (|int|)
		return .debug >> IR.MsgDebugPosShift
	
	function FS (|FastString| fs)
		opt norefcounts
		|| op = instruction.typelist[.op] #debug_Require
		fs <~ op.name
		fs <~ ':'
		fs <~ (' ', 5-op.name.length)
		|| GotAny = ""
		|| Remain = 25
		|| f = op.sizes
		for i in 5
			|| bs = f[i].bitsize
			if remain > 0 and bs
				fs <~ gotany
				gotany = ", "
				if f[i].isreg
					fs <~ 'r'
				if i >= 4
					fs <~ .rest
				  else
					fs <~ .r[i]
				remain += bs

	function Print
		visible
		if asm.NoisyASM >= 3
			printline .render
	
	render
		.fs(fs)
	
	module
		|[string]|	Resources
		|int|		CurrFileNum
	constants
		MsgDebugPosShift = 19

 
 
class µFunc1 (memory)
	linkage
		cpp_class ASMFunc2
		cpp_part ASMFunc2
	contains ASM

	function Visible
		visible // needed to compile strangely...
	
	function Run (|&int64| Args = nil, |int| ArgCount=nil, |int64|)
		cpp_part RunArgs
		require self
		if args
			|| r = jb_vm.vm.ClearRegisters(argcount)
			for i in argcount
				r[i] = args[i] 
		
		return jb_vm.Run(.ptr, .length)

