


// vm.box
forms
	U0:
	U1: r1 r
	U2: r1 r,  r2 r
	U3: r1 r,  r2 r,  r3 r
	U4: r1 r,  r2 r,  r3 r,  r4 r

// whats the max exe size ill allow?
// 2mb? 4? 1? lets say... 2mb. reallyistically, it makes the most senes
// so we'll 4mb range for +-
// so thats 20-bits
// using 32-bits, we lose 8, leaving 4.
// its not enough, for saveregs.
// OK... lets just try this... 64-bits, forget about anything else.
// 64 - (7 + 20 + 6 + 1)

// x = (a + b) - (c + d)
// we put a+b into a temp reg, at the top, so reg 31.
// the thing that makes it no longer needs it.
// but what about us? there are two choices.
// either IT allocates it and dumps it
// or we allocate it.
// if IT allocated and dumped it, it COULD be overwritten by us, by accident
// however heres the thing... WE know we need it. So we could re-reserve it.

// OK... lets say we just pre-reserve it.
// We prereserve _1 and store a+b in it.
// then we wanna do c+d
// so... we need to pre-reserve that too.
// great.
  
// x = _1 - (c + d)
// x = _1 - _2
// now we have two regs... that we don't need afterwards. so it does work.
// but what about simpler things like || x = a+(b+c)
// we can reuse the registers, but how does it know that. lets see.
// well... the first + has "a", but needs (b+c)
// so it asks for it... it has no reg. So we pre-allocate it.
// then the operation can be done. Easy.
// lets try this: || x = a+(b+(c+d))
// we ask for: b+(c+d). lets pre-allocate.
// it asks for (c+d). lets pre-allocate.
// i mean... it works? it uses more regs than we need?
// when we ask for b+(c+d)... we have a pre-allocated reg... but the reg is also unused.
// how to state that its (currently) unused? set a bit on the reg?

// I mean... why not? we are trying to compute: b+(c+d)
// in fact... x could be used to store the temps even.
// i know theres a simple wy to do this.

// lets try again... lets say x = a+(b+(c+d))
// so... x is unused... lets just mark it unused. we can simplify later.
// so x is unused... its the dest. we pass the dest in. its been marked unused.

// 




	Func	// func: fnc:
		SaveRegs	5
		Incr		1
		JUMP		j
	
	Cmp		// cmp:
		r1		r
		r2		r
		Cmp		4
	
	CmpEq	// cmpeq:
		r1		r
		r2		r
		Jmp		j

	Const	// const:
		r1		r
		rot		6
	
	Bra		// bra:
		r1		r
		c1		2
		jmp		j
	
	Mem		// mem:
		r1		r
		r2		r
		move	2
	
	Setn
		len		2
		Dest	5
		Cond	2	// 0 == always, 1 = only if dest == 0, 2 = only if dest != 0
	
	CNTR	// 
		r1		r
		r2		r
		incr	3
		size	2 // 1, 2, 4, 8
		// *(u1+L3-8) += i2
		// u1+=incr-3
		// this can add a reg to an obj property
		// incr useful for writing to an array?
	
	CNTC
		r1		r
		cnst	8
		size	2 // 1, 2, 4, 8
		// *(u1+CNTC_Lu-8) += CNTC_cnsti
	
	BFLD
		r1		r
		r2		r
		up		6
		down	6
	
	SWAP
		A		6
		B		6
		C		6
		D		6


// this file:
// 1) builds the c++ codes, and the jump-table, and the ASM accessor functions
// 2) builds the instruction-info speedie uses exec can just include this file too.
// 3) builds the Âµforms

 
#!						 (((((STOP)))))
EROR (U1)
	debugger
	return u1+U1_Lu


#!						 (((((FUNC)))))
STCK (U1)
	r[-1] += u1 + U1_Lu

SWAP (Swap)
	std_swap(r[SWAP_Au], r[SWAP_Bu])
	std_swap(r[SWAP_Cu], r[SWAP_Du])

FNC  (Func)
	__
	Code = BumpStack(r, Code, Op)
	___

FNCX (Func)
	__
	vm.CurrStack = r // to make this recursive
	ForeignFuncSimple(r, Code, Op)
	___

RET (rn)
	__ 
	Code = Return(r, Code, Op)
	___

LEAF ("j")
	__
	JumpLeaf(Code + U0_Li)
	___
	
RETL ("l")
	__
	Code = LeafCode
	___
	

#!						 (((((Utils)))))
RARE (U2)
	if_rare (Rare(r, Op)) return n3
CONV (U3)
	Conv(r+n1, n2)


#!						 (((((Consts)))))
SET1 ("rS")
	i1 = U1_Li
SETK (Const)
	i1 = JB_u64_RotL(Const_Lu, Const_rotu)
SETN (setn)			// OK
	loadconst(r, Op, Code)


#!						 (((((Math)))))
ADDC ("rrnl")
	i1  =  i2 + JB_u64_RotL(L3, n3)
ADD  (U3)
	i1  =  i2 + (i3 << L3) // only need 6 bits for shift! can we save 3 conditional add?
SUB  (U3)
	i1  =  i2 - (i3 << L3)
MUL  (U4)
	i1 = (i2 * i3) + i4
DIV  (U4)
	divmath(r, Op)


#!						 (((((Bitops)))))
SHRS  (U3)
	i1 = i2 >> (u3 + L3)
SHRU  (U3)
	u1 = u2 >> (u3 + L3)
SHLS  (U3)
	i1 = i2 >> (u3 + L3)
BAND  (U3)
	u1 = u2 &  (u3|||L3)
BOR   (U3)
	u1  |= (u2|||u3)
BXOR  (U3)
	u1 = u2 ^ u3
BNOT  (U2)
	u1 = ~u2
BFLG  (BFLD)
	if (BFLD_Lu) // perhaps sign can allow for 1-4 contig regs to be masked?
		i1 = ((i2 << BFLD_upu) >> BFLD_downu)
	else
		u1 = ((u2 << BFLD_upu) >> BFLD_downu)
BFLS  (BFLD)		 // same?
	i1 |= ((i2 << BFLD_downu) >> BFLD_upu)

	
//BSTT  (U4)
//	i1 = 0//bitstats(u2, u3, u4)
BROL  (U3)
	i1 = JB_u64_RotL(u2, u3 + L3)
BROR  (U3)
	i1 = JB_u64_RotR(u2, u3 + L3)

#!						 (((((Branches)))))
CMPI  (Cmp)					// Yes. int/uint/u64/i64 versions
	__
	Code = CompI(r, Op, Code)
	___
CMPF  (Cmp)
	__
	Code = CompF(r, Op, Code)
	___
CMPE  (CmpEq)				// NO (add 8/16/32/64 versions? and a neq version?)
	Code = CompEq(r, Op, Code)
	___
CMPN  (CmpEq)				// NO (But easy to fix)
	__
	Code = CompNeq(r, Op, Code)
	___
BRA   (Bra)					// NO (But easy to fix)
	__
	if (!i1)
		Code += Bra_jmpi
	___
	i1 += Bra_c1u-1
	
BRAN  (Const)				// NO (But easy to fix)
	__
	if (i1)
		Code += Bra_jmpi
	___
	i1 += Bra_c1u-1

LUPU  ("rrj")				// assume uint64
	__
	if (i1++ < i2)
		Code -= U2_Lu
	___
LUPD  ("rrj")			 	// same
	__
	if (i1-- > i2)
		Code -= U2_Lu
	___


#!						 (((((Refs)))))

RSDE  ("rrrj")
	__
	Code += U3_Li
	___
	decr(o3)
	decr(o2)
	safedecr(o1)
	#!jump too? for branches...
RSET  (U4)
	setref(n1, o1, o2)
	setref(n3, o3, o4)

RALO  (U2)
	o1 = alloc(o2)
	#!should call constructor too.

	
#!						(((((Memory)))))
TABL  (U2)
	u1 = table(u2, L2)
RD1U  (mem)				// OKALL
	u1 = mem(uint8)
	mem2(uint8)
RD1S  (mem)
	u1 = mem(char)
	mem2(char)
RD2U  (mem)
	u1 = mem(u16)
	mem2(u16)
RD2S  (mem)
	u1 = mem(s16)
	mem2(s16)
RD4U  (mem)
	u1 = mem(u32)
	mem2(u32)
RD4S  (mem)
	u1 = mem(int)
	mem2(int)
RD8U  (mem)
	u1 = mem(u64)
	mem2(u64)
RD16  (mem)
	((ivec4*)r)[n1] = mem(ivec4)
	mem2(ivec4)
WR1U  (mem)
	mem(uint8) = u1
	mem2(uint8)
WR2U  (mem)
	mem(u16) = u1
	mem2(u16)
WR4U  (mem)
	#! xcode only complains about this one? ?
	mem(u32) = (u32)u1
	mem2(u32)
WR8U  (mem)
	mem(u64) = u1
	mem2(u64)
WR16  (mem)
	mem(ivec4) = (ivec4)(((ivec4*)r)[n1])
	mem2(ivec4)

CNTC  (CNTC)					// aWESOME  JOBBBBBBBBBBB BROOOOOO LOLLLLLLL ::DDDDDD
	CountConst(r, Op)
MEMM  ("rrnl")
	#! copy/fill/endian/xor
	MemStuff((u32*)u1, (u32*)u2, n3, L3)


#!						(((((Float)))))
FADD  (U3)
	f1 = f2 + f3
FSUB  (U3)
	f1 = f2 - f3
FMUL  (U4)
	f1 = (f2 * f3)+f4
FDIV  (U3)
	f1 = f2 / f3
DADD  (U3)
	d1 = d2 + d3
DSUB  (U3)
	d1 = d2 - d3
DMUL  (U4)
	d1 = (d2 * d3) + d4
DDIV  (U3)
	d1 = d2 / d3
PRNT (U1)
	printf("%lli\n", i1)
