

module SourceMap
	|faststring|		Positions
	|int|				LastLength
	|FastString|		BreakPoints
	|FastString|		Breakable

	function Check (|scfunction| fn, |int| T, |bool|)
		opt norefcounts
		|| p = .positions
			|| Dbg = p.length - .LastLength
			expect (dbg == T)								(fn, "Debug length corrupt")
		return true
		

	function Reserve (|int| T, |&uint|)
		opt norefcounts
		|| p = .positions
			.breakpoints ?= faststring()
			.breakable ?= faststring()
			.lastlength = p.length
			return p.Reserve(T)|&uint|


	prototype SourceSorter (|SourceLocation| A, |SourceLocation| B, |int|)
	function BreakableSorter (SourceSorter)
/		return (A>>32) - (B>>32)

	function SortBreaks (|FastString| B)
		|| Start = B.ResultPtr
		|| Last = (Start + B.length)|&object| - 1
/		memory.sort((&BreakableSorter)|&nil|, Start|&object|, Last)


	////    ////    ////    ////    ////    ////    ////    ////    ////    ////    ////    ////    ////    ////


datatype SourceLocation (uint64)
	function FileNum (|uint|)
		return self >> 53
	
	function BytePos (|uint|)
		return (self>>32) & (21~bits)


function fatasm.BakeBreak (|uint| SrcMap, |uint| ASMTotal, |uint| Break)
	|| i = .ASMIndex + ASMTotal
	if break & Assembler.BreakPoint
		SourceMap.BreakPoints!.AppendInt(I)
		
	if break & Assembler.Breakable
		SourceMap.Breakable!.AppendInt(SrcMap)
		SourceMap.Breakable!.AppendInt(I)

		target debug
			FoundBreaks++
//			printline ("::::" + FoundBreaks)// + (" / " + breakCount) + (" - " + LostBreaks)

target debug
	|| LostBreaks = 0
	|| FoundBreaks = 0
	|| BreakCount = 0
		
	
function fatasm.BakeDebug (|uint| SrcMap, |uint| ASMTotal, |uint| Break)
	opt inline
	if break
		.BakeBreak(SrcMap, ASMTotal, break)
	if .info is DebugVars
		.OutputDebugVars


