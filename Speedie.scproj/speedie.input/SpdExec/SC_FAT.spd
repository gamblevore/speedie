

/*
	we need a very simple exmaple... where we set some regs... and all the everything else is done automatically.
	all the refcounting... etc etc etc.
	
	does that mean something like this?
	
	asm.TERN(exp,1,2,3,4)
	asm.TERN(1,2,3,4,exp)
	exp.TERN(1,2,3,4)
	exp <~ asm.TERN(1,2,3,4)
	asm.TERN(1,2,3,4) <~ exp
	
	exp.TERN(1,2,3,4)
	
	we could do the refcounting later? like during the block-checking pass?
	
	what about closing of if/elsees... how can it know about that. seems like we should do the 
	refcounting then. anyhow... lets assume its immediate. We can also make all of these inlined
*/
	

struct FatASM 
	|ASMReg| 			Info		// only needs 32-bits of this. Could we make a smaller asmreg?
	|message--| 		Msg
	|uint64| 			Const
	|&FatASM| 			BackLink	// for multiple instructions setting the same register.

	|uint[5]|			R
	|uint|				ASMIndex	
	|uint16| 			BlockNum
	|uint16| 			ParentBlock
	|uint16|			RefCount
	|byte|				Op
	|byte|				Label		// 254 labels per function
	
	
	function AsReg (|asmreg|)
		cpp_part AsReg0
		return self * .info

	operator mul (|asmreg| info, |asmreg|)
		cpp_part AsReg
		info.FatIndex = .index
		.info = info
		return info
	
	function F32 (assigns:|float|)
		((&.const)|&float|)[] = Value

	function F64 (assigns:|f64|)
		((&.const)|&f64|)[] = Value
		
	function F32 (|float|)
		return ((&.const)|&float|)[]

	function F64 (|f64|)
		return ((&.const)|&f64|)[]
		
	setter Debug (|message|)
		.msg = Value

	function Nop (|bool|)
		.op = asm.noop
		return true

	function has (|int| a, |int| b, |bool|)
		|| out = .out
		return out == a or b
	
	function Info (|asmreg|)
		nil safe
		return .info
	
	function Index (|uint|)
		opt inline
		return 1 + self - asmstate.sh.funcstart

	function uint.FAT (|&FATASM|)
		opt inline
		return asmstate.sh.funcstart + (self - 1)
	
	function FileNum (|int|)
		return .msg.filenum & 0x4095
	
	function BytePos (|int|)
		return .msg.position
		
	operator isa (|int| m, |bool|)
		nil checker
		if self
			return m == .op
	
	syntax append (|asmreg| flags)
		real self
		.info = .info as flags

	syntax is (|asmreg| flags, |bool|)
		if self
			return .info & flags

	syntax is (|asmreg| flags, assigns:|bool|)
		if value
			(.info as= flags)
		  else
			(.info asnt= flags)
	
	function BitCorrect (|&FATASM|)
		.info = .info <~ AsmReg.BitCorrect
		return self
	
		
	function LinkIn (|fatasm| old)
		if old.BlockNum == .BlockNum					// add it's backlink
			.BackLink = old.BackLink
		  elseif .ParentBlock == old.parentblock		// if x {a=b} else {a=c}
			.BackLink = old								// what about while loops or combinations?
														// what about nested ifs?
														// if a {if b {x=1}} else {x=2}

														// what about this?
														// || xx = 1
														// if y
														//     x = 2
	
	function Dest (|int| a, |asmreg| info, |bool|)
		|| dest = info.reg
		.r[a] = dest
		if dest
			|| place = asmstate.sh.RegPlace(dest)
			|| oldfat = place.Creator
			place.Creator = self
			if oldfat
				.linkin(oldfat)
			return true
	
	
	function File (|string|)
		opt norefcounts
		|| s = scimport.allfiles[.filenum]
			return s
	
	function SyntaxExpect (|string| Error)
		|| err = Error(nil, error, ErrorSeverity.Error, .file)
		err.position = .BytePos
		stderr <~ err

	function RegInput (|int| a, assigns:|asmreg| info, |int|)
		rz = info.reg
		.r[a] = rz
		|| f = info.fat
			if !a // why?
			f.refcount++
		
	function NumInput (|int| a, assigns:|int| v)
		.r[a] = v
		

	function out (|uint|): return .r[0]
	function out (assigns:|uint|): .r[0] = value
	
	// easier to do maths ad figure stuff out if its expressed like abcd
	function a (|uint|): return .r[1]
	function a (assigns:|uint|): .r[1] = value
	function b (|uint|): return .r[2]
	function b (assigns:|uint|): .r[2] = value
	function c (|uint|): return .r[3]
	function c (assigns:|uint|): .r[3] = value
	function d (|uint|): return .r[4]
	function d (assigns:|uint|): .r[4] = value

	function fa (|&FATASM|): return ASMState.Sh.Zero
	function fb (|&FATASM|): return ASMState.Sh.Zero
	function fc (|&FATASM|): return ASMState.Sh.Zero
	function fd (|&FATASM|): return ASMState.Sh.Zero

	function Swap (|int| a, |int| b)
		swap (.r[a-1]) (.r[b-1])

	function Swap (|&FatASM| other, |bool|)
		|| s = self|&ivec4|
		|| o = other|&ivec4|
		swap (s++[]) (o++[])
		swap (s[])   (o[])
	
	helper Step (|int| dir, |&FatASM|)
		real self
		|| b = .blocknum
		while
			self += dir
			if .op != asm.noop
				return (self, nil)(b == .BlockNum)
		
	function Prev (|&FatASM|)
		opt inline
		return .step(-1)
		
	function Next (|&FatASM|)
		opt inline
		return .step(1)

	function match3_2 (|int| reg, |bool|)
		// prefers the value to be at 3.
		if reg == .a
			.swap(2, 3)
			return true
		return reg == .b
	
	
		// what  if it got rendered into multiple asms?
		// like: if x==y: jump(10000)
		// how do we deal with this?
	function ReRender (|!&asm| Start, |!&asm| After)
		|| where = start+.ASMIndex
		|| reg = .info.reg

		debug_require  where >= start  and  where < after
		debug_require reg < 5
		|| dest_index = .r[reg]
		|| mask = dest_index & asmreg.FatRef
		debug_require mask
		dest_index &=~ mask
		|| dest = start + dest_index

		debug_Require dest >= start and dest <= after
		.r[reg] = where - dest 
		.µrenderinto(where, where+1)
	
	
	function µRenderInto (|!&asm| Where, |!&asm| After, |!&asm|)
		opt inline
		rz = (ASM.encoders[.op]!)(self, where, after)
		target debug
			if where.DecodeBaseOp != .op // AAARGHHH
				"AARGHHH"
				debugger
				rz = (ASM.encoders[.op]!)(self, where, after)

		// OK so... now what? how do we re-render anything?
		// we could store the length and the addr... so we don't really
		// need a re-render.


	
	function Renda (|FastString| fs)
		opt norefcounts
		|| op = instruction.typelist[.op]		#debug_require
		fs <~ op.name
		fs <~ ':'
		fs <~ (' ', 5-op.name.length)
		|| GotAny = ""
		|| Remain = 24
		|| f = op.sizes
		for i in f.count
			|| bs = f[i].bitsize
			if remain > 0 and bs
				fs <~ gotany
				gotany = ", "
				if f[i].isreg
					fs <~ 'r'
				fs <~ .r[i]
				remain += bs


	function Print
		visible
		if asm.NoisyASM >= 3
			|| fs = faststring()
			.Renda(fs)
			printline fs

 
