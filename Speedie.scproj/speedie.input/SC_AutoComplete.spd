

module Interact { // module autocomplete
cpp_part AC

|scfunction|		AnonFn
|string|			AnonText
|SCNode|			AnonParent
|errorreceiver|		Errors
|bool|				CompiledOK
|bool|				Cleaned
|bool|				WillExit 
||					func_tmp_src   = <(`return, require, "log <string>", while, linkage, for, if, else, elseif, expect, warn, error, disabled, cpp_refs, debugger, debugat, deprecate, `description "<describe this function>"`, print, printline, zalgoline, printerror, beep, continue, cpp_part, cpp_name, cpp_wrapper, `self.`, `super.`, "visible", "exit", "opt norefcounts", "pragma inline"
 `)>.macro
 
||					all_tmp_src	= <(`
@RCM
"function <name>"
"helper <name>"
"target <name>"
@CM
linkage
"syntax <kind>"
@C
module
render
iterator
"operator <name>"
"behaviour <name>"
"virtual <name>"
constructor
destructor
@R
"main\n\t<// code here>"
"extend_module <name>"
"class <name>"
"role <name> (super_class)"
"datatype <name> (super_class)"
"extend <class_name>"
"module <name>"
"dispatch <name> (<Parameters>)"
@L
"cpp_part <name>"
"cpp_class <name>"
visible true
"opt min <1-3>"
wrapper
noauto
`)>.macro


function ParserRestore
	.errors = stderr
	stderr = ErrorReceiver()
	(message).Restore
	parser.using.position = -1 // sigh. I guess something slipped somewhere


function EnterAutoComplete (|bool|)
	|| perry = spdprocess.parent
	require stderr.ok and perry.isopen
	app.AllowInteruptCrash = false			// to debug perry, which runs debug speedie
	"RespondingToCommands"					// Don't delete this... too annoying to miss.
	if !app.ismainthread
		"(AsLib)"
	app.ClearCaches
	if options.PrintLibraries
		perry.pico.config.noise = -1
	pico.Conf.TimeOut = 30s
	compiler.InPerry = true
	.PerryTalk(perry)
	"ExitingCommands"						// this also
	return true


function InitedOK (|bool|)
	if compiler.InitedOK
		return true
	if .Errors.OK
		error "Compiler did not initialise"
	

function CrashTester
	|| __CrashSpd__ = 0



function PerryTalk (|spdprocess| perry) // ReturnsWhenPerryClosesUs
	.CompiledOK = Compiler.CompileAll
	.ParserRestore
	perry <~ .check(@tmp + "check")
	
	for cmd in perry
		if cmd and !.CmdWrap(cmd)
			exit

	pico.SleepForSend
	perry.Disconnect					// calls close, which uses SO_LINGER, to allow sending.


function WriteError (|string| name, |message|)
	rz = @tmp + "error"
	|| err = StdErr.pop
		rz <~ err.name
	  else
		rz <~ "error"
	rz <~ name


function CmdResponse (|Message| cmd, |message| arg, |message|)
	if cmd != "error"
		rz = .docmd(cmd, arg)
	
	rz := .WriteError(cmd.name)


function CmdCleanUp (|Message| arg, |message|) 
	if arg != @arg // reclaim msg
		"missing @arg"
		|| tmp = @arg + "Perry"
		tmp <~ arg 
		arg = tmp
	|| date = arg.first
	if date != @num
		"missing date in @arg"
		date = @num + 0
		arg.first = date
	|| Cmd = arg.second
	if Cmd != @tmp
		"missing cmd in @arg"
		Cmd = @tmp + "error"
		date.next = cmd

	cmd.removeafter
	return cmd


|| TestCrash = "__CrashSpd_" + "_"		// for crash-testing

function CmdWrap (|Message| arg, |bool|)
	if arg contains TestCrash
		app.crash
	
	|| cmd = .CmdCleanUp(arg)
	|| response = .cmdresponse(cmd, arg) 

	if cmd != response
		cmd.replacewith(response)
	SpdProcess.parent! <~ arg
	stderr.clear						// super-important!!!
	
	return !.willexit


function ErrorsToPerry (|message|)
	if !.Cleaned
		.errors!.PrePrintErrors
		.Cleaned = true
	return compiler.RenderErrors(.errors!, errorseverity.warning).parse


function UnusedFuncs (|message| cmd, |message|)
	opt norefcounts
	|| path = cmd[@str]										#require
	|| scf = compiler.files.valuelower(path.name)			#expect ("No file at: " + path.name)
	|| unused_libs = path.next
		for lib in unused_libs
			if lib.ExpectString
				lib.HateUnusedFuncs
			
	cmd.Clear												// so... now what?
	
	if !.CompiledOK
		return cmd
	|| arg = cmd.GiveArg
	for fn in Compiler.FuncList
		|| src = fn.source
		if src and (fn.File == scf) and fn.isunused
			|| str = "() is unused"
			if fn.linkfrom != nil
				str = "()'s callers are unused"
			arg.msg(@tmp, fn.name + str) <~ src.position
	
	return cmd

function Check (|message| cmd, |message|)
	if .errors.HasProblems
		return cmd.SendPerryErrors
	cmd.name = "check"
	cmd <~ (@thg, "ok")
	return cmd


function Message.SendPerryErrors (|message|)
// how can I say its OK and that it has warnings? just append to a different section of the errorlog?
	.clear
	self <~ Interact.ErrorsToPerry
	return self
	

function ReportMemory (|Message| cmd, |message|)
	cmd.clear
	|| arg = cmd.msg(@arg)
	arg <~ app.ObjMemory
	arg <~ app.stringmemory
	return cmd
	

function DoCmd (|Message| cmd, |message| arg, |message|)
	require cmd == @tmp
	
	if !.InitedOK:						return cmd.SendPerryErrors
	if cmd ~= "unused_funcs":			return .UnusedFuncs(cmd)
	if cmd ~= "check":					return .Check(cmd)
	if cmd ~= "mem":					return .ReportMemory(cmd)
	if cmd == 1 or cmd.last == @name:	return .autoJump(cmd)

	|| req = cmd[@str].name
	|| my_file = compiler.files.valuelower(req)
		rz = .MainAct(cmd, my_file)
	  else
		error "nofile"


function compiler.FindModuleOrClass (|message| mod, |bool| retry, |SCNode|)
	opt norefcounts
	if mod == @name and "main"
		return compiler.program
	|| Module = .findmodulemsg(mod, SCNodeFindMode.noerrors)		#require
	if (mod == @thg)
		rz = module.cls
		require rz or retry
	rz := module


function Backup_Define (|SCFile| myfile,  |int| f,  |message| thg,  |string| purpose,  |message|)
	opt norefcounts
	thg := myfile.GetMsg(f)
	expect thg "nomsg"
	thg = thg.CmdImprove
	return .DefineOrCall(thg, purpose, myfile)


function message.CmdImprove (|message|)
	opt norefcounts
	if self != @rel		// Well rel is useless for defines
		return self
	|| ch = .first
	if ch == @func
		return ch		// Probably came from:    a >= b   -->   a.func(b) >= 1
	return self


function scfunction.InsertIn (|SCNode| parent, |string| name, |SCObject|)
	.name = name
	if parent isa scclass
		.cls = parent
		.parent = parent.modul
	  else
		.cls = nil
		.parent = parent // ooofffff
	return parent[name]
		

function GetFunc2 (|message| cmd, |scfile| myfile, |int| f, |int| n,  |scfunction|)
	opt norefcounts
	|| ast = myfile.ast
		|| src = ast.findpos(f,n)
			return src.InsideFunc

	
function GetFunc (|message| cmd, |scfile| myfile, |int| ff, |int| n, |scfunction|)
	opt norefcounts
	|| src = cmd.last
	if src != @dot
		return .getfunc2(cmd, myfile, ff, n)
	|| fn   = .anonfn init scfunction()
	|| prm  = src.second
	|| mpos = prm.first
	|| str  = prm.second
	expect (mpos and str) "badinput"

	|| f = src.first!
	|| parent = compiler.FindModuleOrClass(f, false)
	if !parent
		f.func = @name
		parent = compiler.FindModuleOrClass(f, true)
	
	expect parent "noparent"
	if parent == .AnonParent and str == .anontext
		return fn
	|| orig = fn.insertin(parent, src.name)
	|| pos = mpos.int
	parser._dotinsertallow = true
	if fn.update_source(pos, str.name, myfile, orig)
		.AnonParent = parent
		.anontext = str.name
		return fn


function SCFunction.Update_Source (|int| start, |string| text, |scfile| myfile, |SCObject| orig, |bool|)
	scfunction.currfunc = self
	parser.using.position = -1
	parser.using.Flags = 0 // oop
	parser.using.Tag = 0 // right?
	|| source = text.parseclean
	if source and source != @tmp
		source = source[@tmp]
	if source
		source.SlidePositions(start)
		.source = source
		.Cleanupfunc(Source)
		parser.using.Flags = MsgParseFlags.Inserted
		rz = .UpdateSourceSub(source)
		source.obj = orig.disambiguate(source)
	parser.using.Flags = 0
	parser.using.Tag = 0


function SCObject.Disambiguate (|message| src, |scfunction|)
	opt norefcounts
	if self isa scdecl
		rz = .hiderfunc
	if self isa scfunction
		rz = self
	rz = rz.disambiguate(src)


function SCFunction.Disambiguate (|message| src, |scfunction|)
	opt norefcounts
	if !self or !.nextfunc
		return self
	for curr in self
		|| s = curr.source!
		if s.deepequals(Src)
			return curr
		|| ss = s.second
			if ss.deepequals(Src.second)
				return curr
	return self // better than nothing?


function AutoJump (|message| cmd, |message|)
	opt norefcounts
	|| c = cmd.last
	if c == @name
		if cmd starts "autocomplete"
			return .AutoComplete(c.first, c.name, cmd.name)  
		  else
			return .DefineOrCall(c, cmd.name)
			
	if cmd starts "autocomplete"
		return .RootTmpComplete(cmd)
	if c ~= "import"
		return .JumpImport(cmd)


function MainActAutoComplete (|Message| thg, |string| str, |message| cmd, |message|)
	if thg == @tmp
		return .TmpAutoComplete(thg, str, cmd.name)
	return .AutoComplete(thg, str, cmd.name)


function MainAct (|Message| cmd, |scfile| my_file, |message|)
	opt norefcounts
	|| f = cmd[@num, 1].int|int|
	|| n = cmd[@num, 2].int|int|					#expect "nolen"
	my_file.use
	|| fn = .GetFunc(cmd, my_file, f, n)
	(message).restore
	require fn
	
	|| thg = fn.source!.findpos(f, n)
	if !thg and cmd == "callfrom"
		thg = fn.source // sigh
	if  thg == @thg  and  fn.source!.isbehaviour  and  thg in fn.source
		return .define_behaviour(fn, cmd.name)
	if cmd starts "define" or "display" or "callfrom"
		return .backup_define(my_file, f, thg, cmd.name)

	expect (thg)                       ("nomsg")
	expect (cmd starts "autocomplete") ("badcmd")
	|| stuff = cmd[@str, 3]
	|| Auto = MainActAutoComplete(thg, stuff.name, cmd)
		rz = @arg + "result"
		rz <~ stuff[0] // meta
		rz <~ auto
	



function Message.ACInIsa (|bool|)
	opt norefcounts
	require (self == @thg) and .islast
	|| p = .parent$
	if (p == @rel)
		|| pr = .prev
		if pr ~= "isa" or "as" or "mustbe"
			return true
	|| pfn = p.asfunc
		if pfn.name ~= "isa"
			return true


function GetScope (|message| orig, |&int| types, |SCNode|)
	if !orig
		return compiler.program
	if orig == @ask
		*types = 8
		return compiler.program
	|| f	= orig.CutifyCopy
	|| arg	= orig.MsgArg
	|| fn	= f.func
	if arg and fn == @dot
		|| decl = TypeOfExprModulesOK(f.first!, arg)
		if !decl
			error "notype"
			return nil
		if decl isa SCNode
			return decl
		if decl isa scdecl
			return decl.type
	
	if orig.acInIsa
		* types = 1
		return compiler.program
	if arg
		return arg
	if orig.IsTypeOfDecl
		* types = 1
		return compiler.program // right????
	
	return orig.msgarg #expect "noscope"


function SCFunction.VisibleArgs (|int|)
	opt NoRefCounts
	for s in .args
		if !s.default
			rz++
	rz -= (.cls!=nil)


function SCObject.CanAuto (|string| search, |string|)
	opt norefcounts
	rz = .CanAutoSub(Search)
	if rz
		|| IsExact = rz ~= search
		if self isa scfunction
			if .VisibleArgs
				rz += "(<>)"
		
		if !IsExact and .NoAutoComplete
			rz = ""


function SCObject.CanAutoSub (|string| search, |string|)
	opt norefcounts
	
	if self isa scfunction
		require !.noautocomplete or (.name ~= search) // is .noautocomplete == 1 allowed?
		if (.name starts "operator")  and  !(search starts "oper")
			return ""
		//require .VisibleArgs // makes no sense... we don't care if the args are visible?
							 // for some cases... yes, but not for plain autocomplete.
							 // only for exact match
							 // i can't remember why i added it, so just remove it :[
	  elseif self isa scdecl
		return .realname
		
	  elseif self isa scmodule
		|| cls = .cls
			require !(cls.NoAutoComplete or cls.IsBehaviourTable)
	if self isa scnamed
		return .name


function SCDecl.RealName (|string|)
	opt NoRefCounts
	|| l = .IsLookupOnly
	if l isa SCObject
		return "" // oooff
	|| s = .source
	if s == @thg and s in @rel
		s = s.parent
	if s == @rel or @decl
		return s.DeclName.name
	return .name // sigh... 


function SCObject.Auto_Type (|int|)
	if self isa scdecl
		if self is property
			return -2
		if self is const
			return 5
		return 0
	if self isa scfunction
		if self is VirtualCaller
			return 4
		return 1
	if self isa scclass or SCModule
		return 2
	return 3


function SCObject.BaseIcon (|string|)
	if self isa SCModule
		if .cls
			return " \19 "
		return " \0C "
	if self isa scfunction
		if .isbehaviour
			return " b "
		if self is VirtualCaller
			return " v "
		return " f "
	if self isa scclass
		return " \0E "
	if self isa scdecl
		if self is property
			return " \1B "
		if self is const
			return " k "
	if self isa sciterator
		return " \0A "
	return "   "


function SCObject.CallFromName (|string|)
	if self isa scfunction
		return .RenderName
	if self isa scdecl
		return .AutoCompleteName
	if self isa scnamed
		return .Name


function SCObject.Display (|bool| exact, |string|)
	if self isa scfunction
		if .IsAllocOrNew or .isdisabled
			return ""
		return (.RenderTitle(false), .name)(Exact)
	if self isa SCDecl
		return .AutoCompleteName
	if self isa sciterator
		return ""
	if self isa scnamed
		return .name


function SCObject.NextDisplay (|bool| exact, |SCObject|)
	if exact
		if self isa scfunction
			return .nextfunc
		if self isa scdecl
			return .hiderfunc
			
	

|| max_total = 400
|| total	 =   0

function Active (|bool|)
	return .total < .max_total


function SCObject.AutoCompleteType (|int|)
	if self isa scmodule
		if .cls
			|| r = 1
			// probably better to copy the actual basetype-info over... but whatever.
			if .cls == SCNodetype.FuncProto
				r |= 8
			return r
		return 2
	return 4



function Object.AsDecl (|scdecl|)
	opt norefcounts
	if self isa SCClass
		return .typenormal
	  elseif self isa SCModule
		|| c = .cls
			return c.typenormal
	  else
		return .BaseAsDecl


function Object.BaseAsDecl (|scdecl|)
	if self isa SCDecl
		return self
	if self isa scfunction
		return .returntype


function AutoSub2 (|SCObject| value, |string| key,  |string| src_name, |[autoitem]| found, |bool| exact, |int| Types, |scdecl| TypeLimiter)
	
	while value and .active
		ifn (key ~= "self") and (value isa scmodule)
			if types & value.AutoCompleteType
				|| OK = true
				if typelimiter
					|| mine = value.AsDecl
						OK = mine.minimatch(typelimiter)
				
				if OK
					|| sub_name = value.display(exact)
						.total++
						sub_name = value.baseicon + " " + sub_name
						found <~ autoitem(key, src_name, value, sub_name, exact, value.auto_type)
			 
		value = value.nextdisplay(exact)

			
function AutoSub (|SCNode| scope, |string| name, |[autoitem]| found, |int| Types, |message| NeedTypeLimit) // autocompletesub
	|scdecl| TypeLimiter = nil
	if NeedTypeLimit
		TypeLimiter = TypeOfExpr(needtypelimit, scope) // >:P
	
	for (value in scope.access) (key)
		|| orig = value.canauto(name)
		if orig and (!name or orig starts name)
			.autosub2(value, key, orig, found, orig ~= name, Types, typelimiter)
			


function AutoCompleteSorter (autosort_fn)
	|| type = a.type - b.type 
		return type < 0
	return a.sort < b.sort


function FuncTmps (|message|)
	if .func_tmp_src.cleaned
		return .func_tmp_src.Source
	.func_tmp_src.cleaned = true
	rz = .func_tmp_src.Source
	
	for ch in rz
		if ch != @dot
			ch <~ (@str, ch.name)
		if ch != @str
			|| f = ch.first
				f.name += " "
		ch.func = @dot


function message.Autocomplete_State (|int|)
	|| s = .name
	rz += (s contains 'R')<<0
	rz += (s contains 'M')<<1
	rz += (s contains 'C')<<2
	rz += (s contains 'L')<<3
	

function AllTmps (|message|)
	opt norefcounts
	if .all_tmp_src.cleaned
		return .all_tmp_src.Source
	.all_tmp_src.cleaned = true
	rz = .all_tmp_src.Source
	
	|| state = 0
	for ch in rz
		if ch == @name
			state = ch.autocomplete_state
			ch.remove
		  else
			ch.tag = state


function TmpAutoComplete (|message| f, |string| name, |string| type, |message|)
	|| finished = false
	rz = @tmp + type
	if name ~!= "r" // too annoying.
		for ch in .functmps
			if ch starts name
				if ch.name > 2  and  ch.name ~= name
					finished = true
				  else
					|| cf = ch.first
						|| arg = rz.msg(@arg, name)
						arg.msg(@tmp, cf.name) <~ (@str, cf.name)
				
	if rz.hasany
		0 //
	  elseif f
		rz = .AutoComplete(f, name, type)
	  else
		rz = nil
	  


function JumpImport (|message| cmd, |message|)
	|| f = cmd[@arg][0]
		cmd.clear
		|| proj = Compiler.FindProject(f.name, false)
		require proj.exists
		cmd <~ (@sstr, proj.path)
		cmd <~ 0
		return cmd


function RootTmpComplete (|message| cmd, |message|)
	opt norefcounts
	|| f = cmd[0][0]
	|| req = f.next.name
	|| flags = 0 // for now
	flags += f.IsModuleType  <<  1
	flags += f.IsClassType   <<  2
	flags += f.IsLinkageType <<  3
	flags := 1
	rz = @tmp.msg(cmd.name)
	|| arg = rz.msg(@arg, req)
	for ch in .alltmps
		|| found = ch.name 
		if (ch.tag & flags) and (found starts req)
			|| tmp = arg.msg(@tmp, found)
			tmp <~ (@str, found.Before("<"))


function SCNode.UpClass (|message| f, |SCNode|)
	opt norefcounts
	rz = .parent
	if  f == @dot  and  rz isa scmodule
		require !rz.isimport


helper message.GetTypeLimiter (|message|)
	opt norefcounts
	require self
	|| rel = .parent
	if (rel == @rel) and .islast and !(rel in @decl)
		return rel


function AutoComplete (|message| ff, |string| name, |string| Purpose, |message|)
	require ff
	|| f = ff.func
	require f != @bra and @prm and @list and @arg and @arr and @acc and @decl and @rel
	// maybe better to restrict it to an allowed-list... than a banned-list
	.Total = 0
	|| Types = -1
	|| scope = .GetScope(ff, types)		#require
	|| NeedTypeLimit = ff.GetTypeLimiter
	|[autoitem]| arr
	while scope and .active
		.AutoSub(scope, name, arr, Types, NeedTypeLimit)
		if !name and scope isa scarg
			exit
		scope = scope.upclass(ff)
		
	arr.sort(AutoCompleteSorter)
	rz = @tmp.msg(Purpose)
	|| arg = rz.msg(@arg, name)
	|autoitem| Prev
	for i in arr
		if i.OKby(prev)
			|| tmp = arg.msg(@tmp, i.insert)
			tmp <~ (@str, i.display)
			prev = i


function ActualDefine (|message| rz, |message| s, |string| purpose)
	|| f = s.filepath			#expect "nopath"
	rz <~ (@sstr, f)
	rz <~ s.position


function SCNode.DiissplayObj (|message| rz, |message|)
	rz <~ (@emb, .AutoCompleteKind + " " + .name)
	return rz


function message.RenderTypeAndName (|string|)
	|| d = .MsgDecl
		return d.RenderTypeAndName(1)
	return .render


function CanUseName (|SCNode| l, |bool|)
	if l isa scmodule
		return !l.isimport
	return true


function Diissplay (|message| msg, |message| s, |string| purpose, |message|)
	rz = @arg.msg
	|| fn = s.Identifyfunc
	if msg == @name
		if purpose == "display"  and  s istmp "prototype"
			return s
		msg.func = @thg // findmoduleorclass needs this
		|| obj = compiler.findmoduleorclass(msg, true)
			return obj.diissplayobj(rz)
	
	if (s == @decl) and (!fn or msg.deepequals(s.DeclName))
		rz <~ (@emb, s.RenderTypeAndName)
		return rz

	if !fn
		|| obj = s.obj
		if obj isa SCNode
			return obj.diissplayobj(rz)
	
	if purpose ~= "displayall"
		if fn and !fn.nextfunc and !fn.args
			return rz // I guess we want empty result.
	if !fn
		return s.copy
	
	while fn
		|| copy = fn.source!.cutifycopy 
		rz <~ copy
		|| desc = fn.description
			rz <~ @emb
			rz <~ (@back, desc)
			if fn.nextfunc
				rz <~ @emb
		|| l = fn.parent
			if .CanUseName(l)
				.IdentifyBetter(copy, l.name)
		  else
			exit
		ifn purpose starts "displayall"
			exit
		fn = fn.nextfunc


function RespondDefine (|message| msg, |message| s, |string| purpose, |message|)
	rz = @tmp.msg(purpose)
	if purpose starts "define"
		.ActualDefine(rz, s, purpose)
	  else
		rz <~ .Diissplay(msg, s, purpose) // on purpose


function Message.AutoMsgFuncFn (|SCFunction|)
	opt norefcounts
	if self == @name
		|| cls = compiler[self]
			return cls.ConstructorFunc // what if there are multiple?
	|| tmp = self
	if tmp != @tmp
		tmp = .parent
		if tmp == @dot
			tmp = tmp.parent
	if tmp == @tmp
		|| fn = tmp.asfunc
			return fn


function Message.AutoMsgFunc (|SCFunction|)
	opt norefcounts
	rz = .MsgFunc
	rz:=.parent.MsgFunc


function CallFromDefine (|message| msg, |scfunction| fn,  |object| found, |message|)
	rz = @tmp + "callfrom"
	|| arg = rz.msg(@arg)
	|| define = .define(msg, "define", found)
	define := @tmp + "nodefine"
	define <~ fn.name
	arg <~ define


function CallFrom (|message| msg,  |string| purpose,  |object| found=nil,  |message|)
	opt norefcounts
	
	|| fn = msg.AutoMsgFuncFn
	fn := msg.AutoMsgFunc
	require fn
	
	rz = .CallFromDefine(msg, fn, found)
	.CallFromSub(rz.first, fn)


function CallFromSub (|message| arg, |scfunction| fn)
	opt norefcounts
	for call_point in fn.linkfrom
		|| s = call_point.source
			|| f = s.filepath
				|| item = arg.msg(@tmp, "line")
				item <~ (@sstr, f)
				item <~ call_point.CallFromName
				item <~ s.FuncPos(fn)


helper Message.FuncPos (|scfunction| fn, |int|)				
	opt norefcounts
	for ss.flat in self
		if ss.obj == fn
			return ss.position
	return .position // oh well


function Define (|message| msg,  |string| purpose,  |object| found=nil,  |message|)
	|| IsDisplay = purpose starts "display"
	|| IsDefine  = purpose starts "define"
	expect (IsDisplay or IsDefine) ("badcmd")
	ifn found isa SCObject
		found = nil
	|| s = .LocateDefinition(msg, found|SCObject|, IsDisplay)	
		return .RespondDefine(msg, s, purpose)
	if platform.isdebug
		.LocateDefinition(msg, found|SCObject|, IsDisplay)
	error "nosource"


function DefineOrCall (|message| msg,  |string| purpose,  |object| found=nil,  |message|)
	if  purpose starts "callfrom"
		return .Callfrom(msg, purpose, found)
	return .define(msg, purpose, found)


function Define_Behaviour (|SCFunction| fn,  |string| purpose,  |message|)
	// behaviour abc --> .__abc__
	|| cls = fn.cls #require
	|| name = fn.name.moat
	|| found = cls.UpCheck(name)
	if found isa SCFunction
		rz = .DefineOrCall(found.source!, purpose, found)


function message.CutifyCopy (|message!|)
	rz = message(self)
	for v in self
		if v == @arg
			0 //
		  elseif v.isreffer
			|| vll = v.last.last
				rz <~ vll.CutifyCopy
			  else
				debugger // what?
		  else
			rz <~ v.CutifyCopy

	|| fn = rz.MsgFunc			// what about modules?
		|| cls = fn.cls
		|| modname = ""
		|| space = fn.parent
		if space isa scmodule
			modname = space.name
		if cls or modname // ok so...
			|| name = rz.first
			if name == @thg
				|| prm = name.next!
				rz.become( @dot, fn.name )
				if cls
					rz.first = prm.first
				  elseif space != compiler.program
					|| mod = @thg.msg(modname)
					mod.obj = space //oop
					rz.first = mod
				if !prm.hasany
					prm.func = @emb
				name.remove



function message.IdentifyFunc (|scfunction|)
	opt NoRefCounts
	if self == @tmp
		require  self!="class"  and  self!="module"
	|| obj = .obj
	if obj isa scfunction
		return obj


//function message.IsClassOrExtOrModule (|bool|)
//	return (self == @tmp) and (.IsClassType or .IsExtender or .MsgIsProperModule)


function object.ClassOrModule (|SCNode|)
	opt norefcounts
	if self isa scmodule
		|| c = .cls
			return c
		return self


function IdentifyBetter (|message| node, |string| name) // p.firstname
	opt NoRefCounts
	node.become( @emb )
	node = node.first!
	node.func = @dot
	node <~ (@thg, name)
	node <~ @emb
	

function Message.ModuleSrc (|message|)
	opt norefcounts
	|| name = .name
		|| found = compiler.program.FindModule(name, nil)
			|| c = found.cls
				|| fp = c.funcproto
					return fp.source
				  else
					return c.sourcearg
			return found.source


function FindAdj (|message| msg, |bool| DisplayOnly, |message|)
	opt norefcounts
	|| adj = msg
	if msg in @adj
		adj = msg.parent
	ifn adj in @decl
		|| found = compiler.FindAdj(adj)
			return found._parsed // why not .source?
	 

function LocateDefinition (|message| msg, |SCObject| already_defined, |bool| DisplayOnly, |message|)
	opt norefcounts
	if (msg in @adj) or (msg == @adj)
		rz = .FindAdj(msg, displayonly)
		if rz
			return rz
		
	|| ty = TypeOfExpr(msg, msg.msgarg) // needs refcounts
	rz = .LocateDefinitionSub(msg, already_defined, ty, DisplayOnly)
	if rz == @arg
		|| p = rz.parent
			rz = p

	if msg in @tmp
		msg = msg.parent
	if (msg == @tmp)
		|| fn = msg.obj
		if fn isa SCFunction
			return fn.Source


function LocateDefinitionSub (|message!| msg, |SCObject| already_defined, |scdecl| ty, |bool| DisplayOnly, |message|)
	opt norefcounts
	if already_defined
		return already_defined.source
	
	if  msg == @thg  and  msg in @func
		msg = msg.parent! // :)
	|| fn = msg.msgfunc
		|| it = fn.source
			return it

	if !ty
		return msg.ModuleSrc
	if ty.type == SCNodetype.funcproto
		|| l = ty.IsLookupOnly 
		if l isa scfunction
			return l.source
	
	if !displayonly and msg == @decl
		return ty.Type.Sourcearg
	|| src = ty.source
		if  DisplayOnly  and  ty is const
			ty.name = msg.name		// unimprove it
			return ty.WriteDeclFull("", 1)
		if src == @decl and src.last == @rel
			src = src.copy
			|| L = src.last!
			L.replacewith(l.first!)
		return src
	
	if DisplayOnly
		|| t = ty.type
		return t.typenormal.source ?? t.source
	|| found = msg.obj.ClassOrModule
		return found.source
		
}


prototype autosort_fn (|autoitem| a, |autoitem| b, |bool|)

class autoitem
	|string|		Sort
	|string|		Insert
	|SCObject|		Value
	|string|		Display
	|bool|			Exact
	|int|			type
	
	function OKBy (|autoitem| prev, |bool|)
		if !prev
			return true
		if .insert ~!= prev.insert
			return true
		if .exact != prev.exact
			return true



function message.IsClassType (|bool|)
	return self ~= "class" or "datatype" or "struct" or "role"

function message.IsLinkageType (|bool|)
	return self ~= "linkage"

//function message.IsExtender (|bool|)
//	return self ~= "extend" or "extend_module"	

function message.IsModuleType (|bool|)
	return self ~= "module" or "extend_module" // don't need root. flags:=1 does it
	
	
//function message.MsgIsProperModule (|bool|)
//	opt norefcounts
//	require self ~= "module"
//	|| p = .parent
//	require p == @arg
//	return p.parent == nil

	
function message.FindPos (|int| fr, |int| len, |message|)
	return  .FindPosSub(fr, len, true)  ??  .FindPossub(fr, len, false)

function message.FindPosSub (|int| fr, |int| len, |bool| Exact, |message|)
	opt norefcounts
	|| Strength = 1
	for ch.flat in self
		if ch.position == fr
			|| CurrStrength = (ch.RangeLength == len) + !Exact
			if (CurrStrength >= Strength)
				if ch isnt Inserted
					return ch.unbra
				Strength = CurrStrength
				rz = ch


extend message
	render JDB4_
		fs <~ .Func.name
		fs <~ ' '
		if (.name)
			fs <~ '"'
			fs.appendescape(.name[0,32])
			fs <~ '"'
		if .obj
			ifn .obj isa message // awkward
				fs <~ ' '
				.obj.render(fs)
		if .hasany
			fs.indent++
			for ch in self
				fs.IndentLine
				ch.jdb4_(fs)
			fs.indent--
			fs.IndentLine


	api message.JDB4 (|string|)
		cpp_name jdb4
		visible
		printline .jdb4_
