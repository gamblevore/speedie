

module SC_Init
	function SCModule.BuildInitArg (|message|)
		opt norefcounts
		|| s = .source
			using s
				rz = .BuildInitArgSub
		  else
			rz = .BuildInitArgSub
	
	
	function SCModule.BuildInitArgSub (|message|)
		rz = @arg.msg
		rz <~ @arg
		rz.msg(@tmp, "opt")<~(@thg, "norefcounts")
		|| src = .source
			|| ig = src.msg(@tmp, "ignore")
			ig.Obj = self // ignore in the renderer.
			ig <~ rz


	function Message.SettingToNil (|bool|)
		opt norefcounts
		if (self == @Decl)
			|| d = .Last
			if (d == @Rel) and (d.Last ~= "nil")
				Return true


	function SCModule.AvoidMain (|bool|)	
		opt norefcounts
		return (self == compiler.program) and !(compiler.project!.isstdlib)


	function SCModule.InitDecls
		description "Collects global decls from this module." 
		opt norefcounts
		|| a = .initvarsarg.First
		if a.hasany
			.Project.use
			CollectDeclsGlobals( a, self )
		if false and self == compiler.program
			CollectDeclsGlobals( compiler.AppInitGlobals, self )
//			SC_CollectDeclsGlobals(SC__Comp_AppInitGlobals, Self)		


	function SCModule.MoveToInitFunc (|Message| c)
		description "Put globally found decls+funcs, into a function that can be called at init-time. Each module will have an init-func... and it will be called if it has any code. We just store the stuff right now, but later, we create them via .CreateInitFunc"
		
		// (Why not create the init funcs right away? via .CreateInitFunc. I mean... its less confusing?)
		
		opt norefcounts

		if (c == @sheb or @url)
			c.remove
			return
		expect c.AllowedMoveToInit (c)

		if false and .AvoidMain
/			if c == @decl
				compiler.AppInitGlobals <~ c
				return
			  else
				compiler.AppInitCode <~ c
				return

			
		if c == @decl
			require !c.SettingToNil
			|| dest = .InitVarsArg init .BuildInitArg
			dest = dest.first
			dest <~ c
		  else
			|| dest = .InitCodeArg init .BuildInitArg
			dest <~ c


function Message.AllowedMoveToInit (|bool|)
	opt norefcounts
	|| type = .func
	if (type == @dot or @sdot or @func or @rel or @decl)
		return true
//	if self istmp "once" // inits are always once anyhow
//		return true


function SCModule.CreateInitFuncSub (|message| init, |string| name)
	|| msg = "helper $Name (|int|)".ParseClean
	msg <~ init
	|| fn = .NewModuleFunc( msg )
		(fn is InitFunc)
		|| L = init.Last
		if !L.hasany
			L.Remove // never called anymore?


function SCModule.CreateInitFunc
	SCNode.CurrVisibility = true
	scmodule.Curr = self
	|| arg = .InitCodeArg
		.CreateInitFuncSub(arg, "InitCode_")
	
	arg = .InitVarsArg
	if arg
		.CreateInitFuncSub(arg, "Init_")
	scmodule.curr = nil


function SCModule.TryInit (|array of scmodule| req, |bool|)
	opt norefcounts
	for name in .InitAfter
		name.expect(@thg)$
		|| m = compiler.FindModuleMsg(name)
		require m and m.Inited

	.Inited = true
	req <~ self
	return true


extend_module SCModule
	function DoInitAfter (CollectFunc)
		opt norefcounts
		|| mod = name_Space.SpaceModule(node)$
		mod.InitAfter = node[@prm, @bra]
		return compiler.program


function SortInitOrderSub (|array of scmodule| mods, |array of scmodule| out, |bool|)
	opt norefcounts
	|SCModule| failed
	|| GotAny = false
	for m in mods
		require stderr.ok
		if m.inited
			//
		  elseif m.tryInit(out)
			gotany = true
		  else
			Failed = m

	expect (gotany or !failed) (Failed.source, "Modules has recursive init order")
	return failed

	
function SortInitOrder (|array of scmodule| mods, |array of scmodule|)
	while SortInitOrderSub(mods, rz)
		0 // this is such a wierd loop. But it works well. :)

	
function SCModule.CallInit (|message| src, |message| dest, |string| fn_name)
	opt norefcounts
	require src and .HasActualCode(src) and (self != Compiler.program)
	for s.flat in src
		if s.position < 0
			s.position = 0
	using src
	dest.AlmostAppend  @sheb + ("// " + .Name)

	|| dot2 = «dot fn_name
«thg .name »
«prm »
	»
	
	dest.almostappend  dot2



function message.AlmostAppend (|message| v)
	opt norefcounts
	|| s = .last
	if s == @tmp
		s.prev = v
	  else
		self <~ v
	

function SCModule.CallOurInitsByTheBiggerInitFunc
	opt norefcounts
	|| v = .InitVarsArg
	if .IsLibrary
		|| p = Compiler.program
		.CallOurInitsByTheBiggerInitFunc(v, p.InitVarsArg, p.InitCodeArg)
	  else
		.CallOurInitsByTheBiggerInitFunc(v, compiler.appinitglobals, compiler.appinitcode)
	


function SCModule.CallOurInitsByTheBiggerInitFunc (|message| v, |message| DestVars, |message| DestCode)
	opt norefcounts
	.CallInit(.InitCodeArg, destcode, "InitCode_")

	|| it = v.first											#require
	for (msg in it)
		if .InitRootDecl( msg )
			msg.Remove
	
	.CallInit(v, destvars, "Init_")



function SCModule.HasActualCode (|message|arg, |bool|)
	opt norefcounts
	for curr.flat in arg
		if (curr == @Decl)
			continue_with curr.FlatAfter
		  elseif (curr != @arg)
			return true // found something!



function SCModule.InitRootDecl (|Message| DeclMsg, |bool|) {
	// this code just seems wrong... it finds an SCDecl and puts it into "Decl" :)
	// have an SCDecl... that should always already have a default! So why we are creating a default?

	require (declmsg.func == @Decl)
	|| name = declmsg.GetDclName$	///	require name.expect(@thg)
	
	|| decl = .LookUpVarRootDecl( name.name, name )
	if decl isa SCDecl
		if decl.isbarestruct
			return true
		using (name)

		|| P = name.parent
		|| NewDefault = (P.last, nil)(P == @Rel)
			
		if !NewDefault
			if !Decl.IsNormal
				return true
			NewDefault = Decl.CreateDefault(name)
			if (NewDefault and decl.contains)
				NewDefault = decl.WriteTypeCast(NewDefault)
				NewDefault.Obj = nil // just keep doing what it used to do
		
		if newdefault
			if !newdefault.IsNilOrZero // and !(options.modepack and decl.islib)
				DeclMsg.Prev = NewRel( @thg + name.name, NewDefault, "=" )
		Return true
}


function message.IsNilOrZero (|bool|)
	opt norefcounts
	|| f = .func
	|| n = .name
	if f == @thg
		if .obj == typenil or FalseBool
			return true
		if n == "nil" or "false" // what?
	if f == @num
		return .iszero
	if f == @arg
		return !.hasany
		
