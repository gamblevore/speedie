
/*
	Jeebox internals. By Theodore H. Smith...
*/



class SCClass (SCBase) {
linkage
	cpp_part		Class

|SCClass|					Super
|Message|					Defawlt
|Message|					False
|Message|					SourceClass
|SCModule|					Modul
|[SCDecl]|					Properties
|SCDecl|					TypeNormal
|SCDecl|					TypeOptional
|SCDecl|					TypeVeryExists
|[SCFunction]|  			Casts
|[SCClass]|					Children
|SCDecl|					Contained
|scdecl|					Signed								// int/uint
|scdecl|					NotConstUwU
|SCFunction|				FuncProto
|SCFunction|				TheIsFunc
|SCFunction|				ConstructorFunc
|SCFunction|				DestructorFunc
|string|					CppClass
|SCDecl|					ClassType
|SCDecl|					SelfStrong
|Message|					IsModel
|SCBehaviour|   			Behaviour
|string|					SaveAs
|SCClass|					ProcessAs
|SCDecl|					DataTypeWrapper
|uint16|					Size
|uint16|					Depth
|uint16|					StructContainerDepth
|DataTypeCode|  			TypeInfo
|bool|						HasCompareFunc
|bool|						HasEqualsFunc
|bool|						IsRole
|Byte|						IsBehaviour
|Byte|						MinOpt
|bool|						IsBuiltin
|bool|						IsDataTypeLike
|bool|						IsStruct
|bool|						IsDataType
|byte|						IsWrapper
|bool|						HasSubClass
|bool|						NoEarlyFree
|bool|						AutoGeneratedSavers
|bool|						SavingCanSkip
|bool|						TreatAsBaseType
|bool|						IsNotNumeric
|bool| 						Banned


constructor (|Message| node, |SCBase| parent)
	Compiler.stClasses++
	
	node.obj = self			// for autocomplete :)
	.name   = LoadClassName(node)
	.Source = node[@Arg, -1]
	.SourceClass = node		// sigh. bad design
	.project = parent.project
	.IsVisible = scbase.CurrVisibility
	.saveas = nil
	.TypeInfo = DataTypeCode.UnusedType
	.Banned = .TestBanned
	
	|| IsDataType = node == "datatype"
	|| T = SCDecl.new(self)
	if isdatatype
		T.nildeclared = nilstate.Real
		T.nilused = nilstate.Real
	.TypeNormal = T
	.TypeOptional = T.NilConstructor(NilState.optional*IsDataType)
	.TypeVeryExists = T.NilConstructor(NilState.Real*IsDataType)
	
	if node == "struct"
		T = T.GetAddress
	  else
		T = T.Copy
	T.Name = "self"
	t.NilDeclared &=~ NilState.Stated // :) not stated!
	(T is implicit)
	T.Strength = kStrSharedParams
	.SelfStrong = T


function IsSTDLib (|bool|)
	return .Project.IsSTDLib


function PreferAddress (|bool|)
	return .isstruct and !.isdatatypelike

function NumericCount (|int|)
	if self
		return .TypeInfo.NumericCount


render
	super.Render(fs)
	if .isstruct
		fs <~ " struct"
	if .NumericCount
		fs <~ " numeric"
	if (.funcProto)
		fs <~ " prototype"
	  elseif (.isdatatype)
		fs <~ " datatype"
	if .ismodel
		fs <~ " model"


function message.alreadysets (|string| name, |bool|)
	opt norefcounts
	for ch in self
		if SettingSelfProperty(ch) and (ch.first == name)
			return true


function scdecl.ispassable (|bool|)
	return .c_array == 0


function PassableCount (|int|)
	opt norefcounts
	for p in .properties
		rz += p.ispassable


function AutoConstructor
	opt norefcounts
	|| fn = .CreateEmptyFunc( "Constructor", "ConstructorAuto" )
	|| node = fn.source
	|| prms = node[1]
	|| arg	= prms.next
	for prop in .properties
		if prop.ispassable
			|| name = prop.name
			if name ~= "super"
				name = "sooper"
			check (name != "__rz__") (prop.source, "Invalid name.")
			prms <~ prop.WriteDeclTypeAndName(name, false)
			arg  <~ «rel
				«sdot name »
				«opp "=" »
				«thg  name »
			»
	(fn)


function LoadProperties
	require !.IsBehaviourTable
	.Properties = CollectDecls( .source, .Modul, self, 3 )
	if .properties == nil // fail gracefully
		.properties = []
		return
	|| it = .properties.first
		expect (!self.IsRole) (it.source, "Roles can't have properties!")
	for (p in .properties)
		expect (!p.default) (p.source, "Class properties can’t have default values.")

	if .IsModel
		.ModelDecls



function GetDepth
	opt norefcounts
	
	if !.depth
		.depth = 1
		for c.Upwards in self
			.depth++
	


function GetStructDepth
	opt norefcounts
	expect (.StructContainerDepth != -1) (self, "This struct contains itself?")
	.StructContainerDepth = -1
	
	|| r = 0
	for p in .properties
		|| t = p.type
		if (t.isstruct) and (p.pointercount == 0) 
			t.GetStructDepth
			r = r max t.StructContainerDepth+1
	.StructContainerDepth = r


function CalculateSize (|int| Depth=0, |int|)
	.CalculateSizeRaw(Depth)
	return .size


function CalculateSizeRaw (|int| Depth=0, |int|)
	if (.size)
		return .size

	if .isdatatype
		.size = .typeinfo.bytesize
		return .size

	expect (Depth < 16) (.source, "Class hierarchy too deep")
	|| Count = 0
	if self == typeobject
		count = 4 // refcount? depends if we are "owned" or "shared".
	if .super
		Count = .super.CalculateSizeRaw				#debug_require

	for p in .properties
		|| Mul = P.c_Array ?? 1
		|| curr = 0
		if (P.IsNormalObject) or (p.PointerCount)
			Curr = platform.PointerBytes
		  elseif (P)
			Curr = P.type.calculatesize(depth+1)	#require
		Count = Count Align Curr
		Count += Curr * Mul 

	.size = Count align 4
	return count


function LoadSuperDepth
	


function LoadSuperclass
	.Modul.LookUp = compiler.program 
	
	|| p = .SourceClass								#require
	|| supc = p[ 1 ]
	|SCClass| S
	if (supc != @bra)
		if supc: expect (supc == @arg) (supc)
		if (.IsObject) and (self != TypeObject)
			S = TypeObject
	  else
		|| SupName = supc[@Thg].Nyme				#require
		S = Compiler[ SupName, supc ]				#require
		
		if (.isDataType)
			expect (S.IsDataType)	(supc, "Datatypes can only subclass datatypes.")
		  elseif (.IsStruct)
			expect (S.IsStruct)		(supc, "Structs can only subclass structs.")
		  else
			expect (S.IsObject)		(supc, "Classes can only subclass classes.")
	
	if (S)
		.Super = S
		if Options.ListAllLib
			s.Children <~ self
		if .IsRole
			.modul.lookup = s.modul
		  else
			s.HasSubClass = true
		.LookUp = S
		|| b = .behaviour
		|| SB = S.behaviour
		if (B and SB)
			b.FuncTayble.cls.super = SB.FuncTayble.cls


module {
function LoadClassName (|message| node, |string|)
	|| S = node.first
	if (s == @thg or @dot)
		return s.name
	if (node istmp "class")
		error (node, "Can't find class name.")


// maybe better to make an init func for this...
|Message| ConstrNew
|Message| ConstrLayerNew2

ConstrNew = `function New () {
	flow off
	|| __rz__ = alloc()|type|
	if __rz__|bool|
		__rz__.Constructor()
	return __rz__
}`.ParseClean

ConstrLayerNew2 = `function NewWithLayer (|MemoryLayer| _L) {
	visible false
	flow off
	cpp_part NewWithLayer
	|| __rz__ = LayerAlloc(_L)|type|
	if __rz__|bool|
		__rz__.Constructor()
	return __rz__
}`.ParseClean
}



// CreateConstructors is so we don't HAVE to call the parent's constructor
// For example, SCModule doesn't have a constructor set, so it creates one
// however, the parent SCBase.Constructor has a param, so the empty constructor
// doesn't know how to call it. So we create one for EVERY class... then the
// problem goes away.


function SCFunction.CopyParams (|message| list)
	|| p = .prms
	using list
	|| a = .source.GiveArg
	|| dot = @dot.msg("constructor")
	a.first = dot
	|| name = dot.msg(@thg, "super")
	|| SubPrms = dot.msg(@prm)
	
	for s in list
		p <~ s.copy
		subprms <~ s.DeclName.copy
		
	
	


function scfunction.prms (|message|)
	return .source.find(@prm)


function CreateEmptyConstructors (|scfunction|)
	|| f = .CreateEmptyFunc( "Constructor" )
	|| pc = .PassableCount
	f.alloccode |= kIsEmptyConstructor
	|| s = .super
	if s and s != TypeObject // object has no constructor-func
		|| l = s.constructorfunc.Prms 
		if l.hasany
			f.CopyParams(l)
			pc = 0 // i guess?
	
	if pc >= 1 and pc <= 8
		.AutoConstructor
	return f


function CreateConstructors 
	if .IsObject
		|| Con = .FindAllocFunc( "Constructor" )
		if .IsRole
			check (!con or .super.ConstructorFunc) (con.source, "Role's super lacks a constructor.")
			con := .super.ConstructorFunc
			.destructorfunc = .super.DestructorFunc
			require con
		
		using .source
		if !con and !.IsWrapper		// some wrapper classes cant be newed.
			con = .CreateEmptyConstructors
		.ConstructorFunc = con
		
		for f in con
			if f.cls == self // role messageroot doesnt need an allocator
				.NewClassNew( f, ConstrNew.copy(f.source)      , 0        )
				.NewClassNew( f, ConstrLayerNew2.copy(f.source), kIsLayer )
	
	if !.IsRole
		|| NeedsDestructor = .IsObject or (.IsStruct and .HasObjectProperties)
		.DestructorFunc = .FindAllocFunc( "destructor", !NeedsDestructor )


function RootName (|string|)
	opt norefcounts
	|| c = self
	while
		|| s = c.super
		if !s or s == typeobject: exit
		c = s
	return c.name


function FindSpecialFunc (|string| keyword, |bool| CheckParents, |SCFunction|)
	return .FindFunc(keyword, CheckParents, true)


function FindFunc (|string| keyword, |bool| CheckParents, |bool|DoError, |SCFunction|)
	keyword = keyword.Lowercase
	
	for (b.upwards in self)
		if (b.access)
			|| o = b.access[ keyword ]
			if (!o)
				|| a = 1
			  elseif (o isa SCFunction)
				Return o // prefer improved #expect
			  else
				if .IsObject
					expect (!DoError) (b.source, "'$keyword' keyword only usable with functions.")
		
		require (CheckParents)



function NewClassNew (|SCFunction| con, |Message| src, |int| ExtraCode)
	src.Position = con.Source.Position
	
	|| result			= .Modul.NewModuleFunc( src )
	result.counterpart	= con
	con.counterpart    := []
	con.counterpart|array| <~ result
	result.AllocCode   |= kIsNew (|) ExtraCode
	con.AllocCode		= kIsConstructor
	
	|| NewParams		= src[ @prm, 1 ]
	|| A				= con.Source[ 1 ]
	|| rsrc				= result.source
	|| TypeStr			= rsrc.FindNested(@thg, "type")
	
	if A == @prm or @list
		|| CallParams = rsrc.FindNested(@dot).last
		for dcl in A
			NewParams  <~ dcl.Copy(Src)
			CallParams <~ dcl.GetDclName.Copy(src)
	
	typestr.ReplaceWith(.TypeNormal.writetype)
	NewParams <~ .TypeNormal.WriteDeclFull


function CreateAlloc (|string| ParseThing, |int| Extra)
	require .IsObject and !.IsRole
	
	|| src = ParseThing.ParseClean.first
	|| fn = .modul.NewModuleFunc( src )
	fn.refs = cpprefs.new
	fn.refs.disturbs = nil
	fn.AllocCode = kIsAlloc (|) extra
	if extra
		fn.IsVisible = false


function NeedsDefaultValue (|message| def, |&message| place, |string| name)
	require !*place
	if .IsObject and !.IsRole
		if def and !(def isthing "nil")
			error (self, "Missing "+name+" value for class: "  + .name)
	*place = def


function ContainedTypeLoad
	.use
	|| sup = .super
		.Contained = sup.Contained
		.SelfStrong.Contains = sup.SelfStrong.Contains
		
		.NeedsDefaultValue(sup.Defawlt, .defawlt, "default")
		.NeedsDefaultValue(sup.false, .false, "false")
	
	.defawlt := «thg "nil"»
	.false := «thg "nil"»

	|| ContainedMsg = .Source.findflat(@Tmp, "contains")[@thg]		#require
	|| cls = compiler[ ContainedMsg.name, ContainedMsg ]			#require
	|| TN = Cls.TypeNormal
	.Contained = TN.Copy											// no difference (self is never borrowed)
	(.Contained Is UpgradeableContained)
	.SelfStrong.Contains = TN


function ContainedButNotUpgrade (|scdecl|)
	return .SelfStrong.Contains


function scfunction.DontWantSameReturnType (|scfunction| f)
	require self
	if f.ReturnType.MiniMatch(.returntype, 0)
		error (.source,  "Multiple casts found [1]")
		error (f.source, "Multiple casts found [2]")
	

function OverrideSyntax
	require stderr.OK
	|| cast = .FindSpecialFunc( "SyntaxCast", false )
	.casts = array.new
	
	for f in cast
		f.IsInline = true
		check  (f.args == 1)		(f.Source, "No params allowed." )
		expect (f.ReturnType)       (f.Source, "Need a return type.")
		f.nextfunc.DontWantSameReturnType(f)
		.Casts <~ f
		if f.returntype == typebool.typenormal
			f.IsNilChecker = true
	
	.HasCompareFunc = .FindSpecialFunc( "SyntaxCompare", true )
	.HasEqualsFunc = .FindSpecialFunc( "SyntaxEquals", true )
	.TheIsFunc = .FindSpecialFunc( "SyntaxIs", true )



function HasObjectProperties (|bool|)
	for p in .properties
		if p.isnormalobject
			return true


function LoadConstructorsAndAllocators
	.Use									// parsed messages come from our source's file
	scbase.CurrVisibility = false			// for allocators that we generate
	
	.CreateConstructors
	if .IsObject and .constructorfunc
		.CreateAlloc( .AllocStr, 0 )
		.CreateAlloc( .AllocStrLayer, kIsLayer )

	if .super
		.NoEarlyFree := .Super.NoEarlyFree

	(Message).Restore // restore message parsing to general


function AllocStr (|string|)
	|| s0 = .name
	|| s = (s0, .super.name)(!.IsRole)
	return "
	helper Alloc (|$s0|)
		return JB_New(__classes__.$s)|$s0|
	"


function AllocStrLayer (|string|)
	|| s0 = .name
	|| s = (s0, .super.name)(!.IsRole)
	return "
	helper LayerAlloc (|MemoryLayer| _L, |$s0|)
		visible false
		return JB_LayerNew(_L, __classes__.$s)|$s0|
	"


function AfterFuncsDecled
	.OverrideSyntax
		
	|| f = .ConstructorFunc
		expect (!f.ReturnType)  ( f.Source, "Constructors can’t return things." )
		.CheckAllocVsWrapper( f, true )
	
	
	f = .DestructorFunc
	if (f)
		expect (!f.NextFunc) ( f.Source, "Can’t have multiple destructors" )
		expect (!f.ReturnType and (f.args.length == 1))   ( f.Source, "Destructor can’t have a return type or parameters." )
	.CheckAllocVsWrapper( f, false )
	
	
	.ClassType = TypeJBClass.TypeNormal.Copy // no difference
	.ClassType.Name = .CStructName



function IsFunc (|bool|)
	Return .FuncProto


function IsObject (|bool|)
	Return (!.IsDataType) and (!.IsStruct)


function CreateEmptyFunc (|String| fname, |string| cpp_name="", |SCFunction|)
	scbase.CurrVisibility = .IsVisible
	cpp_name := fname
	|| e	= "function $fname { cpp_part $cpp_name }"
	|| msg	= e.ParseClean
	rz		= SCFunction.NewFunc( msg, self, .source )|SCFunction|
	.TryAdd( msg, rz, fname )
	rz.IsVisible = false


function FindAllocFunc (|String| fname, |bool| DontCreate = true, |SCFunction|)
	|| it = .FindSpecialFunc( fname, false )
		Return it
	
	if !DontCreate and !.IsWrapper
		Return .CreateEmptyFunc( fname )


function CStructName (|String|)
	opt norefcounts
	if self
		if !.IsRole
			return .CppClass init .name.unicodesafename
		return .RealClass.cstructname


function HasStuffToHandleInDestructor (|bool|)
	opt norefcounts
	for p.upwards in self
		for d in p.Properties
			if d.HasStructDestructor: return true
			if d.IsReffable(true): Return true


function CanCompareSub (|string|s, |scdecl|against, |bool|)
	opt norefcounts
	for (b.upwards in self)
		|| o = b.access[ s ]
		if (o isa SCFunction)
			if o.cancompare(against)
				Return true
	
	
function CanCompare (|SCDecl| Against, |bool| AsEquals, |bool|)
	|| CanUseEquals = AsEquals and .hasEqualsFunc
	if !.HasCompareFunc  and  !CanUseEquals
		Return false

	if CanUseEquals and .CanCompareSub( "syntaxequals", Against )
		Return true

	if .HasCompareFunc
		Return .CanCompareSub( "syntaxcompare", Against )


function CheckAllocVsWrapper (|SCFunction| f, |bool| IsConstructor)
	require .IsWrapper
	require .IsObject
	require .super
	require (!f == isconstructor)

	if !IsConstructor
		require .FirstDestructor
	
	require !f.IsWrapper
	error (.Source, "Wrapper classes must have a constructor that is a wrapper function.")


function FirstDestructor (|SCFunction|)
	for p.Upwards in self
		|| fn = p.DestructorFunc
		
		if !fn
			|| a = 1
		  elseif (p.IsWrapper and p.super) // don't count "object" as having properties!
			Return fn
			
		  elseif (p.HasStuffToHandleInDestructor or fn.SourceArg.Hasany)
			return fn


function AddSelfToFunc (|SCBase| space)
	space.TryAdd( space.FuncSrc, .selfstrong, "self" )


function scdecl.TypeReach (|scbase| from, |message| src)
	opt norefcounts
	flow off
	require self
	|| t = .type
		t.reach(from, src)


function SCBase.ReachedName (|string|)
	opt norefcounts
	|| c = .CurrReacher
	rz = "    via: " + .name
	if c.class == scbase
		rz += " (visible func)"


function Compiler.Banned (|string| name, |bool|)
	return Options.BannedClasses.valuelower(name)
		
function TestBanned (|bool|)
	return compiler.banned(.name)
	
function BannedCheck (|message| src)
	opt norefcounts
	require .TestBanned
	error (self, "Banned class reached: " + .name)
	|| curr = .CurrReacher
	for 100
		if !curr or curr.class == SCBase
			exit
		if src
			error (src, curr.ReachedName)
			src = nil
		  else
			error (curr, curr.ReachedName)
		curr = curr.CurrReacher


function Reach (|scbase| from, |message| src=nil)
	opt norefcounts
	flow off
	require !.currreacher
	if !from
	.CurrReacher = from
	Compiler.stReachedClass++
	
	if Options.BannedClasses
		.BannedCheck(src)
	if .super
		.super.Reach(self)
	if .behaviour
		.behaviour.FuncTayble.cls.reach(self)
	
	if .DestructorFunc
		.DestructorFunc.findReached(self)
	
	for d in .Properties
		d.TypeReach(self, d.source)
		d.contains.TypeReach(self, d.source)


function ReachBehaviours
	flow off
	for f in .Access
		if f isa SCFunction
			if f.IsBehaviour
				f.FindReached(self)


function IsA (|SCClass| S, |bool|) // hassuper, issuper, issubclass
	opt norefcounts
	for p.upwards in self
		if p == S
			return true


function real_isa2 (|SCClass| cls, |bool|)
	opt norefcounts // why doesnt the first one do this?
	return .realclass.isa(cls.realclass)

function real_isa (|SCClass| cls, |bool|)
	opt norefcounts
	return .realclass.isa(cls)


function IsBuiltinChain (|bool|)
	opt norefcounts
	for p.upwards in self
		if (p.IsBuiltin)
			Return true


function AfterAfterFuncs
	if .super
		.HasCompareFunc := .super.HasCompareFunc
	
	if .super
		.HasEqualsFunc := .super.HasEqualsFunc
	
	if .defawlt
		TypeOfExpr( .defawlt, .Modul )
	
	if .IsModel
		.DeclModel


function JSStructName (|String|)
	if .IsDataType
		Return .Name
	
	return .SubProjName + "_" + .name

function IsAtomic (|bool|)
	return .typeinfo.isatomic

function TryAddToProject
	require !.funcproto
	|| NameNode = .SourceClass.first
	|| mod = Compiler.DisamClasses
	if NameNode == @dot
		// load the modules first.
		mod = compiler.FindModulemsg(namenode.first)#require

	mod.TryAdd( .source, .modul, .name )



module
	function SCClass.LoadLinkage
		opt NoRefCounts
		|| Arg = .LinkagePlace 				#require
		if arg.DeprecatedClassOption("wrapper", "union") // for SDL2
			.iswrapper = 2
		  elseif arg.DeprecatedClassOption("wrapper", nil)
			.iswrapper = 1
		.NoAutoComplete = arg.DeprecatedClassOption("noauto")
		  
		.NoEarlyFree = arg.DeprecatedClassOption("pragma", "NoEarlyFree")
		.TreatAsBaseType = arg.DeprecatedClassOption("pragma", "TreatAsBaseType")
		.minopt = arg.DeprecatedClassOption("opt", "min")



	function NeuClassSub (|Message| node, |SCBase| parent, |Message| ErrPlace, |string| ForInterface, |SCClass|)
		if !ForInterface
			expect (parent==compiler.program) (errplace, "Internal Error")
		
		|| arg = node.GiveArg
		|| cls = SCClass.new( node, parent )
		
		cls.IsRole = (node ~= "role")

		|| SA = cls.SourceArg
		cls.loadlinkage
		Compiler.ClassList <~ cls

		|| Module = arg.findflat( @tmp, "module" )
		MoveFutureStaticsIn(Module)				// bad work around
												// makes impossible to extend a static section...

		cls.Modul = SCModule.Neu( Module, cls, ErrPlace )|SCModule|

		if (ForInterface and parent isa scmodule)
			cls.CppClass = "__${parent.cls.name.UnicodeSafeName}_${ForInterface.UnicodeSafeName}__"
				
		Return cls
	
	
	function NeuRole (CollectFunc)
		|| mod = neuclass(node, name_Space, errplace)|scmodule| $
		|| cls = mod.cls$
		cls.IsRole = true
		if !(cls.properties)
			return mod
		
	
	function NeuClass (CollectFunc)
		|| it = .NeuClassSub(node, name_space, ErrPlace, nil)
			it.ClassCollect
			return it.modul

	
	function SCClass.ClassCollect
		.Collect( .Source, .IsVisible )


	function DataTypeSub (|Message| Node, |SCBase| Parent, |Message| ErrPlace, |string| ForInterface, |SCModule|)
		if node.obj isa SCModule	// already processed.
			Return Compiler.program // OK
		
		scbase.CurrVisibility = false
		node.givearg
		
		|| it = .NeuClassSub( node, parent, ErrPlace, ForInterface )
			it.IsDataType = true
			it.ClassCollect
//			it.typenormal.isconst = true
// makes no sense.
		
			expect !(it.Properties) (it.Source, "Datatypes can’t have properties.")
					
			|| m = it.modul // to say it's already been processed...
			node.obj = M
			Return M
	
	
	function DataType (CollectFunc)
		return .datatypesub(node, name_space, errplace, nil)
	

	function NewStruct (CollectFunc)
		|| it = .NeuClassSub(node, name_space, errplace, nil)
			it.IsStruct = true
			it.classcollect
			return it.modul


	function NewCast (CollectFunc)
		expect (name_space isa SCClass)  (node, "'cast' only goes inside classes." )
		
		node[0].name = "function"
		|| NameNode = «Thg "operator_cast"»
		node[0].Next = NameNode
		
		return SCFunction.NewFunc( node, name_space, ErrPlace )
	

	function SCClass.DataTypePostLoad
		require .IsDataType and !.IsFunc
		|| node = .SourceClass
		|| s = .super
			.Size = s.Size
			if !.IsNotNumeric
				.TypeInfo = s.TypeInfo
				.defawlt := s.defawlt

		|| N		= .name.lowercase
		|| Td		= DataTypeCode.Types[n]
			|| t = *td
			require T != 255
	
			.size = T.bytesize
			.TypeInfo	= T
			.IsBuiltin	= true
			
			require T.isint and !.Signed
			|| s2		= t.CreateSignedStuff$
			.Signed		= s2.typenormal
			s2.Signed	= .typenormal
	
	
	function datatypecode.CreateSignedStuff (|scclass|)
		opt norefcounts
		|| s = .setsigned(!.issigned)
		for (c in datatypecode.types) (key)
			if (c == s)
				|| M = compiler.program.access[ key ]
				if M isa scmodule
					return m.cls
		

	function LoadSyntax (CollectFunc)
		|| name = node.name.UpperFirst
		|| AlreadyName = node[@thg] 		#require

		node.name = "function"
		AlreadyName.name = name + AlreadyName.name.UpperFirst

		Return SCFunction.NewFunc( node, name_space, ErrPlace )


	function StoreExtend (CollectFunc)
		Compiler.ExtendList <~ node
		node.obj = SCImport.curr
		Return Compiler.program


	function StoreExtendModule (CollectFunc)
		Compiler.ExtendModuleList <~ node
		node.obj = SCImport.curr
		Return Compiler.program


	function ExtendOneFunc (CollectFunc)
		Compiler.ExtendList <~ node
		node.obj = SCImport.curr
		if !SCImport.curr
			printline "C: $node"
			debugger

		|| dot = node.first
		|| name = dot[@thg, @name]
			|| emb = name.next
			check (emb != @prm) (emb, "Need space between bracket and name.")
			emb.remove
		return compiler.program


	function ProcessExtend (|Message| c, |bool| PreferClass)
		// OK now what?
		if (c == @tmp and "extend_module" or "extend")
			// can we remove this?
			.ProcessExtendOld(c, preferclass)
			return
			
		|| dot = c[@dot]
		|| name = Dot[@thg, @name]					#require
		|| M = Compiler.FindModuleMsg(name)			#require
		
		dot.clear
		dot.func = @thg
		|SCBase| B = M
		if name == @name		// it's a module
			PreferClass = false // whatever
		if (PreferClass and M.Cls)
			B = M.Cls
		name.func = @thg

		|| imp = c.obj as scimport
			imp.use
		  else
			B.project.use

		|| fn = scfunction.NewFuncSub(c, b, c)
		if fn != compiler.program and fn isa scfunction
			fn.tryadd(b)
	

	function SCFunction.TryAdd (|scbase| b)
		b.tryadd(.source, self, .name)
	

	function ProcessExtendOld (|Message| c, |bool| PreferClass)
		|| name = c[@thg]							#require
		|| arg  = c[@arg, -1]						#require
		|| M = Compiler.FindModulemsg(name)			#require
		
		|SCBase| B = M
		if (PreferClass and M.Cls)
			B = M.Cls

		|| imp = c.obj as scimport
			imp.use
		  else
			B.project.use

		B.Collect(arg, scbase.CurrVisibility, m.sourcearg)
	
	
	function DoOneNamedField (|message| c,  |string| name,  |string| datatype,  |int| n,  |message|)
		using c 
		|| src = "
		function ${c.name} (|$Datatype|)
			return .$name[$n]
		function ${c.name} (assigns:|$Datatype|)
			.$name[$n] = value
		".parse
		return src
	
	
	function SCClass.FindDecl (|string| name, |message|)
		opt norefcounts
		for l in .sourcearg
			if l == @decl
				if l.declname ~= name
					return l
	
	
	function ProcessAs (CollectFunc) // node, parent, errplace
		|| Name = node[@thg]					#require
		|| Cls = compiler[name]					#require
		if name_space.mustbe(scclass, node)
			name_space.processas = cls
		
		return compiler.program
	
	
	function GetFalse (CollectFunc)
		if name_space isa scclass
			name_space.false = node.NeedFirst
	
	function GetDefault (CollectFunc)
		if name_space isa scclass
			name_space.defawlt = node.NeedFirst
	
	function NamedPropertyFields (CollectFunc) // node, parent, errplace
		// not a great feature???
		// only galaxxies used this. we should remove
	/*
		|float[5]| Stats
		Fields (Stats) {
			Speed
			Jump
			Health
		}
		// creates
		function Speed (|float|) {
			return .fields[Speed]
		}
		function Speed (assigns:|float|) {
			.fields[Speed] = Value
		}
	*/
			
		|| Name 	= node[@bra][@thg]									#require
		|| decl 	= name_space|scclass|.FindDecl(name.name)			#require
		|| Type		= decl[@acc]										#require
		|| Arg		= node[@arg, 1]										#require
		|| DataType = Type[@Thg]										#require
		|| Cls		= compiler[datatype]								#require
		|| CountMsg = Type[@arr, 1][@num]								#require
		|| Consts	= «Arg »
		|int| Count = CountMsg.int
		|| Found	= 0
		
		
		for (c in arg)
			expect (!c.hasany and (c == @tmp)) (C)
			|| src = .DoOneNamedField(c, name.name, Cls.name, found)	#require
			|| getter = src.first
			|| setter = getter.next
			(src)
			
			consts <~ «rel
				«thg name.name + c.name »
				«opp "="»
				found
			»
			name_space.Collectone(getter, false)
			name_space.Collectone(setter, false)

			Found++

		
		expect (Count >= Found) (countmsg, "Too few fields specified")
		
		consts <~ «rel
			«Thg "kCount"»
			«opp "="»
			found
		»
		name_space.sourcearg <~ «tmp "constants", consts »
		node.remove
		return compiler.program
}


extend SCClass
	iterator Upwards
		|| Curr_ = self
		while (Curr_)
			yield Curr_
			Curr_ = Curr_.super

extend byte
	constants
		abc = 1
