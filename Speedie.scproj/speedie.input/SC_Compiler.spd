
/*
	Jeebox internals. By Theodore H. Smith...
*/

|SCClass|	Typef64
|SCClass|	Typefloat
|scclass|	Typehfloat
|SCClass|	TypeSaveable
|SCClass|	TypeInt
|SCClass|	TypeInt16
|SCClass|	TypeDate
|SCClass|	TypeInt64
|SCClass|	TypeuInt16
|SCClass|	TypeuInt
|SCClass|	TypeuInt64
|SCClass|	TypeString
|SCClass|	TypeStringZero
|SCClass|	TypeSyntax
|SCClass|	TypeBool
|SCClass|	TypeCharSet
|SCClass|	TypeByte
|scclass|	TypeCodePoint
|SCClass|	TypeObject
|SCClass|	TypeWrapper
|SCClass|	TypeArray
|SCClass|	TypeDictionary
|SCClass|	TypeFastString
|SCClass|	TypeJBClass
|scclass|	TypeTask
|SCClass|	TypeVec4
|SCClass|	TypeVec3
|SCClass|	TypeVec2
|SCClass|	TypeiVec4
|SCClass|	TypeiVec3
|SCClass|	TypeiVec2
|SCDecl|	TypeNil
|SCClass|	TypeVoid_
|SCDecl|	TypeVoid
|scdecl|	TypeVoidPtr
|SCDecl|	TrueBool
|SCDecl|	FalseBool


function Compiler.FindSpeedieRoot (|string|)
	|| paths = app.exepath.resolve.parent
	|| srch = "/Speedie/"
	|| found = paths.find(srch, 0, int.max, true)
		return paths[0, found + srch.length]
	return "/usr/local/speedie"
	

module Compiler {
linkage
	cpp_part Comp

|SCNode|					VisibleFuncs
|SCNode|					Interpreter

|File|						BaseProjectPath
|string|					OriginalInputPath
|File|						_BuildFolder
|String|					_Projects
|String|					_SpeedieProj
|File|						TempFolder
|SCFile|					InternalFile = SCFile.new(nil, SCImport(nil, true), -1)
|string|					ProjectName
|string|					ReportedName
|scimport|					Project
|scfunction|				MainFunc
|message|					ConfMsg
|dictionary|				InsecureWords
|[message]| 				TodoList

|Dictionary of SCFile|		Files = nil
|[SCImport]|				ImportedList
|Dictionary of SCImport|	ImportedNames = Dictionary.new


|SCModule|					program = InternalFile.Proj.Mod

|[SCClass]|					ClassList
|[SCModule]|				ModuleList
|[SCFunction]|				FuncList
|[SCFunction]|				ProtoTypes
|[scdecl]|					ActualSyxes

|Dictionary of SCNode|		ExportNames = Dictionary()
|dictionary of dictionary of macro|	AdjDicts = dictionary()

|SCFunction|				PrivateProperty
|SCFunction|				RefIncr
|SCFunction|				RefDecr
|SCFunction|				RefClear
|SCFunction|				RefDecrMulti
|SCFunction|				RefFreeIfDead
|SCFunction|				RefSafeDecr
|SCFunction|				RefSetRef

|SCFunction|				NewFunc
|SCFunction|				TernaryFunc
|SCFunction|				fnFastIsa
|SCFunction|				fnFastAs
|SCFunction|				fnAs
|SCFunction|				fnIsa
|SCFunction|				fnMustbe
|SCFunction|				fnOpMustBe

|[String]|					SyxArray
|Message|					ExtendList = message()
|Message|					ConstantsList = message()
|[scdecl]|					DeclConstants
|[scclass]|					TasksList
|[Message]|					TasksTodo
|[Message]|					ExtendModuleList
|[Message]|					API_List
|[SCFunction]|				API_Funcs
|Message|					API_Place

|SCModule|					DisamClasses
|SCModule|					DisamModules

|bool|						InPerry 
|bool|						HasMainFunc
|bool| 						InitedOK = true
|int|						stClasses
|int|						stFuncs
|int|						stReachedFunc
|int|						stReachedClass
|int|						stParseTime
|int|						stTotalSourceSize
|int|						stTotalFileCount
|int|						stParseTimeTotal
|int|						CurrStage
|SCFunction|				ClassListInitFunc


constants
	kTimeWidth = 19


function BuildFolder (|file|)
	opt norefcounts
	|| b = ._BuildFolder!
	if !B.Exists
		B.MakeDir
	return B!


function CompileAll (|bool|)
	require .stage("Compilation")
	.InitCompiler
	.ImportAll
	
	ErrorDelayer.ReturnErrors
	require .InitedOK
	
	if .Stage( "More constructors" )
		.BuildConstructors // constructors
	.CheckIsGoodLibrary

	if .Stage( "Stripping dead code" )
		.DeadStrip
	
	if (options.NilStrength > 0) and .Stage( "NilChecking" )
		.Timer( "NilChecking" )
		ArchonPurger.FixArchons
	
	require .Stage( "RefCounting" )
	.Timer( "RefCounting" )
	.DoRefAnalysis				// do actual refcounts.

	require .Stage( "String Correction" )
	PackMaker.AddAll
	StringCorrector.Correct
	
	if Options.ModePack
		.Timer( "Export Pack" )
		PackMaker.MakePack	
	
	if Options.ModeCpp
		.Timer( "Export Cpp" )
		Cpp_Export.ExportAllSource

	SCImport.ExportShaders

	require .Stage( "Finished" )
	.TimerSub("Parse", .stParseTimeTotal)
	.Timer( "" )
	return stderr.ok


function Projects (|String|)
	return ._projects init .findspeedieRoot


function SpeedieProj (|String|)
	return ._SpeedieProj init .projects["Speedie.scproj"]


function TestDate
	|int64| day  = 5662310400
	|int64| hour = 235929600
	|int64| min  = 3932160
	|int64| sec  = 64*1024
	if sec  != 1s
	if min  != 1mins
	if hour != 1hours
	if day  != 1days
	

function compiler.ReachedClassCount (|int|)
	opt norefcounts
	for C in compiler.classlist
		RZ += ((C.MyReacher) and c.isobject)


function FastString.AppendWidth (|string| s, |int| Width)
	self <~ s
	self <~ (' ', Width - s.length)


function Reached (|string| s, |bool|)
	flow off
	|| obj = self[s]
		return (obj.MyReacher)


function InitTypes
	TypeInt				= compiler["int"]
	TypeInt16			= compiler["int16"]
	TypeInt64			= compiler["int64"]
	TypeuInt			= compiler["uint"]
	TypeuInt16			= compiler["uint16"]
	TypeuInt64			= compiler["uint64"]
	Typef64				= compiler["f64"]
	Typehfloat			= compiler["hfloat"]
	Typefloat			= compiler["float"] 
	TypeBool			= compiler["bool"]
	TypeString			= compiler["string"]
	TypeStringZero		= compiler["stringzeroterminated"]	
	TypeByte			= compiler["byte"]
	TypeCodePoint		= compiler["codepoint"]
	TypeCharSet			= compiler["charset"]
	Typevec2			= compiler["vec2"]
	Typevec3			= compiler["vec3"]
	Typevec4			= compiler["vec4"]
	Typeivec2			= compiler["ivec2"]
	Typeivec3			= compiler["ivec3"]
	Typeivec4			= compiler["ivec4"]
	Typedate			= compiler["date"]
	TypeJBClass			= Compiler["classdata"]
	TypeTask			= Compiler["task"]
	TypeObject			= Compiler["object"]
	TypeSyntax			= Compiler["syntax"]
	TypeVoid_           = Compiler["_void"]
	TypeWrapper			= Compiler["dataobject"]
	TypeDictionary		= Compiler["dictionary"]
	TypeFastString		= Compiler["faststring"]
	TypeArray			= Compiler["array"]
	TypeSaveable		= Compiler["saveable"]
		
	require StdErr.ok
	TypeVoid_!.LinkedFrom = int.max //noice
	TypeStringZero!.DowngradeTo = TypeString
	typevoid = TypeVoid_!.TypeNormal
	TypeVoidPtr = typevoid!.GetAddress
	TypeString!.HasSubClass = true // compiler doesn't know about internal-subclasses of string.
	for s in .actualsyxes
		s.type = typesyntax! // sigh


function InitBasicStuff (|int|) // compiler.init
	opt norefcounts
	rz = stderr.errorcount
	if rz > 0
		stderr.LowerErrorsTo = ErrorSeverity.Warning
		compiler.InitedOK = false
	(Message).Restore
	.ModuleList <~ .program
	
	.InitTypes
	
	TypeNil   = .AddGlobalConst( "nil",   TypeObject!,   NilState.ActuallyNil )
	TrueBool  = .AddGlobalConst( "true",  TypeBool!,     NilState.real ||| NilState.trueValue )
	FalseBool = .AddGlobalConst( "false", TypeBool!,     NilState.real ||| NilState.falseValue )
	
	TrueBool!.exportposition = 1
	.AddGlobalConstNum( "__time_id__",  typeint!,  scimport.recent.timeid )
	.AddGlobalConstNum( "__now__",      typedate!, date.now )
	.AddGlobalConstNum( "__modified__", typedate!, scimport.recent)
	.AddGlobalConstNum( "π",            typef64! , "3.1415926535897932")
	.AddGlobalConstNum( "τ",            typef64! , "6.2831853071795864")
	if stderr.ErrorCount > rz
		compiler.InitedOK = false
		

function LoadTypeTest (|string| s, |scfunction|)
	opt norefcounts
	|| f = TypeObject![ s ]
	if f isa scfunction
		(f is TypeTest)
		return f


function InitBasicFuncs (|bool|)
	.RefSetRef		= .LoadRefFunc( "JB_SetRef" )
	.RefIncr		= .LoadRefFunc( "JB_Incr" )
	.RefDecr		= .LoadRefFunc( "JB_Decr" )
	.RefClear		= .LoadRefFunc( "JB_Clear" )
	.RefDecrMulti	= .LoadRefFunc( "JB_DecrMulti" )
	.RefFreeIfDead	= .LoadRefFunc( "JB_FreeIfDead" )
	.RefSafeDecr	= .LoadRefFunc( "JB_SafeDecr" )
	
	.NewFunc		= .FindFunction( "JB_New" )
	.TernaryFunc	= .FindFunction( "JB_Ternary" )
	.fnAs			= .LoadTypeTest( "operatoras" )
	.fnFastAs		= .LoadTypeTest( "operatorfast_as" )
	.fnFastIsa		= .LoadTypeTest( "operatorfast_isa" )
	.fnIsa			= .LoadTypeTest( "operatorisa" )
	.fnmustbe		= .LoadTypeTest( "mustbe" )
	.fnopmustbe		= .LoadTypeTest( "operatormustbe" )
	.PrivateProperty = .CreateFuncFromSource("function Private () {disabled `This property is private.`}")
	return StdErr.OK


function CreateFuncFromSource (|String| Src, |SCFunction|)
	|| msg	= src.ParseClean
		rz		= SCFunction.NewFunc( msg, nil, msg )|SCFunction|
		if rz
			rz.IsVisible = false


function Library (|file|)
	return .projects.filech("Library")


function Jeebox (|file|)
	return .Projects.filech("jeebox.scproj")


function Speedie (|file|)
	return .Projects.filech("Speedie.scproj")


function ImportLibs
	SCImport.STDLibTime = true
	SCImport.Importpath( "Library",		.Library,		1, true )
	SCImport.Importpath( "jeebox",		.Jeebox,		1, true )


function ImportProj
	SCImport.STDLibTime = false
	|| ToUse = (options.SingleFileInput.file, .BaseProjectPath!)(options.SingleFileInput)
	compiler.Project = SCImport.ImportPath( "",  ToUse,  0, false )
	expect compiler.Project ("No user-project found.")


function ImportAST
	opt norefcounts
	for rz in .ImportedList
		rz.PrepareAll


function ImportAll
	.Timer( "Read" )
	require .Stage( "Finding Files" )
	
	.ImportLibs
	.ImportProj
	.ImportAST
	if options.SelfReplacement
		VM_Builder.MakeTheVM

	require .Stage( "Import" )
	.Timer( "Import" )
	
	for L in SCImport.AllFiles
		L.Proj.use
		compiler.program.ImportFile( L )

	.Stage( "Initialising Compiler" )

	|| mark = .InitBasicStuff
	require .AddMain(mark)
		
	
	parser.using.Flags = MsgParseFlags.Inserted // noice
	scimport.noproj
	
	sctasks.CollectAll
	for c in .classlist
		C.TryAddToProject
	
	require .Stage( "Processing Delayed Imports" )
	for l in .ExtendList
		SCClass.ProcessExtend( l, true )

	for l in .ExtendModuleList
		SCClass.ProcessExtend( l, false )

	require .initbasicfuncs
	require .Stage( "Creating Class Hierarchy" )
		

	for c in .ClassList
		c.CreateBehaviour	// creates new classes, put before loadsuperclass
	
	.LoadSuperClasses
	
	for c in .ClassList
		c.GetDepth
	
	
	require stderr.ok
	
	.SortModulesAndClasses

	for c in .ClassList
		c.DataTypePostLoad
	
	require .Stage( "Savers and behaviours" )
	for c in .ClassList
		c.LoadSaver

	.DoSavers(0)

	for c in .ClassList
		c.ProcessBehaviours
	
	// ProcessBehaviours generates classes
	
	require stderr.ok
	for c in .ClassList
		c.LoadClassType
		c.ProcessInterfaces
	
	require .Stage( "Creating Class Allocators And Stuff" )
	for c in .ClassList
		c.ContainedTypeLoad

	require .Stage( "Parsing Class Properties" ) // just moved this... used to come after
	for c in .ClassList					  // handling function prototypes.
		c.CollectProperties
		require !TooManyErrors()


	for c in .ClassList					  // handling function prototypes.
		if c.isstruct
			c.GetStructDepth

	.SortModulesAndClasses	// need to re-sort array by depth


	for c in .ClassList
		c.CalculateSize


	for c in .ClassList: c.LoadConstructors
	
	require .Stage( "Collecting Constants" )
	.CollectConstants
	(Message).Restore
	scimport.noproj


	// we need decls for this.
	// can we move decls earlier?
	if .API_Place
		|| Proj = .API_Place[@thg]
			for m in .api_list
				sc_api.DelayedClassAPI(m, proj.name)

	.DoSavers(1)


	require .Stage( "Creating Class Exportnames" )
	for c in .ClassList: c.LoadExportName

	
	require .Stage( "Initialising Modules And More" )
	.LoadInitsAndMore


	scimport.noproj
	

	require .Stage( "Handling Function Prototypes" )
	for f in .ProtoTypes
		f.ProtoExportName
		f.FuncDecls
		f.MakeParamsReal
	scfunction.currfunc = nil // set in funcdecls

	require StdErr.OK
	

	.DoSavers(2)

	
	require .Stage( "Parsing Function Parameters" )
	for f in .FuncList
		f.FuncDecls
		f.LoadExportName
		require !TooManyErrors()
	scfunction.currfunc = nil


	|| fn = .XFunc("JB_App__Quit")
		fn.iskiller = true
	

	require .Stage( "A Bit More Stuff On Classes" )
	for c in .ClassList
		c.ExportName = c.StructName // minifier...
		c.AfterFuncsDecled //
	  

	require .Stage( "Even More Stuff On Classes" )
	for c in .ClassList
		c.AfterAfterFuncs


	require .Stage( "Collecting Globals" )
	for m in .ModuleList
		m.InitDecls
	for F in SCImport.AllFiles
		F.CollectGlobals Compiler.Program

	scimport.noproj
	(Message).Restore

	for m in .ModuleList
		if m != Compiler.program
			m.BaseDecls
		m.GlobalsFix
		|| c = m.cls
			c.RenameInterfaces

	for m in SortInitOrder(.ModuleList)
		m.DelayedInitFuncTransform
	.PostInitCodeCall
	
	.Stage( "Creating Exportnames For Function Prototypes" )
	for f in .FuncList
		|| p = f.ProtoDecl
			p.Name = f.ExportName
		  else
			f.AddConstructorReturn2
	
	.Stage( "Checking Iterators" )
	for c in .ClassList
		c.CheckIterator

	.Timer( "Transform" )
	.Stage( "Transforming Functions" )
	scfunction.TransformAll

	.Stage( "Building Function Link Map" )
	LinkMap.CollectAll
	scfunction.currfunc = nil
		

function LoadSuperClasses
	opt norefcounts
	for c in .ClassList
		c.LoadSuperclass
	for c in .classlist
		c.LoadSuperBehaviours


function LoadInitsAndMore
	opt norefcounts
	for m in .ModuleList
		m.Use
		m.LoadExportName
		m.LoadInitFunc


function PostInitCodeCall
	.program.initvarsarg <~ "initcode_()"~parse


function InitCompiler
	require (.Projects.fileCH("Library").mustexist) and stderr.ok
	scoperator.Init
	Cpp_Export.Init

	.files := Dictionary.new
	
	////////////////////////////////////////////////
	.TimerOutput <~ "\n"
	StringCorrector.CollectString(@str.msg, true)
	.CurrStage = 1
	SCGlobals.UniqueNum = 100
	////////////////////////////////////////////////
	
	if options.SingleFileInput
		if SpdProcess.parent
			._BuildFolder = compiler.originalinputpath.ScriptContainer.file
		  else
			._BuildFolder = .BaseProjectPath
	  else
		._BuildFolder = .BaseProjectPath![ "Build" + Compiler.VariantSuffix ]

	|| t = TransCompiler.ProjTmpPath.file!  /// Tmp/Speedie/Proj
	.TempFolder = t
	t.MakeEntirePath
	.GeneratedCppsFolder.makeEntirePath
	
	.CreateRoot
	.CreateDisambiguation
	SCImport.AllFiles <~ .InternalFile



function GeneratedCppsFolder (|File!|)
	// * For most projects (Galaxies), we build jb.cpp in the temp folder, when built from terminal.
	// * For xcode compiles, we use ExternalCompile, which creates a "Cpp" folder for the jb.cpp to be in
	//   keeping it nice and separate from the builds that we want to use.
		// * we COULD build straight from the temp-folder? I don't see why not...
	// * For self-replacement, well... we use the buildfolder, which is versioned: Build, BuildTest, BuildTest2. 
	
	// the question is, what happens to compiling speedie from xcode? :D
	// I guess it's considered "self-replacement". It's OK.

	if !Options.ExternalCompile
		return .TempFolder!
	if  Options.SelfReplacement
		return .BuildFolder!
	return .BaseProjectPath!["Cpp"]!



function CreateDisambiguation
	// classes.string, module.string, globals.whatever, etc.
	// make a module...

	.DisamClasses = SCModule.NewContainer("__classes__")
	.DisamModules = SCModule.newContainer("__modules__")


syntax access (|string| name, |SCClass|)
	cpp_part FindClassName
	return compiler.program.FindClass(name, nil)


syntax access (|Message| name, |SCClass|)
	if name
		return compiler.program.FindClassMsg( name, 0 )


function FindClassType (|message| n, |scdecl|)
	opt norefcounts
	|| m = SCModule.curr
	if !m
		m = compiler.program
	|| c = m.findclassmsg(n)
		return c.typenormal


function FindModuleMsg (|Message| where, |SCNodeFindMode| Mode=0, |SCModule|)
	return compiler.program.FindModulemsg(where, Mode)


function CreateRoot
	|| M = .InternalFile.Proj.Mod
	.program = M

	M.ExportName = "JB"
	M.Name = "main"
	M.parent = nil


function LoadRefFunc (|String| name, |SCFunction|)
	opt norefcounts
	|| o = .FindFunction(name)
		(o is Reffer)
		return o

		
function XFunc (|string| name, |message| m=nil, |SCFunction|)
	opt norefcounts
	|| fn = .ExportNames[name]
	if fn isa scfunction
		return fn
	if m
		if fn
			error (m, "This isn't a function")
		  else
			error (m, "Can't find this function")


function FindFunction (|string| Name, |SCFunction|)
	opt norefcounts
	|| o = compiler.program[ name ]
	if o isa SCFunction
		Return o
	
	error ( nil, "Can’t find function: " + name )


function scfunction.IsAllocOrNew (|bool|)
	return self is Constructor


function NewConst (|scdecl| d)
	d.nildeclared = nilstate.real
	d <~ scdeclinfo.Const ||| scdeclinfo.Global
	.DeclConstants <~ d
	

function DoRefAnalysis
	opt norefcounts
	|[message]| list // avoid reading same thing that we alter.
	for f in .FuncList
		if f.IsARealSpdFunc
			list.clear
			f.AnalyseRefs(list)
	scfunction.currfunc = nil


function scfunction.IsARealSpdFunc (|bool|)
	if .IsWrapper or .IsMacro
		return false
	scfunction.currfunc = self
	return true


function scfunction.CanBuildConstructor (|bool|)
	if (self is ConOrDes) and .IsARealSpdFunc
		return true


function BuildConstructors 
	opt norefcounts
	require stderr.ok
	for f in .FuncList
		if f.CanBuildConstructor
			f.BuildConstructorDestructor
		
	scfunction.currfunc = nil


function SortModulesAndClasses 
	.ModuleList.sort(ModulesSorter)
	.ClassList.sort(ClassSorter)
	

function ClassSorter (SorterComparer)
	return ModulesSorter(a|scclass|.modul, b|scclass|.modul)


function ModulesSorter (SorterComparer)
	opt norefcounts
	|| aa = a|scmodule|
	|| bb = b|scmodule|
	|| ca = aa.cls
	|| cb = bb.cls
	
	if !ca or !cb // a module
		if ca or cb
			return cb
		// could use initafter?
	  else
		|| tt = ca.basetype
		|| D = tt|int| - cb.basetype|int|
			return D < 0
		
		D = ca.depth|int| - cb.depth|int|
		if D
			return D < 0

		if tt == SCNodetype.struct 
			D = ca.StructContainerDepth|int| - cb.StructContainerDepth|int|
			if D
				return D < 0
		
	return aa.name < bb.name


function SCFunction.ReachedDetect
	opt norefcounts
	|| Base = Compiler.VisibleFuncs!
	
	if !.IsVisible	
		require options.MakeInterpreter and !.IsDisabled
		base = Compiler.Interpreter!
	
	.ReachFunc(base)
			

function CheckIsGoodLibrary
	if options.ProjectIsLibrary
		expect compiler.api_place ("No 'main' or 'export_api' found. Create 'export_api' to make this a library, create 'main' to make this an app.")


function InputFile (|File| Default, |String| s, |message| where,  |File|)
	opt norefcounts
	expect !(s contains "../") (where, "Insecure path")
	// find the "highest" file...
	|| c = SCImport.Curr
		|| found = c.Resources.ValueLower(s)
			return found
			
	|| best = int.max
	for (imp in .ImportedList)
		if (imp.depth < best)
			|| f = imp.Resources.ValueLower(s)
				rz = f
				best = imp.Depth
	if rz
		return rz

	rz = Compiler.BaseProjectPath![s]
	if (Default != nil)
		rz := default[s]
	if !rz.exists
		rz = nil


function AddGlobalConstNum (|string| name, |SCClass| c, |int64| value)
	.AddGlobalConstNum(name, c, value.render)

function AddGlobalConstNum (|string| name, |SCClass| c, |string| value)
	.AddGlobalConst(name, c).IsLookupOnly = @num + value

function AddGlobalConst (|string| name, |SCClass| c, |nilstate| dcl = NilState.real, |SCDecl|)
	|| d = SCDecl(c)
	(D is dataconst)
	d.NilDeclared = dcl
	d.IsLookupOnly = "" // it is lookuponly... but what for? "" i guess... whatever.
	d.Name = name
	d.default = «thg name »
	Compiler.program.TryAdd( nil, d, name )
	Return d


function MakeMainFunc (|message|)
	|| f = compiler.MainFunc 
		f.blindcasts = errorseverity.error // this for now.
		return f.sourcearg
	"Compiling as library."
	Options.ProjectisLibrary = true
	return .program.CollectStr( "main:\n" ).last				// mainproj.collect


function AddMain (|int| mark, |bool|)
	|| m = .MakeMainFunc()
	|| b = (Truebool, falsebool)(Options.ProjectisLibrary) 
	
	if m and .ConfMsg
		m.first = "app.configure = __AppConfString"~parse
	
	.program.TryAdd( nil, b, "__IS_LIBRARY__" )

	stderr.LowerErrorsTo = 0
	return mark == stderr.errorcount


syntax append (|message| m)
	.InternalFile.LiveAST <~ m


////  ////  ////  ////  ////  ////  ////  ////  ////  ////  ////  ////  ////  

|Date|			LastTime
|string|		LastTimeName
|FastString|	TimerOutput = FastString.new

function AppendCompilerTime (|string| s, |int| Durr)
	compiler.TimerOutput.appendwidth(s, compiler.kTimeWidth)
	if options.color
		compiler.TimerOutput <~ errorcolors.good
	compiler.TimerOutput.appenddurr(Durr)
	if options.color
		compiler.TimerOutput <~ errorcolors.normal
	compiler.TimerOutput <~ '\n'


function TimerSub (|string| s, |int| Durr)
	Durr -= .stParseTime
	.stParseTimeTotal += .stParseTime
	.stParseTime = 0
	.AppendCompilerTime(s, durr)


function Timer (|string| name)
	|| Curr = Date.Now
	if (.LastTime)
		.TimerSub( .LastTimeName, (Curr - .LastTime)|int| )

	if !name and !options.silent
		print .TimerOutput
	
	.LastTimeName = name
	.LastTime = Date.now


function Stage (|string| name, |bool|)
	require StdErr.OK
	if (Options.PrintStages)
		|| space = " "*(Compiler.CurrStage <= 9)
		" ${.CurrStage}$space  :: $name ::  "
	.CurrStage++
	return true


function @transcompiler.PrintProduct (|string| s)
	print s
	print " `"
	print compiler.ProductPath
	printline "`"


function IsTest (|bool|)
	return (App.fileName contains "Test")


function VariantSuffix (|string|)
	if (Options.SelfReplacement) and Options.Compile
		return "Test" + Options.Variant
	return Options.Variant


function AddSCProj (|string| Path, |string|)
	if (path.name contains '.')
		return path
	return path + ".scproj"


function FindProjNoSuffix (|string| Path, |string|)
	|| spd = path + ".spd"
	if spd.FileExists
		return spd
	return path + ".scproj"


function FindProject (|string| Path, |bool| error, |File|)
	|| p = .BaseProjectPath!.parent
	|| B = .FindProjectSub(p, path)
		return B
	|| A = .FindProjectSub(.projects, path)
		return A

	
helper FindProjectSub (|string| base, |string| Path, |File|)
	if (*Path == '/')
		return Path.FileThatExists
	
	|| First = Path
	|| SlashPos = Path.find('/')
		First = Path[0, SlashPos]
	first = .AddSCProj(first)
	
	if SlashPos
		First = First + Path[SlashPos...]

	rz = base.FileCh(First)
	if !rz.Exists
		rz = nil
}

