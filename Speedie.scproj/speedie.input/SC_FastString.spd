

extend_module scfunction
	function OptMe (|string| t)
		opt norefcounts
		|| s = "help$t!"


module FastStringOpts {

|| FSRemoved  = 0
|| StrRemoved = 0
|| InitedOK   = 0
|| VargCount  = 0

|SCFunction| FnByte
|SCFunction| FnGetResult 
|SCFunction| FnAppend 
|SCFunction| FnAppend4
|SCFunction| FnAppend6
|SCFunction| FnPlus 


function FSOptInit (|string| name, |message| s)
	opt norefcounts
	|| fn = Compiler.XFunc(name, s)
		fn.FSOpt = ++.VargCount
		
	
function Init (|message| s, |bool|)
	require .InitedOK == 0
	|| m = StdErr.Mark
	
	.FnByte = compiler.XFunc("JB_FS_AppendByte", s)
	.FnGetResult = compiler.XFunc("JB_FS_GetResult", s)
	.FnAppend = compiler.XFunc("JB_FS_AppendString", s)
	.FnAppend4 = compiler.XFunc("JB_Str_Append4", s)
	.FnAppend6 = compiler.XFunc("JB_Str_Append6", s)
	.FnPlus = compiler.XFunc("JB_Str_OperatorPlus", s)

	.FSOptInit("JB_FS_AppendLocalTime", s)			// 0
	.FSOptInit("JB_FS_AppendCString", s)			// 1
	.FSOptInit("JB_FS_AppendByte", s)				// 2
	.FSOptInit("JB_FS_AppendHex", s)				// 3
	.FSOptInit("JB_FS_AppendIntegerAsText", s)		// 4
	.FSOptInit("JB_FS_AppendString", s)				// 5
	.FSOptInit("JB_FS_AppendUTF8Char", s)			// 6
	.FSOptInit("JB_FS_AppendDoubleAsText", s)		// 7
	.FSOptInit("JB_Obj_Render", s)					// 8
	
	rz = m
	.InitedOK = 2 - rz


function Optimise (|message| s)
	opt norefcounts
	if .InitedOK != 1
		require .init(s)
	
	|| fn = s.MsgFunc
	|| prms = s.second							#require
	if fn == .FnAppend
		|| item = prms.last
		if item.msgfunc == .fnGetResult
			FastStringOpts.FS(s, item)
		  else
			FastStringOpts.StringToByte(item)
	  elseif fn == .FnGetResult
		.TryStringAppend(s)


function message.FirstPrmObj (|object|)
	opt norefcounts
	|| p = .last.first
		return p.obj


function TryStringAppend (|message| s)
	opt norefcounts
	// 3 to 6 items.
	// Removes faststrings which can be wasteful.
	
	|| desiredObj = s.firstprmobj
	|| s2 = s.uptoarg
	|| Count = 0
	|| p = s2
	while 
		p = p.prev$
		|| fn = p.MsgFunc 
		if fn == .FnAppend or .fnbyte
			require p.firstprmobj == desiredObj
			Count++
			require count <= 6
		  else
			require p == @decl and p.obj == desiredObj
			exit  // some kinda constructor actually just debug it
	// so... now that we constructed and appended it... now wht do wed o?
	// OK... so we found a few in row
	
	require count >= 2
	|| prms = s.second!
	prms.first.remove
	if count == 2
		s.become(.FnPlus!)
	  elseif count >= 3 and count <= 4
		s.become(.fnappend4!)
	  else	
		s.become(.fnappend6!)

	while
		|| n = p.next
		p.remove
		p = n
		if p==s2
			exit
		|| oof = p.last.last
		if oof == @char // damn! well it was from appendbyte. anyhow. Lets change it back.
			oof.func = @sstr
			oof.obj = typestring!.typenormal
			.StrRemoved-- 
		prms <~ oof
	
	if count&1
		prms.msg(@thg, "nil").obj = TypeNil



function FS (|Message| exp, |Message| GetResult)
	opt norefcounts
	|| fs2 = getresult.last.first!
	|| t2 = TypeOfExpr(fs2, nil)
	require t2 is compilercreated

	|| Place = t2.default!.UpToArg
	|| arg = place.parent
	require arg.expect(@arg)
	
	|| fs1 = getresult.prev!
	require fs1.func == @thg
	
	|| name2 = fs2.name
	for ch.flat in arg
		if ch isthing name2
			ch.name = fs1.name
			ch.obj = fs1.obj
	
	place.SafeRemove
	exp.SafeRemove
	.FSRemoved++


function StringToByte (|Message| str)
	opt norefcounts
	require (str == @str or @sstr or @back) and (str.name == 1)
	str.obj = typebyte!.typenormal

	str.parent!.obj = .fnbyte
	str.func = @char
	TypeOfChar(str, nil)
	.StrRemoved++
}

