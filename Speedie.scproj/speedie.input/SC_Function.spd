
/*
	Jeebox internals. By Theodore H. Smith...
*/

datatype DotUseType (uint)
	flags
		|DotUseType|
		Property
		Memory
	syntax is (|DotUseType| d, |bool|)
		return self == d


datatype FunctionType (uint)
	flags
		|FunctionType|
		Constructor
		Destructor
//		New
		Comparison
		Reffer
//		Alloc
		NewStruct
		TypeTest
		InitFunc
		Recursive
		EmptyConstructor
		VirtualCaller
		Behaviour
		NewNew
		ExpectsRealVars
		AlreadyExported
		ConOrDes = Constructor + Destructor
//		ConOrNew = Constructor + New
//		AllocOrNew = Alloc + New
	syntax is (|functiontype| t, |bool|)
		return self & t


class SCFunction (SCNode) {
linkage
	cpp_part		Func

|array? of SCNode|		LinkTo
|[SCDecl]|				Args
|SCClass?|				Cls
|String|				Description
|CppRefs?|				Refs
|object?|				CounterPart
|SCFunction?|			NextFunc
|¬µFunc?|				ASM
|SCDecl?|				ProtoDecl
|SCClass?|				ProtoType
|SCDecl?|				ReturnType
|scfunction--?|			DepthFinder
|macro?|				IsMacro
|uint16|				LinkDepth
|uint16|				TmpCounter
|uint16|				TableId
|uint|					AllocCode // some flags above 255!
|Byte|					MinOpt
|Byte|					IsAssigns
|byte|					IsCppInBuilt
|errorseverity|			BlindCasts
|bool| 					FlowDisabled
|bool|					IsExternalLib
|bool|					IsWrapper
|byte|					IsNilChecker
|nilstate|				NilSelf
|bool|					IsInline
|bool| 					IsKiller
|bool|					IsDisabled
|bool|					IsAPI
|bool|					NoRefCounts
|bool|					AutoGeneratedSaver
|bool|					HidesProperties // for property hiding
|byte| 					Badness



constructor (|Message?| msg = nil)
	Super.Constructor( msg )
	.linkto = nil
	if (msg)
		Compiler.stFuncs++
			


syntax equals (|string| name, |bool| Aware, |bool|)
	require (self)
	
	if .ExportName.syntaxequals( name, true )
		return true
	return .Name.syntaxequals( name, true )		// never needs !aware.


syntax is (|FunctionType| k, |bool|) // assumes ANY match. Asking "x is a+b", then a or b is enuf
	if self
		return .alloccode & k

syntax is (|FunctionType| k, assigns:|bool|)
	if value
		.alloccode |= k
	  else
		.alloccode &= ~k

function IsReal (|bool|)
	return (self != nil) and !.isMacro 


function Last (|SCFunction|)
	opt norefcounts
	rz = self
	while
		rz = rz.NextFunc #loop


function ParentName (|string|)
	opt norefcounts
	|| c = .cls
		return c.name
	|| Mod = .parent
	if mod isa SCModule
		if !mod.isimport
			return mod.name


render RenderParams (|bool| ForErrors=true)
	fs <~ '('
	|| sep = ""
	for a in .args
		if (a.source)
			fs <~ sep
			sep = ", "
			fs <~ a.source
	
	if !ForErrors and .ReturnType
		fs <~ sep
		.returntype.render(fs)
	
	fs <~ ')'


render RenderTitle (|bool| ForErrors=true)
	fs <~ .Name
	if .args or (!forerrors and .ReturnType)
		fs <~ " "
		.renderparams(forerrors, fs)


render RenderName
	|| pname = .parentname
		fs <~ pname
		fs <~ '.'
	fs <~ .Name


render Describe 
	fs <~ "function "
	fs <~ .Name
	fs <~ " "
	fs <~ .Source.second


Render
	|| it = .source
		return it.Render(fs_in)
	return .describe(fs_in)


function Message.TestFuncName (|bool|)
	opt norefcounts
	|| fn = .func
	expect (fn != @Func and @prm and @list) (self, "Need space between bracket and name.")
	expect (fn == @Thg)                     (self, "Doesn't follow 'function name (|Type| Name)'")
	return true


function ParseName (|Message| node, |bool|)
	opt norefcounts
	|| fType = node.name
	|| cname = node.first	#require
	cname.func = @thg
	.Name = cname.name
	
	if ftype == "helper"
		.NoAutoComplete = 2
	  elseif fType == "api"
		.isapi = true
	  elseif fType == "setter"
		.isassigns = 2
		.HidesProperties = true 
	  elseif ftype == "getter"
		.HidesProperties = true 

	if !.cls
		0	
	  elseif cname ~= "constructor"
		is Constructor
	  elseif cname ~= "destructor"
		is Destructor
	
	Return cname.TestFuncName


function ApparantArgCount (|int|)
	|| a = .args.length
	a = a - (.cls|bool|)
	a = a - (.isassigns)
	return a


function CheckNotBadName
	if (!.ApparantArgCount and .cls)
		|| W = .cls.NumericCount 
		if (W > 1) and .name.isswizzle(w)
			error (.source, "Can't use a swizzle-name (xyzw/rgba) on a vector-type!")


function FuncDecls 
	scfunction.currfunc = self
	|| P = .Source.second				#require
	if self is constructor
		.AddConstructorReturn(p)
	
	|| fc = p.first
		if (fc.func == @thg or @dot)
			.DeclsProtoTypeClass( fc )
	
	|| A = .SourceArg
	|| space = a.SCArg(self)
	
	if (P==@List or @Bra or @prm)
		p.Func = @prm
		.CollectDeclsParams( P, space )
			
	FuncStats[.args.length min 11]++ 

	if space and !.cls
		|| L = .parent|SCModule|
		if  (L isa SCModule)  and  (L.IsProperModule)
			L.AddModuleToFunc( space )

	if .AllocCode
		|| r = .ReturnType$
		if r == r.Type.TypeNormal
			r = r.copydecl
			.ReturnType = r
		r.AllocSource = .AllocCode



function @scfunction.TransformAll 
	opt norefcounts
	for f in compiler.FuncList
		require !TooManyErrors()
		f.Transform


function Transform ()
	opt norefcounts

	.CheckNotBadName
	require !.isMacro
	scfunction.CurrFunc = self
	scmodule.curr = .parent as scmodule
	.Badness = 0
	|| StillOK = StdErr.Mark

	|| n = .SourceArg						#require
	|| Space = n.SCArg( self )				#require

	if (.IsWrapper)
		space.ProcessLinkage( n, FuncLinkageTable )
	  else
		|| r_z = Tran_Result( self )
		Tran_All( self, n, space )
		if r_z
			Tran_ResultFinish( self, r_z, space )

	if !StillOK
		.Badness |= 1
	  else
		.CallSuperConstructor //hehe ü•∞

	CurrFunc = nil
	scmodule.curr = nil


function message.MacroFixSub (|SCDecl?| contains)
	opt norefcounts
	for s.flat in self
		if (s == @sthg and "...") and s.WithinType
			expect (contains) (self, "Container type needed for macro")
			s.replacewith(contains.writetype)			// cast to contained type!


function MacroFix (|SCDecl?| contains, |SCNode| name_space, |SCParamArray| Incoming, |scdecl|)
	|| Orig = incoming.exp				#debug_require
	|| R = incoming.CopyArgs
	orig.BecomeMacro(.ismacro!, r)
	orig.MacroFixSub(contains) 
	rz = TypeOfExpr(orig, name_space) 
	rz := typevoid!



function message.FailOrCopy (|message| p, |message|)
	if (self == @Thg)
		return .copy
	error (p, "Please simplify this expression")


function message.AssignsFix (|scfunction| f)
	|| RP   = .NiceParent
	|| RightSide = rp.Last! // in case of syntax_cast
	|| List = .last!
	|| Upon = .first!
	List <~ RightSide
	// a.b(c) = c

	list.func = @prm
	
	// what if... its a datatype? vec.width = 1 --> vec = vec.width(1)
	|| L = rp.last!
	L.remove
	|| c = f.cls
	if f.returntype and c and c.IsDataTypeOrFP
		using (self)
		rp.first = L // put it back
		rp.first = upon.FailOrCopy(rp)
	  else
		RP.Func = @Bra	


function ArgsMatch (|SCDecl| base, |SCNode| name_space, |SCParamArray| Incoming, |int| Options=0, |SCFunction|)
	opt norefcounts
	if !Options
		rz = .argsmatch1(base, name_Space, incoming, 0)
		if !rz
			rz = .argsmatch1(base, name_Space, incoming, kTypeCastAssigns)
	  else
		// just merge these two branches. Dont think we need opposite order really...
		.argsmatch1(base, name_Space, incoming, kTypeCastAssigns ||| Options)
		.argsmatch1(base, name_Space, incoming, Options)
		if !incoming.madeerror // backup
			error ( incoming.exp, "Wrong params to " + .RenderTitle )


function ArgsMatch1 (|SCDecl| base, |SCNode| name_space, |SCParamArray| Incoming, |int| Cast, |SCFunction|)
	opt norefcounts
	|| f = .ArgsMatch2( base, kTypeCastFalse ||| Cast, name_space, Incoming )
	|| macro = f			
	if !f.IsReal
		f = .ArgsMatch2( base, kTypeCastNumbers ||| Cast, name_space, Incoming )
		if f
			macro = f
		if !f.IsReal
			f = .ArgsMatch2( base, kTypeCastTrue ||| Cast, name_space, Incoming )

	if (f.IsReal and Incoming.IsAssigns)		// a.b = c --> (a.b(c))
		incoming.exp!.AssignsFix(f)
	if f
		Return f
	return macro


function uint.IsNormalMatch (|bool|)
	return (self == kSimpleMatch or kNumericMatch or kSuperClassMatch)


function ArgsMatch3 (|int| TypeCast,  |SCDecl| base,  |bool| ThisAlter,  |SCNode| name_space,  |SCParamArray| Incoming,  |int|)
	if ((.IsAssigns!=0) != Incoming.IsAssigns)
		require (TypeCast & kTypeCastassigns) and (!Incoming.IsAssigns)
	
	|| Pos = 0
	|| Result = kSimpleMatch
	|| SelfCast = Incoming.ignoreselfContain()
	TypeCast |= kNoBoolTypeCast ||| kTypeCastWantSuperDistance
	
	|| fin = .args.length
	|| fi = 0
	if  (self is constructor)  and  Incoming.ConstructorAsNew
		fi = 1
			
	while fi < fin
		|| FuncArg = .Args[fi]!
		|| PArg_Ch = Incoming[Pos]
		|| PArg_Type = TypeOfExpr( PArg_Ch, name_Space )
		if Base
			FuncArg = FuncArg.ContainedReplace(base, false)

		|| LArg_ch = (PArg_Ch, nil)(ThisAlter)
		|| Matched = FuncArg.TypeMatch( PArg_Type, TypeCast ||| SelfCast, LArg_ch )
		SelfCast = 0
		
		if (Matched != kNoMatch) and !((matched == kUseDefaultParams) and ThisAlter)
			if (Matched > result)
				result = Matched				// don't replace worse matches with better ones.
			  elseif ((Matched ||| Result) & kNeedsAddressOfButAlsoNeedsSuperMatch)
				result = kNeedsAddressOfButAlsoNeedsSuperMatch
					// handled bugs from overloading functions belonging to structs.
					// like struct.append(string) and struct.append(object) 
					// but its handled separately now!! I can remove this branch?
			pos++
			
		  elseif (!FuncArg.Default)
			if TypeCast & kTypeCastDescribeErrors
				.DescribeParamFail(incoming, fi)

			Return kNoMatch
			
		  elseif (ThisAlter)	// we need to put something in exp
			|| def = FuncArg.Default!.Copy
			Incoming.exp.last.InsertBefore( def, PArg_Ch )
			TypeOfExpr( def, Name_Space )

		  else
			Result = kUseDefaultParams
		fi++
	
	if Pos >= Incoming.Size
		Return result

	if (typecast & ktypeCastDescribeErrors) and !incoming.madeerror
		error (incoming.exp, "Too many params to " + .rendertitle)
		error (self.source,  "Function here:")


function HiderMatch (|bool| IsAssigns, |bool|)
	if self
		if .IsAssigns
			return IsAssigns
		 // elseif .HidesProperties
		//	return !IsAssigns


function DescribeParamFail (|SCParamArray| params, |int| bad)
	require !params.MadeError
	|| IsSelf = (bad==0) and params.isdot and params.IsNotModule
	|| P = params[bad]
		bad++
		|| str = ("Wrong self: ",  "Wrong param ($bad): ")(IsSelf)
		|| Type = TypeOfExpr(P, nil)
			str += Type.RenderTypeName
		  else
			str += "(Unknown Type)"
		error ( P, str )
	  else
		|| Num = bad - isself
		error ( params.exp, "Missing param $num: ${.args[bad]}" )
	error ( .Source, "to " + .RenderTitle )


function String.ArgsMatchError (|bool| TypeCast, |string|)
	if !TypeCast
		return self
// Useful hint
	return self + " (But none matched exactly. All needed a type-cast.)"


function SCParamArray.ArgsMatchError (|int| TypeCast, |SCFunction| f, |SCFunction| R, |SCFunction|)
	if !.madeerror
		error   (.Exp, "Multiple matching functions.".ArgsMatchError(TypeCast!=0) )
		error   (f.Source, "Candidate 1")
		error   (R.Source, "Candidate 2")


function int.IsSimpleOrPointerCast (|bool|)
	return (self == kSimpleMatch) or (self == kNumericMatch) or (self == kNeedsAddressOf)


function TryKeepBetter (|int|OldMatch, |SCFunction| f, |int| Match, |SCFunction|)
	if (OldMatch & kSuperClassMatch) and (Match.issimpleOrPointerCast)
		return f
	if (Match & kSuperClassMatch) and (OldMatch.issimpleOrPointerCast)
		return self
	if (OldMatch & kTypeCastBothWays) and !(Match & kTypeCastBothWays)
		return self
	if (Match & kTypeCastBothWays) and !(OldMatch & kTypeCastBothWays)
		return f
	if (OldMatch == kSimpleMatch) and (Match != kSimpleMatch)
		return self
	
	if (Match == kSimpleMatch) and (OldMatch != kSimpleMatch)
		return f
		
	if (OldMatch < Match)
		return self
	if (Match < OldMatch)
		return f


function ArgsMatch2 (|SCDecl| base, |int| TypeCast, |SCNode| name_space, |SCParamArray| Incoming, |SCFunction|)
	|| NeedsAlter = false
	|| OldMatch = 0
	|| Result
	|| Missing 

	for f in self
		if f.isMacro
			Missing = f
			continue
		
		|| Match = f.ArgsMatch3( TypeCast, base, false, name_space, Incoming )
			if (Result)
				|| CanKeepBetter = result.TryKeepBetter(OldMatch, f, Match)
				if (!CanKeepBetter)
					return incoming.ArgsMatchError(TypeCast, f, result)
				Result = CanKeepBetter
			
			if (Match & kNeeds) or (Match == kUseDefaultParams)
				NeedsAlter = Match
			
			Result := f
			OldMatch = Match

	if (NeedsAlter)
		Incoming.Exp.Last!.Func = @prm
		Result!.Argsmatch3( TypeCast, base, true, name_space, Incoming )

	if Result
		return Result
	return missing


function FLookup (assigns:|SCNode|)
	if (Value isa SCClass)
		.Cls = Value
		.parent = value.Modul
	  else
		.parent = Value.ProjectFix
	
	if scimport.curr
		.Project = SCImport.Curr
		return 

	|| S = .Source
		|| f = S.SCFile
			.Project = f.Proj


function CreateTypeCast (|SCDecl| MyType, |Message| exp, |int| Loss=kCastedMatch, |int|)
	if !exp
		Return kNeedsTypeCast
	expect  (!.isdisabled)  (exp, .description)

	while (exp == @bra)
		exp.obj = .ReturnType
		exp = exp.first!
		if exp == @arg // unbra fail.
			exp = exp.parent!
			exit // we really want args to be statement-exprs by themself

	|| Using = exp.SyntaxUsing
	|| cst = .IsSimpleCast
		// if (s)
		// ->
		// if (s|bool|)
		
		cst = cst.Copy
		exp.ReplaceWith( cst )
		cst.First!.ReplaceWith( exp )

	  else
		cst = (@thg + .ExportName).wrapwith(@func)  // JB_Str_Exists(obj)
		exp.Next = cst
		cst.msg(@prm) <~ exp
		if MyType.IsNormalStruct
			exp.GetAddressOf(MyType)
		cst.Last!.Obj = self

	cst.obj = .ReturnType

	Return loss


function DeclsPrototypeClass (|Message| ch0)
	opt norefcounts
	|| p = .parent as scmodule											#require
	|| fpType = p.FindClassMsg(ch0)										#require

	|message| Route
	if !fptype.funcproto
		|| task = fptype.modul.FindClass("interface", nil, scnode.DontGoUp)
			fpType = task
			route = fptype.modul.parent.Route("interface")
			
		|| task_proto = fptype.modul.findclass("prototype", nil, scnode.DontGoUp)
			fptype = task_proto
	
	.DeclsProtoCleanup(fpType, ch0, false, false, Route)
	.DeclsProtoTypeAdd(fpType)


function scnode.Route (|string| name, |message|)
	opt norefcounts
	rz = @dot.msg(name)
	|| curr = rz
	while self
		|| next = .parent|scmodule|
		if !next or (next == compiler.program) or next.IsImport
			curr <~ (@thg, .name)
			exit
		
		curr = curr.msg(@dot, .name)
		self = next
	

/*
dot "d"
	dot "c"
		dot "b"
			thg "a"
*/

function scdecl.CouldUpgradeToReal (|bool|)
	return .typesuffers and !.nilstated


function MakeParamsReal // for cpp funcs...
	opt norefcounts
	for (a in .args) (i)
		if a.CouldUpgradeToReal
			.args[i] = a.DefaultToReal
	|| r = .ReturnType
		if r.CouldUpgradeToReal
			.returntype = r.DefaultToReal


function CollectReturnAsReal (|bool|)
	if .isallocornew and Options.NilTestAllocNeverFails
		return true


setter IsCppInBuilt (|int|)
	if value and !.IsCppInBuilt
		.MakeParamsReal
	.IsCppInBuilt = Value


function DeclsPrototypeInterface (|Message| ch0, |SCClass| fpType, |bool| late)
	opt norefcounts
	.DeclsProtoCleanup(fpType, ch0, true, late)
	if !late
		.DeclsProtoTypeAdd(fpType)


function DeclsProtoTypeAdd (|SCClass| fpType, |scdecl|)
	|| Dcl = SCDecl(fpType)
	dcl.IsLookupOnly = self
	dcl.Name = .Name
	(dcl is const)					// lets kill da hoe
	(dcl is Global)					// kill! kill!
	dcl.NilDeclared = nilstate.real
	.ProtoDecl = dcl
	if (.Cls)
		.parent!.TryAdd( .Source, Dcl, .Name )
	return dcl


function DeclsProtoCleanup (|SCClass| fpType, |Message| ch0, |bool| AssumeSelf, |bool| late, |message| Route=nil)
	|| Proto = fpType.FuncProto										#expect (ch0, "This isn't a prototype!")
	|| fProtoParams = Proto.Source[ @prm, 1 ]						#require
	|| p = ch0.Parent!

	p.Func = @prm

	using (ch0)
		fProtoParams.CopyAllInto( p )
	
	if route
		|| nxt = ch0.next
		|| first = nxt.first
		if first.next isthing "self"
			first!.replacewith(route)
		
	ch0.Remove
	
	|| c = .cls														#require
	if late
		p.first.remove // ooof
	
	if (!AssumeSelf)
		|| d    = p[@decl]
		|| ch   = D[@nil]											#require
		|| decl = ExtractDecl( ch, nil, declmode.ProtoParam )		#expect p
		expect (decl matches c.TypeNormal)	   ( self, "Receiver must be same class as first param in function prototype." )
		d.Remove


function IsSimpleCast (|Message|)
	opt norefcounts
	expect .Source
	
	|| found = .Source.last(@arg).first
	require found and found.IsLast and (found IsTmp "return")

	found = found.first
	require (found.IsLast) and (found == @Type) and (found.first isThing "self")

	Return found


function EqualOrMoreSpecific (|SCFunction| f, |bool|)
	opt norefcounts
	require self and f
	require ((f.ReturnType)|bool| == (.ReturnType)|bool|)
	require (f.args.length == .args.length)

	|| r = f.ReturnType
		require r matches .ReturnType!
	
	for (a in .args) (i)
		require (f.args[i]! matches a)
	
	Return true


function CheckReturnValue (|Message| msg)
	|| c = msg.first
	
	if (!c)
		check (!.ReturnType) (msg, "Need to specify a return value")
		return

	expect ( c.IsOnlyChild ) ( msg, "Can‚Äôt return multiple values" )
	
	if !.ReturnType and (c == "nil") and (c==@thg or @ques) // auto-generated in many places :)
		c.Remove
		return
	
	|| FoundReturnType = TypeOfExpr( c, msg.MsgArg )
	if (FoundReturnType == TypeVoid)
		FoundReturnType = nil

	|| r = .ReturnType
		expect FoundReturnType (msg, "Has no return type.")
		
		if (FoundReturnType == TypeNil) and (r.CantBeNilInCpp)  // OK so what if we can‚Äôt return nil?
			|| def = r.CreateDefault(c)
				c.ReplaceWith(def)
			  else
				error (msg, "Can't return this")
		  else
			r.ExpectMatch( FoundReturnType, kTypeCastTrue, c )
	  else
		check (!FoundReturnType) ( msg, "This function has no return value." )


function Message.SelfUsedForProperty (|int|)
	opt norefcounts
	|| R = .parent
	require r and .func == @dot  and  r.func == @rel
	if .first IsThing "self"
		if .DotType
			return 1 + (r.second.name != "=")



function CheckConstructorAndDestructor (|Message| root, |bool| IsConstructor)
	opt norefcounts
	require !.Badness
	|| Supper = .cls!.super
	|| GotSuperConstructor = false
	if supper
		GotSuperConstructor  =  Supper == typeobject  or  (typetask == supper.parent or supper)
	|| NoNesting = "This should be at the function root. (not nested)."
	
	for dot.flat in root
		if dot == @func
			|| prms = dot.last!
			|| fn = (prms.obj as scfunction)!
			if fn is constructor and prms.first!.obj|scdecl| is self // super.constructor...
				GotSuperConstructor = true
				check (dot in root) (dot, NoNesting)
				
		|| UsedAtAll = dot.SelfUsedForProperty
			|| t = TypeOfExpr(dot, nil)
				|| IsSet = UsedAtAll == 1
				if !t.IsNormalObject
					0
				  elseif (IsConstructor)
					check (GotSuperConstructor)				(dot, "Can't access properties before calling super.constructor")
					ifn dot.isfirst and IsSet				// failed:  .obj = value
						check (t is PropertyWasConstructed)	(dot, "Object property was read before set")
					check (t isnt PropertyWasConstructed)	(dot, "Can‚Äôt set object property twice during a constructor.")
					check (dot.parent in root)				(dot, NoNesting)
				  else
					check (dot.islast or !IsSet)			(dot, "Can‚Äôt set object properties during a destructor.")
				if (IsConstructor)
					(t is PropertyWasConstructed)
	

function FillInMissingConstructorDefaults (|Message| root, |Message| AfterHere)
	// fillindefaultconstructor, fillconstructordefaults, defaultconstructors, fillinconstructor
	opt norefcounts
	|| cls = .cls$
	|| oof = .ConstructorLinePlace
	using (oof)
	
	for (d.backwards in cls.Properties)
		if d isnt PropertyWasConstructed
			|| Made = .NewDefaultRel( oof, d )
			root.InsertAfter( made, AfterHere )
	
	while cls
		for (d in cls.Properties)
			(d isnt PropertyWasConstructed)
		cls = cls.super
				


function ConstructorLinePlace (|message|)
	opt norefcounts
	|| s = .Source
		if s.HasPosition
			return s
	|| c = .cls
		return c.source


function CanCompare (|SCDecl|Against, |bool|)
	opt norefcounts
	for (f in self)
		|| arg = f.args[ 1 ]!
		if (against matches arg)
			return true


function ParamlessConstructor (|SCFunction|)
	opt norefcounts
	for (f in self)
		|| prm = f.source[@prm, 1]
		|| last = prm.last
		if !last
			return f
		if last == @decl and last == 1
			return f


function TranStrings
	|| S = .SourceArg
	if (S and !.IsWrapper)
		SCFunction.Tran_Strings( S.parent!, self )


function message.IsParentConCall (|scfunction|)
	opt norefcounts
	require (self == @func)
	|| f = .MsgFunc
	if f and f is ConOrDes
		return f


function scclass.RealSuper (|scclass|)
	opt norefcounts
	|| s = .super
		return s.realclass


function scclass.RealClass (|scclass|)
	opt norefcounts
	real self
	|| s = self
	while s and s.IsRole
		s = s.super
	return s! // roles always come from real classes


function CountCallsToParentAlloc (|Message| root, |message|)
	opt norefcounts
	|| FoundCount = 0
	|| c = .cls!
	for (curr in root)
		|| f = curr.IsParentConCall
			|| fcls = f.cls
			expect  (f.cls == c.realsuper or c.super)   (curr, "Function should belong to parent class, but doesn't.")
			rz := curr
			FoundCount++
			expect  (FoundCount < 2)   (curr, "Multiple calls to parent constructor/destructor not allowed.")

		


function Borked (|bool|)
	return .Badness & 128



function Message.ExpectParamsTransform (|int| P, |message| errnode, |string| Type = "", |Message|)
	using (errnode)
	nil self
	|| L = self
	|| On = L
	if Type != "warn"
		Type = "expect"
	
	if (!L)
		On = @thg + "nil"
	  elseif (L == @list or @bra or @prm)
		L.Func = @prm
		on = L.first
	  else
		L = nil


	|| l2 = L
	if (L != @prm)
		l2 = @prm.msg
		l2 <~ L
	|| tmp = @dot + ("syntax" + Type)
	tmp <~ on
	tmp <~ l2
	
	L = tmp 
	L.Position = P
	return L


function FixCnj (|Message| exp)
	using (exp)
	.FixCnjSub(exp)


function FixCnjSub (|Message| exp) {
	if exp == @ARel					// x$ --> x#require
		exp.become(@TRel)
		exp <~ (@opp, "require")
	
	// get the name (it's important)
	|| ch = exp.first!
	|| name = ch.Next!.Name
	|| CreatesError = (name == "expect" or "check")
	|| DoesReturn =   (name != "loop" and "check")
	
	ifn (CreatesError or (name == "debug_require" or "require" or "continue" or "loop"))
		error (exp, "Must be: 'require/expect/continue/loop' .")
		ch.name = "require"
		name = "require"		// just make autocomplete more reliable.
		// or else we leave dangling @trels
	
	// lets fix it, if its in a rel, (it shouldn't be)
	// || x = a #require   -->   || x = (a #require)
	|| nxt = ch.next!
	if (ch == @Rel) and (exp in @arg or @Decl) and (ch.second!.name == "=")
		expect  (ch.first!.IsAssignable)   (exp, "Use brackets here, like this: ‚Äú($ch) #${name}‚Äù")
		
		exp.ReplaceWith( ch )
		
		|| RightSide = ch.Last!
		|| bra = @bra.msg
		RightSide.ReplaceWith( bra )
		bra <~ RightSide
		bra.WrapWith( exp )
		bra.ReplaceWith( bra.first! )
	
	if name == "require" // unneeded? "cant" doesnt seem to need it?
		nxt.Name = "return"
		name = "return"
		
	// helpfully replace the exp.
	ch = exp.first!
	ch.Remove
	exp.ReplaceWith( ch )
	
	// x = (a #require)			-->		x = a, if (!x) {return}
	//
	//  (a #require)			-->		if (!a)   {return}
	//  (!a #require)			-->		if (a)	  {return}
	//
	// if (a() #require) {code}	-->		|| tmp = a(), if (!tmp) {return}, {code}
	// (a() #require).Func		-->		|| tmp = a(), if (!tmp) {return}, tmp.Func
	// if (a #require) {code}	-->		if (!a) {return}, {code}
	// (a #require).Func		-->		if (!a) {return}, a.Func
	
	|Message|	Thg
	|Message|	pp
	|Message|	RemoveMe
	|bool|		UsePrev
	if (ch isbrel "++") and (ch in @arg) and (ch.first == @thg) {
		// ++ch #require // just an opt.
		// Actually I didn't implement the general case yet :) haha.
		Thg = @thg + ch.first!.name
		pp = ch
		
	} else {
		pp = ch.NiceParent!
		|| Done = false
		if ((ch.UnBra == @thg)) or ((pp == @arg) and !CreatesError)
			thg = ch.copy!
			if (pp == @arg)
				RemoveMe = ch // i think so...
			pp = ch.ParentPoint!
			UsePrev = true
			Done = 1
		  elseif (pp.IsSetRel and pp.first == @thg)			
			// || word = (a.b[c] #require)
			|| IsDecl = (pp in @Decl)
			if isdecl or (name != "loop")
				Done = 1
				Thg = @Thg + pp.first!.name
				if IsDecl
					pp = pp.Parent!
			
		if !Done
			// func( item isa SyxItem #require ) -->
			// || tmp_318 = (item isa SyxItem)
			// if !tmp_318 { return }
			// func( tmp_318 )
			
			pp = SCFunction.TempMoveOut( ch )!
			Thg = @thg + pp.DeclName!.Name
	}
	
	// || tmp = func()
	//	  -->
	// || tmp = func()
	// if (!tmp) {
	//	 .SyntaxExpect(x, y), return
	// }
	// || x = tmp
	
	
	|| arg = @arg.msg
	if (CreatesError)
		|| L = exp.first.Next!
		if (name != "expected")
			L = L.ExpectParamsTransform( exp.Position, exp )
		  else
			error (exp)
		arg <~ L

	
	if (name == "debug_require")
		arg <~ (@tmp, "debugger")

	if (name == "continue") and pp.WithinLoop( .SourceArg )
		arg <~ (@tmp, "continue")
		
	  elseif (name == "loop") and pp.WithinLoop( .SourceArg )
		arg <~ (@tmp, "exit")
		
	  elseif (DoesReturn)
		arg.msg(@tmp, "return") <~ (@ques,"nil")
	
	thg = thg!.Negate	
	|| if_ = @tmp + "if"
	if_ <~ thg
	if_ <~ arg
	
	if (UsePrev)
		pp.Prev = if_
	  else
		pp.Next = if_
	

	RemoveMe.Remove
}

	
function RegType (|datatypecode|)
	if self
		return .returntype.regtype


function scdecl.MarkAsRefAltered 
	opt norefcounts
	(self is altered)
	if self is typeimprove
		|| orig = .islookuponly
		if orig isa scdecl
			(orig is altered)



function Self (|scdecl|)
	opt norefcounts
	return .args[0]



function NewDefaultRel (|message| place, |SCDecl| d, |Message|)
	// .bla = X
	require !d.IsCArray				// we actually need to clear it!
	
	|| def = d.CreateDefault(place)
	return NeweqRel( d.DeclToDot(.self), def )


iterator
	|| F = self
	while (F)
		yield F
		F = F.NextFunc



module {
||				DisabledPoints = 0
|SCFunction|	CurrFunc
|int[12]|		FuncStats


function NewMacro (CollectFunc)
	return SCFunction.NewFunc( node, name_space, errplace )


function scfunction.MakeProtoClassName (|string| start, |string|)
	|| name = start
	
	|scnode--| p = .parent
	while p
		if p isa SCModule
			|scclass--| CurrCls = p.cls #loop
			name = currcls.name + "_" + name
		p = p.parent
	
	if !name.find('_')
		name = "FP_" + name
	return name


function scfunction.ProtoExportName
	opt norefcounts
	|| cls = .prototype
	
	if cls and !cls.cppclass
		cls.cppclass = .MakeProtoClassName(cls.name)

	
function NewProtoType (CollectFunc)
	return NewProtoTypeSub(node, name_space, ErrPlace)


function NewProtoTypeSub (|Message| node, |SCNode!| parent, |Message| ErrPlace, |string| ForInterface="", |SCModule|)
	if parent isa scclass
		if !ForInterface
			node.NormaliseFunc(parent)
		parent = parent.modul|scclass|
	  else
		require parent.ExpectModule(node)
		
	|| f = NewFunc( node, parent, ErrPlace )|SCFunction|		#require
	Compiler.FuncList.Pop
	
	|| Using = node.SyntaxUsing
	|| tmp = @tmp + "datatype"
	tmp <~ (@thg, f.Name)
	tmp <~ node.last
	
	|| modul = SCClass.DataTypeSub( tmp, parent, node, ForInterface, SCNodetype.funcproto )
		|| clss = modul.Cls!
		clss.BaseType = SCNodeType.funcproto
		clss.IsBuiltin = false		// datatype sets it to true.
		clss.FuncProto = f
		f.ProtoType = clss
		Compiler.ProtoTypes <~ f
	
		parent.TryAdd(node, modul, modul.Name)		
	
		if !ForInterface
			modul = compiler.program
	
	Return modul



function NeuSyx (CollectFunc)
	|| Using = node.syntaxusing 
	|| NewNode = Tran_Syx( node )
		rz = SCFunction.NewHelper( NewNode, name_space, ErrPlace )



function Tran_AfterRel (|Message| msg, |SCNode| name_space, |message| side, |SCDecl|)
	|| exp = msg.first!
	if msg == "!"
		|| ty = TypeOfExpr( exp, name_space )				#require
		return ty.MakeReal

	expect (msg == "--" or "++") (msg)
	
	
	|| P = msg.parent
	Using (exp)
	|message| exp_copy
	if exp != @thg
		exp_copy = exp.copy			// needed before get type :(
									// or else we can't do array.size++

	|| Type = TypeOfExpr( exp, name_space )					#require
	if type.PointerCount > 0
		return type.CheckMath(msg)

	|| numc = Type.type.NumericCount
	if !Type.type.IsObject  and  !type.hiderfunc  and  numc <= 1
		return type

	|message| R
	if numc or type.hiderfunc
		R = NewRel(exp, @num + "1", msg.name[0, 1])
	  else
		|| name = ("next", "prev")(msg == "++")
		R = @dot + name
		r <~ exp
		r <~ @emb


// X++ --> X = X.next,  ("arl" "++" ("thg" "x")) -> rel(thg("x")  opp("=")  dot("next" thg("x") lst() ))
	if !exp_copy
		exp_copy = exp.copy
	msg.become(@rel)
	msg <~ exp_copy
	msg <~ (@opp, "=")
	msg <~ R
	msg.obj = nil
	
	return TypeOfExpr( msg, name_space ) // why aren't i returning this? :/
	// y = x++
	// y = x
	// y = ++x --> x = x.next, y = x



function message.FixMultiArr
	opt norefcounts
	for item in self
		|| kkey = item.first			//   [(a,b,c):x]  -->  [a:x, b:x, c:x]
		if kkey == @list
			|| val = kkey.next
				while (|| c = kkey.first)
					|| i2 = @item.msg
					i2 <~ c
					i2 <~ val.copy
					item.prev = i2
			item.remove


function Tran_Log (TranFunc)
	ignore
		log abc
		// -->
		platform.log(abc)
	using (node)
		|| f = node.first
		node <~ (@Thg, "platform")			// this seems better... than tran_print
		node.msg(@prm) <~ f					// probably tranprint should use this instead.
		node.func = @dot					// like Platform.print, Platform.printline, Platform.printerror
	TypeOfExpr( node, name_space )			// Platform.log


function AlterPostCond (|Message?| PostCond, |Message?| IterPostCond, |message| NodeSrc, |Message|)
	opt norefcounts
	if !IterPostCond
		Return PostCond
	
	IterPostCond = IterPostCond.copy(nodesrc)
	if (!PostCond)
		Return IterPostCond

	return NewRel( ¬´Bra, postcond ¬ª, ¬´bra, IterPostCond ¬ª, "or" )


function ArgToFunc (|string| NewName, |Message| Params, |Message| arg,  |Message|)
	rz = @tmp + "function"
	rz <~ (@thg, newname)

	if (params == @prm)
		rz <~ params

	  elseif (params == @thg)	// prototype
		rz.msg(@bra) <~ params 

	  else
		debugger// whatever...

	rz <~ arg
	rz.position = arg.position


//function Message.FindOwningLoop (|message| top, |Message|)
//	opt norefcounts // using the new try syntax would be good here.
//	for P.up in self
//		require (P != top)
//		if (P == @tmp) and (P == "while" or "for")
//			return P


function Tran_NotAllowed (TranFunc) // "continue"
	opt norefcounts
	if !node.tmptype
		error (node)


function Tran_Debugger (TranFunc) {
	|| ch = node.first
	if !ch
		node.name = "debugger"
		node.tmptype = asmtmp.kdebugger
		return
	
	expect ((node == "debugger") and (!ch.next)) (node)

	using (node)
		ExpandToBool(ch, name_space)
		// why cant I use negate?
		node.first!.Negate
		node.Name = "if"
		|| dbg = node.msg(@arg).msg(@tmp, "debugger")
		dbg.tmptype = asmtmp.kdebugger
	
	Tran_If(fn, node, name_space)

	// "Apple... I think I've heard of that name. Do they eat computers?"
	// I think It's better to forget society.
}


function Tran_DoAt (TranFunc)
	|| ch = node.first
	using (node)
		node.become(@func)
		node.msg(@thg, "DebugAt")
		node.msg(@prm) <~ ch
	TypeOfExpr(node, name_Space)

/*
decl 
	emb 
	rel 
		thg "fs"
		opp "="
		func 
			thg "faststring"
			prm 
*/

 
//function message.Tran_FS
//	macros.fs.clean
//	.BecomeMacro(macros.FS)


function Tran_Ifn (TranFunc)
	|| f = node.NeedFirst
		node.name = "if"
		f.Negate
		tran_if(fn, node, name_space)


function SCNode.LateAddTempory (|string| type, |string| name1, |message| Value, |message| err, |string|)
	|| name = UniqueTmpVar(compiler.program, name1)
	TypeOfExpr(Value, self)
	|| msg = MakeDecl(type, name, Value, scdeclinfo.body)
	|| D = TypeOfExpr(msg, self)$
	(d is dataconst) = false
	.Source <~ msg
	.TryAdd( err, D, name )
	return name


function scdecl.IsConstOf (|scdecl| b, |bool|)
	opt norefcounts
	
	// Needs a "constant preservation" system.
	// basically... takes: (kPositiveInt==1) and return "the false-bool".
	// typeofrel, etc needs to be changed... just ints, and bools maybe strings is enough for now.
	// (typeofbrel is already altered!)

	require self is const
	if self == b
		return true
	return .default$.Obj==b


|| OnceCount = 0
function Tran_Once (TranFunc)
	// once: "abc" --> if !globaltmp: "abc"
	|| arg = node[@arg]$ // needs arg... don't embed statements! cozz it sucksssss
	require arg.expectlast
	
	using (node)
		node.name = "if"
		|| obj = compiler.program.lateAddTempory( "bool",  "once"+(++OnceCount).render, @thg + "false", node )

		|| rel = @rel+""
		rel <~ (@thg, obj)
		rel <~ (@opp, "=")
		rel <~ (@thg, "true")
		arg.first = rel
		|| brel = @brel + "!"
		brel <~ (@thg, obj)
		node.first = brel
		
	tran_if(fn, node, name_space)
  

function Tran_If (TranFunc) 
	node.TmpType = asmtmp.kIf // for the ASM
	Tran_IfSub(node, name_space)


function message.Blocks (|SCBlockage|)
	if self
		return .TAG & SCBlockage.Bits


function message.Blocks (assigns:|int|)
	.TAG = (.TAG & ~SCBlockage.bits) ||| Value


function Tran_IfSub (|message| node, |SCNode| name_space) 
	opt norefcounts
	|| cond = node.NeedFirst						#require
	|| arg = cond.next
		require arg.expect(@arg)
	  else
		arg = @arg.msg
		if node == "if"
			arg <~ (@tmp, "debugger")				// better than debugat
		cond.next = arg
	
	|| SubTest = arg.next
		expect (SubTest isTmp "elseif" or "else")  ( SubTest )
		SubTest.ExpectLast
		
		if SubTest == "elseif"
			subtest.tmptype = asmtmp.kelseIf		// for the ASM
			Tran_IfSub(SubTest, name_Space)
		  else // "else" branch
			|| ElseArg = SubTest.first
				check (ElseArg ~!= "if")    (ElseArg, "Use 'elseif' instead.")
			SubTest[@arg]
	
	name_space = arg.scarg(name_space) #require
	using (node)	
	cond = ExpandToBool( cond, name_space )
	if !cond
		0 //
	  elseif cond.IsAlwaysFalse
		cond.ElseNeverFires
	  else
		cond.NeedBra
		if cond.first == @arg // if a.b? --> if ({||x=a.b, rejoin x}), fails in c cos if ({}) is bad
			cond.wrapwith(@bra).obj = cond.obj 
		Tran_Isa(node, name_space)


function message.ElseNeverFires // self == cond
	opt norefcounts
	|| arg = .next
	|| after = arg.next
		
	if !after
		|| p = .parent
			p.saferemove
		return
	if arg == @arg
		arg.clear
		arg.TAG |= SCBlockage.Return // blocks!
	.NeedBra


function Tran_Else (TranFunc) 
	opt norefcounts
	
	|| p = node.parent
	expect (p == @tmp and "if" or "elseif") (node, "This must be in an 'if' block.")


function Tran_Deprecate (TranFunc)
	// deprecate (msg, "error")
				// -->
	// msg.Syntaxdeprecate((test), "error")
	
	|| stuff = node.needfirst						#require
	require stuff.expectlast

	if stuff != @list and @bra
		stuff = stuff.wrapwith(@list)

	using (node)
		stuff.func = @prm
		node.become(@bra)
		|| Dot = node.msg(@dot, "SyntaxDeprecate")
		Dot <~ stuff.first
		Dot <~ stuff

	TypeOfExpr(node, name_space)


function Tran_Fails (TranFunc)
	expect (fn) (node, "Only use this on functions")
	node.TmpType = asmtmp.kfail
	fn.Badness |= 128
	expect (!node.islast) (node, "Put 'borks' before some code.") 



//function TranFuncDummy (TranFunc) {
//	// nothing
//}

function Tran_Visible (TranFunc)
	expect (fn) (node, "Only use this on functions")
	fn.LoadVisibility( node )


function Tran_Return (TranFunc)  // exitter
	expect (fn) (node, "Only use this on functions")
	if node.tmptype == asmtmp.kreturn
		debugat
	node.tmptype = asmtmp.kreturn
	
	if !node.islast
		expect (fn isnt ConOrDes)   (node, "You can‚Äôt return in a constructor or destructor")
	fn.CheckReturnValue( node )
	node.LastInBlock(SCBlockage.Return)
	node.CheckNotInStateExpr(fn.SourceArg)


function message.CheckNotInStateExpr (|message| top)
	opt norefcounts
	|| node = self
	while node and node != top
		check (!node.IsStatementExpr) (self, "Statement expressions don't allow: " + .name)
		node = node.parent


function Tran_Rejoin (TranFunc)  // exitter
	node.tmptype = asmtmp.kRejoin
	|| p = node.first
	if p == @arg
		|| arg = p.AsArg
		expect (arg and arg.IsStatementExpr) (node, "Can't use this here.")
		|| n = p.next
		expect !n (node, "Blocks should end with 'rejoin'")
//	node.LastInBlock(0) // makes no sense
	

function NewCppWrapper (CollectFunc)
	|| name = node[@thg]
	|| prm = name.Next$
	expect (prm.islast) (prm)
	
	using name
	|| thg = @thg + name!.name
	if node == "cpp_inbuilt"
		thg = thg.WrapWith(@bra)
	|| IsNothing = node == "cpp_nothing"
	|| IsLib	 = node == "cpp_libwrapper"
	node.name = "function"
	node.msg(@Arg).msg(@Tmp, "cpp_wrapper") <~ thg

	rz = SCFunction.NewFunc( node, name_space, ErrPlace )
	if rz isa SCFunction
		rz.noautocomplete = 1
		if isnothing
			rz.IsCppInBuilt = 2
		  elseif node == "cpp_inbuilt"
			rz.IsCppInBuilt = 1
		rz.IsExternalLib = islib
		rz.MakeParamsReal


function NewHider (CollectFunc)
	expect (name_space isa SCClass) (errplace, "Must go in a class") // move this tow here sets .hidesproperties
	return SCFunction.NewFunc( node, name_space, ErrPlace )


function NewHelper (CollectFunc)
	if !node.name.IsLower
		deprecate (node, "Helpers need lowercase names")
	return SCFunction.NewFunc( node, name_space, ErrPlace )


function message.NeedsPreprocess (|bool|)
	opt norefcounts
	if self == @TRel or self IsARel "$"
		return true
	if self == @tmp
		return .name == "using" or "expect" or "require" or "debug_require" or "warn" or "error" or "check" or "loop"

	require (self == @rel)
	|| L = .first
	if (L == @rel) and (L.next == "or")
		return (L.second == "=") and (.last.second == "=")



function SCFunction.PreProcessExpects
	|[Message]| list = nil
	
	for ch.flat in .SourceArg
		if ch.NeedsPreprocess
			list := array.new
			list <~ ch
	require list!=nil
	
	for ch in list
		if ch == @Trel or @Arel
			.FixCnj( ch )
		  elseif ch == @rel
			RelSetOrExpansion(ch)
		  elseif ch != "using"
			Tran_Expect(self, ch, nil)
		
	for ch in list
		if ch == "timetest"
			ch.name = "using"
			|| w = ch.first
			w := ch.msg(@str, "Time")
			w.needbra
		  elseif ch=="using"
			tran_using(self, ch, nil)



function message.NormaliseFunc (|scclass| AddSelf = nil, |message|)
	opt norefcounts
	|| name = self[@thg]$
	using (name)
	|| prm = name.next
	if prm == @arg
		prm = @prm.msg
		name.next = prm
	  elseif !prm
		prm = .msg(@prm)
	  else
		|| fn = prm.func
		expect (fn == @bra or @list or @prm) (prm)
		prm.Func = @prm
	if (addself)
		|| d = prm.first
		ifn (d == @decl) and (d.second isthing "self")
			d = @decl.msg
			d <~ (@thg, addself.name)
			d <~ (@thg, "self")
			prm.first = d
	rz = prm.next
	if rz
		rz.expect(@arg)
	  else
		rz = .msg(@arg)
	

function message.SlidePositions (|int| add)
	opt norefcounts
	for s.flat in self
		if s.position >= 0
			s.position += add



function scfunction.Cleanupfunc (|message| s)
	|| n = s.name
	using s
	|| cls = .cls!.isnormalobject
	if s ~= "constructor" or "destructor"
		s.name = "function"
		s.first = @thg + n
	  elseif s ~= "render"
		if Tran_Render(s, cls)
			s.name = "behaviour"
	if s.isbehaviour and cls
		scbehaviour.Tran_Behaviour(s, cls)
		cls.FillInterFaceIn(self, true)


function message.mainfix2
	|| m = .MainFix
		.become(m)


function scfunction.UpdateSourceSub (|message| src, |bool|)
	opt norefcounts
	if src ~= @tmp and "main"
		src.mainfix2

	|| f = src.first$
	if f == @dot
		f.func = @thg
		f.clear
	rz = stderr.ok				// awesome! dont delete this!
	.init_sub(src, nil)
	rz = stderr.ok 
	if rz
		.FuncDecls
		.Transform
		stderr.clear			// lol


function scfunction.SetBlindCasts (|SCNode| name_space)
	opt norefcounts
	if name_space
		|| p = name_space.project
			.BlindCasts	= p.blindcast
	  else
		|| c = scimport.curr
			.BlindCasts	= c.blindcast


function scfunction.Init_Sub (|message| node,  |SCNode| name_space)
	|| arg = node.NormaliseFunc
	node.obj = self
	if name_space
		if node != "iterator"
			Compiler.FuncList <~ self
		.FLookup = name_space  // sets as a module even if parent is a class
		.refs = name_space.SpaceModule$.defaultrefs
		scfunction.currfunc = self
	
	.ParseName( node )
	using ErrorDelayer // not a terrible error but still an error 
		.PreProcessExpects
		.TranStrings
	.PreRead(arg)
	.SetBlindCasts(name_space)
	
	if (node == "macro")
		.MakeMacro(arg)
			


function scfunction.MakeMacro (|message| arg)
	opt norefcounts
	|| C = arg.first
	|| prm = arg.prev
	check (C and !C.next) (self, "Macros must be one line!")
	check !(prm.HasAny)   ("Macros don't directly state arguments.")
	.ismacro = macro(C)



function NewFuncSub (|message| node, |SCNode| name_space, |scfunction|)
	|| fn = SCFunction(node)
	fn.init_sub(node, name_space)
	return fn


function NewFunc (CollectFunc)
	require node
	|| name = node.first			   #expect (node, "No function name found.")
	if name == @Dot
		return SCClass.ExtendOneFunc(node, nil, ErrPlace)
	return NewFuncSub(node, name_Space)	


function NewConstructor (CollectFunc)
	node.name = "function"
	using (node)
	node.first = @Thg+ "Constructor"
	return SCFunction.NewFunc( node, name_space, ErrPlace )


function NewDestructor (CollectFunc)
	if name_space isa scclass
		expect !(name_space.IsRole) (node, "destructors aren't allowed on roles")
		node.name = "function"
		using node
			node.first = @Thg+ "Destructor"
		return SCFunction.NewFunc( node, name_space, ErrPlace )


function message.MainFix (|message|)
	|| prms = self.first
	if !prms
		prms = .GiveArg
		prms <~ "hello world"

	.name = "function"
	|| fn_src = "function app.Main (|ErrorInt|,) {cpp_name JB_Main, visible true}".ParseClean
	|| src_arg = fn_src.Last!
	
	|| fn = prms.func
	|message| inc_arg
	if fn == @list or @bra
		inc_arg = prms.next(@arg)
		fn = @prm
	  else
		inc_arg = self[@arg]

	if inc_arg
		if fn == @prm
			src_arg.InsertMainArgs(prms)

		fn_src <~ inc_arg
		inc_Arg.expectlast

		src_arg.Remove
		inc_arg.TakeAllFrom( src_arg )
		return fn_Src


function NeuMain (CollectFunc)
	expect  (name_space == compiler.program)  (node, "Can‚Äôt have main inside here.")
	|| fn_src = node.mainfix
		Compiler.HasMainFunc = true
		|| m = compiler.Project!.mod
		rz = SCFunction.NewFunc( fn_Src, m, ErrPlace )
		if rz isa scmodule // sigh. Not ideal.
			compiler.MainFunc = scclass.ProcessExtend(fn_Src, false, m)
			fn_src.remove



function NeuLibrary (CollectFunc)
	error (node, "Can‚Äôt use this")
	Options.ProjectisLibrary = true // better than omitting main. more... specific.
									// but what if someone includes a library?
	return NeuMain(node, name_space, errplace)
	// library {} -->

}

}


