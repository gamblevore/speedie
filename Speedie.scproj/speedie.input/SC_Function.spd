
/*
	Jeebox internals. By Theodore H. Smith...
*/


flags
	kIsConstructor
	kIsDestructor
	kIsNew
	kIsProperty
	kIsComparison
	kIsReffer
	kIsLayer
	kIsAlloc
	kIsNewStruct
	kIsTypeTest
	kDestructorNotFromLocalRefs
	kIsInitFunc
	kIsMemory
	kIsVirtualCaller
	kIsRecursive
	kIsEmptyConstructor



class SCFunction (SCBase) {
linkage
	cpp_part		Func

|[SCDecl]|				Args
|SCClass|				Cls
|String|				Disabled
|CppRefs|				Refs
|dictionary of SCBase|	LinkTo
|object|				CounterPart
|SCFunction|			NextFunc
|µFunc|					ASM
|SCDecl|				ProtoDecl
|SCClass|				ProtoType
|SCDecl|				ReturnType
|string|				Description
|scfunction--|			DepthFinder
|uint16|				Depth
|uint16|				TmpCounter
|uint16|				AllocCode // some flags above 255!
|Byte|					MinOpt
|Byte|					IsAssigns
|byte|					IsCppInBuilt
|errorseverity|			BlindCasts
|bool| 					FlowDisabled
|bool|					IsExternalLib
|bool|					IsWrapper
|bool|					IsNilChecker
|bool|					IsInline
|bool| 					IsKiller
|bool|					IsAPI
|bool|					NoRefCounts
|bool|					AutoGeneratedSaver
|bool|					IsMacro
|bool|					ExternalOnly // for property hiding
|bool| 					IsOK



constructor (|Message| msg = nil)
	Super.Constructor( msg )
	if (msg)
		Compiler.stFuncs++
			


syntax equals (|string| name, |bool| Aware, |bool|)
	require (self)
	
	if .ExportName.syntaxequals( name, true )
		return true
	return .Name.syntaxequals( name, true )		// never needs !aware.


operator isa (|int| Code, |bool|)
	return ( .AllocCode & Code )


function IsReal (|bool|)
	return (self != nil) and !.isMacro 


function Last (|SCFunction|)
	opt norefcounts
	rz = self
	while
		rz = rz.NextFunc #loop


function ParentName (|string|)
	if (.cls)
		return .cls.name
	|| Mod = .lookup
	if mod isa SCModule
		require !mod.isimport
		return mod.name


render RenderParams (|bool| ForErrors=true)
	fs <~ '('
	|| sep = ""
	for a in .args
		if (a.source)
			fs <~ sep
			sep = ", "
			fs <~ a.source
	
	try
		need !ForErrors and .ReturnType
		fs <~ sep
		.returntype.render(fs)
	
	fs <~ ')'


render RenderTitle (|bool| ForErrors=true)
	fs <~ .Name
	if .args or (!forerrors and .ReturnType)
		fs <~ " "
		.renderparams(forerrors, fs)


render RenderName
	|| pname = .parentname
		fs <~ pname
		fs <~ '.'
	fs <~ .Name


render Describe 
	fs <~ "function "
	fs <~ .Name
	fs <~ " "
	fs <~ .Source[1]


Render
	|| it = .source
		return it.Render(fs_in)
	return .describe(fs_in)


function Message.TestFuncName (|bool|)
	|| fn = .func
	expect (fn != @Func and @prm and @list) (self, "Need space between bracket and name.")
	expect (fn == @Thg)                     (self, "Doesn't follow 'function name (|Type| Name)'")
	return true


function ParseName (|Message| cName, |bool|)
	cname.func = @thg
	.Name = cname.name
	if .cls
		if cname ~= "constructor"
			.AllocCode = kIsConstructor
			.IsInline = true
		  elseif cname ~= "destructor"
			.AllocCode = kIsDestructor
	
	Return cname.TestFuncName


function ApparantArgCount (|int|)
	|| a = .args.length
	a = a - (.cls|bool|)
	a = a - (.isassigns)
	return a


function CheckNotBadName
	if (!.ApparantArgCount and .cls)
		|| W = .cls.NumericCount 
		if (W > 1) and .name.isswizzle(w)
			error (.source, "Can't use a swizzle-name (xyzw/rgba) on a vector-type!")


function FuncDecls 
	|| P = .Source[1]		#require
	|| fc = p.first
	
	if (fc == @thg)
		.DeclsProtoType( fc )
	
	|| A = .SourceArg
	|| space = (A.scarg( self ), nil)(a)
	
	if P == @arg
		P = «prm »
	
	if (P==@List or @Bra or @prm)
		p.Func = @prm
		.Args = CollectDecls( P, self, space )
		FuncStats[.args.length min 11]++ 

	if !space
		0
	  elseif .cls
		.cls.AddSelfToFunc( space )
	  else
		|| L = .lookup|SCModule|
		if (L isa SCModule)  and  (L.IsProperModule)
			L.AddModuleToFunc( space )

	if (.AllocCode) and (.ReturnType)
		.ReturnType = .ReturnType.Copy // no difference, returntypes are never borrowed.
		.ReturnType.AllocSource = .AllocCode


function Disablerizer (|bool|)
	return .disabled


function AfterGotClasses
	|| S = .Source
	|| ClassName = S[0][0].Nyme					#expect S
	|| ClassObj = Compiler[ ClassName, S ]
		.FLookup = ClassObj
		ClassObj.TryAddBase( S, self )


function TranDebugInsert
	|| d = compiler.debuginsert			#require
	|| m = .sourcearg				
	using (d)
		if (self isa kIsConstructor)
			m.last = d.copy
		  else
			m.first = d.copy


function Transform ()
	opt norefcounts

	require !.isMacro
	CurrFunc = self
	|| StillOK = StdErr.Mark

	|| n = .SourceArg
	|| Space = n.SCArg( self )

	if (.IsWrapper)
		space.ProcessLinkage( n, FuncLinkageTable )
	  else
		.TranDebugInsert
		|| r_z = Tran_Result( self )
		Tran_All( self, n, space )
		if r_z
			Tran_ResultFinish( self, r_z, space )

	.isok = StillOK
	CurrFunc = nil


function Message.ParamNum (|int|)
	if self == @thg
		if self == "self":			return 0
		if .name[0] == '_'
			if .length == 1:		return 1
			if stderr.ok:			return .int
	return -1


function MacroFix (|SCDecl| contains, |SCBase| name_space, |SCParamArray| Incoming, |scdecl|)
	debugger .IsMacro
	|| msg		= incoming.exp
	|| Using	= msg.syntaxusing 
	|| cpy		= .SourceArg.first.copy(msg)
	|| oof		= cpy.flatten
	|| SizeShift= (0, 1)(.cls)

	// make sure each incoming para is used.
	|int| IncomingParams = incoming.size
	IncomingParams -= incoming.IsAssigns|int|
	IncomingParams = IncomingParams.bits
	
	for s in oof
		|| Num = s.ParamNum - SizeShift
		if num < incoming.size and num >= 0
			incomingparams[num]=false // wow!
		
		if (Num >= incoming.size)
			error (.sourcearg.first,	"This missing-function:")
			error (msg,					"doesn't match this incoming function." )
			exit

		  elseif (Num >= 0)
			s.replacewith(incoming[num].copy)

		  elseif (s == @sdot)
			s.Func = @dot
			incomingparams[0] = false
			s.first = incoming[0]						// "self"

		  elseif (s == @sthg and "...")
			if s.istype
				s.replacewith(contains.writetype)			// cast to contained type!
			  elseif s.parent.IsContainer
				for i in incoming.size|int|
					if IncomingParams[i]
						IncomingParams[i] = false
						s.prev = incoming[i].copy
				s.remove
		  elseif contains and (s == @type)
			|| dest = s.last
			if (dest == @emb)
				dest.replacewith(contains.writetype)	// cast to contained type!
	
	if IncomingParams
		error (incoming.exp,	"Some params not used.")
		error (self,			"For this macro.")
	  else 
		msg.SafeReplaceWith(Cpy)
		rz = TypeOfExpr(cpy, name_space) 
		rz := typevoid

	
function Message.MacroFixCount (|int|)
	opt norefcounts
	|| Found = 0
	for (s.flat in self)
		if (s == @sthg) and (s.parent.IsContainer) // oop
			return -111111
		|| Num = s.ParamNum
		if (num >= 0)
			Found |= 1<<num
		if (s == @sdot)
			Found |= 1
	return Found.Countbits


function scfunction.MacroGet (|scparamarray| paramsarray, |scfunction| prev, |bool|)
	opt norefcounts
	|| M = .sourcearg.MacroFixCount
	if m != -111111	and  paramsarray.macrosize != M
		return false
	if prev
		error (self, "Multiple macros match?")
		error (prev, "Multiple macros match?")
	
	return true


function message.FailOrCopy (|message| p, |message|)
	if (self == @Thg)
		return .copy
	error (p, "Please simplify this expression")


function message.AssignsFix (|scfunction| f)
	|| RP   = .NiceParent
	debug_Require (RP == @Rel)
	|| RightSide = rp.Last // in case of syntax_cast
	debug_Require (RightSide.obj)
	|| List = .last
	|| Upon = .first
	List <~ RightSide
	// a.b(c) = c

	list.func = @prm
	
	// what if... its a datatype? vec.width = 1 --> vec = vec.width(1)
	|| L = rp.last
	L.remove
	if f.returntype and f.cls and f.Cls.isdatatype 
		using (self)
		rp.first = L // put it back
		rp.first = upon.FailOrCopy(rp)
	  else
		RP.Func = @Bra	


function ArgsMatch (|SCDecl| base, |SCBase| name_space, |SCParamArray| Incoming, |SCFunction|)
	opt norefcounts
	for i in 2
		|| Assigns = (kTypeCastAssigns, 0)(i)
		|| f = .ArgsMatchSub( base, kTypeCastFalse (|) Assigns, name_space, Incoming )			
		ifn f.IsReal
			f = .ArgsMatchSub( base, kTypeCastNumbers (|) Assigns, name_space, Incoming )
			ifn f.IsReal
				f = .ArgsMatchSub( base, kTypeCastTrue (|) Assigns, name_space, Incoming )
	
		if (f.IsReal and Incoming.IsAssigns)		// a.b = c --> (a.b(c))
			incoming.exp.AssignsFix(f)
		
		if f
			Return f


function uint.IsNormalMatch (|bool|)
	return (self == kSimpleMatch or kNumericMatch or kSuperClassMatch)


function ArgsMatchTwo (|int| TypeCast,  |SCDecl| base,  |bool| ThisAlter,  |SCBase| name_space,  |SCParamArray| Incoming,  |int|)
	
	if ((.IsAssigns!=0) != Incoming.IsAssigns)
		require (TypeCast & kTypeCastassigns) and (!Incoming.IsAssigns)

	|| Pos = 0
	|| Result = kSimpleMatch
	TypeCast |= kNoBoolTypeCast (|) Incoming.IgnoreSelf (|) kTypeCastWantSuperDistance
	

	for (FuncArg in .Args) (fi)
		|| PArg_Ch   = Incoming[Pos]
		|| PArg_Type = TypeOfExprMaybeNil( PArg_Ch, name_Space )
		expect (FuncArg.type) (.Source)

		if Base
			FuncArg = FuncArg.ContainedReplace(base, false)

		|| LArg_ch = (PArg_Ch,nil)(ThisAlter)
		|| Matched = FuncArg.Match( PArg_Type, TypeCast, LArg_ch )
		TypeCast  &= ~kTypeCastIgnoreContained

		if (Matched != kNoMatch) and !((matched == kUseDefaultParams) and ThisAlter)
			if (Matched > result)
				result = Matched				// don't replace worse matches with better ones.
			  elseif ((Matched (|) Result) & kNeedsAddressOfButAlsoNeedsSuperMatch)
				result = kNeedsAddressOfButAlsoNeedsSuperMatch // handle bugs from overloading functions belonging to structs.
					// like struct.append(string) and struct.append(object) 
			pos++
			
		  elseif (!FuncArg.Default)
			expect !ThisAlter
			Return kNoMatch
			
		  elseif (ThisAlter)	// we need to put something in exp
			|| def = FuncArg.Default.Copy
			Incoming.exp.last.InsertBefore( def, PArg_Ch )
			TypeOfExpr( def, Name_Space )

		  else
			Result = kUseDefaultParams
	
	if Pos >= Incoming.Size
		Return result



function String.ArgsMatchError (|bool| TypeCast, |string|)
	if !TypeCast
		return self
// Useful hint
	return self + " (But none matched exactly. All needed a type-cast.)"


function SCParamArray.ArgsMatchError (|int| TypeCast, |SCFunction| f, |SCFunction| R, |SCFunction|)
	if !.madeerror
		error   (.Exp, "Multiple matching functions.".ArgsMatchError(TypeCast!=0) )
		error   (f.Source, "Candidate 1")
		error   (R.Source, "Candidate 2")


function int.IsSimpleOrPointerCast (|bool|)
	return (self == kSimpleMatch) or (self == kNumericMatch) or (self == kNeedsAddressOf)


function TryKeepBetter (|int|OldMatch, |SCFunction| f, |int| Match, |SCFunction|)
	if (OldMatch & kSuperClassMatch) and (Match.issimpleOrPointerCast)
		return f
	if (Match & kSuperClassMatch) and (OldMatch.issimpleOrPointerCast)
		return self
	if (OldMatch & kTypeCastBothWays) and !(Match & kTypeCastBothWays)
		return self
	if (Match & kTypeCastBothWays) and !(OldMatch & kTypeCastBothWays)
		return f
	if (OldMatch == kSimpleMatch) and (Match != kSimpleMatch)
		return self
	
	if (Match == kSimpleMatch) and (OldMatch != kSimpleMatch)
		return f
		
	if (OldMatch < Match)
		return self
	if (Match < OldMatch)
		return f


function ArgsMatchSub (|SCDecl| base, |int| TypeCast, |SCBase| name_space, |SCParamArray| Incoming, |SCFunction|)
	|| NeedsAlter = false
	|| OldMatch = 0
	|| Result
	|| Missing 

	for f in self
		if f.isMacro
			Missing = f
			continue
		
		
		|| Match = f.ArgsMatchTwo( TypeCast, base, false, name_space, Incoming )
		ifn Match
			continue

		if (Result)
			|| CanKeepBetter = result.TryKeepBetter(OldMatch, f, Match)
			if (!CanKeepBetter)
				return incoming.ArgsMatchError(TypeCast, f, result)
			Result = CanKeepBetter
		
		if (Match & kNeeds) or (Match == kUseDefaultParams)
			NeedsAlter = Match
		
		Result := f
		OldMatch = Match

	
	if (NeedsAlter)
		Incoming.Exp.Last.Func = @prm
		Result.Argsmatchtwo( TypeCast, base, true, name_space, Incoming )

	return result ?? missing


function FLookup (assigns:|SCBase|)
	if (Value isa SCClass)
		.Cls = Value
		.lookup = .Cls.Modul
	  else
		.lookup = Value.ProjectFix
	
	if scimport.curr
		.Project = scimport.curr
	  elseif (.Source)
		|| f = .Source.SCFile
		if f != nil
			.Project = f.Proj


function CreateTypeCast (|SCDecl| MyType, |Message| exp, |int| Loss=kCastedMatch, |int|) {
	if !exp
		Return kNeedsTypeCast
	expect  (!.Disablerizer)  (exp, .Disabled)


	while (exp == @bra)
		exp.obj = .ReturnType
		exp = exp.first
		if exp == @arg // unbra fail.
			exp = exp.parent
			exit // we really want args to be statement-exprs by themself


	|| Using = exp.syntaxusing 
	|| cst = .IsSimpleCast
		// if (s)
		// ->
		// if (s|bool|)
		
		cst = cst.Copy
		exp.ReplaceWith( cst )
		cst.First.ReplaceWith( exp )

	  else
		cst = «func, «thg .ExportName »»  // JB_Str_Exists(obj)
		exp.Next = cst
		cst <~ «prm, exp »
		if (Mytype.IsNormalStruct)
			exp.GetAddressOf(MyType)
		cst.Last.Obj = self

	cst.obj = .ReturnType

	Return loss
}


function DeclsProtoType (|Message| ch0, |SCClass| fpType=nil, |bool| late=false)
	// prototype syx (|Message| self, |FastString| fs)
	// + function Name (Syx) { }
	// = function Name (|Message| self, |FastString| fs) { }
	// try re-use this for behaviours?
	
	|| IsClass = fpType != nil
	fpType := Compiler[ ch0.name, .Source ]
	if fptype
		.DeclsProtoTypeRemove(fpType, ch0, IsClass, late)
		if !late
			.DeclsProtoTypeAdd(fpType)


function DeclsProtoTypeAdd (|SCClass| fpType)
	|| Dcl = SCDecl.new		 // make a lookuponly decl... to allow this func to be "found".
	dcl.IsLookupOnly = self
	dcl.TypeContained = fpType
	dcl.Name = .Name
	(dcl is const) // right?
	(dcl is onmodule) // not sure where this is found cos .cls is nil sometimes yet its still being found
	.ProtoDecl = dcl
	
	if (.Cls)
		.lookup.TryAdd( .Source, Dcl, .Name )



function DeclsProtoTypeRemove (|SCClass| fpType, |Message| ch0, |bool| AssumeSelf, |bool|late=false)
	|| p = ch0.Parent
	|| Proto = fpType.FuncProto						#expect (ch0, "This isn't a prototype!")
	
	|| fProtoParams = Proto.Source[ 1 ]
	expect (fprotoParams == @prm) (proto, "Expected function parameters here.")

	using (ch0)
		fProtoParams.CopyAllInto( p )
		p.Func = @prm
		ch0.Remove
	
	require .cls
	if late
		p.first.remove // ooof
	if (!AssumeSelf)
		ch0 = p[@Decl][@thg]						#require
		|| decl = ExtractDecl( ch0, nil )			#expect p
		expect (decl isa .cls.TypeNormal)	   ( self, "Receiver must be same class as first param in function prototype." )
		ch0.parent.Remove



function IsSimpleCast (|Message|)
	opt norefcounts
	// return |whatever|self
	expect .Source
	
	|| found = .Source[@arg, -1][ 0 ]
	require (found and found.IsLast) and (found IsTmp "return")


	found = found.first
	require (found.IsLast) and (found == @Type) and (found.first isThing "self")

	Return found


function CreateProtoCastTo (|SCFunction| f) {
	|| P  = f.prototype
	|| sP =  .Prototype
	
	require !P.isinterface and !sp.isinterface
	
	|| Using = f.source.syntaxusing 
	|| P1 = P.TypeNormal.WriteDeclFull
	
	// take whatever we are?

	|| arg = «arg » 
	|| func = «tmp "function"
		«thg "SyntaxCast"»
		«prm ""
			p1
		»
		arg
	»

	arg <~ «tmp "cpp_part", «thg "cast"»»
	arg <~ «tmp "return"
		«type ":)"
			«thg "self"»
			p1.first.Copy
		»
	»
	sp.CollectSub( func )
}


function EqualOrMoreSpecific (|SCFunction| f, |bool|)
	require self and f
	require ((f.ReturnType)|bool| == (.ReturnType)|bool|)
	require (f.args.length == .args.length)

	
	if (f.ReturnType)
		require f.ReturnType isa .ReturnType
	
	for (i in .args.length)
		require (f.args[i] isa .args[i])
	
	Return true


function CheckReturnValue (|Message| msg)
	|| c = msg.first
	
	if (!c)
		expect (!.ReturnType) (msg, "Need to specify a return value")
		return

	expect ( c.IsOnlyChild ) ( msg, "Can’t return multiple values" )
	
	if (!.ReturnType)
		if c == "nil" and c==@thg or @ques // auto-generated in many places :)
			c.Remove
			return

	
	|| FoundReturnType = TypeOfExpr( c, msg.MsgArg )
	if (FoundReturnType == TypeVoid)
		FoundReturnType = nil

	if (!.returnType)
		expect ( !FoundReturnType ) ( msg, "This function has no return value." )
		return

	expect FoundReturnType (msg, "Can’t find return type.")
	
	if (FoundReturnType == TypeNil) and (.ReturnType.CantBeNilInCpp)  // OK so what if we can’t return nil?
		c.ReplaceWith(.ReturnType.CreateDefault(c))
	  else
		.ReturnType.ExpectMatch( FoundReturnType, kTypeCastTrue, c )



function FillInConstructorAndDestructor (|Message| root, |bool| IsConstructor, |Message| SuperDot)
	|Dictionary| Dict = nil
	if IsConstructor
		dict = Dictionary.new
		
	
	for (curr.flat in root)
		if curr IsThing "self"
			|| P = curr.Parent
			|| KindaUse = curr.SelfKindaUse
			if (KindaUse != kIsProperty)
				|| PObj = P.Obj
				if (Pobj isa SCFunction) and (P == @prm)
					if (Pobj.AllocCode == .AllocCode): continue
				  elseif (KindaUse == kIsComparison)
					Continue

				warn !(IsConstructor) ( curr, "Don't use self before the constructor is complete." )
			  else
				|| TheSetter = IsSelfOfSetter( curr )
				|| t = TypeOfExpr(p, nil)
					|| tester = TheSetter ?? p
					if (t.IsNormalObject)
						(!(IsConstructor and !TheSetter) #check (tester, "Can’t read object properties during a constructor."))
						(!(!IsConstructor and TheSetter) #check (tester, "Can’t set object properties during a destructor."))
					
					if (IsConstructor)
						|| s = p.name.Lowercase
						
						if (t.isNormalObject)
							(!dict[ s ]					#check (tester, "Can’t set object property twice during a constructor."))
							(TheSetter.Parent == root	#check (tester, "Object property set must be at the root. (not nested)."))
						dict[ s ] = "x"
	
	
	// should come AFTER super.constructor
	if (IsConstructor)
		|| oof = .ConstructorLinePlace
		using (oof)
			for (d.backwards in .cls.Properties)
				if (!dict[ d.name.lowercase ])
					root.InsertAfter( .NewDefaultRel( oof, d ), SuperDot )


function ConstructorLinePlace (|message|)
	if .sourcearg.hasposition
		return .sourcearg
	if .cls
		return .cls.source
	debugger
	return compiler.program.source


function CanCompare (|SCDecl|Against, |bool|)
	opt norefcounts
	for (f in self)
		if (against isa f.args[ 1 ])
			return true


function Paramless (|SCFunction|)
	opt norefcounts
	for (f in self)
		|| s = f.Source
		|| lst = s.find(@prm)
		ifn lst and lst.hasany
			Return f


function TranStrings
	|| S = .SourceArg
	if (S and !.IsWrapper)
		SCFunction.Tran_Strings( S.parent, self )


function IsConstructorOrDestructor (|bool|)
	return self isa ( kIsConstructor (|) kIsDestructor )


function message.IsParentConCall (|scfunction|)
	opt norefcounts
	require (self == @func)
	|| f = .MsgFunc
	if f and f.IsConstructorOrDestructor
		return f


function scclass.RealSuper (|scclass|)
	opt norefcounts
	return .super.realclass


function scclass.RealClass (|scclass|)
	opt norefcounts
	rz = self
	while rz.IsRole
		rz = rz.super


function CountCallsToParentAlloc (|Message| root, |message|)
	|| FoundCount = 0
	for (curr in root)
		|| f = curr.IsParentConCall
			expect  (f.cls == .cls.realsuper)   (curr, "Function should belong to parent class, but doesn't.")
			rz := curr
			FoundCount++
			expect  (FoundCount < 2)   (curr, "Multiple calls to parent constructor/destructor not allowed.")


function CollectLinks (|object| obj)
	opt norefcounts
	if obj isa SCFunction
		.DoLinkTo( obj )
		obj.DoLinkFrom( self )
		
	  elseif obj isa SCDecl
		if obj.type
			.DoLinkTo( obj.type )
		|| t = obj.IsLookupOnly
			.CollectLinks( t )
		
	  elseif obj isa SCClass
		.DoLinkTo( obj )


function FindReached (|scbase| from, |bool|)
	flow off // memory order dependant!
	
	require !.CurrReacher
	.currreacher = from
	Compiler.stReachedFunc++

	.cls.Reach(self)?
		
	for o in .LinkTo
		if (o.CurrReacher)
			//
		  elseif (o isa SCFunction)
			o.FindReached(self)
			rz = true
		  elseif (o isa SCClass)
			o.Reach(self)
	
		
	
function Message.ExpectParamsTransform (|int| P, |message| errnode, |string| Type = nil, |Message|)
	using (errnode)
	|| L = self
	|| On = L
	if Type != "warn"
		Type = "expect"
	
	if (!L)
		On = «thg "nil"»
	  elseif (L == @list or @bra or @prm)
		L.Func = @prm
		on = L.first
	  else
		L = nil


	|| l2 = L
	if (L != @prm)
		l2 = «prm, L »		
	|| tmp = «dot ("syntax" + Type)
		on
		l2
	»
	L = tmp 
	L.Position = P
	return L


function FixCnj (|Message| exp)
	using (exp)
	.FixCnjSub(exp)


function FixCnjSub (|Message| exp) {
	if exp == @ARel					// x$ --> x#require
		exp.become(@TRel)
		exp <~ «opp "require"»
	
	// get the name (it's important)
	|| ch = exp.first
	|| name = ch.Next.Name
	|| CreatesError = (name == "expect" or "check")
	
	|| DoesReturn =  (name != "loop" and "check")
	expect (CreatesError or (name == "debug_require" or "require" or "continue" or "loop" or "need")) (exp, "Must be: 'require/expect/continue/loop' .")
	
	// lets fix it, if its in a rel, (it shouldn't be)
	// || x = a #require   -->   || x = (a #require)
	|| nxt = ch.next
	if (ch == @Rel) and (exp in @arg or @Decl) and (ch[1].name == "=")
		expect  (ch.first.IsAssignable)   (exp, "Use brackets here, like this: “($ch) #${name}”")
		
		exp.ReplaceWith( ch )
		
		|| RightSide = ch.Last
		|| bra = «bra »
		RightSide.ReplaceWith( bra )
		bra <~ RightSide
		bra.WrapWith( exp )
		bra.ReplaceWith( bra.first )
	
	if name == "require" // unneeded? "cant" doesnt seem to need it?
		nxt.Name = "return"
		name = "return"
		
	// helpfully replace the exp.
	ch = exp.first
	ch.Remove
	exp.ReplaceWith( ch )
	
	// x = (a #require)			-->		x = a, if (!x) {return}
	//
	//  (a #require)			-->		if (!a)   {return}
	//  (!a #require)			-->		if (a)	  {return}
	//
	// if (a() #require) {code}	-->		|| tmp = a(), if (!tmp) {return}, {code}
	// (a() #require).Func		-->		|| tmp = a(), if (!tmp) {return}, tmp.Func
	// if (a #require) {code}	-->		if (!a) {return}, {code}
	// (a #require).Func		-->		if (!a) {return}, a.Func
	
	|Message|	Thg
	|Message|	pp
	|Message|	RemoveMe
	|bool|		UsePrev
	if (ch isbrel "++") and (ch in @arg) and (ch.first == @thg) {
		// ++ch #require // just an opt.
		// Actually I didn't implement the general case yet :) haha.
		Thg = «thg ch.first.name »
		pp = ch
		
	} else {
		pp = ch.NiceParent
		|| Done = false
		if ((ch.UnBra == @thg)) or ((pp == @arg) and !CreatesError)
			thg = ch.copy
			if (pp == @arg)
				RemoveMe = ch // i think so...
			pp = ch.ParentPoint
			UsePrev = true
			Done = 1
		  elseif (pp.IsSetRel and pp.first == @thg)			
			// || word = (a.b[c] #require)
			|| IsDecl = (pp in @Decl)
			if isdecl or (name != "loop")
				Done = 1
				Thg = «Thg pp.first.name »
				if IsDecl
					pp = pp.Parent
			
		if !Done
			// func( item isa SyxItem #require ) -->
			// || tmp_318 = (item isa SyxItem)
			// if !tmp_318 { return }
			// func( tmp_318 )
			
			pp = SCFunction.TempMoveOut( ch )
			Thg = «thg pp.DeclName.Name »
	}
	
	
	// || tmp = func()
	//	  -->
	// || tmp = func()
	// if (!tmp) {
	//	 .SyntaxExpect(x, y), return
	// }
	// || x = tmp
	
	
	|| arg = «arg »
	if (CreatesError)
		|| L = exp.first.Next
		if (name != "expected")
			L = L.ExpectParamsTransform( exp.Position, exp )
		  else
			error (exp)
		arg <~ L

	
	if (name == "debug_require")
		arg <~ «tmp "debugger"»

	if (name == "continue") and pp.WithinLoop( .SourceArg )
		arg <~ «tmp "continue"»
		
	  elseif (name == "loop") and pp.WithinLoop( .SourceArg )
		arg <~ «tmp "exit"»
		
	  elseif name == "need"
		arg.msg(@tmp, "cant")
	
	  elseif (DoesReturn)
		arg <~ «tmp "return", «ques "nil"»»
	
	if (thg isbrel "!")  // cancel out "!!test"
		thg = thg.ReplaceWithChild
	  else
		|| tmp = «brel "!", thg » // sigh. error otherwise 
		thg = tmp
	
	|| if_ = «tmp "if"
		thg
		arg
	»
	if (UsePrev)
		pp.Prev = if_
	  else
		pp.Next = if_
	
	if (RemoveMe)
		RemoveMe.Remove
}


function Fix_Continue (|Message| s)
	// this function is messed up now... needs a re-design.

	require !s.WithinLoop(.sourcearg)
	|| curr = s.first						#expect curr

	using (s)
	s.Name = "return"
	if .ReturnType
		s <~ «thg "nil"»


	
function PostTransform
	opt norefcounts
	scfunction.currfunc = self

	|| arg = .SourceArg
	for msg.flat in arg
		|| o = msg.obj
			.CollectLinks( o )

	for d in .args
		.CollectLinks( d )

	.CollectLinks( .ReturnType )
	scfunction.currfunc = self


function RegType (|datatypecode|)
	if self
		return .returntype.regtype


function RefSmooth (|SCDecl| N)
	opt norefcounts
	N.Strength = 0
	if n is typeimprove
		|| orig = n.islookuponly
		if orig isa scdecl
			orig.strength = 0
		


function TreeSanity
	.source.treesanity


function DeclToDot (|SCDecl| d, |Message|)
	|| slf_msg = «thg "self"»
	slf_msg.obj = .cls.SelfStrong
	
	|| dot = «dot d.Name
		slf_msg
		«emb »
	»
	dot.obj = d
	Return dot


function NewDefaultRel (|message| place, |SCDecl| d, |Message|)
	// .bla = X
	require !d.C_array				// we actually need to clear it!
	
	|| def = d.CreateDefault(place)
	return NewRel( .DeclToDot(d), "=" , def )


function DoLinkTo (|SCBase| B)
	b.StoreLinkToMe(.linkto)


function scobject.DoLinkFrom (|SCBase| B)
	B.StoreLinkToMe(.linkfrom)


function NewNilRel (|SCDecl| d, |Message|)
	// .bla = nil
	|| def = «thg "nil"»
	def.Obj = TypeNil
	return NewRel( .DeclToDot(d), "=" , def )



iterator
	|| F = self
	while (F)
		yield F
		F = F.NextFunc



module {
||				DisabledPoints = 0
|SCFunction|	CurrFunc
|int[12]|		FuncStats

		
	
function ringtree.TreeSanity
	opt norefcounts
	for s in self
		if s.parent != self
			.debugprint
			debugger
		s.TreeSanity


syntax equals (|string| s, |bool| aware, |bool|)
	return currfunc.syntaxequals(s, aware)




function NewMissingFunc (CollectFunc)
	|| f = SCFunction.NewFunc( node, name_space, errplace )
	if (f isa scfunction)
		|| arg = f.sourcearg
		|| C = arg.first
		expect (C and !C.next) (F, "Missing functions must be one line!")
		|| prm = arg.prev
		expect (!prm.hasany) ("Missing functions don't directly state arguments.")
		f.isMacro = true
		node.name = "function"
	return f

function NewProtoType (CollectFunc)
	return NewProtoTypeSub(node, name_space, ErrPlace, nil)


function NewProtoTypeSub (|Message| node, |SCBase| parent, |Message| ErrPlace, |string| ForInterface, |SCModule|)
	if (ForInterface)
		parent = parent|SCClass|.modul
	  else
		expect (parent isa SCModule) (node, "Function prototypes must be in a module." )
		
	|| f = SCFunction.NewFunc( node, parent, ErrPlace )|SCFunction|
	expect (Compiler.FuncList.Pop == f)
	
	|| Using = node.syntaxusing
	|| tmp = «tmp "datatype"
		«thg f.Name »
		node.last
	»
	
	|| modul = SCClass.DataTypeSub( tmp, parent, node, ForInterface )
		|| clss = modul.Cls
		clss.IsBuiltin = false // datatype sets it to true.
		clss.FuncProto = f
		f.ProtoType = clss
		Compiler.ProtoTypes <~ f
	
	Return Modul



function NeuSyx (CollectFunc)
	|| Using = node.syntaxusing 
	|| NewNode = Tran_Syx( node )
	return SCFunction.NewHelper( NewNode, name_space, ErrPlace )



function Tran_AfterRel (|Message| msg, |SCBase| name_space, |message| side, |SCDecl|)
	|| exp = msg.first
	if msg isbrel "!"
		return TypeOfExpr( exp, name_space )

	expect (msg == "--" or "++") (msg, "Unrecognised operator.")
	
	
	|| P = msg.parent
	Using (exp)
	|| exp_copy = exp.copy		 // needed before get type :(
								 // or else we can't do array.size++

	|| Type = TypeOfExpr( exp, name_space )		#require
	
	// OK so the problem here is that it's already getting the type of this
	// and failing, because we aren't giving it something that we are setting it to.
	// we'd have to do the transform FIRST, THEN get the type!
	// but we can't do the transform until we have the type.
	// we'd ahve to remove that silly next/prev thing.
	// So that x = x + 1 can work for nodes too. which is MORE annoying.
	//// require type and type.ConstCheck(exp, side, nil) /// needs above fix

	|| numc = Type.type.NumericCount
	if (!Type.type.IsObject and Type.Name and !type.setter and numc <= 1) or type.pointercount > 0
		return type											// gui.scproj won't compile :(

	|message| R
	if numc or type.setter
		R = NewRel(exp, msg.name[0, 1], «num "1"»)
	  else
		|| name = ("next", "prev")(msg == "++")
		R = «dot name
			(exp)
			«emb »
		»


// X++ --> X = X.next,  ("arl" "++" ("thg" "x")) -> rel(thg("x")  opp("=")  dot("next" thg("x") lst() ))

	msg.become(@rel)
	msg <~ exp_copy
	msg <~ (@opp, "=")
	msg <~ R
	msg.obj = nil
	
	return TypeOfExpr( msg, name_space ) // why aren't i returning this? :/
	// y = x++
	// y = x
	// y = ++x --> x = x.next, y = x



function message.FixMultiArr
	opt norefcounts
	for item in self
		|| kkey = item.first			//   [(a,b,c):x]  -->  [a:x, b:x, c:x]
		if kkey == @list
			|| val = kkey.next
			while (|| c = kkey.first)
				|| i2 = @item.msg
				i2 <~ c
				i2 <~ val.copy
				item.prev = i2
			item.remove


function Tran_Log (TranFunc)
	ignore
		log abc
		// -->
		platform.log(abc)
	using (node)
		|| f = node.first
		node <~ «Thg "platform" »		// this seems better... than tran_print
		node <~ «prm, f »				// probably tranprint should use this instead.
		node.func=@dot					// like Platform.print, Platform.printline, Platform.printerror
	TypeOfExpr( node, name_space )		// Platform.log


function AlterPostCond (|Message| PostCond, |Message| IterPostCond, |message| NodeSrc, |Message|)
	opt norefcounts
	if !IterPostCond
		Return PostCond
	
	IterPostCond = IterPostCond.copy(nodesrc)
	if (!PostCond)
		Return IterPostCond

	return NewRel( «Bra, postcond », "or", «bra, IterPostCond » )


function ArgToFunc (|string| NewName, |Message| Params, |Message| arg,  |Message|)
	|| result = «tmp "function"
		«thg newname »
	»

	if (params == @prm)
		result <~ params

	  elseif (params == @thg)	// prototype
		result <~ «bra, params »

	  else
		debugger// whatever...

	result <~ arg
	result.position = arg.position
	Return result


function Message.FindOwningLoop (|message|top, |Message|) 
	for P.up in self
		require (P and P != top)
		if (P == @tmp) and (P == "while" or "for")
			return P


function Tran_Exit (TranFunc)  // exitter
	opt norefcounts
	expect (!node.first) (node)
	// OK so... also check it must be within a loop.
	|| Found = node.FindOwningLoop(fn.sourcearg)
	expect Found (node, "Must be within a loop.")


function Tran_Debugger (TranFunc) {
	|| ch = node.first
	if !ch
		node.name = "debugger"
		return
	
	expect ((node == "debugger") and (!ch.next)) (node)

	using (node)
		ExpandToBool(ch, name_space)
		node.first = «brel "!", node.first »
		// So.... transform it.
		node.Name = "if"
		node <~ «arg, «tmp "debugger" »»
	
	Tran_If(fn, node, name_space)

	// "Apple... I think I've heard of that name. Do they eat computers?"
	// I think It's better to forget society.
}


function Tran_DoAt (TranFunc)
	|| ch = node.first
	using (node)
		node.become(@func)
		node <~ «thg "DebugAt"»
		node <~ «prm, ch »
	TypeOfExpr(node, name_Space)

/*
decl 
	emb 
	rel 
		thg "fs"
		opp "="
		func 
			thg "faststring"
			prm 
*/

 
function message.Tran_FS
	.cleanbecome(macros.FS)


function Tran_Ifn (TranFunc)
	|| f = node[@nil]
		using (node)
			node.name = "if"
			node.first = «brel "!", f.needbra »
		tran_if(fn, node, name_space)


function scbase.LateAddTempory (|string| type, |string| name1, |message| Value, |message| err, |string|)
	|| name = UniqueTmpVar(compiler.program, name1)
	typeofexpr(Value, self)
	|| msg = MakeDecl(type, name, Value)
	|| D = TypeOfExpr(msg, self)$
	(D is const) = false
	.source <~ msg
	.tryadd( err, D, name )
	return name


function scdecl.IsConstOf (|scdecl| b, |bool|)
	opt norefcounts
	
	// Needs a "constant preservation" system.
	// basically... takes: (kPositiveInt==1) and return "the false-bool".
	// typeofrel,etc needs to be changed... just ints, and bools maybe strings is enough for now.
	// (typeofbrel is already altered!)

	require self is const
	if self == b: return true
	return .default$.Obj==b


|| OnceCount = 0
function Tran_Once (TranFunc)
	// once: "abc" --> if !globaltmp: "abc"
	|| arg = node[@arg]$ // needs arg... don't embed statements! cozz it sucksssss
	require arg.expectlast
	
	using (node)
		node.name = "if"
		|| obj = compiler.program.lateAddTempory( "bool",  "once"+(++OnceCount).render, «thg "false"», node )

		arg.first = «rel
			«thg obj »
			«opp "="»
			«thg "true"»
		»
		node.first = «brel "!", «thg Obj »»
		
	tran_if(fn, node, name_space)
  

function Tran_If (TranFunc) 
	Tran_IfSub(0, node, name_space)

	
function Tran_IfSub (|int| mode, |message| node, |scbase| name_space) 
	opt norefcounts
	|| cond = node[nil|syntax|]					 #require
	|| arg = cond.next
	node.flags |= asmtmp.iIf // for the ASM
	
	if (!arg)
		arg = @arg.msg
		if node == "if"
			arg <~ (@tmp, "debugger") // better than debugat
		cond.next = arg
	// cond.obj = asmops.if // this causes bugs! need to fix this!

	require arg.expect(@arg)
	|| Next = arg.next
		expect (Next isTmp "elseif" or "else")  ( node )
		expect (next.parent != @arg) (node, "Can’t have this at the argument root!")

		if next == "else"
			|| N2 = next.first
			next.expectlast$
			expect  (N2 ~!= "if")         (node, "Can’t use 'else if', use 'elseif' instead.")
			require (N2.wantasarg(next))
		
		while next istmp "elseif"
			Tran_Ifsub(0, next, name_Space)
			next++
	
	using (node)	
	name_space = arg.scarg(name_space)
	
	cond = ExpandToBool( cond, name_space )$
	|| d = TypeOfExpr(cond, name_Space) $
	if d.IsConstOf(falsebool)
		cond.RemoveElseIf
		return
	
	
	cond.NeedBra
	if cond.first == @arg // if a.b? --> if ({||x=a.b, rejoin x}), fails in c cos if ({}) is bad
		cond.wrapwith(@bra.msg).obj = cond.obj 
	Tran_Isa(node, name_space)
	

function Tran_Or (TranFunc) 
	opt norefcounts
	|| p = node.parent
	check (p istmp "try") (node)


function Tran_Try (TranFunc) 
	opt norefcounts
	|| f = node[@arg]$
	while
		f = f.next #loop
		f.expect(@tmp, "or")
		f[@arg]

	node.flags |= asmtmp.itry

function Tran_Need (TranFunc) 
	opt norefcounts
	with node
		node.name = "ifn"
		|| arg = node.msg(@arg)
		arg.msg(@tmp, "cant")
		tran_ifn(fn, node, name_Space)
		


function Tran_Cant (TranFunc) 
	opt norefcounts
	|| x = node.first
		error (x)
	node.flags |= asmtmp.icant
	node.removeafter
	

function message.RemoveElseIf // self == cond
	opt norefcounts
	|| arg = .next
	|| after = arg.next
	if !after
		.parent.saferemove
		return
	if arg == @arg
		arg.clear
	.NeedBra


function Tran_Else (TranFunc) 
	opt norefcounts
	|| p = node.prev
	// expect (p istmp "if" or "elseif") (p, "Should be else/elseif")
	node[@arg].expectlast


function Tran_Elsa (TranFunc) 
	opt norefcounts
	node.name = "else"
	node[@arg].expectlast


function Tran_Deprecate (TranFunc)
	// deprecate (msg, "error")
				// -->
	// msg.Syntaxdeprecate((test), "error")
	
	|| stuff = node[nil|syntax|]						#require
	require stuff.expectlast

	if stuff != @list and @bra
		stuff = stuff.wrapwith(@list.msg)

	using (node)
		stuff.func = @prm
		node.become(@bra)
		|| Dot = @dot.msg(node, "SyntaxDeprecate")
		Dot <~ stuff.first
		Dot <~ stuff

	typeofexpr(node, name_space)



function TranFuncDummy (TranFunc) {
	// nothing
}

function Tran_Visible (TranFunc)
	fn.LoadVisibility( node )


function Tran_Return (TranFunc)  // exitter
	expect (! fn.IsConstructorOrDestructor)   (node, "You can’t return in a constructor or destructor")
	node.flags |= asmtmp.ireturn
	fn.CheckReturnValue( node )
	node.removeafter


function Tran_Rejoin (TranFunc)  // exitter
	|| p = node.first
	if p == @arg
		|| arg = p.asarg
		expect (arg.IsStatementExpr) (node, "Can't use this here.")
		expect !p.next (node, "Value expected here.")


function NewCppWrapper (CollectFunc)
	|| name = node[@thg]
	|| prm = name.next(@nil)$
	expect (prm.islast) (prm)
	
	using name
	|| thg = «thg name.name »
	if node == "cpp_inbuilt"
		thg = «bra, thg »
	|| IsNothing = node == "cpp_nothing"
	|| IsLib	 = node == "cpp_libwrapper"
	node.name = "function"
	node <~ «Arg
		«Tmp "cpp_wrapper"
			thg
		»
	»
	rz = SCFunction.NewFunc( node, name_space, ErrPlace )
	rz.noautocomplete = 1
	if isnothing
		rz|scfunction|.IsCppInBuilt = 2
	  elseif node == "cpp_inbuilt"
		rz|scfunction|.IsCppInBuilt = 1
	rz|scfunction|.IsExternalLib = islib


function NewSetter (CollectFunc)
	expect (name_space isa scclass) (errplace, "Must go in a class")
	return SCFunction.NewFunc( node, name_space, ErrPlace )


function NewHelper (CollectFunc)
	node.name = "function"
	rz = SCFunction.NewFunc( node, name_space, ErrPlace )
	if rz
		rz.noautocomplete = 2


function SCBase.StoreLinkToMe (|&(dictionary of SCBase)| dp)
	opt norefcounts
	require self != typevoid_
	|| d = *dp init dictionary.new
	d[._dictname] = self


function message.NeedsPreprocess (|bool|)
	opt norefcounts
	if self == @TRel or self IsARel "$"
		return true
	if self == @tmp
		return .name == "using" or "expect" or "require" or "debug_require" or "warn" or "error" or "check" or "loop"

	require (self == @rel)
	|| L = .first
	if (L == @rel) and (L.next == "or")
		return (L[1] == "=") and (.last[1] == "=")



function SCFunction.PreProcessExpects
	|[Message]| list = nil
	
	for ch.flat in .SourceArg
		if ch.needspreprocess
			list := array.new
			list <~ ch
	require list
	
	for ch in list
		if ch == @Trel or @Arel
			.FixCnj( ch )
		  elseif ch == @rel
			RelSetOrExpansion(ch)
		  elseif ch != "using"
			Tran_Expect(self, ch, nil)
		
	for ch in list
		if ch == "timetest"
			ch.name = "using"
			|| w = ch.first
			if !w
				ch <~ (@str, "Time")
				w = ch.first
			w.needbra
		  elseif ch=="using"
			tran_using(self, ch, nil)



function message.NormaliseFunc (|message|)
	opt norefcounts
	|| name = self[@thg]$
	using (name)
	|| prm = name.next
	if prm == @arg
		prm = @prm.msg
		name.next = prm
	  elseif !prm
		prm = .msg(@prm)
	  else
		|| fn = prm.func
		expect (fn == @bra or @list or @prm) (prm)
		prm.Func = @prm
	rz = prm.next
	if rz
		rz.expect(@arg)
	  else
		rz = .msg(@arg)
	

function message.SlidePositions (|int| add)
	opt norefcounts
	for s.flat in self
		if s.position >= 0
			s.position += add


function message.AppMainFix
	|| desired = "function app.Main (|int|)".parse
	|| arg = .last
	.become(desired)
	self <~ arg


function scfunction.Cleanupfunc 
	|| s = .source
	|| n = s.name
	using s
	|| cls = .cls.isnormalobject
	if s ~= "constructor" or "destructor"
		s.name = "function"
		|| f = «thg n »
		s.first = f
	  elseif s ~= "render"
		if Tran_Render(s, cls)
			s.name = "behaviour"
	if (s ~= "behaviour") and cls
		scbehaviour.Tran_Behaviour(s, cls)
		cls.FillInterFaceIn(self, true)


function scfunction.updateSourceSub (|message| source, |bool|)
	opt norefcounts
	if source ~= @tmp and "main"
		source.AppMainFix

	|| f = source[0]$
	if f == @dot
		f.func = @thg
		f.clear
	rz = stderr.ok // awesome! dont delete this!
	.init_sub(source, nil)
	rz = stderr.ok 
	if rz
		.FuncDecls
		.CheckNotBadName
		.Transform
		stderr.clear // lol


function scfunction.SetFuncType (|message| node)
	if node == "api"
		.isapi = true
		node.name = "function"
	  elseif node ~= "setter"
		.isassigns = 2


function scfunction.SetBlindCasts (|scbase| name_space)
	if name_space and name_Space.project
		.BlindCasts		= name_space.project.blindcast
	  elseif scimport.curr
		.BlindCasts		= scimport.curr.blindcast


function scfunction.init_sub (|message| node,  |scbase| name_space)
	|| arg = node.NormaliseFunc
	node.obj = self
	if name_space
		if node != "iterator"
			Compiler.FuncList <~ self
		.FLookup = name_space  // sets as a module even if parent is a class
		.refs = name_space.getasmodule$.defaultrefs
		scfunction.currfunc = self
	
	.SetFuncType(node)
	.ParseName( node.first )
	.PreProcessExpects
	.TranStrings 
	.ReadDisabled(Arg)

	.IsInline		= arg.DeprecatedClassOption("pragma", "inline")
	.NoRefCounts	= arg.DeprecatedClassOption("opt",	"NoRefCounts")
	.minopt			= arg.DeprecatedClassOption("opt",	"min")
	.SetBlindCasts(name_space)

	if  Arg.DeprecatedClassOption("pragma", "DontDestructLocally")
		.AllocCode |= kDestructorNotFromLocalRefs
	

function NewFuncSub (CollectFunc)
	|| fn = SCFunction(node)
	fn.init_sub(node, name_space)
	return fn


function NewFunc (CollectFunc)
	require node
	|| name = node.first			   #expect (node, "No function name found.")
	if name == @Dot
		return SCClass.ExtendOneFunc(node, nil, ErrPlace)
	return NewFuncSub(node, name_Space, errplace)	


function SCFunction.ReadDisabled (|message| arg)
	|| p = arg.findflat( @tmp, "disabled" )
		p.Remove
		.disabled = "Called a disabled function."
		|| s = p[@str, @nil]
			.disabled = s.name


function NewConstructor (CollectFunc)
	node.name = "function"
	using (node)
	node.first = «Thg "Constructor"»
	return SCFunction.NewFunc( node, name_space, ErrPlace )


function NewDestructor (CollectFunc)
	node.name = "function"
	using node
		node.first = «Thg "Destructor"»
	return SCFunction.NewFunc( node, name_space, ErrPlace )


function NeuMain (CollectFunc)
	expect  (name_space == compiler.program)  (node, "Can’t have main inside here.")

	node.name = "function"
	|| s = "function app.Main (|int|,) {cpp_name JB_Main, visible true}"
	|| fn_src = s.ParseClean
	|| src_arg = fn_src.Last
	|| inc_arg = node[@arg, -1]$
	|| prms = node[0]
	expect (prms == inc_arg) (prms)
		
	src_arg.Remove
	fn_src <~ inc_arg
	inc_arg.TakeAllFrom( src_arg )

	Compiler.HasMainFunc = true
	rz = SCFunction.NewFunc( fn_Src, name_space, ErrPlace )
	if rz isa scmodule // sigh. Not ideal.
		scclass.ProcessExtend(fn_Src, false)
		fn_src.remove



function NeuLibrary (CollectFunc)
	error (node, "Can’t use this")
	Options.ProjectisLibrary = true // better than omitting main. more... specific.
									// but what if someone includes a library?
	return neumain(node, name_space, errplace)
	// library {} -->

}

}



function SettingSelfProperty (|Message| Rel, |bool|)
	// .bla = X
	opt norefcounts
	|| Dot = SettingAProperty(rel) #require
	return (Dot.first IsThing "self")


function SettingAProperty (|Message| Rel, |Message|)
	// bla.bla = X
	opt norefcounts
	require (Rel IsRel "=")
	|| it = Rel.first
		if (it.DotType == kIsProperty)
			return it


function SettingMemory (|Message| Rel, |bool|)
	// bla.bla = X
	opt norefcounts
	require (Rel IsRel "=")
	|| it = Rel.first
		if (it.DotType == kIsProperty or kIsMemory)
			return true


function message.SelfKindaUse (|int|)
	opt norefcounts
	|| p = .parent
	|| R = p.parent
	if R == @Rel
		|| Op = R[1]
		require (Op == "=") and Op.next
		return p.DotType


function IsSelfOfSetter (|Message| curr, |Message|)
	opt norefcounts
	// .bla = X
	|| dot = curr.Parent
	|| P   = dot.Parent
	require (P IsRel "=")
	require (P.first == dot)
	Return P



function string.UnicodeSafeName (|string|)
	if .isascii
		return self
	
	|| fs = faststring()
	for s in self
		if C_Letters[s]
			fs <~ s
		  else
			fs <~ 'x'
			fs.appendhex(s)
	return fs


constants
	kReplaced = 0x800

