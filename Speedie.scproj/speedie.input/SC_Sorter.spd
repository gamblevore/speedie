


///// LEAF SORTING
prototype SorterComparerFn		(|scfunction| a, |scfunction| b, |int|)
prototype SorterComparerDecl	(|scdecl| a, |scdecl| b, |int|)


helper SCFuncSorter (SorterComparerFn)
	// just to help compression. otherside will use a dictionary anyhow.
	|| fA = a.Tableid|int|
	|| fB = b.Tableid|int|
	|| d = fb - fa  // we need init and main first
		return d
	return a.ExportName < b.ExportName


helper NodeSorter (SorterComparerFn)
	return a.ExportName < b.ExportName



module CodeSorter
	function LeafsFirst
		opt norefcounts
		for f in compiler.FuncList
			f.FindDepths
		compiler.funclist.sort(LeafFunctionsSorter)


	function LeafFunctionsSorter (SorterComparerFn)
		opt norefcounts
		|| x = a.LinkDepth|int| - b.LinkDepth|int|
		if x < 0
			return 1
		if x == 0
			return a.exportname < b.exportname
		return 0
	
	
function SCFunction.MarkRecursive (|scfunction| EndAt)
	opt norefcounts
	|| s = self
	while
		(s is Recursive)
		require s != endat
		s = s.DepthFinder
		require s != nil and EndAt


function SCFunction.FindDepths (|int|)
	opt norefcounts
	flow off
	// Orders the functions in terms of which ones need others.
	// So we can process leaf functions first. Maybe easier to optimise

	if .LinkDepth
		return .LinkDepth
	
	rz = 1
	for f in .LinkTo
		if (f isa SCFunction)
			if (f == self) or f.DepthFinder
				.MarkRecursive(f)
			  else
				f.DepthFinder = self
				|| D = f.FindDepths+1
				(rz max= D)
				f.DepthFinder = nil

	.LinkDepth = rz

	
