

// ADDC? optimise stages... OR special-case it specifically.

struct ASMState
	linkage: cpp_part Pac
	|SCFunction--|				fn       
	|µFunc|						Out      
	|&FatASM|					Start		// a "slice" feature would be nice    
	|&FatASM|					Curr    
	|&FatASM|					End    
	|&FatASM|					WhileStart
	|bool|						OK       
	|byte|						LabelCount
	|datatypecode|				ReturnType
	|byte|						VDecls
	|byte|						VTmps
	|uint64[32]|				Consts 

	function AddFuncParams (|SCFunction| fn)
		opt norefcounts
		for a in fn.Args
			a.dtype = .DeclareMe(nil, a.RegType|asmreg|)|datatypecode|

	function Last (|&FatASM|)
		return .curr-1
	
	syntax access (|asmreg| a, |&uint64|)
		cpp_part GetConst, pragma inline
		return .consts[a.reg]

	
	function IntPowerOfTwo (|asmreg| r,  |FailableInt|)
		// -1 --> -1,  0 --> 0,  1 --> 1,  2 --> 2,  4 --> 3,  8 --> 4
		if r is const
			|| v = .Consts[r.reg]
			if v == -1
				return v
			if v.IsPo2
				return v.Log2+1

		if (!r.reg) // what?


	function TryAddConstant (|message| exp,  |AsmReg| Dest,  |AsmReg| Src,  |int64| Value, |bool|)
		if dest.isint
			if value.CanStoreAsIntImmediate
				.AddASM(asm.ADDK, exp.parent!, dest, src, Value)
				return true
		  elseif dest.fourbytes
			if value|uint64|.CanStoreAsFloatImmediate
				.AddASM(asm.FADK, exp.parent!, dest, src, Value)
				return true

		
	function AddASM (|int| SM, |message| dbg, |int| a, |int| b, |int| c, |int| d, |int| e, |&FatASM|)
		pragma inline,  opt norefcounts,  cpp_part AddASM5
		rz = self <~ (sm, dbg)
		rz.r[0] = a
		rz.r[1] = b
		rz.r[2] = c
		rz.r[3] = d
		rz.r[4] = e
		
	function AddASM (|int| SM, |message| dbg, |int| a, |int| b, |int| c, |int| d, |&FatASM|)
		pragma inline,  opt norefcounts,  cpp_part AddASM4
		rz = self <~ (sm, dbg)
		rz.r[0] = a
		rz.r[1] = b
		rz.r[2] = c
		rz.r[3] = d

	function AddASM (|int| SM, |message| dbg, |int| a, |int| b, |int| c, |&FatASM|)
		pragma inline,  opt norefcounts,  cpp_part AddASM3
		rz = self <~ (sm, dbg)
		rz.r[0] = a
		rz.r[1] = b
		rz.r[2] = c

	function AddASM (|int| SM, |message| dbg, |int| a, |int| b, |&FatASM|)
		pragma inline,  opt norefcounts,  cpp_part AddASM2
		rz = self <~ (sm, dbg)
		rz.r[0] = a
		rz.r[1] = b

	function AddASM (|int| SM, |message| dbg, |int| a, |&FatASM|)
		pragma inline,  opt norefcounts,  cpp_part AddASM1
		rz = self <~ (sm, dbg)
		rz.r[0] = a
	
	function AddASM (|int| SM, |message| dbg, |&FatASM|)
		pragma inline,  opt norefcounts,  cpp_part AddASM0
		return self <~ (sm, dbg)

	syntax append (|int| code, |message| dbg, |&FatASM|)
		cpp_part RequestOp
		|| p = .curr
		if p < .end
			.curr = p + 1
			P.op = code
			p.debug = dbg
			return p
		if .OK
			error "ASM is out of memory."
			.OK = false
		return .start
	
		
	function DeclareMe (|Message| where,  |asmreg| T,  |asmreg|)
		|| d = .VDecls|int| + 1
		if (d + .vtmps <= 31)
			t.reg = d
			.vdecls = d
			return t
		error (where, "No free local variables.")			
	
	
	function TempMe (|Message| where,  |asmreg| T=asmreg.discard,  |asmreg|) // .needreg
		if t.reg
			return t
		
		|| d = .vtmps|int| + 1
		if (d + .vtmps <= 31)
			t.reg = 32-d
			.vtmps = d
			return t
		error (where, "No free local variables.")


	function OpenVars (|int|)
		return .vdecls ||| (.vtmps << 8)


	function CloseVars (|int| Old, |bool| DeclsToo=true)
		pragma inline
		if DeclsToo
			.vdecls = old & 255
		.vtmps  = old|uint| >> 8


///////////////////////////////////////////////////////////////////////////////////////////////////
	
	function Branch (|message| cond,  |&fatasm|)
		|| dest = asmreg.newCondRequest
		|| Src = .µ(cond, dest)
		if Src isnt cond
			(dest is negate) = (src isnt AlreadyNegated)
			.equals(dest, dest, src, cond)
		return .curr - 1
	
	
	function FindConst (|uint64| Code, |asmreg|)
		if Code
			return asmreg()
		|int| i = 31 - .VTmps
		// any flow-control can destroy this
		// what about something like:
		// || x = (1,2+1)
		// perhaps tern should open/close?
		while i > .VDecls
			if .Consts[i] == code
				return i.reg as asmreg.const
			i--
	
	
	function µ (|message| exp,  |AsmReg| Dest = asmreg(), |AsmReg|)
		opt norefcounts
		pragma inline
		cpp_part Get
		|| T = exp.ASMType
		|| fn = fn_asm_table[T]!
		target debug
			if !T
				fn = fn_asm_table[exp.func|int|]!
				debugger

		if dest isnt StayOpen
			debugger, #! Can't close declarations in args!
			|| OV = .OpenVars		
			rz = (fn)(self, exp, dest)
			.CloseVars(ov, dest isnt discard)
		  else
			rz = (fn)(self, exp, dest)
		
		target debug
			|| dd = dest.reg
			if dd and rz.reg != dd
				// its not about "being different"... but "did it allocate something that it didnt need to"
				#!FFFFFFASSDJKLASDM<>AS


	function Prm (|message| prm, |asmreg|)
		|| r = .ExistingVar(prm)
		if r.Exists
			return r
		|| Where = .DeclareMe(prm, asmreg())
		return .µ(prm, where)
		
		
	function DoFunc (|message| prms, |asmreg| dest, |asmreg|)
		opt norefcounts
		|| fn = prms.asfunc
		expect (fn and fn.args <= 10) (prms, "Too many parameters")
		// speedie's function histogram:  0:410, 1:1656, 2:1464, 3:713, 4:167, 5:61, 6:10, 7:3, 8:1
		// there are only 4 above 6!, only 14 above 5

		if dest is discard
			dest = asmreg()
		  else
			dest = .TempMe(prms, dest)
			dest.µtype = fn.RegType

		|int| Reg2
		|int| Reg3
		|| sh = 0
		|| OV = .OpenVars

		for p.fast in prms
			|| v = .prm(p).reg
			if sh <= 25
				reg2 |= (v << sh)
			  else
				reg3 |= (v << (sh-30))
			sh += 5
		.closevars(OV)

		|| OP = (asm.func2, asm.func3)(sh <= 25)
		|| SaveAmount = 0
		if dest isnt forreturn
			SaveAmount = .vdecls
		.AddASM(OP,  prms.parent!,  save: SaveAmount,  incr: 0,  jump: fn.TableId,  reg2,  reg3)
		return dest


	module
		|FatASM[]|					JSMSpace = FatASM[0]!
		|[memory of fatasm]|		Olds
		|ASMState|					Sh
		

function ASMState.PackMakerInit (|bool|)
	opt norefcounts
	VM_Builder.JustMakeMyBread
	treeassembler.InitTree
	return .alloc(ASMState.JSMSpace)


function ASMState.Alloc (|memory of fatasm| j, |bool|)
	if j.setcap(4MB)
		.start = j.ptr
		.curr = .start
		.end = j.Capacity + .start
		.AddASM(asm.EROR, compiler.InternalFile.ast!, 0)
		olds <~ j
		return true


function @ASMState.ExpandJSM (|bool|)
	require .olds < 16
	|| j = FatASM[4MB]
		.olds <~ .jsmspace
		.JSMSpace = j
		return sh.Alloc(j)
	


function ASMState.InitState (|scfunction| fn)
	if fn.ASM
		.out = fn.asm!
	  else
		.out = µfunc(fn, .curr)
	.LabelCount = 0
	.fn  = fn
	.returntype = fn.returntype.regtype
	.ok  = true
	.vdecls = 0
	.vtmps = 0
	.AddFuncParams(fn)


function ASMState.FinishASM
	opt norefcounts
	ifn .last isa asm.ret
		debugger
	.out.length = .curr - .out.IR

