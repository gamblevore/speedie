

prototype fn_OpASM  (|&ASMState| self, |asmreg| dest, |asmreg| L, |asmreg| R, |message| exp, |!&fatasm|)
prototype fn_OpASM2 (|&ASMState| self, |asmreg| dest, |asmreg| L, |asmreg| R, |message| exp, |?&fatasm|)


extend asmreg
	function boolasm (|asmreg|)
		.µtype = DataTypeCode.bool
		
		is AlreadyNegated			// speedie crashing somehow but it is used OK elsewhere?
		if self is CondRequest
			isnt condrequest
			is cond
		return self 
		
		
	function BitsAreCorrect (|int| gap, |bool|)
		return  gap == 0  or   self is bitcorrect  or   .reg == 0  or  .µtype is bool


	function BadBits (|asmreg| r, |errorint|)
		|| gl = .GapBits
		|| gr = r.GapBits
		|| cl =  .BitsAreCorrect(gl)
		|| cr = r.BitsAreCorrect(gr)
		if (cl and cr)
			return 0
		if (gl == gr)
			return gl
		if (gl < gr) and cr
			return gl
		if (gl > gr) and cl
			return gr
		
		return -1
			
		// if the smaller one is bit-correct... its ok? lets see:
		// byte GB vs int  OK	// needs correct
		// int  OK vs byte GB 	// needs correct
		// byte OK vs int  GB 	// can CMPI
		// int  GB vs byte OK	// can CMPI



extend ASMState
	function EqualsInt (|asmreg| dest, |asmreg| L, |asmreg| R, |message| exp, |&fatasm|)
		|| negate = dest is negate
		|| badness = l.BadBits(r) 

		if (dest is condrequest) and (badness >= 0)
			if badness > 0
				dest = .TempMe(exp, dest)
				.AddASM(asm.BCMP, exp, dest, L, R, badness, Negate|int|)
				r = dest
				l = 0.asm
			if !l.reg
				return .AddASM(asm.BRAA • negate, exp, R, 1)
			return .AddASM(asm.JMPE • Negate, exp, L, R)

		
		if badness > 0
			return .AddASM(asm.BCMP, exp, dest, L, R, badness, negate|int|)

		if badness == -1
			|| gl = l.GapBits
			|| gr = r.GapBits
			.AddASM(asm.BCLR, exp, L, R, gl, gr, (l.signed|int|) + (r.signed|int|<<1))
		return .AddASM(asm.JMPE • Negate, exp, L, R, dest)
				
	
	
	function Equals (fn_opasm)
		if r.reg == 0  and  l.reg != 0
			swap (l) (r) // put reg 0 into the left... more convenient.

		if dest.IsInt
			rz = .equalsint(dest, l, r, exp)
		  else
			|| Mode = 2+(dest is negate)
			rz = .Compare(dest, l, r, exp, mode)
		rz.reg = rz.reg.boolasm
//		return dest.boolasm
	
		
	function NotEq  (fn_opasm)
		return .Equals(dest.negate, l, r, exp)


	function CompareInt (|asmreg| dest, |asmreg| L, |asmreg| R, |message| exp, |int| Mode, |&fatasm|)
		|| bb = l.bitcount max r.bitcount
		if !l.signed
			mode += 8
			if r.signed and r.bitcount >= l.bitcount // bad
		  elseif !r.signed
			if l.signed and l.bitcount >= r.bitcount // bad

		|| bigness = (bb.log2-3)<<1
		mode += bigness
		
		if l.BadBits(r) 
			|| gl = l.GapBits
			|| gr = r.GapBits
			.AddASM(asm.BCLR, exp, L, R, gl, gr, (l.signed|int|) + (r.signed|int|<<1))

		|| OPP = (asm.JMPI, asm.CMPI)(dest is condrequest)
		return .AddASM(OPP, exp, L, R, mode, dest)


	function CompareFloat (|asmreg| dest, |asmreg| L, |asmreg| R, |message| exp, |int| Mode, |&fatasm|)
		mode += 8 * l.isbig
		mode += 4 * r.isbig
		|| OPP = (asm.JMPF, asm.CMPF)(dest is condrequest)
		return .AddASM(OPP, exp, L, R, Mode, dest) // it is cmpf either way


	function Compare (|asmreg| dest,  |asmreg| L,  |asmreg| R,  |message| exp,  |int| Mode,  |!&fatasm|)
		if dest.IsInt
			rz = .compareint(dest, l, r, exp, mode)
		  else
			rz = .comparefloat(dest, l, r, exp, mode)
		rz.reg = rz.reg.boolasm
//		if rz.Reg.µType != des
	
	function Less   (fn_opasm)
		return .compare(dest, l, r, exp, 1)

	function MoreEq (fn_opasm)
		return .compare(Dest, r, l, exp, 1)

	function More   (fn_opasm)
		return .compare(dest, l, r, exp, 0)

	function LessEq (fn_opasm)
		return .compare(Dest, r, l, exp, 0)
	


	// MATH
	
	
	function TypeCast (fn_OpASM)
		debugger 
		return .Zero
//function DoSingleMath (|&ASMState| self, |message| exp, |AsmReg| Dest, |scoperator!| Scop, |AsmReg|)
//	|| Src = .µ(exp, dest)
//	(src is SingleExpr)
//		.AddBit( "",	"RotateRight",	&asmstate.ROR,		asmmath.ROR,	opmode.shift)
//	return DoMathSub(self, exp, dest, src, scop)
		

	function QuickFloatPlus    (fn_OpASM2)
		require r is ConstAny
		|| v = .f(r)
		if v == 0.0
			return .assign(dest, l, asmreg(), exp)
		
		if r.fourbytes
			|| k = self[r][]
			if (k >> 18) << 18 != k
				debugger, #!hmmm. const-optimiser/renderer will handle it, but lets check to make sure
			return .AddASM(asm.fadk, exp, dest, l, k)


	function QuickFloatDiv    (fn_OpASM2)
		require r is ConstAny
		|| p = self[r]
		|ivec2| ex
		// we could optimise f/-1.0 or f/-0.5... but who cares. dont write such dumb code.
		if l.IsBig
			|| f = p|&f64|[0]
			require f > 0
			ex = f.exponent
		  else
			|| f = p|&float|[0]
			require f > 0
			ex = f.exponent
		
		if ex.y == 1
			return .AddASM(asm.FEXK, exp, dest, L, 0, ex.x, l.IsBig|int|)


	function QuickIntMul    (fn_OpASM2)
		|| PToi = .IntPowerOftwo(r)$

		if ptoi <= 1
			if ptoi == -1							//   y = x * -1  -->  y = 0-x 
				return .subtract(dest, asmreg(), l, exp)
			if ptoi == 0    						//   y = x * 0   -->  y = 0
				l = asmreg()						//   y = x * 1   -->  y = x 
			return .assign(dest, l, asmreg(), exp)
	
		return .AddASM(asm.BLUE , exp, dest, l, ptoi - 1)  // y = x * 4 --> y = x << 2


	function QuickFloatMul    (fn_OpASM2)
		require r is ConstAny	
		|| v = .f(r)
		if  v == -1.0
			return .Subtract(dest, asmreg(), l, exp)
		
		if  v == 1.0  or  v == 0.0
			if v == 0.0
				l = asmreg()
			return .assign(dest, l, asmreg(), exp)
		
		if  v == 2.0
			return .plus(dest, l, l, exp)
		
		if r.Fourbytes
			|| x = self[r][]
			|| y = x >> 18
			if x == y << 18
				return .AddASM(asm.FMLK, exp, dest, l, x)

	
	function PlusInt     (fn_opasm)
		|| LL = self[L][],		|| RR = self[R][]
		//		a - 1,		a + 1
		//		1 - a,		1 + a
		|| subtract = l is alternate
			RR = -RR

		if !subtract and l.CanAddK(LL)					// 1 + a
			rz = .AddASM(asm.ADDK, exp, dest, R, LL)
//			exp.addk(dest, R, LL)

		  elseif r.CanAddK(RR)							// a - 1,  a + 1
			rz = .AddASM(asm.ADDK, exp, dest, L, RR)

		  elseif subtract
			rz = .AddASM(asm.SUBB, exp, dest, L, R)

		  else
			rz = .AddASM(asm.ADD, exp, dest, L.l(r), R.r(l))
		
		// so... how do we calculate the const? I'd rather do it in one place... honestly.
		// we could go through one by one, though... its ok either way


	function PlusFloat   (fn_opasm)
		|| IsFloat = dest.FourBytes
			|| A = .QuickFloatPlus(dest, r, l, exp)
				return A
			|| B = .QuickFloatPlus(dest, l, r, exp)
				return B

		|| SubTract = (l is alternate)
		return .AddASM(asm.fADD, exp, dest, l, r.reg*!subtract, r.reg*subtract, 1-isfloat)

// do this transform here:
// p1 = p2 * k3,  f1 = f2 + p1  -->  f1 = f2 + (p2 << log2(k3))	
// we need the info on double/float...
//	if p isa ASM.FMLK
//		|| k = p.a3|int|.asfloat.Log2
//		require !k.Fract and !.match3_2(out)
//		.op = asm.fexk
//		.a3 = p.a2
//		.a4 = k|int|
//		return true
// FEXK  (FloatAddExp)
//		f1 = FloatSh1(u2, r4) + FloatSh1(u3, r5)



	function BoolMul (|asmreg| dest, |asmreg| Boo, |asmreg| V, |message| exp, |&fatasm|)
		return .addasm(asm.TERN, exp, dest, boo, V)

		
	function Plus   (fn_opasm) // add (
		if !r.reg
			return .assign(dest, l, AsmReg(), exp)
		if !l.reg and (l isnt alternate)
			return .assign(dest, R, AsmReg(), exp)
		if l.isint
			return .PlusInt(dest, l, r, exp)
		return .PlusFloat(dest, l, r, exp)


	function Subtract  (fn_opasm)
		(l is alternate) // the logic ismostly shared...
		return .plus(dest, l, r, exp)


	function Mul    (fn_opasm)
		|| b = DataTypeCode.bool
		if l isa b
			return .BoolMul(dest, l, r, exp)
		if r isa b
			return .BoolMul(dest, r, l, exp)
			
		if l is ConstAny
			swap (l) (r)
		if l.isint
			|| D1 = .QuickIntMul(dest, R, L, exp)
				return D1
			|| D2 = .QuickIntMul(dest, L, R, exp)
				return D2
			return .AddASM(asm.MULT , exp, dest, L, R)
		  else
			|| D1 = .QuickFloatMul(dest, R, L, exp)
				return D1
			|| D2 = .QuickFloatMul(dest, L, R, exp)
				return D2
			return .AddASM(asm.FMUL, exp, dest, L, R, l.IsBig|int|) 
	

	function Div    (fn_opasm)
		if dest.isint
			return .DivInt(dest, l, r, exp)
		return .DivFloat(dest, l, r, exp)
	
	
	function DivFloat    (fn_opasm)
		|| D1 = .QuickFloatDiv(dest, R, L, exp)
			return D1
		|| D2 = .QuickFloatDiv(dest, L, R, exp)
			return D2
		|| big = dest.IsBig|int|
		rz = .AddASM(asm.FDIV, exp, dest, big, L, R)
		|| Alt = l is alternate
			rz = .AddASM(asm.FFRC, exp, dest, big, dest, R)

	

	function DivInt    (fn_opasm)
		|| Alt = l is alternate
		|| d = dest.Reg
		return .AddASM(asm.DIVV, exp, d*!alt, d*alt, L, R, dest.IntDivType)
	
	
	function Mod    (fn_opasm)
		(l is Alternate)
		return .div(dest, l, r, exp)


	// BITS
	function BitNot (fn_opasm)
		if r.reg // what?
		return .AddASM(asm.BNOT, exp, dest, l, l)
	
	function BitXor (fn_opasm)
		if (l.reg == r.reg)
			return .BitOr(dest, asmreg(), asmreg(), exp)
		return .AddASM(asm.BXOR, exp, dest, L.l(r), R.r(l))

	function BitOr  (fn_opasm)
		if l is ConstAny
			swap (l) (r)
		|| dd = dest.reg
		if !dd
			debugger 
		|| rr = r.reg,  || ll = l.reg
		if ll == 0							// swap
			swap (ll) (rr)
		  elseif (ll == rr)
			rr = 0							// same thing
		if rr == 0 and dd == ll
			debugger // we need to return the left asm. how to get it?
			return dest.fat						// no need
		return .AddASM(asm.BOAR, exp, dest, L, R)
	
	function BitAnd (fn_opasm)		
		return .AddASM(asm.BAND, exp, dest, L.l(R), R.r(l))
	
	function ROL    (fn_opasm)
		return .AddASM(asm.BROL, exp, dest, L, R)
	
	function ROR    (fn_opasm)
		return .AddASM(asm.BROR, exp, dest, L, R)
	
	function ConstForShift (|asmreg| r, |int| btc, |message| exp,  |int64|)
		rz = self[r][] #debug_require
		if rz < 0
			error (exp, "Can't negative shift")
		  elseif rz >= btc
			error (exp, "Shift too large for type")
		
		
	function SHR    (fn_opasm)
		if !r.Reg
			// how to find the asm for this?
			return l.fat
		|| btc = l.bitcount
		|| up = 64 - btc
		if r is ConstAny
			|| sh = .ConstForShift(r, btc, exp)
			if !sh: return l.fat // what?
			if l.signed
				return .AddASM(asm.BFLG, exp, dest, l, up, sh+up)
			  else
				return .AddASM(asm.BFLG, exp, dest, l,  0, sh, 1)

		return .AddASM(asm.BRUS • !l.signed, exp, dest, L, R, up*l.signed)
	
	
	function SHL    (fn_opasm)
		if !r.Reg
			return l.fat
		|| btc = l.bitcount
		|| up = 64 - btc
		if r is ConstAny
			|| sh = .ConstForShift(r, btc, exp)
			if !sh: return l.fat // what?
			return .AddASM(asm.BFLG, exp, dest, l,  sh, 0, 1)
		return .AddASM(asm.BLUE, exp, dest, L, R), return dest
	
	
	function Assign (fn_opasm)
		return .bitor(dest, l, asmreg(), exp)



function asmreg.l (|asmreg| r, |asmreg|)
	return (r, self)(self is ConstAny)


function asmreg.r (|asmreg| r, |asmreg|)
	return (r, self)(r is ConstAny)

