

prototype fn_OpASM  (|&ASMState| self, |asmreg| dest, |asmreg| L, |asmreg| R, |message| exp, |!&fatasm|)
prototype fn_OpASM2 (|&ASMState| self, |asmreg| dest, |asmreg| L, |asmreg| R, |message| exp, |?&fatasm|)


extend asmreg
	function boolasm (|asmreg|)
		.µtype = DataTypeCode.bool
		
		is AlreadyNegated			// speedie crashing somehow but it is used OK elsewhere?
		if self is CondRequest
			isnt condrequest
			is cond
		return self 
		
		
	function BitsAreCorrect (|int| gap, |bool|)
		return  gap == 0  or   self is bitcorrect  or   .reg == 0  or  .µtype is bool


	function BadBits (|asmreg| r, |errorint|)
		|| gl = .GapBits
		|| gr = r.GapBits
		|| cl =  .BitsAreCorrect(gl)
		|| cr = r.BitsAreCorrect(gr)
		if (cl and cr)
			return 0
		if (gl == gr)
			return gl
		if (gl < gr) and cr
			return gl
		if (gl > gr) and cl
			return gr
		
		return -1
			
		// if the smaller one is bit-correct... its ok? lets see:
		// byte GB vs int  OK	// needs correct
		// int  OK vs byte GB 	// needs correct
		// byte OK vs int  GB 	// can CMPI
		// int  GB vs byte OK	// can CMPI



extend ASMState
	function EqualsInt (|asmreg| dest, |asmreg| L, |asmreg| R, |message| exp, |&fatasm|)
		|| negate = dest is negate
		|| badness = l.BadBits(r) 

		if (dest is condrequest) and (badness >= 0)
			if badness > 0
				dest = .TempMe(exp, dest)
				.AddASM(asm.BCMP, exp, dest, L, R, badness, Negate|int|)
				r = dest
				l = 0.asm
			if !l.reg
				return .AddASM(asm.JBRA • negate, exp, R, 1)
			return .AddASM(asm.JMPE • Negate, exp, L, R)

		
		if badness > 0
			return .AddASM(asm.BCMP, exp, dest, L, R, badness, negate|int|)

		if badness == -1
			|| gl = l.GapBits
			|| gr = r.GapBits
			.AddASM(asm.BCLR, exp, L, R, gl, gr, (l.signed|int|) + (r.signed|int|<<1))
		return .AddASM(asm.JMPE • Negate, exp, L, R, dest)
				
	
	
	function Equals (fn_opasm)
		if r.reg == 0  and  l.reg != 0
			swap (l) (r) // put reg 0 into the left... more convenient.

		if dest.IsInt
			rz = .equalsint(dest, l, r, exp)
		  else
			|| Mode = 2+(dest is negate)
			rz = .Compare(dest, l, r, exp, mode)
		rz.reg = rz.reg.boolasm
//		return dest.boolasm
	
		
	function NotEq  (fn_opasm)
		return .Equals(dest.negate, l, r, exp)


	function CompareInt (|asmreg| dest, |asmreg| L, |asmreg| R, |message| exp, |int| Mode, |&fatasm|)
		|| bb = l.bitcount max r.bitcount
		if !l.signed
			mode += 8
			if r.signed and r.bitcount >= l.bitcount // bad
		  elseif !r.signed
			if l.signed and l.bitcount >= r.bitcount // bad

		|| bigness = (bb.log2-3)<<1
		mode += bigness
		
		if l.BadBits(r) 
			|| gl = l.GapBits
			|| gr = r.GapBits
			.AddASM(asm.BCLR, exp, L, R, gl, gr, (l.signed|int|) + (r.signed|int|<<1))

		|| OPP = (asm.JMPI, asm.CMPI)(dest is condrequest)
		return .AddASM(OPP, exp, L, R, mode, dest)


	function CompareFloat (|asmreg| dest, |asmreg| L, |asmreg| R, |message| exp, |int| Mode, |&fatasm|)
		mode += 8 * l.isbig
		mode += 4 * r.isbig
		|| OPP = (asm.JMPF, asm.CMPF)(dest is condrequest)
		return .AddASM(OPP, exp, L, R, Mode, dest) // it is cmpf either way


	function Compare (|asmreg| dest,  |asmreg| L,  |asmreg| R,  |message| exp,  |int| Mode,  |!&fatasm|)
		if dest.IsInt
			rz = .compareint(dest, l, r, exp, mode)
		  else
			rz = .comparefloat(dest, l, r, exp, mode)
		rz.reg = rz.reg.boolasm
//		if rz.Reg.µType != des
	
	function Less   (fn_opasm)
		return .compare(dest, l, r, exp, 1)

	function MoreEq (fn_opasm)
		return .compare(Dest, r, l, exp, 1)

	function More   (fn_opasm)
		return .compare(dest, l, r, exp, 0)

	function LessEq (fn_opasm)
		return .compare(Dest, r, l, exp, 0)
	


	// MATH		

	function QuickFloatPlus    (fn_OpASM2)
		require r is ConstAny
		|| v = .f(r)
		if v == 0.0
			return .assign(dest, l, asmreg(), exp)
		
		if r.fourbytes
			|| k = self[r][]
			if (k >> 18) << 18 != k
				debugger, #!hmmm. const-optimiser/renderer will handle it, but lets check to make sure
			return .AddASM(asm.fadk, exp, dest, l, k)


	function QuickFloatDiv    (fn_OpASM2)
		require r is ConstAny
		|| p = self[r]
		|ivec2| ex
		// we could optimise f/-1.0 or f/-0.5... but who cares. dont write such dumb code.
		if l.IsBig
			|| f = p|&f64|[]
			require f > 0
			ex = f.exponent
		  else
			|| f = p|&float|[]
			require f > 0
			ex = f.exponent
		
		if ex.y == 1
			return .AddASM(asm.FEXK, exp, dest, L, 0, ex.x, l.IsBig|int|)


	function QuickIntMul    (fn_OpASM2)
		|| PToi = .IntPowerOftwo(r)$

		if ptoi <= 1
			if ptoi == -1							//   y = x * -1  -->  y = 0-x 
				return .subtract(dest, asmreg(), l, exp)
			if ptoi == 0    						//   y = x * 0   -->  y = 0
				l = asmreg()						//   y = x * 1   -->  y = x 
			return .assign(dest, l, asmreg(), exp)
	
		return .AddASM(asm.BLUE , exp, dest, l, ptoi - 1)  // y = x * 4 --> y = x << 2


	function QuickFloatMul    (fn_OpASM2)
		require r is ConstAny	
		|| v = .f(r)
		if  v == -1.0
			return .Subtract(dest, asmreg(), l, exp)
		
		if  v == 1.0  or  v == 0.0
			if v == 0.0
				l = asmreg()
			return .assign(dest, l, asmreg(), exp)
		
		if  v == 2.0
			return .plus(dest, l, l, exp)
		
		if r.Fourbytes
			|| x = self[r][]
			|| y = x >> 18
			if x == y << 18
				return .AddASM(asm.FMLK, exp, dest, l, x)

	
	function PlusInt     (fn_opasm)
		|| LL = self[L][],		|| RR = self[R][]
		//		a - 1,		a + 1
		//		1 - a,		1 + a
		|| subtract = l is alternate
			RR = -RR

		if !subtract and l.CanAddK(LL)					// 1 + a
			rz = .AddASM(asm.ADDK, exp, dest, R, LL)
//			exp.addk(dest, R, LL)

		  elseif r.CanAddK(RR)							// a - 1,  a + 1
			rz = .AddASM(asm.ADDK, exp, dest, L, RR)

		  elseif subtract
			rz = .AddASM(asm.SUBB, exp, dest, L, R)

		  else
			rz = .AddASM(asm.ADD, exp, dest, L.l(r), R.r(l))
		
		// so... how do we calculate the const? I'd rather do it in one place... honestly.
		// we could go through one by one, though... its ok either way
		
	function PlusFloat   (fn_opasm)
		|| IsF32 = dest.FourBytes
			|| A = .QuickFloatPlus(dest, r, l, exp)
				return A
			|| B = .QuickFloatPlus(dest, l, r, exp)
				return B

		|| ss = (l is alternate)
		|| rr = r.reg
		rz = .AddASM(asm.fADD, exp, dest, l, rr*!ss, rr*ss, 1-IsF32)
		ifn dest is ConstAny
			0 //
		  elseif IsF32
			|| rf = r.F32
			|| lf = l.F32
			if ss
				lf += rf
			  else
				lf -= rf
			rz.F32 = lf
		  else
			|| rf = r.F64
			|| lf = l.F64
			if ss
				lf += rf
			  else
				lf -= rf
			rz.F64 = lf


// do this transform here:
// p1 = p2 * k3,  f1 = f2 + p1  -->  f1 = f2 + (p2 << log2(k3))	
// we need the info on double/float...
//	if p isa ASM.FMLK
//		|| k = p.a3|int|.asfloat.Log2
//		require !k.Fract and !.match3_2(out)
//		.op = asm.fexk
//		.a3 = p.a2
//		.a4 = k|int|
//		return true
// FEXK  (FloatAddExp)
//		f1 = FloatSh1(u2, r4) + FloatSh1(u3, r5)



	function BoolMul (|asmreg| dest, |asmreg| Boo, |asmreg| V, |message| exp, |&fatasm|)
		return .addasm(asm.TERN, exp, dest, boo, V)

		
	function Plus   (fn_opasm) // add (
		if !r.reg
			return .assign(dest, l, AsmReg(), exp)
		if !l.reg and (l isnt alternate)
			return .assign(dest, R, AsmReg(), exp)
		if l.isint
			return .PlusInt(dest, l, r, exp)
		return .PlusFloat(dest, l, r, exp)


	function Subtract  (fn_opasm)
		(l is alternate) // the logic ismostly shared...
		return .plus(dest, l, r, exp)


	function IntMul (fn_opasm)
		rz = .QuickIntMul(dest, R, L, exp)
		rz := .QuickIntMul(dest, L, R, exp)
		rz := .AddASM(asm.MULT , exp, dest, L, R)
		if dest is ConstAny
			rz.const = l.const * r.const


	function FloatMul (fn_opasm)
		rz = .QuickFloatMul(dest, R, L, exp)
		rz := .QuickFloatMul(dest, L, R, exp)
		rz := .AddASM(asm.FMUL, exp, dest, L, R, l.IsBig|int|) 
		ifn dest is ConstAny
			0 //
		  elseif dest.FourBytes
			rz.F32 = l.F32 * r.F32
		  else
			rz.F64 = l.F64 * r.F64


	function Mul    (fn_opasm)
		|| b = DataTypeCode.bool
		if l isa b
			return .BoolMul(dest, l, r, exp)
		if r isa b
			return .BoolMul(dest, r, l, exp)
			
		if l is ConstAny
			swap (l) (r)
		if l.isint
			|| D1 = .QuickIntMul(dest, R, L, exp)
				return D1
			|| D2 = .QuickIntMul(dest, L, R, exp)
				return D2
			return .AddASM(asm.MULT , exp, dest, L, R)
		  else
			return .floatmul(Dest, l, r, exp)
	

	function Div    (fn_opasm)
		if dest.isint
			return .DivInt(dest, l, r, exp)
		return .DivFloat(dest, l, r, exp)
	
	
	function DivFloat    (fn_opasm)
		rz = .QuickFloatDiv(dest, R, L, exp)
		rz := .QuickFloatDiv(dest, L, R, exp)
		rz := .AddASM(asm.FDIV,  exp,  dest,  dest.isbig|int|,  L,  R)
		if dest is ConstAny
			if dest.FourBytes
				rz.f32 = l.f32 / r.f32
			  else
				rz.f64 = l.f64 / r.f64


	function DivInt    (fn_opasm)
		rz = .AddASM(asm.DIVV, exp, dest.reg, 0, L, R, dest.IntDivType)
		if dest is ConstAny
			|int64| C
			if dest.FourBytes
				if dest.Signed
					C = l.const|int| / r.const|int|
				  else
					C = l.const|uint| / r.const|uint|
			  else
				if dest.Signed
					C = l.const|int64| / r.const|int64|
				  else
					C = l.const|uint64| / r.const|uint64|
			rz.Const = C
	
	
	function ModFloat    (fn_opasm)
		|| d = dest.Reg #check (Exp)
		|| big = dest.IsBig|int|
		.AddASM(asm.FDIV, exp, dest, big, L, R)
		rz = .AddASM(asm.FFRC, exp, dest, big, dest, R)
		if dest is ConstAny
			if dest.FourBytes
				rz.f32 = l.f32 mod r.f32
			  else
				rz.f64 = l.f64 mod r.f64
	
	
	function ModInt    (fn_opasm)
		rz = .AddASM(asm.DIVV, exp, 0, dest, L, R, dest.IntDivType)
		if dest is ConstAny
			|int64| C
			if dest.FourBytes
				if dest.Signed
					C = l.const|int| mod r.const|int|
				  else
					C = l.const|uint| mod r.const|uint|
			  else
				if dest.Signed
					C = l.const|int64| mod r.const|int64|
				  else
					C = l.const|uint64| mod r.const|uint64|
			rz.Const = C
	
	
	function Mod    (fn_opasm)
		if dest.isint
			return .ModInt(dest, l, r, exp)
		return .ModFloat(dest, l, r, exp)
		


	// BITS
	function BitNot (fn_opasm)
		if r.reg // what?
		return .AddASM(asm.BNOT, exp, dest, l, l)
	
	function BitXor (fn_opasm)
		if (l.reg == r.reg)
			return .BitOr(dest, asmreg(), asmreg(), exp)
		return .AddASM(asm.BXOR, exp, dest, L.l(r), R.r(l))

	function BitOr  (fn_opasm)
		if l is ConstAny
			swap (l) (r)
		|| dd = dest.reg
		if !dd
			debugger 
		return .AddASM(asm.BOAR, exp, dest, L, R)
	
	function BitAnd (fn_opasm)		
		return .AddASM(asm.BAND, exp, dest, L.l(R), R.r(l))
	
	function ROL    (fn_opasm)
		return .AddASM(asm.BROL, exp, dest, L, R)
	
	function ROR    (fn_opasm)
		return .AddASM(asm.BROR, exp, dest, L, R)
	
	function ConstForShift (|asmreg| r, |int| btc, |message| exp,  |int64|)
		rz = self[r][] #debug_require
		if rz < 0
			error (exp, "Can't negative shift")
		  elseif rz >= btc
			error (exp, "Shift too large for type")
		
		
	function SHR    (fn_opasm)
		if !r.Reg
			// how to find the asm for this?
			return l.fat
		|| btc = l.bitcount
		|| up = 64 - btc
		if r is ConstAny
			|| sh = .ConstForShift(r, btc, exp)
			if !sh: return l.fat // what?
			if l.signed
				return .AddASM(asm.BFLG, exp, dest, l, up, sh+up)
			  else
				return .AddASM(asm.BFLG, exp, dest, l,  0, sh, 1)

		return .AddASM(asm.BRUS • !l.signed, exp, dest, L, R, up*l.signed)
	
	
	function SHL    (fn_opasm)
		if !r.Reg
			return l.fat
		|| btc = l.bitcount
		|| up = 64 - btc
		if r is ConstAny
			|| sh = .ConstForShift(r, btc, exp)
			if !sh: return l.fat // what?
			return .AddASM(asm.BFLG, exp, dest, l,  sh, 0, 1)
		return .AddASM(asm.BLUE, exp, dest, L, R), return dest
	
	
	function Assign (fn_opasm)
		return .bitor(dest, l, asmreg(), exp)



function asmreg.l (|asmreg| r, |asmreg|)
	return (r, self)(self is ConstAny)


function asmreg.r (|asmreg| r, |asmreg|)
	return (r, self)(r is ConstAny)

