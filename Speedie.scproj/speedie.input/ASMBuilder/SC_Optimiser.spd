


function asmstate.Optimise 
	|| A = .Curr
	|| S = .FuncStart
	// jumps of 0 can be rendered as a nop
	while A > S
		if S.JumpReg
			S.JumpImprove
		  else
			S.MiniOpt(Self)
		S++
	


function uint.IsTemp (|bool|)
	return self & 1<<31

	FNCX: r2, 1225, 123336, 0                      /* JB_f_SyntaxAccess(0.5) */
	BOR:  t31, r2, r0, 0                           /* JB_f_SyntaxAccess(0.5) */
	JBAN: t31, 1                                   /* hhhMaybeConst(0) */


function uint.OperatorSameReg (|uint| R, |bool|)
	return self&31 == R&31


function fatasm.OptBor (|asmstate| A)
	|| dest = .r0
	|| input = .r1
	require dest.IsTemp and !input.istemp and !.r2 and !.r3
	// Now what? its a temp. We wanna check the prev and next.
	|| p = .prev
	|| n = .next
	require p and n
	require p.Out SameReg input
	require n.ReplaceReg(dest&31, input)
	// what do I do now that we found this match? how to opt it?
	a.nop(Self)
	print "OptBor "
	.DebugPrint
	
	
function FatASM.ReplaceReg (|uint| Dest, |uint| New, |bool|)
	dest &= 31
	for i.reginputs in self
		if .r[i] & 31 == dest
			.r[i] = new
			rz = true
			.InputFats &=~ (1<<i) // not sure what the fat of New is? Its not an ASMReg is it?


function fatasm.MiniOpt (|asmstate| A)
// we aren't doing a full optimiser. A few mini-opts could be nice
	if self isa asm.bor
		.OptBor(A)


