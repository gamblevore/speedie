

/*
	* BFLS, BFLG					// x = (a & b)>>c (so SHL SHR)
									// x = x | (y << 5) // whatever... that kinda thing
	* add blocks to the "if (" function :)
*/


function SpdAssembler.Optimise (|scfunction| fn, |bool|)
	opt norefcounts
	|| raw = fn.ASM$
	|| Curr = raw.IR
	|| length = raw.length
	if curr[-1].op or curr[length-1].op // bad

	for i in length
		|| x = (µOpt[i])
			(x)(curr+i)
//	.AddASM(asm.ADDK, exp, dest, obj, pos)

	if curr[-1].op or curr[length-1].op // bad



dispatch µOpt (|&fatasm| self, |int|)
	(ASM.ADDK):    {}
	(ASM.FUNC):    {} // tail, fncx
	(ASM.CNTC):    {} // (addr+=n), cntc(addr, 0) --> cntc(addr, n)
	(ASM.TABL):    {} // Glob = glob + 1-127 // --> cntc
	(ASM.ADD):     {} //a*b + c --> MUL
	(ASM.FADD):    {} //a*b + c --> MUL,   a*k1 + b*k2 -> FEXK // could perhaps do these at the time.

/*
	* flowcontrol
		* LUPU/LUPD
		* if x: return true/false --> conditional return 
*/
	(ASM.CMPF):    {} // control flow?
	(ASM.CMPI):    {}
	(ASM.JMPI):    {}
	(ASM.JMPF):    {}
	(ASM.JMPN):    {}
	(ASM.JMPE):    {}
	255:  {}

