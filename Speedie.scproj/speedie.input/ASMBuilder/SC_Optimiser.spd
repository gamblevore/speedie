
// inlining do separately

// dead code removal... IDK?
// we need to also opt a+0 into a
// basically most of the quickopts I already did... need to be redone??
// if (a+b==x)
	//// do nothing
// a = b

function SpdAssembler.MarkBlocks (|&FatASM| curr, |int| length)
	|| first = asm.JUMP.op,  || last = asm.LUPU.op
	|| B = 1
	for i in length
		curr.BlockNum = b
		|| op = curr.op
		if (op >= first and op <= last)
			B++

	
function µfunc.Sanity
	|| Curr = .IR
	|| length = .length
	if curr[-1].op or curr[length-1].op // bad

	
function SpdAssembler.Optimise (|µfunc| raw, |bool|)
	raw.Sanity
	|| Curr = raw.IR
	.MarkBlocks(Curr, raw.length)
	|| opts = 0
	|| last = curr + raw.Length
	while curr < last
		|| x = (µOpt[curr.op])
			|| p = curr.prev
			|| n = curr.next
			if n or p
				|| Code = (x)(curr, p, n)
				rz |= Code!=0
				opts += Code>>1
	raw.Sanity


extend FatASM
	setter Debug (|message|)

		|| fn = Value.FileNum
		if fn >= 4096
			fn = 0 // sigh
		.Location = fn ||| Value.Position << 12 // 4K max files


dispatch µOpt (|&fatasm| self, |?&fatasm| P, |?&fatasm| N, |int|)
	(ASM.FUNC2):  OptFunc
	(ASM.FUNC3):  OptFunc
		
		
	(ASM.CNTC):   OptCount
	(ASM.TABL):   OptTabl

	(ASM.SUBB):   OptSubI
	(ASM.ADDK):   OptAddK
	(ASM.ADD):    OptAddI
	(ASM.FADD):   OptAddF
	(ASM.FADK):   OptFADK
	

	(ASM.BRUE):   OptShifting
	(ASM.BRUS):   OptShifting
	(ASM.BLUE):   OptShifting
	(ASM.BOAR):   OptBitOr
	(ASM.CMPF):	  OptCompare
	(ASM.CMPI):   OptCompare
	(ASM.JUMP):   OptJump // control flow?
	(ASM.JMPI):   OptJumpC
	(ASM.JMPF):   OptJumpC
	(ASM.JMPN):   OptJumpE
	(ASM.JMPE):   OptJumpE
	(ASM.BRAA):   OptBra
	(ASM.BRAN):   OptBra
	255:  {}



function OptFunc (Fn_µOpt)
	// TAILCALL
	require N isa asm.ret
	|| RetResult = N.r[0]
	|| FuncResult = .r[0]
	if RetResult == FuncResult // Return the result of this function
		.op = asm.tail
		return N.nop


function OptCount (Fn_µOpt)
	// (addr+=n), cntc(addr, 0) --> cntc(addr, n)


function OptTabl (Fn_µOpt)
	// Glob = glob + 1-127 // --> cntc
	
	
function OptAddK (Fn_µOpt)	
	// a = b + k1 + k2   -->   a = b + k3
	require p isa asm.addk
	|| pout = p.r[0]
	|| myin = .r[1]
	if pout == myin
		|| add2 = p.r[2]|int64| + .r[1]|int64|
		if add2.Canint32
			.r[1] = add2
			return 2


function OptFADK (Fn_µOpt)	
	// a = b + k1 + k2   -->   a = b + k3
	require p isa asm.fadk
	|| pout = p.r[0]
	|| myin = .r[1]
	if pout == myin
		|| add2 = p.r[2]|int|.asfloat + .r[1]|int|.asfloat
		.r[1] = add2.AsInt
		return 2
	

function OptSubI (Fn_µOpt)
	if p isa asm.bflg
		return OptAddI(self, p, n)


function OptAddI (Fn_µOpt)
	// a dead-code finder will remove old ops.

	require p and !.r[3]
	|| out = p.r[0]
	if out == .r[1]
		.swap(1,2)
	  else
		require out == .r[2]

	if p isa asm.MULT   // needs SSA. lets just assume it is, for now.
		// x2 = x1 * x1,  a = b + x2   -->   a = x1 * x1 + b
		.op = asm.MULT
		.r[3] = .r[1]
		.r[2] = p.r[2]
		.r[1] = p.r[1]
		return 2

	// c = d << k,  a = b + c  <-- a = b + (d << k)
	if (p isa asm.BFLG)
		if p.r[4]					// unsigned
			.r[3] = p.r[2]			// a = b + (c << k)
			.r[2] = p.r[1]			// could trigger dead-code removal
			return 2


function OptAddF (Fn_µOpt)
 //a*b + c --> MUL
	require p  and  p.r[4] == .r[4] // both are 64.  or both are 32
	|| out = p.r[0]
	if p isa asm.FADD
		if !p.r[3] and !.r[2]
			if out == .r[1]
				
//		pa = f2 + f3,   f1 = pa - f4   <--   f1 = f2 + f3 - f4
			
		if !p.r[2] and !.r[3]
//		pa = p2 - p4,   f1 = pa + f3   <--   f1 = pa + f3 - p4
//		pa = p2 - p4,   f1 = f2 + pa   <--   f1 = f2 + pa - p4


	if p isa asm.FMUL
// FADD  (Float)
//		f1 = f2 + f3 - f4
// FMUL  (Float)
//		f1 = (f2 * f3)+f4
// FEXK  (FloatAddExp)
//		f1 = FloatSh1(u2, FloatAddExp_Sh2i) + FloatSh1(u3, FloatAddExp_Sh3i)

// a*k1 + b*k2 -> FEXK // could perhaps do these at the time.



function OptShifting (fn_µopt)
/*
//	BFLD
//		r1		r
//		r2		r
//		up		6
//		down	6

BFLG
	if (BFLD_Lu)
		i1 = ((i2 << BFLD_upu) >> BFLD_downu)
	  else
		u1 = ((u2 << BFLD_upu) >> BFLD_downu)

BFLS
	i1 |= ((i2 << BFLD_downu) >> BFLD_upu)

	// x = (a & k1)>>k2	// if b is contiguous bit-const... yes even like a high or low-bit!
	// x = x | (y << 5) // 5 is a const...
	// i think theres another case of setting or getting bits. like a = b&k... or a = a | k
	// could just take a reg and ~it... including reg 0

*/


function OptBitOr (fn_µopt)
	// i1 |= ((i2 << BFLD_downu) >> BFLD_upu) // can remove a const?
	// u1  = (u2|||u3)&~u4


function OptCompare (fn_µopt)



function OptJump (fn_µopt)
// flowcontrol



function OptJumpC (fn_µopt)
// flowcontrol
// if x: return true/false --> conditional return 
// LUPU/LUPD

function OptJumpE (fn_µopt)
// flowcontrol
// if x: return true/false --> conditional return 
// LUPU/LUPD


function OptBra (fn_µopt)
// flowcontrol
// if x: return true/false --> conditional return 
// LUPU/LUPD



/*
	perhaps all consts should simply be refered to... like 0-31 = reg, and 32+ = const
	Then later the const-filler should insert them at the right places.
	this actually is harder than it seems, because of function calls. but it does make
	optimising consts away... much easier.
	
	a *= 3
	a = func(a)
	b *= 3 // 3 needs reload!
	
	
*/

