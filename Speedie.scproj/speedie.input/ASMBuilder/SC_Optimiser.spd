
// inlining do separately

// dead code removal... IDK?
// we need to also opt a+0 into a
// basically most of the quickopts I already did... need to be redone??
// if (a+b==x)
	//// do nothing
// a = b

function SpdAssembler.MarkBlocks (|&FatASM| curr, |int| length)
	|| first = asm.JUMP.op,  || last = asm.LUPU.op
	|| B = 1
	for i in length
		curr.BlockNum = b
		|| op = curr.op
		if (op >= first and op <= last)
			B++

	
function µfunc.Sanity
	|| Curr = .IR
	|| length = .length
	if curr[-1].op or curr[length-1].op // bad

	
function SpdAssembler.Optimise (|µfunc| raw, |bool|)
	raw.Sanity
	|| Curr = raw.IR
	.MarkBlocks(Curr, raw.length)
	|| opts = 0
	|| last = curr + raw.Length
	while curr < last
		|| x = (µOpt[curr.op])
			|| p = curr.prev
			|| n = curr.next
			if n or p
				rz |= (x)(curr, p, n)
				opts++
	raw.Sanity


extend FatASM
	setter Debug (|message|)

		|| fn = Value.FileNum
		if fn >= 4096
			fn = 0 // sigh
		.Location = fn ||| Value.Position << 12 // 4K max files

	function Nop (|int|)
		.op = asm.noop
		return 2
		

dispatch µOpt (|&fatasm| self, |?&fatasm| P, |?&fatasm| N, |bool|)
	(ASM.FUNC2):  OptFunc
	(ASM.FUNC3):  OptFunc
		
		
	(ASM.CNTC):   OptCount
	(ASM.TABL):   OptTabl

	(ASM.SUBB):   OptSubI
	(ASM.ADDK):   OptAddK
	(ASM.ADD):    OptAddI
	(ASM.FADD):   OptAddF
	(ASM.FADK):   OptFADK
	

	(ASM.TERN):   OptTern
	(ASM.BFLG):   OptBFLG
	(ASM.BFLS):   OptBFLS
	(ASM.BRUU):   OptShifting
	(ASM.BRUS):   OptShifting
	(ASM.BLUE):   OptShifting
	(ASM.BAND):   OptBitAnd
	(ASM.BOAR):   OptBitOr
	(ASM.CMPF):	  OptCompare
	(ASM.CMPI):   OptCompare
	(ASM.JUMP):   OptJump // control flow?
	(ASM.JMPI):   OptJumpC
	(ASM.JMPF):   OptJumpC
	(ASM.JMPN):   OptJumpE
	(ASM.JMPE):   OptJumpE
	(ASM.BRAA):   OptBra
	(ASM.BRAN):   OptBra
	255:  {}



function OptFunc (Fn_µOpt)
	// TAILCALL
	require N isa asm.ret
	|| RetResult = N.a1
	|| FuncResult = .a1
	if RetResult == FuncResult // Return the result of this function
		.op = asm.tail
		return N.nop


function OptCount (Fn_µOpt)
	// (addr+=n), cntc(addr, 0) --> cntc(addr, n)


function OptTabl (Fn_µOpt)
	// Glob = glob + 1-127 // --> cntc
	
	
function OptAddK (Fn_µOpt)	
	// a = b + k1 + k2   -->   a = b + k3
	require p isa asm.addk
	|| pout = p.a1
	|| myin = .a2
	if pout == myin
		|| add2 = p.a3|int64| + .a2|int64|
		if add2.Canint32
			.a2 = add2
			return true


function OptFADK (Fn_µOpt)	
	// a = b + k1 + k2   -->   a = b + k3
	require p isa asm.fadk
	|| pout = p.a1
	|| myin = .a2
	if pout == myin
		|| add2 = p.a3|int|.asfloat + .a2|int|.asfloat
		.a2 = add2.AsInt
		return true
	

function OptSubI (Fn_µOpt)
	if p isa asm.bflg
		return OptAddI(self, p, n)


function FatASM.match3_2 (|int| reg, |bool|)
	// prefers the value to be at 3.
	if reg == .a2
		.swap(2,3)
		return true
	return reg == .a3


function OptAddI (Fn_µOpt)
	// a dead-code finder will remove old ops.

	require p and !.a4
	|| out = p.a1

	// c = d << k,  a = b + c  <-- a = b + (d << k)
	if (p isa asm.BFLG)
		require p.a5 and .match3_2(out)			// unsigned
		.a4 = p.a3
		.a3 = p.a2
		return true

	if p isa asm.MULT // needs SSA
		// x2 = x1 * x1,  a = b + x2   -->   a = x1 * x1 + b
		require .match3_2(out)
		.op = asm.MULT
		.a4 = .a2
		.a3 = p.a3
		.a2 = p.a2
		return true


function OptAddF (Fn_µOpt)
    // a*b + c --> MUL
	require p  and  p.a5 == .a5 // both are 64.  or both are 32
	|| out = p.a1
	if p isa asm.FADD
		if !.a2 or out == .a3
			.swap(2,3)
		require out == .a2
		if !p.a4 and !.a3    // pa = p2 + p3,   f1 = pa - f4   <--   f1 = p2 + p3 - f4
			.a3 = p.a3
			.a2 = p.a2
			return true
		if !p.a3 and !.a4	 // pa = p2 - p4,   f1 = pa + f3   <--   f1 = p2 + f3 - p4
			.a4 = p.a4
			.a2 = p.a2
			return true

	require !.a4
	if p isa asm.FMUL		 // x2 = x1 * x1,  a = b + x2   -->   a = x1 * x1 + b
		require !.match3_2(out)
		.op = asm.FMUL
		.a4 = .a2
		.a3 = p.a3
		.a2 = p.a2
		return true


// a1 = a2 << (a3+k4)
function OptShifting (fn_µopt)   // can't really opt this unless registers contain consts...
								 // I will rework to use SSA+Consts
	// we need to combine a bflg with this.
	// bflg(same side only) + shift --> shift
	|| k = .a3
	require k.IsConst and !.a4
	|| v = k.ConstValue
	require v.IsPow2
	|| l = v.log2
	if l >= 63
		|| o = .op
		if o == asm.blue		// left
			.a3 = 0
			.a4 = l
		  else
			.a3 = l
			.a4 = 0
		.a5 = (o == asm.brus)|int|
		.op = asm.BFLG
		return true


//	BFLD
//		r1		r
//		r2		r
//		up		6
//		down	6
function OptBFLG (fn_µopt)
// can merge two bflg... just add up + down!  Works with SSA.  (if sign matches)
//////  BFLG
//	if (BFLD_Lu)
//		i1 = ((i2 << up) >> down)
//	  else
//		u1 = ((u2 << up) >> down)


function OptBFLS (fn_µopt)
// can merge bflg+bfls! same as above
//////  BFLS
//	i1 |= ((i2 << up) >> down)
//  i1 = (i2 >> i3+U3_Lu)


function OptBitOr (fn_µopt)
	// bfls: x = x | (y << 5) // 5 is a const...
	// boar: u1  = (u2|||u3) & (~u4)


function OptBitAnd (fn_µopt)
//  x = a & contig_k2 --> bflg(a,k2)   // optimises well
	// lets find if one is a const...
	if p isa asm.bnot // x = (~a & ~b) in two-passes? can check the double-prev instruction too


function OptTern (fn_µopt)
	if .a2 // if this reg is a const... then we can opt it to a BOAR



function OptCompare (fn_µopt)



function OptJump (fn_µopt)
// flowcontrol



function OptJumpC (fn_µopt)
// flowcontrol
// if x: return true/false --> conditional return 
// LUPU/LUPD

function OptJumpE (fn_µopt)
// flowcontrol
// if x: return true/false --> conditional return 
// LUPU/LUPD


function OptBra (fn_µopt)
// flowcontrol
// if x: return true/false --> conditional return 
// LUPU/LUPD



/*
	perhaps all consts should simply be refered to... like 0-31 = reg, and 32+ = const
	Then later the const-filler should insert them at the right places.
	this actually is harder than it seems, because of function calls. but it does make
	optimising consts away... much easier.
	
	a *= 3
	a = func(a)
	b *= 3 // 3 needs reload!
	
	
*/

