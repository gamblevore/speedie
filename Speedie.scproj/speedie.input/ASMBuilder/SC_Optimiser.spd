
// inlining do separately

// dead code removal... IDK?
// we need to also opt a+0 into a
// basically most of the quickopts I already did... need to be redone??
// if (a+b==x)
	//// do nothing
// a = b

function SpdAssembler.MarkBlocks (|&FatASM| curr, |int| length)
	|| first = asm.JUMP.op,  || last = asm.LUPU.op
	|| B = 1
	for i in length
		curr.BlockNum = b
		|| op = curr.op
		if (op >= first and op <= last)
			B++

	
function µfunc.Sanity
	|| Curr = .IR
	|| length = .length
	if curr[-1].op or curr[length-1].op // bad

	
function SpdAssembler.Optimise (|µfunc| raw, |bool|)
	raw.Sanity
	|| Curr = raw.IR
	.MarkBlocks(Curr, raw.length)
	for i in raw.length
		|| x = (µOpt[i])
			(x)(curr+i, curr+i)
	raw.Sanity


dispatch µOpt (|&fatasm| self, |&fatasm| write, |int|)
	(ASM.FUNC):    {} // tail, fncx
	(ASM.CNTC):    {} // (addr+=n), cntc(addr, 0) --> cntc(addr, n)
	(ASM.TABL):    {} // Glob = glob + 1-127 // --> cntc

// and combinations... we should make some kinda block-detector? perhaps just give a pointer to where the block starts?
	(ASM.ADDK):    {}
	(ASM.ADD):     {
		|| p = .PrevInBlock(asm.mult)
	// can be optimised into either a MUL+add... or add + shift
	// or an add
//		i1 = i2 + (i3 << L3) // add with shift
//		i1 = (i2 * i3) + i4 //mul+Add
			
			// analyse details to make sure they all make sense
	} //a*b + c --> MUL
	(ASM.FADD):    {} //a*b + c --> MUL,   a*k1 + b*k2 -> FEXK // could perhaps do these at the time.

/*
BFLG
	if (BFLD_Lu)
		i1 = ((i2 << BFLD_upu) >> BFLD_downu)
	  else
		u1 = ((u2 << BFLD_upu) >> BFLD_downu)

BFLS
	i1 |= ((i2 << BFLD_downu) >> BFLD_upu)

	// x = (a & k1)>>k2	// if b is contiguous bit-const... yes even like a high or low-bit!
	// x = x | (y << 5) // 5 is a const...
	// i think theres another case of setting or getting bits. like a = b&k... or a = a | k
	// could just take a reg and ~it... including reg 0

*/
	(ASM.BRUE):    {}
	(ASM.BRUS):    {}
	(ASM.BLUE):    {}
	(ASM.BOAR):    {} // i1 |= ((i2 << BFLD_downu) >> BFLD_upu)

/*
	* add blocks to the "if (" function :)
	* flowcontrol
		* LUPU/LUPD
		* if x: return true/false --> conditional return 
*/

	(ASM.CMPF):    {} // control flow?
	(ASM.CMPI):    {}
	(ASM.JMPI):    {}
	(ASM.JMPF):    {}
	(ASM.JMPN):    {}
	(ASM.JMPE):    {}
	255:  {}




extend FatASM
	setter Debug (|message|)
		|| fn = Value.FileNum
		if fn >= 4096
			fn = 0 // sigh
		.Location = fn ||| Value.Position << 12 // 4K max files

