// a dead-code finder will remove old ops.

// inlining do separately. opts better if we call .µ on inlinedfn... but within our range.
// i guess returns can be replaced with sets... or turned to jumps, or eliminated


// dead code removal... IDK?
// we need to also opt a+0 into a
// basically most of the quickopts I already did... need to be redone??
// if (a+b==x)
	//// do nothing
// a = b

function SpdAssembler.MarkBlocks (|&FatASM| curr, |int| length)
	|| first = asm.JUMP.op,  || last = asm.LUPU.op
	|| B = 1
	for i in length
		curr.BlockNum = b
		|| op = curr.op
		if (op >= first and op <= last)
			B++

	
function µfunc.Sanity
	|| Curr = .IR
	|| length = .length
	if curr[-1].op or curr[length-1].op // bad

	
function SpdAssembler.Optimise (|µfunc| raw, |bool|)
	raw.Sanity
	|| Curr = raw.IR
	.MarkBlocks(Curr, raw.length)
	|| opts = 0
	|| last = curr + raw.Length
	while curr < last
		|| x = (µOpt[curr.op])
			|| p = curr.prev
			|| n = curr.next
			if n or p
				rz |= (x)(curr, p, n)
				opts++
	raw.Sanity


extend FatASM
	setter Debug (|message|)

		|| fn = Value.FileNum
		if fn >= 4096
			fn = 0 // sigh
		.Location = fn ||| Value.Position << 12 // 4K max files

	function Nop (|bool|)
		.op = asm.noop
		return true
		

dispatch µOpt (|&fatasm| self, |?&fatasm| P, |?&fatasm| N, |bool|)
	(ASM.FUNC2):  OptFunc
	(ASM.FUNC3):  OptFunc
		
		
	(ASM.CNTC):   OptCount
	(ASM.TABL):   OptTabl

	(ASM.SUBB):   OptSubI
//	(ASM.ADDK):   OptAddK
	(ASM.ADD):    OptAddI
	(ASM.FADD):   OptAddF
	(ASM.FADK):   OptFADK
	

	(ASM.RET):    OptRet
	(ASM.TERN):   OptTern
	(ASM.BFLG):   OptBFLG
	(ASM.BRUU):   OptShifting
	(ASM.BRUS):   OptShifting
	(ASM.BLUE):   OptShifting
	(ASM.BAND):   OptBitAnd
	(ASM.BOAR):   OptBitOr
	(ASM.CMPF):	  OptCompare
	(ASM.CMPI):   OptCompare
	(ASM.JUMP):   OptJump // control flow?
	(ASM.JMPI):   OptJumpC
	(ASM.JMPF):   OptJumpC
	(ASM.JMPN):   OptJumpE
	(ASM.JMPE):   OptJumpE
	(ASM.BRAA):   OptBra
	(ASM.BRAN):   OptBra
	255:  {}



function OptFunc (Fn_µOpt)
	// TAILCALL
	require N isa asm.ret
	|| RetResult = N.a1
	|| FuncResult = .a1
	if RetResult == FuncResult // Return the result of this function
		.op = asm.tail
		return N.nop


function OptCount (Fn_µOpt)
	// (addr+=n), cntc(addr, 0) --> cntc(addr, n)


function OptTabl (Fn_µOpt)
	// Glob = glob + 1-127 // --> cntc
	

function OptFADK (Fn_µOpt)	
	// a = b + k1 + k2   -->   a = b + k3
	require p isa asm.fadk
	|| pout = p.a1
	|| myin = .a2
	if pout == myin
		|| add2 = p.a3|int|.asfloat + .a2|int|.asfloat
		.a2 = add2.AsInt
		return true
	

function OptSubI (Fn_µOpt)
	if p 
		|| op = p.op
		if op == asm.bflg or asm.SUBB or asm.ADD
			return OptAddI(self, p, n)


function OptAddI (Fn_µOpt)
	|| out = .a1
	if .match3_2(0)
		if out == .a2 // a = a + 0
			return .nop
		
		// a = b + 0
		.op = asm.boar // u1 = (u2|||u3)&~u4
		.a4 = 0 // nice
		return true
	
	require  p  and  !.a4
	|| pout = p.a1
	require (pout == .a2)

	// c = d << k,  a = b + c  -->  a = b + (d << k)
	if (p isa asm.BFLG)
		require p.a5 and .match3_2(pout)			// unsigned
		.a4 = p.a3
		.a3 = p.a2
		return true

	if p isa asm.MULT // needs refcounts
		// x2 = x1 * x1,  a = b + x2   -->   a = x1 * x1 + b
		require .match3_2(pout)
		.op = asm.MULT
		.a4 = .a2
		.a3 = p.a3
		.a2 = p.a2
		return true


function OptAddF (Fn_µOpt)
	|| mout = .a1
	|| a4 = .a4
	// a = b + (c - c),   (a = b + 0 - 0)
	if (a4 == .a3)	or (.match3_2(0) and !a4)
		if mout == .a2 // a = a + 0
			return .nop
		
		// a = b + 0
		.op = asm.boar // u1 = (u2|||u3)&~u4
		.a4 = 0 // nice
		return true

    // a*b + c --> MUL
	require p  and  p.a5 == .a5		// Both are 64.  or both are 32
	|| pout = p.a1
	if p isa asm.FADD
		require .match3_2(pout)
		if !p.a4 and !.a3    		// pa = p2 + p3,   f1 = pa - f4   <--   f1 = p2 + p3 - f4
			.a3 = p.a3
			.a2 = p.a2
			return true
		if !p.a3 and !.a4			// pa = p2 - p4,   f1 = pa + f3   <--   f1 = p2 + f3 - p4
			.a4 = p.a4
			.a2 = p.a2
			return true

	require !.a4
	if p isa asm.FMUL				// x2 = x1 * x1,  a = b + x2   -->   a = x1 * x1 + b
		require !.match3_2(pout)
		.op = asm.FMUL
		.a4 = .a2
		.a3 = p.a3
		.a2 = p.a2
		return true


// a1 = a2 << (a3+k4)
function OptShifting (fn_µopt)   // can't really opt this unless registers contain consts...
								 // I will rework to use refcounts+Consts
	// we need to combine a bflg with this.
	// bflg(same side only) + shift --> shift
	|| k = .a3
	require k.IsConst and !.a4
	|| v = k.ConstValue
	require v.IsPow2
	|| l = v.log2
	if l >= 63
		|| o = .op
		if o == asm.blue		// left
			.a3 = 0
			.a4 = l
		  else
			.a3 = l
			.a4 = 0
		.a5 = (o == asm.brus)|int|
		.op = asm.BFLG
		return true


//	BFLD
//		r1		r
//		r2		r
//		up		6
//		down	6
function OptBFLG (fn_µopt)
// can merge two bflg... just add up + down!  Works with refcounts.  (if sign matches)
//////  BFLG
//	if (BFLD_Lu)
//		i1 = ((i2 << up) >> down)
//	  else
//		u1 = ((u2 << up) >> down)


function OptBitOr (fn_µopt)
	require p
	if p isa asm.bnot // u1 = ~u2 & ~u3
		|| p2 = p.a2,  || p3 = p.a3
		if (p2 == p3) or .match3_2(0)
			
	// boar:   u1  = (u2|||u3)&~u4


function OptBitAnd (fn_µopt)
//  x = a & contig_k2 --> bflg(a,k2)   // optimises well
	// lets find if one is a const...
	if p isa asm.bnot // x = (~a & ~b) in two-passes? can check the double-prev instruction too


function OptTern (fn_µopt)
	if .a2 // if this reg is a const... then we can opt it to a BOAR



function OptCompare (fn_µopt)



//	* if x: {return a}, return b --> y = TERN(x,a,b)
//		* also just with setting
function OptJump (fn_µopt)
// flowcontrol



function OptJumpC (fn_µopt)
// flowcontrol
// if x: return true/false --> conditional return 
// LUPU/LUPD

function OptJumpE (fn_µopt)
// flowcontrol
// if x: return true/false --> conditional return 
// LUPU/LUPD


function OptBra (fn_µopt)
// flowcontrol
// if x: return true/false --> conditional return 
// LUPU/LUPD


function OptRet (fn_µopt)
	// maybe easier to do from the ret?
// flowcontrol
// if x: return true/false --> conditional return 
// LUPU/LUPD

