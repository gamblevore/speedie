
extend Assembler {


function AddConst (|int| Add, |message| exp, |ASMReg| Base, |ASMReg|)
	|| dest = base
	if base isnt temp
		dest.reg = 0
	
	(base is NoScale)
	return .AddToReg(exp, dest, base, Add)


function IncrPointerByVar (|asmreg| dest, |asmreg| base, |asmreg| vara, |message| exp, |asmreg|)
	base = base.HaveAddr
	if !vara.reg
		return base
	dest = dest.HaveAddr
	dest.µType = DataTypeCode._voidptr
	if !dest.reg
		dest.TryReg = Vara
		dest.TryReg = Base
		dest = .TempOnly(dest)
	return .Plus(exp, dest, base, vara)


function CopyMemory (|int| Index, |message| Exp, |asmreg| Src, |asmreg| Dest, |asmreg| vara, |scdecl| D, |!&fatasm|)
	if vara.reg
		dest = .IncrPointerByVar(nil, dest, vara, exp)

	|| Amount = D.SizeOfQuery max 1
	// what about structs like 53 bytes long? What is their alignment?
	
	if index
//		if d isnt property							// Sigh. now what? the size isnt right?
//		if amount > 16								// previous version did "min 16". why? thats wrong?
		dest = .AddConst(index*amount, exp, dest)
	
	check (Amount <= 1<<14) (exp, "Object too large memory-copy requested. Copy this manually.")
	return exp.WCPY(Src, dest, Amount & 14~bits)		// VM treats 0 as the biggest num


function ReadOrWriteSub (|ASMReg| Dest, |message| Exp, |asmreg| Base, |asmreg| VarAdd, |scdecl?| Decl, |int| Index, |&fatasm|)
	(dest isnt AddrRequest)
	|| T = dest.µtype
	|| byte_shift = t.ByteCount
	target debug
		if decl and (byte_shift < 1 or byte_shift > 16)
		
	byte_shift = byte_shift.log2
	
	if  (byte_shift|uint| > 4)
		error (exp, "Object to large to access")				// can we do struct-mem-copy?
		byte_shift = 0
	
	index++
	|| VInd = .Const(varadd, 7, false)
		index += VInd
		VarAdd = ASMReg()
	
	if decl isnt ClassObj
		base = .MemOffsetFix(Base, byte_shift, index, 7, Decl, exp)
	
	|| pinc = .MemOpt(base, index, byte_shift)
	
	if !pinc and (dest isnt set) and (Byte_Shift == 3) and !varadd.reg
		|| bs = base.fat
		if (bs isa asm.gtab)
			(decl!.mu.info |= packmaker.UsedByASM)
			|| K = bs.Const + ((index-1) << Byte_Shift)
			if K <= 18~bits
				return exp.GOBJ(dest, 0, K)

	|| op = ASMType.WriteASM[byte_shift]
	if dest is set
		// avoid setting ._output
		rz = exp.WR4U(dest, base, VarAdd, index, pinc)
	  else
		rz = exp.RD4U(dest, base, VarAdd, index, pinc)
		byte_shift = (byte_shift<<1) + t.issigned
		op = ASMType.ReadASM[byte_shift]
	
	rz._op = op
	if pinc     // || y = (x++)[]
		rz.µrefcount++
		rz.Dest(4, nil, self) // its a dest, but its also an input
	


function MemOpt (|$asmreg| base, |$int| index, |int| bytes, |int|)
	|| bs = base.fat$
	|| Before = bs isa asm.addk
	require before or (bs isa asm.ADAK)
	if base isnt temp
		require  .last == bs
		require  bs.RegOnly(0) == bs.RegOnly(1)
	
	rz = bs.prms[2]|int| >> bytes
	
	|| i = index
	if before
		i += rz
		require i|uint| <= 127 // could go out of range!
	
	if before and (bs is temp)
		rz = 0 // rz becomes unneeded?
	  else
		require rz >= -1 and rz <= 1

	index = i
	base = bs.ASMReg(1)
	.softnop(bs)


function Assembler.InlineOffsetOpt (|asmreg| base, |int| bytes, |$int| index, |uint| MaxBits, |scdecl?| Decl, |message| exp, |asmreg|)
	rz = .MemOffsetFix(Base, bytes, index, maxbits, Decl, exp)
	.MemOpt(rz, index, bytes)


function Assembler.MemOffsetFix (|asmreg| base, |int| pow2, |$int| index, |uint| MaxBits, |scdecl?| Glob, |message| exp, |asmreg|)
	opt norefcounts
	if base is addrnofiddle
		return base asnt asmreg.addrnofiddle
	|uint| maximum = (1 << maxbits) - 1
	|int64| LostBytes = 0
	
	if base is GlobalMemory
		expect (glob)
		ifn (glob isnt global) and (glob is property)		// not a property on a global struct
			LostBytes = glob.ExportPosition - base.fat!.const
			expect LostBytes >= 0

	|| i = index 
	i += (LostBytes >> pow2) 
	if i <= maximum|int|
		index = i
		return base

													// Too large to inline. increase via addtoreg				
	i = (index << pow2) + lostbytes
	index = 0
	return .AddToReg(exp, base, base as asmreg.noscale, i)



function Read (|asmreg| dest, |message| exp, |asmreg| Ptr, |asmreg| VarAdd, |scdecl| ReadDecl, |int| index=0,  |&fatasm|)
	opt inline
	(dest isnt set)
	if (0)
		.Dummy(exp)
	return .ReadOrWriteSub(dest, exp, ptr, VarAdd, ReadDecl, index)


function Write (|asmreg| dest, |message| exp, |asmreg| Ptr, |asmreg| VarAdd, |scdecl| DestDecl, |int| index=0, |&fatasm|)
	opt inline
	(dest is set)
	(dest is discard)
	return .ReadOrWriteSub(dest, exp, ptr, VarAdd, DestDecl, index)


function ReadOrWrite (|ASMReg| dest, |message| exp, |asmreg| base, |asmreg| VarAdd, |scdecl| Ty,  |int| index=0, |asmreg|)
	opt inline
	if dest is set					  // kludge to remove
		(dest is discard)			  // make compiler happy
	  else
		dest = .TempTyped(exp, dest)
	(dest isnt Const)
	|| fat = .ReadOrWriteSub(dest, exp, base, VarAdd, ty, index)
	if dest is set
		dest.reg = 0
	return fat*dest


function Dummy (|message| exp)
	if exp: exp.RD1U, exp.RD1S, exp.RD2U, exp.RD2S, exp.RD4S, exp.RD8U, exp.RD16, exp.WR1U, exp.WR2U, exp.WR4U, exp.WR8U, exp.WR16

}


function scdecl.CanCopyNormally (|bool|)
	opt norefcounts
	|| i = .Internal
	if i and i.IsBareStruct
		return false
// seems simpler to use a memory copy instruction.
// why not?
//		|| s = i.calculatesize
//		return (s <= 16) and s.IsPow2
	return true



