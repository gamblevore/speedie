
extend Assembler {


function AddConst (|int| Add, |message| exp, |ASMReg| Base, |ASMReg|)
	|| dest = base
	if base isnt temp
		dest.reg = 0
	
	(base is NoScale)
	return .AddToReg(exp, dest, base, Add)


function IncrPointerByVar (|asmreg| dest, |asmreg| base, |asmreg| vara, |message| exp, |asmreg|)
	dest = dest.HaveAddr
	dest.µType = DataTypeCode._voidptr
	base = base.HaveAddr
	if !dest.reg
		dest.TryReg = Vara
		dest.TryReg = Base
		dest = .TempOnly(dest)
	return .Plus(dest, base, vara, exp)


function CopyMemory (|int| Index, |message| Exp, |asmreg| Src, |asmreg| Dest, |asmreg| vara, |scdecl| D, |!&fatasm|)
	if vara.reg
		dest = .IncrPointerByVar(nil, dest, vara, exp)

	|| Amount = D.SizeOfQuery			#check exp
	// what about structs like 53 bytes long? What is their alignment?
	
	if index
		if d isnt property							// Sigh. now what? the size isnt right?
		if amount > 16								// previous version did "min 16". why? thats wrong?
		dest = .AddConst(index*amount, exp, dest)
	
	check (Amount <= 1<<14) (exp, "Object too large memory-copy requested. Copy this manually.")
	return exp.RDWR(Src, dest, Amount & 14~bits)		// VM treats 0 as the biggest num


function ReadOrWriteSub (|ASMReg| Dest, |message| Exp, |asmreg| Base, |asmreg| VarAdd, |scdecl?| Decl, |int| Index, |&fatasm|)
	if dest is ContainsAddr
		#!wait?? this is meant to be an AddrRequest? not a response.
		debugger
	
	if dest is FromZeroMemory
		if Decl
			return .CopyMemory(index, exp, asmreg(), base, varadd, Decl)
		error (exp)
		dest = asmreg()

	(dest asnt= asmreg.AddrRequest)
	|| T = dest.µtype
	|| bytes = t.ByteCount
	if decl
		|| curr = Decl.CalculateSize
		if curr != bytes // just check.
		bytes = curr.clamp(1, 16)
	bytes = bytes.log2
	
	
	if  (bytes|uint| > 4)
		error (exp, "Object to large to access")				// can we do struct-mem-copy?
		bytes = 0
	
	index++
	|| VInd = .Const(varadd, 7, false)
		index += VInd
		VarAdd = ASMReg()
	
	if decl isnt ClassObj
		base = .MemOffsetFix(Base, bytes, index, 7, Decl, exp)
	
	|| pinc = .MemOpt(base, index, bytes)
	
	if dest is set
		// avoid setting ._output
		rz = exp.WR4U(dest, base, VarAdd, index, pinc)
		rz._op = ASMType.WriteASM[bytes]
	  else
		rz = exp.RD4U(dest, base, VarAdd, index, pinc)
		|| B = (bytes<<1) + t.issigned
		rz._op = ASMType.ReadASM[b]


function MemOpt (|$asmreg| base, |$int| index, |int| bytes, |int|)
	|| bs = base.fat$
	|| Before = bs isa asm.addk
	require before or (bs isa asm.ADAK)
	if base isnt temp
		require  .last == bs
		require  bs.RegOnly(0) == bs.RegOnly(1)
	
	rz = bs.prms[2]|int| >> bytes
	
	|| i = index
	if before
		i += rz
		require i|uint| <= 127 // could go out of range!
	
	// this logic is so strange. I wonder if any (real) cases exist where this can fail.
	// (not cases that don't get generated). I can't think of how to fix this, though.
	// this is a case of something I can't solve without examples.
	
	if before and (bs is temp)
		rz = 0 // rz... does it still matter?
	  else
		require rz >= -1 and rz <= 1

	index = i
	base = bs.ASMReg(1)
	.softnop(bs)


function Assembler.InlineOffsetOpt (|asmreg| base, |int| bytes, |$int| index, |uint| MaxBits, |scdecl?| Decl, |message| exp, |asmreg|)
	rz = .MemOffsetFix(Base, bytes, index, maxbits, Decl, exp)
	.MemOpt(rz, index, bytes)


function Assembler.MemOffsetFix (|asmreg| base, |int| pow2, |$int| index, |uint| MaxBits, |scdecl?| Glob, |message| exp, |asmreg|)
	opt norefcounts
	|uint| maximum = (1 << maxbits) - 1
	|int64| LostBytes = 0
	
	// So... lib globals? that have indexes set at load time? what do we do with that?
	if base is GlobalMemory
		expect (glob)
		
		// perhaps... the "dot" function should remove the globalmemory flag?
		if (glob isnt global) and (glob is property)		// a property on a global struct
			0 //  
		  else
			|| bs = base.fat!
			LostBytes = glob.ExportPosition
			|| K = bs.const
			LostBytes -= K
			expect LostBytes >= 0
		
	if LostBytes & (pow2)~bits
		#!not good. We'd need to use an addk. but should never happen
		debugger

	|| i = index 
	i += (LostBytes >> pow2) 
	if i <= maximum|int|
		index = i
		return base

													// Unstorable. increase externally				
	i = (index << pow2) + lostbytes
	index = 0
	return .AddToReg(exp, base, base as asmreg.noscale, i)





function Read (|asmreg| dest, |message| exp, |asmreg| Ptr, |asmreg| VarAdd, |scdecl| ReadDecl, |int| index=0,  |&fatasm|)
	opt inline
	(dest isnt set)
	if (0)
		.Dummy(exp)
	return .ReadOrWriteSub(dest, exp, ptr, VarAdd, ReadDecl, index)


function Write (|asmreg| dest, |message| exp, |asmreg| Ptr, |asmreg| VarAdd, |scdecl| DestDecl, |int| index=0, |&fatasm|)
	opt inline
	(dest is set)
	return .ReadOrWriteSub(dest, exp, ptr, VarAdd, DestDecl, index)


function ReadOrWrite (|ASMReg| dest, |message| exp, |asmreg| base, |asmreg| VarAdd, |scdecl| Ty,  |int| index=0, |asmreg|)
	opt inline
	if dest is set or FromZeroMemory
		(dest is OK)					// make compiler happy
	if dest isnt set
		dest = .TempTyped(exp, dest)
	(dest isnt constoutput)
	return .ReadOrWriteSub(dest, exp, base, VarAdd, ty, index) * dest


function Dummy (|message| exp)
	if exp: exp.RD1U, exp.RD1S, exp.RD2U, exp.RD2S, exp.RD4S, exp.RD8U, exp.RD16, exp.WR1U, exp.WR2U, exp.WR4U, exp.WR8U, exp.WR16

}


function scdecl.CanCopyNormally (|bool|)
	opt norefcounts
	|| i = .Internal!
	if i.IsBareStruct
		return false
// seems simpler to use a memory copy instruction.
// why not?
//		|| s = i.calculatesize
//		return (s <= 16) and s.IsPow2
	return true


