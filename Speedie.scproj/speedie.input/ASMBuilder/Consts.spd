

extend Assembler
	function MakeConstFromTwo (|&Assembler| self,  |message| exp,  || dest,  || L,  || R,  |fn_ASMConstifier| fn,  ||)
		// how to vectorise this? sigh...
		|| K = (fn)(l, r)
		.Nop2Consts(r, l)
		return .NumToReg(exp, dest, k, dest.µtype)
	
	
	function SetConst (|message| exp, |int64| value, |asmreg| ml, |asmreg| Dest, |asmreg|)
		// only boolconst1 uses this. can be simplified.
		|| f = ml.fat
			f.const = value
			return ml
		if !ml.reg // its understandable, we sent across reg 0, so lets create a new FAT
			if !value
				return ml
			return .NumToReg(exp, dest, value, ml.µtype)
		ml.NeedFAT // sigh


	function MegaNumFinder (|int64| V, |bool| Special, |DataTypeCode| Type, |ASMReg|)
		if v == 0
			return asmreg.zero.µtype(type)
		|| bi = .BranchID
		// shouldn't the BranchID shift with the basicblock Or not? IDK?
		|| cc = .curr
		for f.Known in self
			if (f.BranchID == bi) and (f < cc) and (f isa asm.KNST) and (f._const == v)
				|| info = f.info
				if info.µType.SpecialReg == Special
					(info is blocknop) // the value might have not been used yet:   x[1] = 1
					return info
			
	
	function LoadNumber (|message| exp, |int64| V, |bool| Special, |asmreg| Dest=nil, |asmreg|)
		if !Dest.reg
			|| Found = .MegaNumFinder(v, special, dest.µtype)
				return Found
		
		dest = .TempOnly(dest)		
		if dest isnt Textual
			|| K = .Last(asm.knst)
				if (k.r0 == dest.reg) and (k is temp)
					.nop(k)
		
		|| fat = exp.KNST(dest, 0, 0, 0)
		return fat.ConstFill(dest, v)
		

	function NumToReg (|message| exp, |asmreg| Reg, |int64| K, |datatypecode| SrcType, |asmreg|)
		if K  // didn't we remove into as a param?
			return .LoadNumber(exp, K, srctype.specialreg, Reg)
		
		reg.reg = 0
		(reg isnt temp)
		(reg is Const)
		reg.µType = SrcType
		return reg
	
	
	function TextConst (|Message| List,  |message| Orig,  |bool|)
		opt norefcounts								// set1: r1, 123
		|| RegMsg = list[@thg]
		|| ValMsg = RegMsg.Next						#require
		|| Value  = ValMsg.ASMConst
		
		|| src = .NumToReg(orig, RegMsg.Reg.textasm, value, datatypecode.uint64)
		|| fat = src.fat
			fat.ConstFinish
		return true
	
	
function message.ASMConst (|uint64|) 
	opt norefcounts
	if (self == @unit)
		.expect(@nil, "d")$
		return .first.float.AsInt
	.expect(@num)$
	if (.name contains '.')
		return .float32.asint
	return .int



// needs refcount upgrade.

function int64.CanStoreAsAddK (|bool|)
	return ((self << 50)>>50) == self


function Assembler.CanAddK (|asmreg| R, |int64| T, |bool|) // used to be used from .plus()... works now from render
	require (r is Const) and R.isint
	require t.CanStoreAsAddK
 
	if r is Const
		.nopconst(r)
	return true


function ConstifyIntDiv (fn_ASMConstifier)
	if l.FourBytes
		if l.Signed
			return l.const|int| / r.const|int|
		return l.const|uint| / r.const|uint|
	if l.Signed
		return l.const|int64| / r.const|int64|
	return l.const|uint64| / r.const|uint64|


function ConstifyIntMod (fn_ASMConstifier)
	if l.FourBytes
		if l.Signed
			return l.const|int| mod r.const|int|
		return l.const|uint| mod r.const|uint|
	if l.Signed
		return l.const|int64| mod r.const|int64|
	return l.const|uint64| mod r.const|uint64|


function ConstifyIntMul (fn_ASMConstifier)
	if l.FourBytes
		return l.const|int| * r.const|int|
	return l.const|int64| * r.const|int64|


function ConstifyBoolMul (fn_ASMConstifier)
	return l.const|bool| * r.const|uint64|

function ConstifyIntPlus (fn_ASMConstifier)
	if l is Subtract
		return l.const - r.const
	return l.const + r.const


function ConstifyFloatPlus (fn_ASMConstifier)
	if l.fourbytes
		|| rf = r.F32
		|| lf = l.F32
		if l is Subtract
			lf -= rf
		  else
			lf += rf
		return lf.asint
	  else
		|| rf = r.F64
		|| lf = l.F64
		if l is Subtract
			lf -= rf
		  else
			lf += rf
		return lf.asint


function ConstifyFloatDiv (fn_ASMConstifier)
	if l.FourBytes
		return (l.f32 / r.f32).asint
	return (l.f64 / r.f64).asint


function ConstifyFloatMul (fn_ASMConstifier)
	if l.FourBytes
		return (l.f32 * r.f32).asint
	return (l.f64 * r.f64).asint


function ConstifyFloatMod (fn_ASMConstifier)
	if l.FourBytes
		return (l.f32 mod r.f32).asint
	  else
		return (l.f64 mod r.f64).asint


function ConstifyBitAnd (fn_ASMConstifier)
	return l.Const & r.const

function ConstifyBitOr (fn_ASMConstifier)
	return l.Const ||| r.const

function ConstifyBitNot (fn_ASMConstifier)
	return ~l.Const

function ConstifyBitXor (fn_ASMConstifier)
	return l.Const xor r.const

function ConstifyBitSHS (fn_ASMConstifier)
	return l.const >> r.const

function ConstifyBitSHR (fn_ASMConstifier)
	return l.const|uint64| >> r.const|uint64|

function ConstifyBitSHL (fn_ASMConstifier)
	return l.const|uint64| << r.const|uint64|



