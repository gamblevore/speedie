


dispatch fn_asm_table (fn_asm)
	@arg: ASMTmp.Arg

	@decl: asmtmp.decl

	@num:  ASMTmp.num

	@rel:  ASMTmp.DoMath

	@thg:  ASMTmp.Thg

	@bra:  ASMTmp.First

	@sheb: ASMtmp.Ignore
		
	@list: // vectors
		debugger
		

	@func: asmtmp.DoFunc

	@dot:  ASMTmp.Dot
	
	@acc:  ASMTmp.Access

	@brel: asmtmp.Brel		// ++, --, -, &

	@arel: asmtmp.arel      // ++, --, 

	@type:					asmtmp.TypeCast

	@tmp:					asmtmp.unexpected

	(ASMtmp.kDebugger):		ASMtmp.Debugger
	(ASMtmp.kif):			ASMtmp.If
	(ASMtmp.krejoin):		ASMtmp.First
	(ASMtmp.kreturn):		ASMtmp.return
	(ASMtmp.kwhile):		ASMtmp.While
	(asmtmp.kTern):			ASMtmp.Ternary

	(asmtmp.kContinue):		ASMtmp.Continue
	(asmtmp.kExit):			ASMtmp.Exit

	(asmtmp.kSetRel):		ASMtmp.SetRel
	(asmtmp.kStatExpr): 	ASMtmp.StatExpr
	(asmtmp.kPointer):		asmtmp.Pointer

	(asmtmp.kIgnore):		ASMtmp.Ignore
	(asmtmp.kFail):			ASMtmp.Ignore

	63:						ASMtmp.unexpected




function asmstate.SimpleTernary (|asmreg| dest, |asmreg| ma, |asmreg| mb, |message| cond, |asmreg|)
	opt norefcounts
	|| dr = dest.reg
	|| mc = (asmreg(), dest)(dr == ma.reg or mb.reg)
	|| µ = .µ(cond, mc)
	return cond.TERN(dest, µ, ma, mb) * dest



function asmstate.AddToReg (|&FATASM| addr, |int| add, |message| exp, |scdecl| upon=nil,   |asmreg|)
	|| reg = addr.info
	if add
		return .plus(reg, reg, .NumToReg(exp, add), exp)
	return reg



extend_module ASMTmp {
constants
	IncrAfter = 2
	IncrBefore = 0
	
|asm_Read[10]| ReadASM
|asm_Write[5]| WriteASM

function InitAccess
	|| R = &ASMtmp.ReadASM[0]
	|| W = &ASMtmp.WriteASM[0]
	R++[] = ASM.RD1U, W++[] = ASM.WR1U
	R++[] = ASM.RD1S, W++[] = ASM.WR2U
	R++[] = ASM.RD2U, W++[] = ASM.WR4U
	R++[] = ASM.RD2S, W++[] = ASM.WR8U
	R++[] = ASM.RD4U, W++[] = ASM.WR16
	R++[] = ASM.RD4S
	R++[] = ASM.RD8U
	R++[] = ASM.RD8U
	R++[] = ASM.RD16
	R++[] = ASM.RD16	


function Debugger		(fn_asm)
	if Options.targetdebug
		exp.TRAP(asmreg(),0,0) // nice!


// abc(), if (x) return, def()   -->   abc(), if !x {def()}, return
function If				(fn_asm)
	opt norefcounts
	debugger
	
	|| cond = exp.first!,  || arg1 = cond.next!
	|| Else = arg1.next!,  || arg2 = else.first
	|message| ElseIfCond
	if arg2 and arg2 != @arg
		ElseIfCond = arg2
		arg2 = arg2.next
	
	|| Flip = !arg1.HasAsmStuff
		if ElseIfCond		// if (x) {} elseif (y) {yy} else {zz} --> if (!x) {if (y) {yy} else {zz}}
			arg1 = ElseIfCond
		  elseif arg2		// if (x) {} else {y()}                --> if (!x) {y()}...
			arg1 = arg2
		  else				// if (X) --> {x} // with discard
			return .µ(cond, asmreg.arg)
		ElseIfCond = nil
		arg2 = nil

	|| Start = .Branch(cond, Flip)
	rz = .µ(arg1)
	Start.jumpto = .curr
	if ElseIfCond or arg2.HasAny
		|| AfterFirst = arg1.jump(0) // marks as ended... to prevent opts. can be removed later during optimisation
		if ElseIfCond
			|| a = asmreg()
			rz = IF(self, elseifcond, a)
		  else
			rz = ARG(self, arg2)
		AfterFirst.jumpto = .curr

	
	
function While			(fn_asm)
	opt norefcounts
	|| BEGIN = exp.JUMP(0)								// jump to end... THEN EMIT arg and jump back.
	ASMTmp.arg(self, exp.second)						// arg

	|| CONTINUE = .curr
	BEGIN.jumpto = CONTINUE
	|| GOBACK = .branch(exp.first!)					// cond
	|| EXIT = .curr
	GOBACK.jumpto = BEGIN+1
	|| C = BEGIN

	while C < CONTINUE
		#!ClearExits
		|| op = C.Op
		if op >= 254
			C.op = ASM.Jump
			if op == 254 // continue
				C.jumpto = CONTINUE
			  else       // exit
				C.jumpto = EXIT
		C++
	


function Exit			(fn_asm)
	opt norefcounts
	self <~ (255, exp)											// request jump fwd


function Continue		(fn_asm)
	opt norefcounts
	self <~ (254, exp)											// request jump fwd a little less
	

function StatExpr		(fn_asm)
	opt norefcounts
	for ch.fast in exp
		if ch.islast
			return .µ(ch, dest)
		.µ(ch, asmreg.Arg)


function Ternary		(fn_asm)
	opt norefcounts
	
	|| prms = exp.second
	|| cond = prms.first!
	|| A = cond.next!
	|| B = A.next!
	
	|| destType = exp.ASMDecl.DType
	|| mA = .ExistingVar(a, desttype)
	|| mB = .ExistingVar(b, desttype)
	if ma!=nil and mb!=nil
		return .SimpleTernary(dest, ma, mb, cond)

	dest = .TempMe(exp, dest)
	|| FailToSecond = .Branch(cond)
	.µ(A, dest)
	|| Exit = exp.jump(0)

	FailToSecond.jumpto = .curr

	rz = .µ(B, dest)
	Exit.r[3] = .curr - Exit
	

	
function First			(fn_asm)
	opt norefcounts
	return .µ(exp.first!, dest)



function Return			(fn_asm)
	opt norefcounts
	|| reg = asmreg()
	|| f = exp.first
		|| Where = AsmReg.ForReturn
		where.reg = 1
		where.µtype = .ReturnASM
		reg = .µ(f, Where)
	exp.RET(reg, asmreg(), 1, 0)



function TypeCast		(fn_asm)
	opt norefcounts
	|| sr = .µ(exp.first!, dest)
	return TypeCastSub(self, exp, dest, sr)



function TypeCastSub (|&asmstate| self, |message| exp, |asmreg| dest, |asmreg| sr, |asmreg|)
	|| NewDecl = exp.ASMDecl
	|| NewType = newdecl.regtype
	if !sr.reg								// x = 0|float|
		sr.µtype = newtype
		return sr

	|| OldDecl = exp.first!.ASMDecl
	|| OldType = olddecl.regtype
	if NewType.count != OldType.count
	
	if newtype is bool
		if OldType is bool					// x = true|bool| // why?
			return sr
		return .NotEq(dest, asmreg(), sr, exp)

	|| OC = oldtype.BitCount
	|| NC = newtype.BitCount

	|| FloatDiff = newtype.isfloat != oldtype.isfloat
	if !FloatDiff and (nc == oc)			// same bittype!
		return sr
	
	dest = .TempMe(exp, dest)
	dest.µType = NewType
	|| UponConst = sr is ConstAny
	|&fatasm| fat
	if oldtype.isfloat or newtype.isfloat
		fat = exp.CONV(dest, sr, oldtype.asmconv(newtype), oc.convshift).BitCorrect
		if UponConst
			(fat is ConstAny)
			|| srf = sr.needfat
			if NewType.IsFloat and !FloatDiff
				fat.FloatConvConst(srf, NC)
			  else
				fat.FloatIntConvConst(srf, oldtype, newtype)
	  else
		|| sh = 64 - oc
		fat = exp.BFLG(dest, sr, sh, sh, sr.signed|int|).bitcorrect
		if UponConst
			|| oof = fat.Const << sh
			fat.Const = (oof|int64| >> sh, oof|uint64| >> sh)(sr.Signed) // shift up and down
			(fat is ConstAny)
	return fat*dest



function Pointer		(fn_asm)
	// *a, x = *(a.b) 
	opt	NoRefCounts
	if dest is AddrRequest // hmmm?
	dest = .TempMe(exp, dest)
	|| Ptr = .µ(exp.first!, dest)
	return Dest.ReadOrWrite(exp,ptr)



function Decl (fn_asm)
// yay
	opt norefcounts
	|| rel = exp.last!
	|| ty = rel.first!.fastdecl
	|| dest2 = .DeclareMe(Exp, ty)
	return SetReg(self, rel.last!, dest2)



function SetReg (|&ASMState| self, |message| exp, |AsmReg| Dest, |AsmReg|)
	|| r2 = .µ(exp, dest as AsmReg.set)
	r2 = r2 asnt asmreg.set
	if r2.reg == dest.reg
		return r2
	return .Assign(dest, r2, asmreg(), exp)



function Arg   (fn_asm)
	opt norefcounts
	|| DclCloser = .VDecls // dcl ooffer
	for ch.fast in exp
		.µ(ch, asmreg.Arg)
	.CloseVDecls(dclCloser)



function Access		(fn_asm)						// a[b], struct.mem[b], func()[func2()]
	opt	NoRefCounts
	dest = .tempme(exp, dest)

	|| Ptr = .µ(exp.first!, dest.RequestPos)		// x = a.b[0]
	check (ptr is ContainsAddr) (exp)
	|| Ind = .µ(exp.second!, ptr • dest)
	if (dest is addrrequest)
		return .plus(dest.HaveAddr, ptr, ind, exp)
	
	return Dest.ReadOrWrite(exp, ptr, ind)


function Dot		(fn_asm)						// a.b
	opt	NoRefCounts
	dest = .tempme(exp, dest)
	|| Obj = .µ(exp.first!, dest)
	|| prop = exp.ASMDecl
	|| T = prop.typeinfo
	dest.µtype = T
	debugger
	
	|| B = t.ByteCount.log2
	|| Pos = prop.exportposition >> B
	if !pos // what?
	if (dest is addrrequest) or (pos >= 128)						// read/write only allows up to 127
		|| addk = exp.ADDK(dest, obj, pos)
		if dest is addrrequest
			return addk.haveaddr*dest
		pos = 0
	
	return Dest.ReadOrWrite(exp, obj, pos)
		

function SetRel	(fn_asm)
	opt	norefcounts									//   x[func()] = y++
	|| L = exp.first!
	|| Var = .ExistingVar(L)
	|| R = .µ(exp.last!, var)
	|| vr = var.reg
		if r.reg == vr
			return r // done!

	check (r.reg) (self, exp, "SetRel failed")
	return setreg(self, exp, r)


function Num (fn_asm)
	opt norefcounts
	|| d = exp.ASMDecl
	return .GenericNumFinder(exp, d.exportposition, dest) 


function Thg (fn_asm)
	|| thg = ThgSub(self, exp, dest, mode)
	|| reg = thg.reg
	if (reg-1)|uint| < 31							// what?
		return thg
	error (exp, "Register out of bounds")


function ThgSub (|&ASMState| self, |message| exp, |AsmReg| Dest, |int| Mode, |asmreg|)
	opt norefcounts
													// what if this is a constant?
	|| d = exp.ASMDecl
	if d is local
		return d.reg

	if d is const
		|| R = dest.reg
		check (R and dest isnt set) (exp)
		|| val = d.exportposition
			require !mode
			(dest is constany)
			return .NumToReg(exp, val, dest)
		return AsmReg()

	if mode
		return nil
	check (d is global) (Exp)
	return DoGlobal(self, exp, dest, d)
 

function DoGlobal (|&ASMState| self, |message| exp, |AsmReg| Dest, |scdecl| D, |asmreg|)
	opt	NoRefCounts
	|| addr = dest
	if dest isnt set								// a = glob
		addr = .tempme(exp, dest)

	|int64| iTable = d.ExportPosition
	expect (iTable > 0)      (exp, "No global address".internal)
	expect (iTable < 16MB)   (exp, "Too much global data")

	if dest is AddrRequest
		|| iAdd = iTable
		if itable >= 16K
			debugger // does this ever happen?
			itable &= 16K-1
		|| a = exp.TABL(addr,  (!d.IsLib)|int|, iTable)
		return .addtoreg(a, iadd-itable, exp).haveaddr

	|| iRead = iTable
	|| iOld = iRead
	if iTable < 128
		iTable = 0		// keep the current table. More optimisable.
	  elseif iTable < 16K
		iRead = 0		// itable has a bigger range... so use that. 
	  else
		itable = 0		// Make this optimisable.
		iRead = 0

	|| tabl = exp.TABL(addr,  (!d.IsLib)|int|, iTable)
	if !itable and !iread
		.addtoreg(tabl, iold, exp)
	debugger 
	#!This used to return ADDR not DEST. so we we returnign addr.bitcorrect. is this faulse?
	#!probably ok aksuually
	return dest.ReadOrWrite(Exp, addr, iread)	//, exp, dest, addr, iRead).BitCorrect * dest

	

function Not		(fn_asm)
	opt	NoRefCounts
	dest = dest.negate
	|| src = .µ(exp.first!, dest)
	if src is AlreadyNegated
		return src
	return .Equals(dest, asmreg(), src, exp)
	

function Negative			(fn_asm)					// -a
	opt	NoRefCounts
	return ASMTmp.DoSingleMath(self, exp, dest, scoperator.Negative!.asm!)


function SlowCountOnAddr (|&ASMState| self, |message| f, |AsmReg| Dest, |int| Mode, |AsmReg| Addr, |int64| Amount, |asmreg|)
//	    *a, x = *(a.b) 
	opt	NoRefCounts
	// need to read... also save old value
	|| TmpCloser = .VTmps
	Dest.Read(F, dest, addr)

	// we have read... now we need to add		
	|| NewValue = (.TempMe(f), dest)(mode & IncrAfter)
	.AddConstant(f, NewValue, dest, amount)

	// now we have the new value... lets write it back again
	|| fat = dest.write(f, newvalue, addr)

	// the new value should exist! now lets close
	.CloseVTmps(TmpCloser)
	return fat * Dest


function CountOnAddr (|&ASMState| self, |message| f, |AsmReg| Dest, |int| Mode, |AsmReg| Addr, |int64| Amount, |asmreg|)
	ifn  dest.isint  and  amount <= 63  and  amount >= -64
		return SlowCountOnAddr(self, f, dest, mode, Addr, amount)
//	|| opp = (ASM.CNTC, ASM.CNTD)(mode & IncrAfter)	
	|| bc  = dest.µtype.ByteCount
	|| log = bc.Log2
	if dest.BitCount * (1<<log) != bc // hmm? maths bug?
	|| fat = f.cntc(Addr, dest, 0, amount, log)
	if mode & IncrAfter
		fat.op = asm.cntd
	return fat*dest


function IncrAmount (|asmreg| upon, |int| IsSubtract, |scdecl| D,  |int64|)
	opt norefcounts
	rz = (1,-1)(IsSubtract & 1)
	if upon.isfloat
		if upon.FourBytes
			rz = rz|float|.asint
		  else
			rz = rz|f64|.asint
	  elseif D.TypeSuffers
		rz *= D.PointerIncrement



function Incrementatulatorifier		(fn_asm)				// --a++
	visible
	opt	NoRefCounts
	|| Src = .µ(exp, dest.RequestPos)
	|| Amount = IncrAmount(src, mode, exp.ASMDecl)
	if src is ContainsAddr
		return CountOnAddr(self, exp, dest, mode, src, amount)
	
	check (src isnt temp) (exp, "Can't increment temporary value.")
	ifn mode & IncrAfter
		return .AddConstant(exp, src, src, Amount)							// ++x,	 y = ++x

	return .AddConstantAndReturnOld(exp, dest, src, amount)					// x++,	 y = x++



function ARel		(fn_asm)
	opt	NoRefCounts
	|| M = (exp.name[] == '+')|int|
	if dest
		M += IncrAfter
	return Incrementatulatorifier(self, exp.first!, dest, M)



function BRel		(fn_asm)						//  --a,  ++a,  &a,  --glob,  --a.b, -a
	opt	NoRefCounts
	|| n = exp.name[]
	|| F = exp.first!
	if n == '&'
		return .µ(F, dest.requestpos)
	if n == '~'
		return dosinglemath(self, exp, dest, scoperator.bnot.asm!)
	if n == '!'
		return Not(self, F, dest)

	if exp.name == 1								// -a
		return Negative(Self, f, dest)
	
	|| IsPlusPlus = n == '+'						// ++a, --a
	return Incrementatulatorifier(self, F, dest, IsPlusPlus|int|)



function DoSingleMath (|&ASMState| self, |message| exp, |AsmReg| Dest, |fn_opasm| fn, |asmreg|)
	|| Src = .µ(exp, dest)
	src = src as asmreg.SingleExpr
	return DoMathSub(self, exp, dest, src, fn)


function DoMath (fn_asm)
	opt norefcounts
	|| op = exp.second!
	|| scop = op.obj|scoperator|
		|| fn = scop.asm
			return DoMathSub(self, exp, dest, 0.asm, fn)
	error (op, "No ASM for this operator?")
	debugger // what?
		

helper DoMathSub (|&ASMState| self,  |message| exp,  |AsmReg| Dest,  |asmreg| mr,  |fn_opasm!| fn, |asmreg|)
	opt norefcounts

	|| F = exp.first!
	|| op = f.next!
	
	|| ml = AsmReg()
	if mr isnt SingleExpr
		|| TmpCloser = .VTmps
		|| D1 = (dest & asmreg.discard) as asmreg.stayopen
		debugat  0
		ml = .µ(F, D1) asnt asmreg.stayopen
		mr = .µ(exp.last!, dest & asmreg.discard)
		.closeVTmps(TmpCloser)
	
	if dest is Discard
		return asmreg() // no need to do anything. {a()+b()}

	dest = .TempMe(exp, dest)
	dest.µtype = ml.µtype				// assignment conversion needs doing?	
	(dest is frommath)

	if  ml isnt ConstAny  or  mr isnt ConstAny
		return (fn)(self, dest, ml, mr, op)
	(Dest is MathConst)
	rz = (fn)(self, dest, ml, mr, op)
	if rz isnt mathconst // hmm?
		debugger, (fn)(self, dest, ml, mr, op)


function Ignore			(fn_asm)


function Unexpected		(fn_asm)
	"Bad asmtmp"
	debugger

}



function ASMReg.ReadOrWrite (|message| m, |asmreg| ptr, |int| index=0, |asmreg|)
	return .ReadOrWrite(m, ptr, index, self is set) * self


function ASMReg.ReadOrWrite (|message| m, |asmreg| ptr, |int| index, |bool| DoRead, |&fatasm|)
	self = self asnt asmreg.containsaddr
	debugger 
	|| T = .µtype
	|| BC = t.ByteCount
	|| bytes = BC.log2
	check  (bytes <= 4)  (m, "Object to large to access")
		
	|asm| A
	if DoRead
		|| B = (bytes<<1) + t.issigned
		A = ASMtmp.ReadASM[b]
	  else
		A = ASMTmp.WriteASM[bytes]
	isnt set
	return m.RD4U(self, ptr, asmreg(), index, 0).BitCorrect
//		r1		R	// dest
//		r2		r	// Base
//		r3		r	// VarAdd
//		L		7	// Const A
//		move	2

//	rz = rz.BitCorrect
	


function ASMReg.Read  (|message| m,  |asmreg| ptr,  |int| index=0,  |&fatasm|)
	opt inline
	return .ReadOrWrite(m, ptr, index, true)
	

function ASMReg.Write (|message| m,  |asmreg| ptr,  |int| index=0,  |&fatasm|)
	opt inline
	return .ReadOrWrite(m, ptr, index, false)


function asmstate.ExistingVar (|message| m, |datatypecode| destType=datatypecode.UnusedType,  |asmreg|)
	opt	norefcounts
	real self
	|| fn = m.func 
	while (fn == @bra) or ((fn == @type) and m.TypeCastDoesNothing(DestType))
		m = m.first!
		fn = m.func
	if fn == @thg
		return asmtmp.ThgSub(self, m, asmreg(), 2)
	if fn == @num
		return .FindConstDecl(m.ASMDecl)


function message.HasAsmStuff (|bool|)
	opt norefcounts
	for ch in self
		if ch.func != @sheb
			return true


function FatASM.FloatConvConst (|&FatASM| src, |int| DestBitSize)
	|| f = (&src.Const)|&nil|
	|| d = (&.Const)|&nil|
	if DestBitSize == 64			// f32 to f64
		d|&f64|[]   = f|&float|[]
	  elseif DestBitSize == 32		// f64 to f32
		d|&float|[] = f|&f64|[]
	  else
		error (src.msg)


function FatASM.FloatIntConvConst (|&FatASM| fat, |datatypecode| src, |datatypecode| dest)
	|| dbc = dest.ByteCount
	|| f = (&fat.Const)|&nil|
	|| d = (&.Const)|&nil|
	if src.IsInt
		|| v = fat.Const
		if src.IsSigned
			if dbc == 4
				(d|&float|)[] = v|float|				// i to f32
			  else
				(d|&f64|)[] = v|f64|					// i to f64
		  else
			if dbc == 4
				(d|&float|)[] = v|uint64||float|		// u to f32
			  else
				(d|&f64|)[] = v|uint64||f64|			// u to f64
	  else
		|| i = d|&int64|
		|| u = d|&uint64|
		if dbc == 4
			|| f32 = f|&float|
			if dest.IsSigned
				i[] = f32[]|int|						// f32 to i
			  else
				u[] = f32[]|int|						// f32 to u
		  else
			|| f64 = f|&f64|
			if dest.IsSigned
				i[] = f64[]|int64|						// f64 to i
			  else
				u[] = f64[]|uint64|						// f64 to u


function DataTypecode.ASMConv (|Datatypecode| To, |int|)
	return to.ASMPart<<2 ||| .asmpart


function DataTypecode.ASMPart (|int|)
	if .isfloat
		return 0 + (.bitcount > 32)
	return 2 + .issigned

/*
        case 0 : d.Float = s.Float;  break;
        case 1 : d.Float = s.Double; break;
        case 2 : d.Float = s.Uint;   break;
        case 3 : d.Float = s.Int;    break;
        
        case 4 : d.Double = s.Float;  break;
        case 5 : d.Double = s.Double; break;
        case 6 : d.Double = s.Uint;   break;
        case 7 : d.Double = s.Int;    break;
        
        case 8 : d.Uint = s.Float;  break;
        case 9 : d.Uint = s.Double; break;
        case 10: d.Uint = s.Uint;   break;
        case 11: d.Uint = s.Int;    break;
        
        case 12: d.Int = s.Float;  break;
        case 13: d.Int = s.Double; break;
        case 14: d.Int = s.Uint;   break;
        case 15: d.Int = s.Int;    break;
*/



function Message.TypeCastDoesNothing (|Datatypecode| Expected, |bool|)
	opt norefcounts
//	if Expected == DataTypeCode.UnusedType
	Expected = .second!.ASMDecl.DType
	|| Src = .first!.ASMDecl.DType
	|| XC = Expected.ByteCount
	|| SC = Src.ByteCount
	if  (Expected.IsFloat != Src.isfloat)  or  (src.Count != Expected.Count)
		return false
	if SC == XC
		return true
	return Expected.isint and (XC < SC)



function int.ConvShift (|int|)
	return (64 - self)>>3
	