


dispatch fn_asm_table (fn_asm)
	@arg:  ASMType.Arg
	@decl: ASMType.decl
	@num:  ASMType.num
	@rel:  ASMType.DoMath
	@thg:  ASMType.Thg
	@bra:  ASMType.First
	@sheb: ASMType.Ignore
	@list: // vectors
		debugger
	@func: ASMType.DoFunction
	@dot:  ASMType.Dot
	@acc:  ASMType.Access
	@brel: ASMType.Brel		// ++, --, -, &
	@arel: ASMType.arel     // ++, --, 
	@type:					ASMType.TypeCast
	@tmp:					ASMType.unexpected

	(ASMType.kif):			ASMstate.If
	(ASMType.kwhile):		ASMstate.While
	(ASMType.kTern):		ASMstate.Ternary
	(ASMType.kContinue):	ASMstate.Continue
	(ASMType.kExit):		ASMstate.Exit

	(ASMType.kDebugger):	ASMType.Debugger
	(ASMType.krejoin):		ASMType.First
	(ASMType.kreturn):		ASMType.return

	(ASMType.kSetRel):		ASMType.SetRel
	(ASMType.kStatExpr): 	ASMType.StatExpr
	(asmtype.kRefCount):	ASMType.RefCount

	(ASMType.kIgnore):		ASMType.Ignore
	(ASMType.kFail):		ASMType.Ignore

	63:						ASMType.unexpected



extend_module ASMType {
constants
	IncrAfter = 2
	IncrBefore = 0
	
|asm_Read[10]| ReadASM
|asm_Write[5]| WriteASM

function InitAccess
	|| R = &ASMType.ReadASM[0]
	|| W = &ASMType.WriteASM[0]
	R++[] = ASM.RD1U, W++[] = ASM.WR1U
	R++[] = ASM.RD1S, W++[] = ASM.WR2U
	R++[] = ASM.RD2U, W++[] = ASM.WR4U
	R++[] = ASM.RD2S, W++[] = ASM.WR8U
	R++[] = ASM.RD4U, W++[] = ASM.WR16
	R++[] = ASM.RD4S
	R++[] = ASM.RD8U
	R++[] = ASM.RD8U
	R++[] = ASM.RD16
	R++[] = ASM.RD16	


function Debugger (fn_asm)
	if Options.targetdebug
		return exp.TRAP(asmreg(), 0, 2)*asmreg() // 2 == sigint
	return asmreg()
	

function StatExpr (fn_asm)
	opt norefcounts
	for ch.fast in exp
		if ch.islast
			return .µ(ch, dest)
		.µ(ch, asmreg.Arg)

	
function First (fn_asm)
	opt norefcounts
	return .µ(exp.first!, dest)


function Return (fn_asm)
	opt norefcounts
	|| reg = ASMReg()
	|| f = exp.first
		|| ret = .ReturnASM|asmreg|
		reg = .µ(f, ret)
	
	|| K = .const(reg, 6, true) // return true, or -1 or whatever
		reg = asmreg()
	  else
		k = 0
	|| amount = (f!=nil)|int|
	exp.RET(reg, asmreg(), asmreg(), amount, K)
	return asmreg()
	


function TypeCast (fn_asm)
	opt norefcounts
	|| f = exp.first!
	|| req = dest as asmreg.ForCast
	req.µtype = exp.asmdecl.datatype
	|| sr = .µ(F, req)
	if sr.µtype == req.µtype
		return sr // already done!
	return TypeCastSub(self, exp, dest, sr)


function TypeCastSub (|&asmstate| self, |message| exp, |asmreg| dest, |asmreg| sr, |asmreg|)
	opt norefcounts
	|| NewDecl = exp.ASMDecl
	|| NewType = newdecl.regtype
	if !sr.reg												// x = 0|float|
		sr.µtype = newtype
		return sr

	|| OldType = sr.µtype
	target debug
		if NewType.count != OldType.count
	
	if NewType is bool
		if (OldType is bool) and (dest isnt negate)			// x = true|bool| // why?
			return sr
		return .NotEq(dest, asmreg(), sr, exp)

	|| OC = oldtype.BitCount
	|| NC = newtype.BitCount
	|| IsInt = NewType.IsInt

	|| Floatness = (newtype.isfloat<<1)+oldtype.isfloat
	if floatness == 0 or 3
		if (nc == oc) and (oldtype.issigned == newtype.issigned)
			sr.µtype = newtype // same all. maybe quicker to test in one go?
			return sr
		if isint  and  (nc > oc  or  oc == 64)
			sr.µtype = newtype
			return sr
	
	dest = .TempOnly(exp, dest)
	dest.µType = NewType
	if sr is ConstAny
		|| srf = sr.needfat
		if floatness == 0
			|| sh = 64 - nc
			|| oof = srf.Const << sh
			srf.Const = (oof|int64| >> sh, oof|uint64| >> sh)(dest.Signed) // shift up and down
		  elseif floatness == 3
			srf.FloatConvConst(srf, NC)
		  else
			srf.FloatIntConvConst(srf, oldtype, newtype)
		
		return .makeconst(srf, dest)
		
	
	if oldtype.isfloat or newtype.isfloat
		return exp.CONV(dest, sr, oldtype.asmconv(newtype))*dest
	|| sh2 = 64 - oc
	return exp.BFLG(dest, sr, sh2, sh2, sr.signed|int|) * dest



function Decl (fn_asm)
	opt norefcounts
	exp = exp.last!
	|| ty = exp.first!.fastdecl
	dest = .DeclareMe(Exp, ty) as ASMReg.decl
	if (ty isnt altered) and (ty is local)
		(dest as= asmreg.neveraltered)
	rz = .µinto(exp.last!, dest)
	if dest is neveraltered
		.neveraltered[.VDecls] = .last.index



function Arg (fn_asm)
	opt norefcounts
	|| DclCloser = .VDecls // dcl ooffer
	for ch.fast in exp
		.µ(ch, AsmReg.Arg)
		//.printprogress(ch)

	.CloseVDecls(DclCloser)
	return asmreg()



function Access (fn_asm)						// a[b], struct.mem[b]
	opt	NoRefCounts
//	if dest is set
	if dest isnt set
		dest = .TempTyped(exp, dest)
	
	|| f = exp.first!
	target debug
		|| d = f.asmdecl
		if !d.pointercount and !d.iscarray
	|| Ptr = .µ(f, asmreg.stayopen)								// x = a.b[0]
	|| sc = exp.second.first!
	|| vara = .µ(sc, asmreg.stayopen)
	if (dest is AddrRequest)
/		return .Plus(dest.HaveAddr, ptr, vara, exp)
	
	return Dest.ReadOrWrite(exp, ptr, vara)


function Dot (fn_asm)							// a.b
	opt	NoRefCounts
//	if dest is set
	if dest isnt set
		dest = .TempTyped(exp, dest)
	|| Obj = .µ(exp.first!, dest as asmreg.stayopen)
	|| prop = exp.ASMDecl
	|| T = prop.typeinfo
	dest.µtype = T
	
	|int64| Pos = prop.exportposition
	if (pos < 0 or pos > 1K) // what?
	
	if (dest is AddrRequest) or prop.iscarray
		pos *= t.ByteCount
		return .AddToReg(exp, dest.HaveAddr, obj as asmreg.NoScale, pos)

	return Dest.ReadOrWrite(exp, obj, asmreg(), pos)
		

function SetRel (fn_asm)	// function relset (
	opt	norefcounts									//   x[func()] = y++
	|| A = exp.first!
	|| B = exp.last!
	|| X = .ExistingVar(A)
	if X.reg
		return .µinto(B, X)
	
	dest = .µ(B, X as asmreg.stayopen) asnt asmreg.SetRelRemove
	return .µ(A, dest as AsmReg.set)


function Num (fn_asm)
	opt norefcounts
	|| d = exp.ASMDecl
	|| T = d.typeonly
	dest.µtype = T
	return .numtoreg(exp, d.exportposition, dest, T)


function Thg (fn_asm)
	|| thg = asmtype.ThgSub(self, exp, dest)
	|| reg = thg.reg
	if (reg-1)|uint| < 31							// what?
		return thg
	if reg == 0  and  thg is constany
		return thg // its still ok.   nil/false
	error (exp, "Register out of bounds")


function ThgSub (|&ASMState| self, |message| exp, |AsmReg| Dest, |asmreg|)
	opt norefcounts
	|| d = exp.ASMDecl
	if d is local
		|| T = d.wholetype
		(t is param) = (d is param)
		if (d isnt altered) and (d isnt param)			// what about params?
			(T is NeverAltered) = true					// what about carrays?
			t.FatIndex = .NeverAltered[t.reg]
		if dest isnt addrneed
			return T
		return exp.addr(dest, t, dest, t) * dest.haveaddr
	
	if d is const
		(dest is constany)
		return .NumToReg(exp, d.exportposition, dest, dest.µtype)

	rz = d.typeonly.zero
	check (d is global) (Exp)
	DoGlobal(self, exp, dest, d)


function DoGlobal (|&ASMState| self, |message| exp, |AsmReg| Dest, |scdecl| D, |asmreg|)
	opt	NoRefCounts
	|| addr = dest
	if dest isnt set								// a = glob
		addr = .TempTyped(exp, dest)

	|int64| iTable = d.ExportPosition
	|| sixteen = 16K-1
	expect (iTable > 0)          (exp, "No global address".internal)
	expect (iTable <= sixteen)   (exp, "Expected under 16K of global data")
						
	if dest is AddrRequest
		|| a = exp.TABL(addr,  (!d.IsLib)|int|,  iTable&sixteen)
		return (a * Dest).HaveAddr
	
	|| AddCosTooBig = (iTable >= 128) * iTable
	|| tabl = exp.TABL(addr,  (!d.IsLib)|int|, AddCosTooBig)
	return dest.ReadOrWrite(Exp, addr, asmreg(), iTable-AddCosTooBig)

	

function BoolNot (fn_asm)						// !a
	opt	NoRefCounts
	dest = dest.negate
	|| src = .µ(exp, dest)
	if src is AlreadyNegated
		return src
	return .exists(dest, src, exp)
	

function BitNot (fn_asm)					// ~a
	return .DoMathSub(exp, dest as asmreg.SingleExpr, scoperator.bnot.asm!)


function Negative (fn_asm)					// -a
	return .DoMathSub(exp, dest as asmreg.singleexpr, scoperator.Negative.asm!)


function IncrSlowOnAddr (|&ASMState| self, |message| f, |ASMReg| Dest, |int| Mode, |ASMReg| Addr, |int64| Amount, |ASMReg|)	
	opt	NoRefCounts									// *a, x = *(a.b)
	|| TmpCloser = .VTmps
	Dest.Read(F, dest, addr)						// READ

	|| NewValue = (.Temptyped(f), dest)(mode & IncrAfter)
	.IncrPre(f, NewValue, dest, amount)				// ADD

	|| fat = dest.write(f, newvalue, addr)			// WRITE BACK

	// the new value should exist! now lets close
	.CloseVTmps(TmpCloser)
	return fat * Dest


function IncrOnAddr (|&ASMState| self, |message| f, |AsmReg| Dest, |int| Mode, |AsmReg| Addr, |int64| Amount, |asmreg|)
	ifn  dest.isint  and  amount <= 63  and  amount >= -64
		return IncrSlowOnAddr(self, f, dest, mode, Addr, amount)
//	|| opp = (ASM.CNTC, ASM.CNTD)(mode & IncrAfter)	
	|| bc  = dest.µtype.ByteCount
	|| log = bc.Log2
	if dest.BitCount * (1<<log) != bc // hmm? maths bug?
	|| fat = f.cntc(Addr, dest, 0, amount, log)
	if mode & IncrAfter
		fat.op = asm.cntd
	return fat * dest


function IncrAmount (|asmreg| upon, |int| IsSubtract, |scdecl| D,  |int64|)
	opt norefcounts
	rz = (1,-1)(IsSubtract & 1)
	if upon.isfloat
		if upon.FourBytes
			rz = rz|float|.asint
		  else
			rz = rz|Float64|.asint
	  elseif D.TypeSuffers
		rz *= D.PointerIncrement



function Incrementatulatorifier		(fn_asm)				// --a++
	visible
	opt	NoRefCounts
	|| Src = .µ(exp, dest as asmreg.addrrequest)
	|| Amount = IncrAmount(src, mode, exp.ASMDecl)
	if src is ContainsAddr
		return IncrOnAddr(self, exp, dest, mode, src, amount)
	
	check (src isnt temp) (exp, "Can't increment temporary value.")
	ifn mode & IncrAfter
		return .IncrPre(exp, dest, src, Amount)				// ++x,	 y = ++x

	return .IncrPost(exp, dest, src, amount)				// x++,	 y = x++



function ARel		(fn_asm)
	opt	NoRefCounts
	|| F = exp.name[]
	if F == '?' or '!'
		return .µ(exp.first!, dest)
	|| M = (F == '+')|int|
	if dest isnt discard
		M += IncrAfter
	return Incrementatulatorifier(self, exp.first!, dest, M)



function BRel		(fn_asm)						//  --a,  ++a,  &a,  --glob,  --a.b, -a
	opt	NoRefCounts
	|| n = exp.name[]
	|| F = exp.first!
	if n == '&'
		return .µ(F, dest as asmreg.addrneed)
	if n == '~'
		return BitNot(self, f, dest)
	if n == '!'
		return BoolNot(self, F, dest)

	if exp.name == 1								// -a
		return Negative(Self, f, dest)
	
	|| IsPlusPlus = n == '+'						// ++a, --a
	return Incrementatulatorifier(self, F, dest, IsPlusPlus|int|)



function DoMath (fn_asm)
	opt norefcounts
	|| op = exp.second!
	|| scop = op.obj|scoperator|
		if scop is AndOr
			return .ASMBoolBadnessMadness(exp, dest, scop.Kind)
		|| fn = scop.asm
			return .DoMathSub(exp, dest, fn)
	error (op, "No ASM for this operator?")
	debugger // what?
		




function Ignore			(fn_asm)
	return asmreg()


function Unexpected		(fn_asm)
	if !exp.asmtype
		|| f = exp.func|int|
			exp.asmtype = f
			return .µ(exp, dest)
	error  (exp, "bad ASMType")
}


helper ASMState.DoMathSub (|message| exp,  |ASMReg| Dest,  |fn_opasm!| fn, |ASMReg|)
	opt norefcounts
	|| ml = ASMReg()
	|| mr = ASMReg()
	|| TmpCloser = .VTmps
	|| DiscardMode = dest & AsmReg.Discard
	if dest is SingleExpr
		ml = .µ(exp, DiscardMode)
	  else
		// should check if the rightside has a function in it...
		// then we can't set the reg specifically.
		|| Mode = (DiscardMode with dest) as ASMReg.stayopen
		ml = .µ(exp.first!, mode)
		mode = DiscardMode.with(dest, ml)
		mr = .µ(exp.last!, mode)
	.CloseVTmps(TmpCloser)
	
	if dest is Discard
		.nopconst(mr)
		.nopconst(ml)
		return dest & ASMReg.discard // no need to do anything:   {a() + b()}
	
	if dest isnt CondRequest
		dest = .TempTyped(exp, dest)
	if  ml is ConstAny  and  mr is ConstAny
		(Dest is constany) // do the bitand trick... later
	
	target debug:if ml.floatness != mr.floatness							// Shouldn't happen.
	rz = (fn)(self, dest, ml, mr, exp.second!)
	target debug
		if dest is Constany  and  rz isnt Constany		// hmm?
			debugger, (fn)(self, dest, ml, mr, exp.second!)



function ASMReg.ReadOrWrite (|message| m, |asmreg| ptr, |asmreg| varadd, |int| index=0, |asmreg|)
	return .ReadOrWriteSub(m, ptr, varadd, index, self is set) * self


// we need a varadd... for x = a[b]
function ASMReg.ReadOrWriteSub (|message| exp, |asmreg| ptr, |asmreg| varadd, |int| index, |bool| DoWrite, |&fatasm|)
	if self is containsaddr
		#!wait?? this is meant to be an addrrequest? not a response.
		debugger
	
	(self asnt= asmreg.AddrRequest)
	|| T = .µtype
	|| BC = t.ByteCount
	|| bytes = BC.log2
	if  (bytes|uint| > 4)
		error (exp, "Object to large to access") // later we can do a struct-mem-copy operation?
		bytes = 0
	
	if index >= 128						// read/write only allows up to 127
		index *= t.ByteCount
		ptr = asmstate.sh.AddToReg(exp, asmreg(), ptr as asmreg.noscale, index)
		index = 0
	
	rz = exp.RD4U(self, ptr, varadd, index, 0)
	if DoWrite
		rz.op = ASMType.WriteASM[bytes]
	  else
		|| B = (bytes<<1) + t.issigned
		rz.op = ASMType.ReadASM[b]


function ASMReg.Read  (|message| exp,  |asmreg| ptr,  |asmreg| varadd,  |int| index=0,  |&fatasm|)
	opt inline
	return .ReadOrWriteSub(exp, ptr, varadd, index, false)
	

function ASMReg.Write (|message| exp,  |asmreg| ptr,  |asmreg| varadd,  |int| index=0,  |&fatasm|)
	opt inline
	return .ReadOrWriteSub(exp, ptr, varadd, index, true)


function message.ASMLocal (|asmreg| extra = 0, |asmreg|)
	opt	norefcounts
	|| d = .ASMDecl
	if d is local
		return d.WholeType as extra


function message.ASMReg (|int|)
	return .asmlocal.reg


function ASMState.ExistingVar (|message| m, |asmreg|)
	opt	norefcounts
	real self
	|| fn = m.func 
	while (fn == @bra) or ((fn == @type) and m.TypeCastDoesnothing)
		m = m.first!
		fn = m.func
	if fn == @thg
		return m.ASMLocal(ASMReg.FromExistingVar)
	

function message.HasAsmStuff (|bool|)
	opt norefcounts
	for ch in self
		|| fn = ch.brafunc
		if fn != @sheb and @num and @char
			return true
		
function message.brafunc (|syntax|)
	opt norefcounts
	while self
		|| fn = .func
		if fn != @bra
			return fn
		self = .first


function FatASM.ConvertConst (|datatypecode| Oldtype, |datatypecode| Newtype)
	if NewType.IsFloat and Oldtype.IsFloat
		.FloatConvConst(self, newtype.BitCount)
	  else
		.FloatIntConvConst(self, oldtype, newtype)


function FatASM.FloatConvConst (|&FatASM| src, |int| DestBitSize)
	|| f = (&src._Const)|&nil|
	if DestBitSize == 64			// f32 to f64
		.f64   = f|&float|[]|Float64|
	  elseif DestBitSize == 32		// f64 to f32
		.f32 = f|&f64|[]|float|
	  else
		error (src.msg)


function FatASM.FloatIntConvConst (|&FatASM| fat, |datatypecode| src, |datatypecode| dest)
	|| dbc = dest.ByteCount
	|| f = (&fat._Const)|&nil|
	if src.IsInt
		|| v = fat.Const
		if src.IsSigned
			if dbc == 4
				.f32 = v|float|					// i to f32
			  else
				.f64 = v|Float64|				// i to f64
		  else
			if dbc == 4
				.f32 = v|uint64||float|			// u to f32
			  else
				.f64 = v|uint64||Float64|		// u to f64
	  else
		if dbc == 4
			|| f32 = f|&float|
			if dest.IsSigned
				.const = f32[]|int|				// f32 to i
			  else
				.const = f32[]|int|				// f32 to u
		  else
			|| f64 = f|&f64|
			if dest.IsSigned
				.const = f64[]|int64|			// f64 to i
			  else
				.const = f64[]|uint64|			// f64 to u


function DataTypecode.ASMConv (|Datatypecode| To, |int|)
	return to.ASMPart<<2 ||| .asmpart


function DataTypecode.ASMPart (|int|)
	if .isfloat
		return 0 + (.bitcount > 32)
	return 2 + .issigned


function Message.TypeCastDoesNothing (|bool|)
	opt norefcounts
	|| Output = .ASMDecl.typeonly
	|| Input = .first!.ASMDecl.typeonly
	require  Output.Count    == Input.Count				// vectors
	require  Output.IsFloat  == Input.isfloat			// floatness
	|| BoolOut = Output is bool
	require (BoolOut) == (Input is bool)				// boolness

	|| BytesLost = Input.ByteCount - Output.ByteCount
	if output.isfloat
		return byteslost == 0
	require byteslost <= 0


