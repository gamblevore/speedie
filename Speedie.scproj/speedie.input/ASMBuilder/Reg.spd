

prototype fn_asm    (|&Assembler| self=Assembler.sh, |message| exp, |AsmReg| Dest=asmreg(), |AsmReg|)



datatype ASMReg (uint64)
	default 0|AsmReg|
	linkage
		cpp_part Reg
		numeric false
	
	Flags
		|asmreg|
		Temp = 1024 // sigh.
		(1<<16)		// starting point
		Negate
		AlreadyNegated
		Discard
		Param
		FromZeroMemory  // kludge to remove
		Alternate
		Subtract = Alternate
		Set
		UnusedSoFar
		Into2
		NoScale
		ContainsAddr
		Textual
		ConstRequest
		CondRequest
		CondAnswer
		BlockSafe
		BlockMostlySafe
		OKAsTemp
//		CompilerCreated
		GlobalMemory
		PreferEqul
		Const
		AddrNeed    = [AddrRequest, AddrForceRequest, AddrNoFiddle]
		Exit        = [ExitFunction, ExitAtAll]
		SetAlways   = Textual ||| Set  // reuse const
		// don't go above 47
		Zero	    = Const   ||| 56 ||| param		// 56 == datatypecode.uint64
//		RealDiscard = Const   ||| discard
		Simple		= Temp

	

	function TestBit
		|| x = ExitAtAll, (x)

	
	target debug
		render
			if self is Const
				fs <~ "k"
			fs <~ ('r' + ((self is temp)<<1))|byte| // r,t
			fs <~ .reg
			fs <~ "("
			.µtype.render(Fs)
			fs <~ ")"
	
	
	function F32 (|float|)
		if .reg
			return .needfat.F32
		
	function F64 (|Float64|)
		if .reg
			return .needfat.F64
	
	function float (|Float64|)
		if .reg
			|| f = .needfat
			if .isbig
				return f.f64
			return f.f32|float64|

	function Simplify (|asmreg|)
		return .ReallySimplify as (self & Simple)

	function ReallySimplify (|asmreg|)
		return self|uint16||asmreg|
	
//	function CopyConst (|asmreg| Src, |asmreg|)
//		return (self &~ Const) as (src & Const)
	
	function ConstCheck
		|| v = .reg$
		|| k = .const
		|| g = Assembler.sh.Register(v) #debug_require
		|| k2 = g.const
		if k2 != k // well fuck
		
	function Const (|int64|)
		// every single caller must check for Const (and does!)
		|| F = .FAT
			return f.const
		if .reg == 0
			return 0
		if self is Const // WHA DA FA!
		if self isnt param
			.NeedFAT
		
//	function Const (assigns:|int64|)
//		.needfat.const = value
//
//	function CanBeKnownValue (|bool|)
//		 return self is NotAlteredInbranch and Const

	function IsZero (|bool|)
		return  (self is Const) and (.const == 0)
		
//	function IsConst (|int64| val, |bool|)
//		return  (self is Const) and (.const == val)
	
	function Negate (|bool| Neg=true, |asmreg|)
		return (self|uint64| xor (neg << 16)|uint64|)|asmreg|
	
	function BitCount (|int|)
		return .µtype.bitcount
		
	function ByteShift (|int|)
		return .ByteCount.log2
	
	function ByteCount (|int|)
		return .µType.ByteCount
	
	function FatIndex (|uint|)
		return self|uint64| >> 48
	
	function FatIndex (assigns:|uint|, |asmreg|)
		return (((self|uint64| << 16) >> 16) ||| (value|uint64| << 48))|asmreg|
	
	function FAT (|?&fatasm|)
		|| i = .FatIndex
			return i.fat
	
	function NeedFAT (|&fatasm|)
		|| f = .fatindex.fat
			return f
		error "anorexic register"
		return Assembler.sh.zero
	
	operator isa (|datatypecode| M, |bool|)
		return .µtype == M

	operator iz (|asmreg| M, |bool|)
		return .reg == M.reg

//	operator iz (|int| M, |bool|)
//		return .reg == M

	function FourBytes (|bool|)
		opt inline
		return self|datatypecode|._shift == 2

	function BasicVec (|asmreg|)
		if .IsFloat
			.µType = DataTypeCode.Vec4
		  else
			.µType = DataTypeCode.iVec4
		return self
		
	function IsVec (|bool|)
		return self|datatypecode| & 0x03
	
	function Clip (|int|)
		if .isbool or !.reg
			return 0
		return 3 + self|datatypecode|._shift

	function bool.EqulMode (|asmreg| L, |asmreg| R, |int|)
		rz = self|int| xor 1
		rz |= L.clip << 1
		rz |= R.clip << 4

	function uint.EqulInputsAreBothBool (|bool|)
		return (self >> 1) == 0	
	
	function IsBig (|bool|)
		opt inline
		return self|datatypecode|._shift == 3 // could also be an int?

	function Small (|int|)
		opt inline
		return (self|datatypecode|._shift < 3)|int|

	function IsFloat (|bool|)
		opt inline
		return self|datatypecode|.isfloat

	function IsInt (|bool|)
		opt inline
		return self|datatypecode|.isint

	function Signed (|bool|)
		return self|DataTypeCode|.issigned
		
	function BitLoss (|int|)
		if .isbool
			return 63
		return 64 - .bitcount
	
	function IsBool (|bool|)
		opt inline
		return .µType is bool
	
	function µType (|DataTypeCode|)
		opt inline
		return self|DataTypeCode| & DataTypeCode.PossibleBits
	
	function µType (assigns:|DataTypeCode|, |asmreg|)
		|| Mask = DataTypeCode.PossibleBits|uint64| // first 10 bits
		return ((self|uint64| & ~Mask) ||| (value&Mask))|asmreg|
	
	syntax is (|AsmReg| R, |bool|)
		target debug
			if !r|int64|.ispow2 and r != asmreg.exit // ooof?
		return self & R
	
	syntax is (|AsmReg| R, assigns:|bool|, |AsmReg|)
		if (value)
			return self as r
		  else
			return self asnt r
		
	function datatypecode.zero (|asmreg|)
		|| K = asmreg.Const
		K.µtype = self
		return K
	
		
	function HaveAddr (|asmreg|)
		rz = self asnt AddrRequest
		rz = self asnt AddrForceRequest
		rz = rz as ContainsAddr
	
	
	function Reg (|int|)
		return (self|uint64| >> 11)&31
	
		
	function Reg (assigns:|int|, |AsmReg|)
		|| Bugged = value&31
		self &= ~(31 << 11)|asmreg|
		(self as= (Bugged << 11)|asmreg|)
		(self is temp) = (value >> 31)
		target debug: if .reg != Bugged // what?
		return self

	
	function Reg (assigns:|asmreg|, |asmreg|)
		.reg = value.reg
		(self is temp) = (value is temp)
		.fatindex = value.fatindex
		return self

	function SCDecl.ASMReg (assigns:|asmreg|)
		target debug
			if !value.reg and self is alteredorref
		
		isnt const
		.ExportPosition = 0 // this is for a local. locals store their consts in fats...
		if value is Const
			value.incr
			value.ConstCheck
			if self isnt Altered
				is const
//				.ExportPosition = value.Const
		value.µType = .mu.DataType
		.mu.DataType = value|datatypecode|
		.WholeType.tmpcheck
	
	
	operator mul (|bool| b, |asmreg|)
		return (self, nil)(b)
			

	operator mul (|message| m, |asmreg|)
		disabled "use temp"
	
	operator temp (|message| m, |asmreg|)
		if !m.ContainsFunc
			is temp
		return self
	

	syntax cast (|int|)
		disabled "use .reg"
		
	operator bitand (|asmreg| A, |asmreg|)
		return (self|int64| & A|int64|)|asmreg|

//	operator xor (|asmreg| A, |asmreg|)
//		return (self|int64| xor A|int64|)|asmreg|
	
	operator as (|asmreg| A, |asmreg|)
		return (self|int64| ||| A|int64|)|asmreg|

	operator asnt (|asmreg| A, |asmreg|)
		return (self|int64| &~ A|int64|)|asmreg|

	operator • (|asmreg| dest, |asmreg|)
		if .reg == dest.reg
			return dest.µtype.zero
		return dest
	
	function TryReg (assigns:|asmreg| dest, |asmreg|)
		if .reg or dest isnt temp
			return self
		.reg = dest 
		return self
	
//	function with (|asmreg| dest, |asmreg| InUse, |asmreg|)
//		if InUse.reg == dest.reg				// dest is in use!
//			.reg = 0
//			isnt temp
//			return self
//												// dest is free!
//		return .reg(dest)
//	

	
	target debug {
	function DebugPrint 
		target debug
			print .render
			|| f = .fat
				print " - "
				f.DebugPrint
			  else
				""
	}
	
	function TmpCheck (|bool|)
		|| R = .reg
		|| IsTmp = self is temp
		|| Big = R >= 26
		if big == IsTmp // bad?
			return true
		if big
			"big reg $R unmarked"
		  else
			"low reg $R marked"
		debugger
	
			
	module
		function New (|asmreg|)
			return Zero
		
	

// we could do this instead (ON RENDER?)
// (self-1)&31!!
// this will "rotate" 0 back to 31 and 1 to 0.

function int.asm (|asmreg|)
	cpp_part ToASM
	rz.reg = self // (self - 1)&31 // would be better?

function int.TextASM (|asmreg|)
	rz.reg = self // (self - 1)&31 // would be better?
	(rz is textual)


