


extend Assembler
	function VecSwizzle (fn_asm)
		opt norefcounts
		dest = .temptyped(exp, dest)
		|int| Swiz = exp.Indent
		|| src_msg = exp.first.first!
		|| src = .µ(src_msg, dest)
		|| fat = exp.VSWZ(dest, src, swiz)
		return fat * dest
	
		
	function VecAccess (|message| exp,  |AsmReg| Dest,  |asmreg| base,  |AsmReg| vara,  |asmreg|)
		|| k = .Const(vara, 8, false)
			vara = asmreg()
		  else
			k = 0

		if dest isnt set
			return exp.VGET(dest, base, vara, k) * dest

		return exp.VSET(base, dest, vara, k) * base


	function IncrVectorPart (|message| exp, |AsmReg| Dest, |AsmReg| Src, |int64| Value, |int| mode, |asmreg|)
		|AsmReg| OldValue
		if (dest isnt discard) and mode & ASMType.IncrAfter		// x = S[1]++
			OldValue = .Assign(exp, .temponly(dest), Src)

		|| vget = src.fat!
		|| VReg = vget.asmreg(2)
		|| VecIndex = vget.prms[3]
		if src.isfloat or vreg.reg
			|| NewValue = .AddToReg(exp, nil, src, value)		// S[1]++  -->  x = S[1], x++, S[1] = x
/			exp.VSET(src, NewValue, vreg, VecIndex)
			if dest is Discard
				return dest
			if mode & ASMType.IncrAfter
				return OldValue
			return NewValue
		
		if dest is Discard
			dest = .zeros(dest)

		src = vget.asmreg(1)
		.SoftNop(vget)
		|| NewValue = exp.QINC(dest, src, VecIndex, value) * dest
		if dest is Discard
			return dest
		if mode & asmtype.incrafter
			return OldValue
		return NewValue
		

	function VectorLoad (fn_asm)
		opt	norefcounts
		|| Closer = .OpenVars
		|asmreg[4]| VV
		|| Count = 0
		for s.fast in exp
			vv[Count++] = .µGetReal(s, s.AllowsTemp)
		
		|| T = vv[0].µType
		Count += (count == 3)
		
		t.VecCount = Count
		t &= ~48
		t |= 32
		dest.µType = T
		
		.CloseVars(Closer)
		dest = .TempOnly(dest)
		
		|| v3 = vv[3]
		if v3.reg >= 16
			v3 = nil
		|| fat = exp.VBLD(dest, vv[0], vv[1], vv[2], v3)
		dest = fat * Dest // for vset
		v3 = vv[3]
		if v3.reg >= 16 // move missing thing in
			exp.VSET(dest, v3, asmreg(), 3)

		return dest

