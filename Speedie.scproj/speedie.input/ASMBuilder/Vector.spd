


extend Assembler
	function VecSwizzle (fn_asm)
		opt norefcounts
		dest = .temptyped(exp, dest)
		|int| Swiz = exp.Indent
		|| src_msg = exp.first.first!
		|| src = .µ(src_msg, dest)
		|| fat = exp.VSWZ(dest, src, swiz)
		return fat * dest
	
		
	function VecAccess (|message| exp,  |AsmReg| Dest,  |asmreg| base,  |AsmReg| vara,  |asmreg|)
		|| k = .Const(vara, 8, false)
			vara = asmreg()
		  else
			k = 0

		if dest isnt set
			return exp.VGET(dest, base, vara, k) * dest

		return exp.VSET(base, dest, vara, k) * dest


	function IncrVectorPart (|message| exp,  |AsmReg| Dest,  |AsmReg| Src,  |int64| Value,  |int| mode,  |fatasm| vget, |asmreg|)
		// what about float vecs?
		if mode & ASMType.IncrAfter
			.Assign(exp, dest, Src)
		
/		|| add = exp.QINC(dest, src, vget.prms[2])
		// maybe better to just access it twice?
		// we have to get vara, k, and then the const. its a lot.
		// although its just 1 more. but its still alot. to be able to do both x[3]++ but also x[n]++
		// i think x[3]++ is acceptable but x[n]++ isnt...
		// leave for now... I guess
		
		// which part was it, though?
//		return .AddToReg(exp, dest, src, value) 
		

	function VectorLoad (fn_asm)
		opt	norefcounts
		|| Closer = .OpenVars
		|asmreg[4]| VV
		|| Count = 0
		for s.fast in exp
			vv[Count++] = .µGetReal(s, s.AllowsTemp)
		
		|| T = vv[0].µType
		Count += (count == 3)
		
		t.VecCount = Count
		t &= ~48
		t |= 32
		dest.µType = T
		
		.CloseVars(Closer)
		dest = .TempOnly(dest)
		
		|| v3 = vv[3]
		if v3.reg >= 16
			v3 = nil
		|| fat = exp.VBLD(dest, vv[0], vv[1], vv[2], v3)
		if v3.reg >= 16 // move missing thing in
			exp.VSET(dest, v3, asmreg(), 3)

		return fat * dest

