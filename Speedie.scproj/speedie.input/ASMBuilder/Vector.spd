


extend Assembler
	function VecSwizzle (fn_asm)
		opt norefcounts
		dest = .temptyped(exp, dest)
		|int| Swiz = exp.Indent
		|| src_msg = exp.first.first!
		|| src = .µ(src_msg, dest)
		|| fat = exp.VSWZ(dest, src, swiz)
		return fat * dest
	
		
	function VecAccess (|message| exp,  |AsmReg| Dest,  |asmreg| base,  |AsmReg| vara,  |asmreg|)
		|| k = .Const(vara, 8, false)
			vara = asmreg()
		  else
			k = 0

		if dest isnt set
			return exp.VGET(dest, base, vara, k) * dest

		return exp.VSET(base, dest, vara, k) * dest


	function IncrVectorPart (|message| exp, |AsmReg| Dest, |AsmReg| Src, |int64| Value, |int| mode, |fatasm| vget, |asmreg|)
		|| v = (1,1,1,1)
		v.x++
		if mode & ASMType.IncrAfter
			rz = .Assign(exp, .temponly(dest), Src)
		
		if src.isfloat or vget.RegOnly(2)
			|| tmp = .AddToReg(exp, nil, src, value)			// f[1]++ --> x = f[1], x++, f[1] = x
/			exp.VSET(src, tmp, vget.asmreg(2), vget.prms[3])
			return dest
		
		|| v2 = vget.prms[2]
		src = vget.asmreg(1)
		.softnop(vget)
		dest = exp.QINC(dest, src, v2, value) * dest
		ifn mode & asmtype.incrafter
			rz = dest
		

	function VectorLoad (fn_asm)
		opt	norefcounts
		|| Closer = .OpenVars
		|asmreg[4]| VV
		|| Count = 0
		for s.fast in exp
			vv[Count++] = .µGetReal(s, s.AllowsTemp)
		
		|| T = vv[0].µType
		Count += (count == 3)
		
		t.VecCount = Count
		t &= ~48
		t |= 32
		dest.µType = T
		
		.CloseVars(Closer)
		dest = .TempOnly(dest)
		
		|| v3 = vv[3]
		if v3.reg >= 16
			v3 = nil
		|| fat = exp.VBLD(dest, vv[0], vv[1], vv[2], v3)
		dest = fat * Dest // for vset
		v3 = vv[3]
		if v3.reg >= 16 // move missing thing in
			exp.VSET(dest, v3, asmreg(), 3)

		return dest

