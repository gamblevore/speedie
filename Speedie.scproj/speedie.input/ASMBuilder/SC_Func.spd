

class µFunc 
	linkage
		cpp_class ASMFunc
		cpp_part ASMFunc 
	|scfunction|			Fn
	|&FatASM|				IR
	|int|					Length
	|bool|					OK

	constructor (|scfunction| fn, |&FatASM| IR)
		.fn = fn
		.IR = ir
		fn.asm = self

//	function Name (|string|)
//		return .fn.ExportName

	function µTest (|memory of asm|)
		description "Generate some code (only for testing)."
		rz = asm[.length*3]$
		rz.length = rz.capacity
		|| p = rz.ptr
		|| after = .µRender(P, P+rz.length)
		rz.capacity = after-p
	
	// cosmic lore unfold... into tales untold
	
	function µRender (|!&ASM| Where, |!&asm| After, |!&asm|)
		|| HasLabel = 0
		rz = where
		// Could use a 64bit jump-map... so just mark each instruction as needing labels or not...
		// If theres only 1 or 2... we can jump directly. if more than 64 we just check da right bits.
		for i in .length
			|| fat = .ir+i
			haslabel |= fat.jumpreg
			fat.ASMIndex = rz - where
			rz = fat.µrenderinto(rz, after)

		if haslabel // could we do this in a bit smarter way? like a fat knows what points to it?
			for i in self
				|| r = i.jumpreg
					i.FillLabelRequest(where, rz, r-1)


	function memory.Run (|memory of asm| self, |&ivec4| Args = nil, |int| ArgCount=0, |int64|)
		cpp_part RunArgs
		|| r = jb_vm.vm.Registers(true)
		if args
			for i in argcount
				r[i] = args[i] 
		
		return jb_vm.Run(.ptr, .length)


/// TEXTUAL STUFF		
	render
		fs <~ "asm ${.fn.name}\n"
		for µ in self
			if µ.op != asm.NOOP
				fs <~ '\t'
				µ.Renda(fs)
				fs <~ '\n'

/// NIBBLER NIBBler nIBBLerr

	iterator
		|| CurrInst = .IR
		|| AfterInst = Currinst + .length
		while currinst < Afterinst
			yield currinst
			++currinst



function JBin.Add (|µFunc| fn)
	.AddMemory(@bin, fn.length*4)
	for i in fn
		.AppendInt(i.Encode)
