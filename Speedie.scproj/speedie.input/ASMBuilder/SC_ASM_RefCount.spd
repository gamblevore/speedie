

extend asmstate
	function InlineOffset (|asmreg| base, |int| pow2, |&int| index, |int| maximum, |asmreg|)
		if base is temp// and containsaddr
			|| bs = base.fat
			if bs isa asm.addk
				|| CC = bs.r[2]
				|| CC2 = CC >> pow2
				if (CC2 <= maximum) and (CC2<<pow2 == CC)
					.nop(bs)
					index[] += CC2
					|| R = bs.r[1]
					base.reg = R
					(base is temp) = (R >> 31)
		return base


	function RefCountSub (|message| exp, |message| prms,  |scfunction| fn, |&FatASM|)	// JB_SetRef(a, b)
		opt	NoRefCounts
		if fn == compiler.refclear
			|| offset = 0
			|| A = .µ(prms.first!, asmreg.AddrRequest)
/			return exp.RFWR(A, nil, 1, offset)						// reg to mem

		if fn == Compiler.RefSetRef
			|| Out = .µ(prms.first!, asmreg.AddrRequest as asmreg.stayopen)
			|| From = .µ(prms.second!, asmreg.AddrRequest)
			if out.reg == from.reg
				return exp.noop // wat?
			
			|| offset = 0
			if Out isnt ContainsAddr
				if From is ContainsAddr
					from = .InlineOffset(from, 3, offset, 13~bits)
					return exp.RFRD(Out, From, 1, offset)			// mem to reg
				return exp.RFST(Out, From, nil)						// reg to reg
			
			if  From is ContainsAddr
				|| P = prms.second!
				|| where = .Temponly(P)
				where.µtype = datatypecode._voidptr
				From = .Read(where, P, From, nil) * where			// (mem to reg)?

			out = .InlineOffset(Out, 3, offset, 13~bits)
			return exp.RFWR(Out, From, 1, offset)					// reg to mem


		if fn == Compiler.RefIncr2
			|| A = .µ(prms.first!, asmreg.addrrequest)
			target debug: if a isnt ContainsAddr					// always memory
			|| offset = 0
			A = .InlineOffset(A, 3, offset, 13~bits)
			|| B = .µ(prms.second!)
			target debug: if b is ContainsAddr						// always reg
/			return exp.RFWR(a, b, 0, offset)
		  else
			|| A = .µ(prms.first!)
			target debug: if A is ContainsAddr						// always a reg!

			if fn == Compiler.RefIncr
				return exp.RFST(asmreg(), a, asmreg())

			if fn == Compiler.RefDecr
				return exp.RFST(a, asmreg(), asmreg())
	
			if fn == Compiler.RefSafeDecr
				return exp.RFST(a, a, asmreg())
	
		debugger 
		return exp.EROR(asmreg(), asmreg(), asmreg(), asmreg(), 0)



	function RefCount (fn_asm)	// JB_SetRef(a,b)
		opt norefcounts
		|| prms = exp.last!
		|| fn = prms.obj|SCFunction|!
			
		if fn != Compiler.RefFreeIfDead
			return .RefCountSub(exp, prms, fn) * asmreg()
		|| A = .µ(prms.first!)
		#! we can do: if (JB_FreeIfDead(obj)), which makes no sense.
		#! In fact all those functions never "disown anything". We should disable
		#! returning the result of freeifdead
		#! if the result is needed... function must not disown, then we remove the freeifdead. 
/		exp.RFST(asmreg(), asmreg(), a)
		return a



function asmstate.Decr (|bool| SafeDecr=false, |asmreg|)
	|| fat = .last(asm.rfst)
		|| out = fat.out&31
			|| In = fat.a&31
			|| against = (out, nil)(SafeDecr)
			if in == against
				.nop(fat)
				rz.reg = out


function ASMState.SafeDecr (|asmreg|)
	return .decr(true)
	


class RefTest
	|string| s
	Constructor
		visible
		.s = "4"

