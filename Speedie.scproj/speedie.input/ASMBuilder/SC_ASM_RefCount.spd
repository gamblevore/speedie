


extend_module ASMType
	function RefCountSub (fn_fatasm)	// JB_SetRef(a,b)
		opt	NoRefCounts
		debugger 
		|| prms = exp.last
		|| fn = prms.obj|SCFunction|!
		|| A = .Âµ(prms.first!, dest)
/*	auto A = r[na].Obj
	auto B = r[nb].Obj
	if (Mode&8)		JB_Incr(B)
	if (Mode&1)		r[na].Obj = B
	if (Mode&4)		JB_SafeDecr_(A)
	if (Mode&2)		JB_FreeIfDead(A) */
	// RefRR(a, b)  // can do anything
	// RefMM(a, b)  // Is Read + RefMR
	// RefMR(a, b)  // Always fully refs
	// RefRM(a, b)  // always incr+return, MAY decr the reg

		|| offset = 0
		if fn == Compiler.RefClear
			if a isnt ContainsAddr					// always an addr
			return exp.RFWR(A, asmreg(), offset, 1) // set mem to nil

		if fn == Compiler.RefFreeIfDead
			if a is ContainsAddr					// always a reg!
			return exp.RFRG(a, a, 2)

		if fn == Compiler.RefSafeDecr
			if a is ContainsAddr					// always a reg!
			return exp.RFRG(a, a, 4)

		if fn == Compiler.RefDecr
			if a is ContainsAddr
				return exp.RFDC(a, 1, offset)		// refcounter SHOULD do decrmulti in destructors/carrays.
			return exp.RFRG(a, a, 6)				// (but doesnt just yet)

		if fn == Compiler.RefDecrMulti				// seems unused
			|| BD = prms.second!.asmdecl
			if a is ContainsAddr					// always a reg!
			if bd isnt const						// always const!!
			return exp.RFDC(a, bd.ExportPosition, offset)

		if fn == Compiler.RefIncr
			if dest.reg
				if dest is containsaddr
					// write
				  else
					// read?
			if A is ContainsAddr // we might wanna set a memory address from a register...
				// return smthgin
			return exp.RFRG(a, a, 6)				// (but doesnt just yet)
			
		if fn == Compiler.RefSetRef
			|| B = .Âµ(prms.second!)
			// exp.refr(A, A, B, B)
			if a is containsaddr
				if b is containsaddr
//					return exp.RSET(A, B)
				return exp.RFWR(A, B, 0, 1)
			if b is containsaddr
				// return exp.loadsome(ðŸ¤©)
//			return exp.rset(A,B)		
		
		

	function RefCount (fn_asm)	// JB_SetRef(a,b)
		|| fat = refcountsub(self, exp, dest)!
		return fat*dest
