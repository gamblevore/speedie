

extend ASMState
	function LoadTitle (|message| m, |message|)
		// asm oof (9)
		opt NoRefCounts
		|| name = m[@thg]$
		.fn.exportname = name.name
		.fn.name = name.name
		|| bra = name.Next(@bra)$
		|| n = bra[@num].int
		expect (n>=0 and n<=10) (m, "Too many arguments")
		for n
			.fn.args <~ TypeInt64!.TypeNormal // :) just ints!

		rz = bra.Next(@arg)
		rz.expectlast

		
	function TryRotateConst (|int64| Value,  |message| where, |int| reg,  |bool|)

	
	function NumToReg (|int64| V, |message| exp, |int| Reg)
		.AddASM(asm.setk, exp, reg, (V << 32) >> 32, V>>32)
		.consts[reg] = v
		
	
	function FatASM.FixConst
		|| V = .r[1]|uint64| << 32
		V |= 0
		|| Inv = V|uint64|.countbits > 32 
			V = ~V
		|| R = (~V|uint64|).LongestBitStretch	// longest false-stretch
		if r.x >= 50		// OK so we have the longest stretch in r.x
			V = V rotl 63-r.y
			.r[2] = inv|int|
			.r[3] = V|int|
			return

		debugat
		|| signed = (v < 0)|int|
			v = ~v

		.op = asm.setn
		.r[1] = 0
		.r[2] = signed
		.r[3] = v|int|
		if v >= (1 << 48)
			if v >= 64K
				//.op = asm.setn2
				.r[3] = v >> 32
				.R[4] = v & 0xFFFFffff
			  else
				//.op = asm.setn3
				.r[3] = 0
				.R[4] = v >> 32
				.R[5] = v & 0xFFFFffff
				
			
	function SetConst (|Message| List,  |message| Orig,  |bool|)
		opt norefcounts								// set1: r1, 123
		|| RegMsg = list[@thg]				#require
		|| ValMsg = regmsg.Next				#require
		|| Value  = ValMsg.ASMConst
		
		.NumToReg(value, orig, RegMsg.reg)
		return true
	
	
	function TextInstruction (|message| m)
		if !.TextOp(m)
			debugat // retry
			.TextOp(m)
		// we also need to go into the if/while things


	function TextOp (|message| m, |bool|)
		opt norefcounts
		
		if m == @rel
	//    r1 = jb_str_length(r2)~5    // save 5 regs on the stack
			|| Dest = m[@thg]$
			|| funcMsg = dest.GetASMFunc$

		require m.expect(@tmp)
		|| op = instruction[m]						#require
		|| list = m.first
		expect (list == nil or @list or @bra) (m)

		if op.IsSetConst
			return .SetConst(list, m)
		
		|| A = self <~ (op.opcode, m)
		|| write = 0
		for p in list
			if p != @name
				a.AddRegParam(p, write)
			  else
				a.AddRegNum(p, write, .GetLabelJump(p))
			expect (++write <= op.pcount) (list, "Too many params")

		return (op.pcount == write) #expect (list, "Too few params")

	
	function GetLabelJump (|message| P, |int|)
		opt NoRefCounts
		return *(textassembler.LabelsToDo.valuelower(p.name) #expect (P, "Label not found"))

	
	function LoadLabelJumps (|bool|)
		opt norefcounts
		require textassembler.LabelsToDo
		for A in .out
			if a.label == 255
				|| Found = .findlabel(a)
				if !found
					debugger, .findlabel(a), return false
				A.r[0] = Found-A
		return true
	
	
	function FatASM.File (|string|)
		opt norefcounts
		|| s = scimport.allfiles[.filenum]
			return s
	
	
	function FatASM.SyntaxExpect (|string| Error)
		|| err = Error(nil, error, ErrorSeverity.Error, .file)
		err.position = .BytePos
		stderr <~ err


	function FindLabel (|&FatASM| dbg, |&FatASM|)
		opt norefcounts
		|| num = dbg.r[0]
		for A in .out
			if a.label == num
				return a
		error (dbg, "No label found")
	
	
	function AddLabel (|message| ch)
		opt norefcounts
		|| T = textassembler.LabelsToDo init dictionary()
		.last.label = ++.labelcount			#expect (ch, "Too many labels")
		expect (!T.valuelower(ch.name))		        (ch, "Label already used" )
		#!debugger
		T.valuelower(ch.name) = dataobject(.out.length)


	function TextFuncSub (|message| m, |bool|)
		opt NoRefCounts
		for ch in .LoadTitle(m)
			if ch == @name
				.addlabel(ch)
			  else
				.TextInstruction(ch)
		return .LoadLabelJumps


function message.ASMConst (|uint64|) 
	opt norefcounts
	if (self == @unit)
		.expect(@nil, "d")$
		return .first.float.AsInt
	.expect(@num)$
	if (.name contains '.')
		return .float32.asint
	return .int


function uint64.LongestBitStretch (|ivec2|)
	if self == -1
		return (64,0)
	|uint64| last
    while self
		last = self
        self &= self rotl 1
		rz.x++
	rz.y = last.log2
	

// how to tell where the range is? we only know how long it is?

// 0101010000000000101010101-->
// 1010101111111111010101010
// 0000001111111110000000000
// OK now what? where is the range? we really want the last value!
// whhere does the range start/end?

extend FatASM
	setter Debug (|message|)
		.filenum = value.FileNum
		.Bytepos = value.position
	
