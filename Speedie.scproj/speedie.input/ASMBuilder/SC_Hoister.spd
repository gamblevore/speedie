


struct SC_Hoister
	linkage
		cpp_part Hoi
	|SCDecl--[6]|	Items
	|int|			OldHoistStart
	|int|			OldHoistEnd
	|byte|			Count
	|byte|			Spare
	
	constants
		MinHoistScore = 3
		AsLoop = 1<<20


// pre-allocating for gtabs/nums, per-loop
// now need to use it.


	function @asmtype.GlobAddr (|scdecl| D, |message| exp, |AsmReg| Dest, |asmreg|)
		opt norefcounts
		
		if "GlobAddr".trap
		
		|| Glob = .TryGetGlob(D)
			return Glob
	
		|int64| iTable = d.ExportPosition
		expect (iTable > 0)          (exp, "No global address".internal)
		expect (iTable <= 24~bits)   (exp, "Used over 16MB of global data")
	
		|| fat = exp.GTAB(dest,  (d.IsLib)|int|,  iTable>>6)
		fat.Const = iTable
		Dest = fat * dest
		dest.µtype = DataTypeCode._voidptr
		return dest.HaveAddr
	
	
	helper HoistOne (|asmreg| dest, |scdecl| decl, |asmreg| K)
		opt NoRefCounts
		|| I = k.fatindex
			I.fat!.µRefCount++
		decl.FatConstIndex = I
		decl.NilReg = dest.reg ||| nilreg.Hoisted
		.Items[.Count++] = decl
		.spare--


	helper GlobalAddrTable (|message| prop,  |scdecl| decl)
		opt NoRefCounts
		|| dest = ASMState.sh.DeclareMe(prop, decl)			// Pre-declare glob.
		|| Addr = ASMType.GlobAddr(decl, prop, dest)
		.HoistOne(dest, Decl, addr)


	helper WriteConst (|message| prop,  |scdecl| decl)
		opt NoRefCounts
		|| dest = ASMState.sh.DeclareMe(prop, decl)			// Pre-declare glob.
		|| K = asmstate.sh.NumToReg(prop, decl.ExportPosition, dest, dest.µtype)
		.HoistOne(dest, Decl, k)


	helper ReuseConst (|message| prop,  |scdecl| decl)
		opt NoRefCounts
		|| k = decl.ExportPosition
		for i in .Count
			|| Old = .items[i]!
			if old.ExportPosition == K
				old.fat!.µRefCount++
				decl.FatConstIndex = old.FatConstIndex
				decl.NilReg = old.NilReg
				return
		.WriteConst(prop, decl)
	
	
	function asmstate.Unhoist (|sc_hoister| H)
		opt NoRefCounts
		for d in h.Items
			loop d
			d.nilreg = 0
			|| f = d.fat
				f.µRefCount--
				if f.IsUnused
					.nop(f)
					

	function HoistNormal (|message| exp)
		.spare = –count .items
		.Hoist(exp, 0)
		
		
	function HoistLoop (|message| exp)
		.spare = 2
		.Hoist(exp.first!, AsLoop)
		.Spare += 2
		.hoist(exp.last!, AsLoop)


	function PreHoist (|asmstate| sh, |int| Amount, |int|)
		.OldHoistStart = sh.HoistStart
		.OldHoistEnd = sh.HoistEnd
		sh.HoistStart = sh.CurrIndex
		sh.HoistEnd = sh.HoistStart + Amount
		for amount
			|| fat = sh._Curr++
			fat._op = asm.noop
		return sh.OpenVars
	

	function TryHoist (|message| exp, |int| Score, |scdecl| prop)
		if prop.nilreg isnt hoisted
			if prop is const
				if (score >= AsLoop) and prop.exportposition
					.ReuseConst(Exp, prop)
			  elseif prop is Global
				.GlobalAddrTable(exp, prop)
		  else
			|| fat = prop.fat
				fat.µRefCount++
	
	
	function message.Declable (|message!|)
		opt norefcounts
		|| fn = .func
		if fn == @decl
			self = .second!
			fn = .func
		while fn == @type
			self = .first! // no go into the type!
			fn = .func
		if fn == @func
			return .second!
		return self
	
	
	function Hoist (|message| exp, |int| Score)
		opt norefcounts
		exp = exp.Declable
		|| fn = exp.func
		if fn == @arg and Score < AsLoop
			return
		if  (fn == @dot or @thg or @num)  and  (.spare > 0)
			|| prop = exp.ASMDecl
			if (score >= 0)
				.TryHoist(exp, score, prop)
			if prop is const or global
				return
	
		for ch.fast in exp
			|| add = 0
			if ch.func == @tmp
				|| ty = ch.ASMType
				add += (ty is kWhile) * MinHoistScore
				add -= (ty is kIf)
				
			.Hoist(ch, add + score)


function scdecl.Hoisted (|asmreg|)
	rz = .datatype|asmreg|
	rz.reg = .nilreg
	rz.fatindex = .FatConstIndex
