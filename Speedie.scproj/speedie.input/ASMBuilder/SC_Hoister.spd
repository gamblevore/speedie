


struct SC_Hoister
	linkage
		cpp_part Hoi
	|uint|				Bits
	|int|				OldHoistStart
	|int|				OldHoistEnd
	|byte|				Count
	|byte|				Spare
	
	constants
		MinHoistScore = 3
		AsLoop = 1<<20


	function ASMState.GlobAddr (|scdecl| D, |message| exp, |AsmReg| Dest, |asmreg|)
		opt norefcounts
		
		if "GlobAddr".trap
		
		|| Glob = .TryGetGlob(D)
			return Glob
	
		|int64| iTable = d.ExportPosition
		expect (iTable > 0)          (exp, "No global address".internal)
		expect (iTable <= 24~bits)   (exp, "Used over 16MB of global data")
	
		|| fat = exp.GTAB(dest,  (d.IsLib)|int|,  iTable>>6)
		fat.Const = iTable
		Dest = fat * dest
		dest.µtype = DataTypeCode._voidptr
		return dest.HaveAddr
	
	
	helper HoistComplete (|asmreg| dest, |SCDecl| decl, |asmreg| K, |asmstate| sh)
		opt NoRefCounts
		|| I = k.fatindex
		|| Fat = k.fat
			fat.µRefCount++
		decl.FatConstIndex = I

		|| n = dest.reg
		target debug
			if sh.HoistMap & (1<<n)		// what?
			if .bits & (1<<n)  			// what?
			if sh.hoisted[n]			// what?

		sh.hoisted[n] = fat
		sh.HoistMap |= 1<<n
		.Bits |= 1<<n
		.Spare--


	helper HoistGlobal (|asmstate| sh, |message| prop, |SCDecl| decl)
		opt NoRefCounts
		require !sh.TryGetGlob(decl)
		|| dest = sh.DeclareMe(prop, decl)
		|| Addr = sh.GlobAddr(decl, prop, dest)
		.HoistComplete(dest, Decl, addr, sh)


	helper HoistConst (|asmstate| sh, |message| prop, |scdecl| decl)
		opt NoRefCounts
		require !.CanReuseConst(decl)
		|| dest = sh.DeclareMe(prop, decl)
		|| K = sh.NumToReg(prop, decl.ExportPosition, dest, dest.µtype)
		.HoistComplete(dest, Decl, k, sh)


	helper CanReuseConst (|SCDecl| decl, |bool|)
		opt NoRefCounts
		|| k = decl.ExportPosition$
		for old in ASMState.sh
			if old._Const == K
				old.µRefCount++
				decl.FatConstIndex = old.Index
				return true


	function ASMState.TryGetGlob (|SCDecl| D, |asmreg|)
		|| find = d.ExportPosition & ~63
		for old in ASMState.sh
			if old isa asm.gtab
				|| k = old.const
				if k == find or (find - 64)
					return old.reg(0).asm
			
	
	function Unhoist
		opt NoRefCounts
		|| sh = asmstate.sh
		for (b.bits in .bits) (i)
			|| f = sh.Hoisted[i]!
			sh.Hoisted[i] = nil
			f.µRefCount--
			if f.IsUnused
				sh.nop(f)
			
		sh.HoistMap &= ~.bits
					

	function HoistNormal (|message| exp)
		.spare = 6
		.HoistRecursive(asmstate.sh, exp, 0)
		
		
	function HoistLoop (|message| exp)
		.spare = 2
		.HoistRecursive(asmstate.sh, exp.first!, AsLoop)
		.Spare += 2
		.HoistRecursive(asmstate.sh, exp.last!, AsLoop)


	function PreHoist (|asmstate| sh, |int| Amount, |int|)
		.OldHoistStart = sh.HoistStart
		.OldHoistEnd = sh.HoistEnd
		sh.HoistStart = sh.CurrIndex
		sh.HoistEnd = sh.HoistStart + Amount
		for amount
			(sh._Curr++)._op = asm.noop
		return sh.OpenVars
	

	function TryHoistOne (|asmstate| sh, |message| exp, |scdecl| prop, |int| Score)
		if prop is const
			if score >= AsLoop
				.HoistConst(sh, exp, prop)
					
		  elseif prop is Global
			.HoistGlobal(sh, exp, prop)
	
	
	function message.Declable (|message!|)
		opt norefcounts
		|| fn = .func
		if fn == @decl
			self = .second!
			fn = .func
		while fn == @type
			self = .first! // no go into the type!
			fn = .func
		if fn == @func
			return .second!
		return self
	
	
	function CanHoist (|asmstate| sh, |bool|)
		require .spare > 0
		|| Start = sh.HoistStart
		return start < sh.Hoistend		
	
	
	function HoistRecursive (|asmstate| sh, |message| exp, |int| Score, |bool|)
		opt norefcounts
		require .CanHoist(sh)
		exp = exp.Declable
		|| fn = exp.func
		if fn == @arg and Score < AsLoop
			return true
		
		if  (fn == @dot or @thg or @num)
			|| prop = exp.ASMDecl
			if prop is const or global
				if score >= 0
					.TryHoistOne(sh, exp, prop, score)
					return .CanHoist(sh)
				return true
	
		for ch.fast in exp
			|| add = 0
			if ch.func == @tmp
				|| ty = ch.ASMType
				add += (ty is kWhile) * MinHoistScore
				add -= (ty is kIf)
				
			require .HoistRecursive(sh, ch, add + score)
		return true
		
