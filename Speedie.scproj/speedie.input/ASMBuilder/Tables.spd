


dispatch fn_asm_table (fn_asm)
	@arg:					ASMType.Argument
	@tril:					ASMType.Argument
	@decl:					ASMType.decl
	@num:					ASMType.num
	@char:					ASMType.char
	@rel:					ASMType.DoMath
	@thg:					ASMType.Thg
	@bra:					ASMType.First
	@sheb:					ASMType.Sheb
	@sstr:					Assembler.Str
	@list:					Assembler.VectorLoad
	@func:					ASMType.ASMFunction
	@dot:					ASMType.Dot
	@acc:					ASMType.Access
	@brel:					ASMType.Brel		// ++, --, -, &
	@arel:					ASMType.arel		// ++, --, 
	@type:					ASMType.TypeCast
	@tmp:					ASMType.unexpected

	(ASMType.kif):			Assembler.If
	(ASMType.kwhile):		Assembler.While
	(ASMType.kTern):		Assembler.Ternary
	(ASMType.kContinue):	Assembler.Continue
	(ASMType.kExit):		Assembler.Exit

	(ASMType.kDebugger):	ASMType.Debugger
	(ASMType.krejoin):		ASMType.First
	(asmtype.kswap):		ASMType.Swap
	(ASMType.kreturn):		ASMType.return

	(ASMType.kSetRel):		ASMType.SetRel
	(ASMType.kStatExpr): 	ASMType.StatExpr
	(asmtype.kRefCount):	Assembler.RefCount
	(asmtype.kSwizzle):		Assembler.VecSwizzle
	(ASMType.kIgnore):		ASMType.Ignore
	(ASMType.kFail):		ASMType.Ignore

	63:						ASMType.unexpected



extend_module ASMType {
constants
	IncrAfter = 2
	IncrBefore = 0
	
|asm_Read[10]|	ReadASM
|asm_Write[5]|	WriteASM

function InitAccess
	|| R = &ASMType.ReadASM[0]
	|| W = &ASMType.WriteASM[0]
	R++[] = ASM.RD1U
	R++[] = ASM.RD1S
	R++[] = ASM.RD2U
	R++[] = ASM.RD2S
	R++[] = ASM.RD4U
	R++[] = ASM.RD4S
	R++[] = ASM.RD8U
	R++[] = ASM.RD8U
	R++[] = ASM.RD16
	R++[] = ASM.RD16
	#!Write	
	W++[] = ASM.WR1U
	W++[] = ASM.WR2U
	W++[] = ASM.WR4U
	W++[] = ASM.WR8U
	W++[] = ASM.WR16


function Debugger (fn_asm)
	if Options.TargetDebug
		return exp.TRAP(asmreg(), 0, 2) * ASMReg() // 2 == sigint
	return asmreg()


function Swap (fn_asm)
	opt norefcounts
	|| prms = exp.last
	|| A = .ExistingVar(prms.first!)
	|| B = .ExistingVar(prms.second!)
	expect (A.reg and B.reg) (Exp, "Can only swap registers")
	
	|| T = .DeclareMe(exp, A)
	T = .assign(exp, T, A)
	.assign(exp, A, B)
	.assign(exp, B, T)
	|| f = T.fat
	if f and f.µrefcount <= 0
		.SoftNop(F)
	return asmreg()


	
function First (fn_asm)
	opt norefcounts
	return .µGetASM(exp.first!, dest)


function Sheb (fn_asm)
	opt NoRefCounts
	exp.noop
	return nil
	

function BadBflg (|&Assembler| self, |fatasm| L, |int| rr, |bool|)
	require (l.RegOnly == rr)
	require .iscurr(l)
	require (l isa asm.BFLG)
	require !l.prms[2] and !l.prms[3]
	return true


function ReturnOpt (|&Assembler| self, |$asmreg| Ret_,  |bool|)
	opt norefcounts
	require .state.TailInlineable
	|| l = .last
	|| ret = ret_
	|| rr = ret.reg

	// We can tail functions that return nothing, assuming we also return nothing?
	
	if rr and BadBflg(self, l, rr)
		// we could make the thing that put it here... change instead?
		|| input = l.prms[1]&31
		|| fn = l-1
		|| fnout = fn.asmreg(0) // fn.output
		if .iscurr(fn) and (fnout.reg == input)
			if ret is Const != fnout is Const // sigh.
			ret.reg = fnout
			ret_ = ret
			.SoftNop(l)
			l = fn
			rr = ret.reg
	
	
	|| ReturnType = .out.ReturnType
	require l isa asm.fnc or asm.fnc3
	require !l.r3							// no pExt (not too many params)
	require !returntype or l.RegOnly == rr	// returning same var, or nothing at all.

	rz = .iscurr(l)							// This fnc must always flow into the return!
											// So its not required to "just work". But
	l.prms[0] = l.prms[1]					// We can't skip the ret if its not curr.
	l.prms[1] = l.prms[2]
	l.prms[2] = 0
	l._op = asm.tail
	(l.info as= ASMReg.exit)
	if 0: nil|message|!.TAIL

	
function InlinedReturn (|&Assembler| self, |message| exp, |asmreg| dest, |AsmReg|)
	opt norefcounts
	// What about getting the address of registers?
	|| extras = asmreg.ExitAtAll
	if .state.TailInlineable
		(extras is exitfunction)

	(dest as= extras)
	|| f = exp.first
		if dest.reg
			dest = .µinto(f, dest)
		  else
			dest = .µ(f, asmreg.discard)
	
	(dest as= extras) // it can get lost... sadly.
	if .state.TailInlineable
		.ClearAllStructs(exp)
		if  ReturnOpt(self, dest)
			return dest
	
	|| fat = exp.RET(Dest)
	fat.µRefCount = 1
	(dest is CondAnswer) // discard surely?
	return fat * Dest


function Return (fn_asm)
	opt norefcounts
	|| L = .state.return						// can remove constants, so try first
		return InlinedReturn(self, exp, L)

	dest = ASMReg.ExitFunction
	|| f = exp.first
		dest = .µGetASM(f, dest)
	
	.ClearAllStructs(exp)

	if ReturnOpt(self, dest)
		return asmreg.exit
	
	|| SafeDecr = FinalDecrements(self, exp, Dest)
		return SafeDecr

	|| K = .Const(dest, 8, true)
	|| HasK = K>=0
	|| fat = exp.RET(dest*!HasK, K * HasK)
	fat.µRefCount++
	return fat * asmreg.Exit
	


function TypeCast (fn_asm)
	opt norefcounts
	|| f = exp.first!
	|| NewDecl = exp.ASMDecl
	if newdecl.isbarestruct
		return asmreg() as asmreg.discard

	dest.µtype = newdecl.mu.DataType
	|| From = .µGetASM(F, dest)
	if From.µtype == dest.µtype
		return From // already done!

	|| NewType = NewDecl.regtype
	if !from.Reg												// x = 0|float|
		from.µtype = NewType
		return from

	|| OldType = from.µtype	
	if NewType is bool
		if (OldType is bool) and (dest isnt negate)				// x = true|bool| // why?
			return from
		return .NotEq(exp, dest, asmreg(), from)

	if  (NewType.BitCount == OldType.BitCount)  and  NewType.IsFloat == oldtype.isfloat
		from.µtype = newtype
		return from
	
	dest = .TempOnly(dest)
	dest.µType = NewType
	if from is Const
		return ConstConvert(self, exp, dest, from, oldtype, newtype)
		
	if oldtype.isfloat or newtype.isfloat
		return exp.CONV(dest, from, oldtype.ASMConv(newtype)) * dest
	
	if oldtype is bool // bools are normally considered bitcorrect. it would be impossible to do jbor otherwise.
		from.µtype = newtype
		return from

	|| sh2 = 64 - OldType.BitCount
	return exp.BFLG(dest, from, sh2, sh2, from.signed|int|) * dest



function ConstConvert  (|&Assembler| self, |message| exp, |ASMReg| dest, |ASMReg| from, |Datatypecode| Old, |Datatypecode| New, |ASMReg|)
	// this converts in place...	// we don't want that.
	
	|| srf = from.NeedFAT
	|| NC = New.BitCount
	|int64| K
	if old.isint != new.isint
		K = srf.FloatIntConvConst(old, new)
	  elseif new.isfloat
		K = srf.FloatConvConst(NC)
	  else
		|| sh = 64 - NC
		|| oof = srf.Const << sh
		K = (oof|int64| >> sh, oof|uint64| >> sh)(dest.Signed) // shift up and down

	.NopConst(from)
	return .NumToReg(exp, dest, K, new)



function SetRel (fn_asm)						// function relset (
	opt	norefcounts								//     x[func()] = y++
	|| A = exp.first!.asmunbra
	|| X = .ExistingVar(A)
		return .µInto(exp.last!, X)

	// Probably x.y = z, or x[y] = z 

	exp = exp.last!
	dest = nil|asmreg| temp a
	|| Src = .µGetReal(exp, dest)
	(Src is SetAlways)
	.µ(A, Src)
	return asmreg.discard



function ThgReference (|&Assembler| self, |message| exp, |AsmReg| Dest, |scdecl| d, |asmreg|)
	|| Reff = d.WholeType
	|| dr = dest.reg
	if dest is AddrRequest // (|$int|) v {v++}
		return reff.haveaddr	
	
	if dr == d.WholeType.reg
/		return dest

	dest.µType = Reff.µType
	
	if dest isnt set
		dest = .TempOnly(dest)
		if dest is ContainsAddr // how?
		// dest = reff --> dest = *reff
		return .Read(dest, exp, Reff, nil, nil) * dest

	// reff = dest --> *reff = dest
	(dest is discard)
	return .write(dest, exp, reff, nil, nil) * dest



function AllocBearStruct (|int| Dir, |message| Exp, |asmreg| Dest, |int| Size, |asmreg|)
	size = (size+15)>>4
	|| fat = exp.ALLO(dest, size*dir)
	fat.µRefCount++ // makes sense it is always reffed
	return fat * dest


function Decl (fn_asm) // declaresub declare 
	opt norefcounts
	
	|| ty = exp.fastdecl
	.DeclReset(ty)
	|| rel = exp.last!
	dest = .DeclareBody(rel, ty)

	(dest is unusedsofar)
	if ty.IsBareStruct or ty.IsCarray
		return AllocBearStruct(1, exp, dest, ty.SizeOfQuery)
	
	rel = rel.last!
	if .State.InlineDepth > 0
		return .µInto(rel, dest) // tail.
	return .µInto(rel, dest).incr


function StatExpr (fn_asm)
	opt norefcounts
	return ArgumentSub(exp.first!, -1|asmreg|) // test default struct-passing (speedie adds a &)


function ArgumentSub (|&Assembler| self=assembler.sh, |message| exp, |asmreg| Mask=asmreg.exit,  |AsmReg|)
	// merge into argument!
	opt NoRefCounts
	|| ch = exp.first
	if !ch
		return asmreg()
	|| v = .OpenVars
	|regfile| Restore = .Regs // adapt nilchecker to check if arg COULD return? If not... dont save.

	while
		if ch.func == @decl
			rz = decl(self, ch)
		  else
			rz = .µ(ch, asmreg.discard)
		ch++
		loop ch and rz isnt exit
	
	if !Mask
		exp = nil
	if rz isnt ExitFunction
		return .CloseVars(v, exp, rz & Mask) // tail
	rz = .CloseVars(v, exp, rz & Mask)
	.regs = Restore


// merge?
function Argument (fn_asm) // argument 
	return ArgumentSub(self, exp)



function Access (fn_asm)										// a[b], struct.mem[b]
	opt	NoRefCounts
	if dest isnt set
		dest = .TempTyped(exp, dest)
	
	|| f = exp.first!
	|| d = f.asmdecl
		
	|| sc = exp.Second.first!
	|| mode = ASMReg.AddrRequest temp sc
	
	ifn (dest isnt AddrRequest) and !d.IsCarray and d.CanCopyNormally
		(mode as= asmreg.AddrNoFiddle)						// inlineoffsetopt can't get at buried glob
															// So we simplify

	|| base = .µGetReal(f, Mode)							// x = a.b[0]
	|| vara = .µGetASM(sc)

	if d.TypeInfo.VecCount > 1
		return .VecAccess(exp, dest, base, vara)

	target debug: if !d.PointerCount and !d.IsCarray
	
	if d.CanCopyNormally
		if dest isnt AddrRequest
			dest.µType = exp.ASMDecl.mu.DataType
			if !d.IsCarray									 		// what if its a carray to a pointer?
				d = d.internal!		
			return .ReadOrWrite(Dest, exp, base, vara, d, 0)		// readorwrite can convert vara to a const
	  elseif dest is set
		return .CopyMemory(0, Exp, dest, base, vara, D.internal!) * asmreg()	
		
	return .IncrPointerByVar(dest, base, vara, exp)
	


function DotConst (|&Assembler| self, |AsmReg| Dest, |message| exp, |scdecl| Prop, |AsmReg|)
	opt norefcounts // wait? don't these all get pre-transformed? SHOULD they be?
	|| fn = prop.islookuponly
	if fn isa scfunction
		.ASMreach(fn)
		return DoGlobal(self, dest, exp, prop)
	return ConstFromThgName(self, exp, dest, prop)


function Dot (fn_asm)										// a.b
	opt	NoRefCounts
	|| prop = exp.ASMDecl		
	if prop is const
		return DotConst(self, dest, exp, prop)
	
	if prop is global
		return DoGlobal(self, dest, exp, prop)
	
	|| OV = .OpenVars				// is this safe? Not sure! delete if it causes problems.
	|| Obj = .µGetASM(exp.first!)
	dest.µtype = prop.typeinfo
	.CloseVars(ov)					// in terms of anything simple... I can't see problems.
	
	|| Index = prop.ExportPosition 
	if (Index >= 1MB) or (prop.TypeSuffers and dest.ByteCount != 8) // what?
		debugger
		prop.typeinfo
		
	if (dest isnt set) and !dest.reg and (obj is temp)
		dest.reg = obj // keeps the const. not what we want
		(dest isnt Const)
	
	if (dest is AddrRequest) or prop.IsCarray or prop.IsBareStruct
		return .DotAddr(exp, dest, Index, prop, obj)
	
	index >>= dest.ByteShift
	return .ReadOrWrite(Dest, exp, obj, ASMReg(), prop, Index)



function Char (fn_asm)
	return num(self, exp, dest) // its just a num, right?


function Num (fn_asm)
	opt norefcounts
	|| d = exp.ASMDecl
	|| T = d.typeonly
	dest.µtype = T
	(dest is Const)
	return .NumToReg(exp, dest, d.ExportPosition, T)


function Thg (fn_asm)
	|| thg = asmtype.ThgSub(self, exp, dest)
	target debug
		|| reg = thg.reg
		if (reg-1)|uint| >= 31								// what?
			if (!reg) and (thg is Const or discard)
				return thg
			error (exp, "Register out of bounds")
	return thg										// Its still ok.   nil/false


function ConstFromThgName (|&Assembler| self, |message| exp, |AsmReg| Dest, |scdecl| d, |asmreg|)
	(dest is Const)
	if dest isnt ConstRequest
		dest.µtype = d.mu.DataType
		return .NumToReg(exp, dest, d.ExportPosition, dest.µtype)
	return dest


function GrabAddr (|&Assembler| self, |message| exp, |AsmReg| Dest, |scdecl| d, |asmreg| T, |asmreg|)
	opt norefcounts
	dest = .TempTyped(d, dest)
	
	|| fat = exp.GRAB(dest, t)
	if d.IsInt and !d.IsBool
		|| L = t.BitLoss
			|| bastard = .CurrFuncGrab.SetSign(t.Signed)|int64|
			fat.Prms[5] = bastard
			fat.const = L
	return fat * dest.HaveAddr


function ThgSub (|&Assembler| self, |message| exp, |AsmReg| Dest, |asmreg|)
	opt norefcounts
	|| d = exp.ASMDecl
	if d is local
		if dest is ConstRequest
			return nil
		if d is reference
			return ThgReference(self, exp, dest, d)
			
		if dest isnt AddrForceRequest
			return .LocalThg(d)
			
		|| T = .LocalThg(d)
		if d.IsBareStruct or d.iscarray					// it already has the address 
			return T.haveaddr
		return GrabAddr(self, exp, dest, d, T)
	
	if d isnt global
		return ConstFromThgName(self, exp, dest, d)

	if d is classobj
		(dest is AddrNeed)
	if (dest is ConstRequest)
		return nil

	|| fn = d.IsLookupOnly
	if fn isa scfunction
		.ASMreach(fn)
	return DoGlobal(self, dest, exp, d)
		



function DoGlobal (|&Assembler| self, |AsmReg| Dest, |message| exp, |scdecl| D, |ASMReg|)
	opt	NoRefCounts
	|| addr = .GlobAddr(d, exp, dest)
		if (dest is AddrRequest) or d.isbarestruct or d.iscarray
			addr.µtype = d.mu.DataType
			return addr.HaveAddr
		
		dest.µtype = d.mu.DataType
		(dest isnt ContainsAddr)
		return .ReadOrWrite(dest, Exp, addr, ASMReg(), d)
	


function AddressOf (fn_asm)
	rz = .µGetASM(exp, dest as asmreg.addrneed)
	target debug: if (rz isnt ContainsAddr)
	(rz isnt ContainsAddr)
	(rz isnt AddrRequest)
	(rz isnt AddrForceRequest)



function BoolNot (fn_asm)							// !a
	dest = dest.negate
	|| src = .µGetASM(exp, dest)
	if src is AlreadyNegated
		return src
	return .Exists(dest, src, exp)
	


function IncrSlowOnAddr (|&Assembler| self, |message| f, |ASMReg| Dest, |int| Mode, |ASMReg| Addr, |int64| Amount, |scdecl| glob,  |ASMReg|)	
	opt	NoRefCounts											// *a, x = *(a.b)
	|| TmpCloser = .OpenVars
	dest = .temponly(Dest)
	.Read(Dest, F, dest, addr, glob)						// READ

	|| NewValue = (.Temptyped(f), dest)(mode & IncrAfter)
	.IncrPre(f, NewValue, dest, amount)						// ADD

	|| fat = .write(dest, f, NewValue, addr, glob)			// WRITE BACK

	// the new value should exist! now lets close
	return .CloseVars(TmpCloser, nil, fat*dest)




function IncrOnAddr (|&Assembler| self, |message| exp, |AsmReg| Dest, |int| Mode, |AsmReg| Addr, |int64| Amount, |scdecl| Glob, |asmreg|)

	ifn  dest.isint  and  amount.fits(6)
		return IncrSlowOnAddr(self, exp, dest, mode, Addr, Amount, glob)

	|| bc = dest.µtype.ByteCount.log2
	|| offset = 0
	addr = .InlineOffsetOpt(addr, bc, offset, 6, glob, exp)
	
	|| fat = exp.CNTC(dest, Addr, offset, amount, bc)
	if !dest.reg
		fat._Outputs &= ~1 // clear output
	
	if mode & IncrAfter
		if 0: exp.CNTD
		fat._op = asm.cntd
	return fat * dest



function IncrAmount (|asmreg| upon, |int| IsPlus, |scdecl| D,  |int64|)
	opt norefcounts
	rz = (1,-1)(IsPlus & 1)
	if upon.isfloat
		if upon.FourBytes
			rz = rz|float|.asint
		  else
			rz = rz|Float64|.asint
	  elseif D.TypeSuffers
		rz *= D.PointerIncrement



function NotTemp (|&Assembler| self, |asmreg| Src, |message| p)
	|| r = .state.return.reg
	if r and r == src.reg
		return
	check (src isnt temp) (p, "Can't increment temporary value.")

	
function Incrementa (|&Assembler| self, |message| exp, |AsmReg| Dest, |int| Mode, |AsmReg|)
	opt	NoRefCounts
	
	|| Src = .µGetASM(exp, dest as ASMReg.AddrRequest)
	|| D = exp.ASMDecl
	|| Amount = IncrAmount(src, mode, D)

	if dest is discard
		mode = IncrBefore
	  elseif !dest.reg
		if (mode & IncrAfter) // or (src isnt temp) // why? Why was this added? it messes things up?
			dest = .TempTyped(exp, dest)
			if (dest is const)
		  else
			dest.reg = src
		(dest isnt const)

	src = src as asmreg.noscale
	|| p = exp.parent! // better positions
	if src is ContainsAddr
		dest.µType = src.µType
		return IncrOnAddr(self, p, dest, mode, src, amount, D)
	
	NotTemp(self, src, p)
	if mode & IncrAfter
		return .IncrPost(p, dest, src, amount)				// x++,	 y = x++
	return .IncrPre(p, dest, src, Amount)					// ++x,	 y = ++x



function ARel (fn_asm)
	opt	NoRefCounts
	|| F = exp.name[]
	if F == '?' or '!'
		return .µGetASM(exp.first!, dest)
	|| M = (F == '+')|int|
	if dest isnt discard
		M += IncrAfter
	return Incrementa(self, exp.first!, dest, M)



function BRel (fn_asm)						//  --a,  ++a,  &a,  --glob,  --a.b, -a
	opt	NoRefCounts
	|| S = exp.name
	|| n = S[]
	if n == '~'
		return .DoMathSub(exp, dest, scoperator.bnot.OpASM!)
	if n == '-' and S == 1								// -a
		return .DoMathSub(exp, dest, scoperator.Negative.OpASM!)

	|| F = exp.first!
	if n == '!'
		return BoolNot(self, F, dest)
	if n == '&'
		return AddressOf(self, f, dest)
	
	|| IsPlusPlus = n == '+'						// ++a, --a
	return Incrementa(self, F, dest, IsPlusPlus|int|)



function DoMath (fn_asm)
	opt norefcounts
	|| op = exp.second!
	|| scop = op.obj|scoperator|!
	if scop is AndOr
		return .ASMBoolMaker(exp, dest, scop.Kind)
	|| fn = scop.OpASM!
	return .DoMathSub(exp, dest, fn)



function Ignore			(fn_asm)
	return ASMReg()


function Unexpected		(fn_asm)
	if !exp.asmtype
		|| f = exp.func|int|
			exp.asmtype = f
			return .µGetASM(exp, dest)
	error (exp, "bad ASMType")
}



extend Assembler {

function DotAddr (|message| exp, |AsmReg| Dest, |int| Pos, |scdecl| prop, |asmreg| obj, |AsmReg|)
	if prop.iscarray
		dest.µtype = DataTypeCode._voidptr
	dest = dest.haveaddr
	obj = obj as asmreg.NoScale
	return .AddToReg(exp, dest, obj, pos)


function message.ASMUnbra (|message|)
	opt	norefcounts
	real self
	|| fn = .func 
	while (fn == @bra) or ((fn == @type) and .TypeCastDoesnothing)
		self = .first!
		fn = .func
	return self



function ExistingVar (|message| m, |asmreg|)
	opt	norefcounts

	m = m.ASMUnbra
	|| fn = m.Func
	
	require fn == @thg or @num
	
	|| d = m.ASMDecl
	if fn == @thg
		require d is local and d isnt Reference
		return .LocalThg(d)

	return .MegaNumFinder(d.ExportPosition, d.mu.DataType)


function Str (fn_asm)
	opt	norefcounts
	dest = .TempOnly(dest)
	|| real = exp.name|MessageID|
	dest.µtype = DataTypeCode._voidptr
	return exp.GOBJ(dest, 0, real.ID) * dest // seems good!


helper VectorUpgrade (|asmreg| Src, |message| exp,  |asmreg|)
	|| T = .TempOnly(src.BasicVec)
	return exp.VSWZ(T, src, 0) * T


helper DoMathSub (|message| exp,  |ASMReg| Mode,  |fn_opasm!| fn, |ASMReg|)
	opt norefcounts
	|| ml = ASMReg()
	|| mr = ASMReg()
	|| First = exp.first!
	|| dest = mode
	target debug: || trap = ++ASMTrapper, if trap == 0
	if First.islast
		ml = .µGetASM(first, dest)
	  else
		ml = .µGetRealOffer(First, dest)
		if (dest is UnusedSoFar) and !(ml iz dest)
			mr = dest

		mr = .µ(exp.last!, mr)
		if ml.IsVec != mr.IsVec
			if ml.IsVec
				mr = .VectorUpgrade(mr, exp)
			  else
				ml = .VectorUpgrade(ml, exp)
	
	if dest is Discard
		.AskNopTemp(ml)
		.AskNopTemp(mr)
		return dest // returning from inline, into func that discards result.
	
	dest = .TempTyped(exp, dest)
	(dest is Const) = (ml&mr is Const)
	
	|| op = exp.second ?? exp.first!
	rz = (fn)(self, op, dest, ml, mr)
	
	target debug: if rz.IsVec != ml.IsVec			// argh?
	
	rz.µtype = dest.µtype



function LocalThg (|scdecl| d,  |asmreg|)     // asmlocal, localasm
	opt norefcounts
	|| T = d.WholeType

	(t is param) = d is param
	(t is BlockMostlySafe) = d isnt AlteredInBranch
	(t is BlockSafe) = d isnt AlteredBranchLike
	|| f = .Register(t.reg)

	// consts must have fats! both in and out. unless r0.
	if f and (.iscurr(f) or (t is BlockSafe))
		t.FatIndex = f.index
		(T is Const) = (f is Const)
	
	|| rr = T.reg
		|| Ret = .State.Return
		if rr == ret.reg
			(T is temp) = (ret is temp)
	  else
		(t is const)
	
	// ASMReg() calling SC_Reg_SyntaxIsSet() triggers this.
	//if d is const and t isnt Const // oof. lost somehow?
	//	debugger
	// this is possible. Using inlines. We can write to a "const register"... but only in the return value.
	// if there are multiple branches, then they'll see the previous branch's write. Which is fine...
	// we just lose the const value, thats all. The arg can't restore this either. It would need to be
	// "unrestored" after the else condition is done. And then merged. What a mess. Nil-checker complexity.
	// leave this as it is!
	
	return T
}



//function SCFunction.TrackReturns (|scdecl| D)
///	if d isnt VarThatGotReturned // remove function?
//		.ReturnedVars++
//		(d is VarThatGotReturned)	


function message.HasAsmStuff (|bool|)
	opt norefcounts
	nil checker
	for ch in self
		|| chh = ch.ASMUnbra
		|| fn = chh.func
		if fn != @sheb and @num and @char
			return true


function FatASM.FloatConvConst (|int| DestBitSize, |int64|)
	|| f = &._Const
	if DestBitSize == 64						// f32 to f64
		return (f|&float|[]|Float64|).asint
												// f64 to f32
	return f|&f64|[]|float|.asint


function FatASM.FloatIntConvConst (|datatypecode| src, |datatypecode| dest, |int64|)
	|| dbc = dest.ByteCount
	|| f = (&._Const)|&nil|
	if src.IsInt
		|| v = .Const
		if src.IsSigned
			if dbc == 4
				return v|float|.asint			// i to f32
			return v|Float64|.asint				// i to f64
		if dbc == 4
			return v|uint64||float|.asint		// u to f32
		return v|uint64||Float64|.asint			// u to f64

	// src.isfloat
	if src.ByteCount == 4
		|| f32 = f|&float|[]
		if dest.IsSigned
			return f32|int64|					// f32 to i
		return f32|uint64|						// f32 to u
	
	|| f64 = f|&f64|
	if dest.IsSigned
		return f64|int64|						// f32 to i
	return f64|uint64|							// f32 to u


function DataTypecode.ASMConv (|Datatypecode| To, |int|)
	return to.ASMPart<<2 ||| .asmpart


function DataTypecode.ASMPart (|int|)
	if .isfloat
		return 0 + (.bitcount > 32)
	return 2 + .issigned


function Message.TypeCastDoesNothing (|bool|)
	opt norefcounts
	|| Output = .ASMDecl.typeonly
	|| Input = .first!.ASMDecl.typeonly
	require  Output.VecCount == Input.VecCount			// Vectors
	require  Output.IsFloat  == Input.isfloat			// Floatness
	if (Output is bool) == (Input is bool)				// Boolness
		return Input.ByteCount == Output.ByteCount

