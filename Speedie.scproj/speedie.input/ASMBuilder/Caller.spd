



extend Assembler {

function IsASMConst (|message| exp, |bool|)
	|| fn = exp.func
	if fn == @num
		return true
	if fn == @thg // now what?
		return ASMType.ThgSub(self, exp, ASMReg.ConstRequest)


function PrmCollectSpd (|message| prms,  |SCFunction| fn,  |uint64|) // paramcollect, paramscollect
	opt norefcounts
	|int64| sh
	|| args = fn.args
	|| i = 0
	for p.fast in prms
		|int64| v = .µReffed(p!, args[i]!).reg
		sh += 5
		rz |= v << sh
		i++
	
	rz |= i


function PrmCollect (|message| prms,  |SCFunction| fn,  |uint64|)
	// We want a simple param order for speedie. Only sensible way to do things.
	// So we can't share the prmcollector.
	opt norefcounts
	
	if !fn.HasCVersion
		return .PrmCollectSpd(prms, fn)
	
	|int64| sh = 64
	|| fc = 0
	|| ic = 0
	|| args = fn.args
	|| n = args.Length
	for Ints in 2
		|| i = 0
		for p.fast in prms
			|| ty = p.ASMDecl
			if ty.SpecialRegs|int| != Ints		// should get .SpecialRegs from message somehow?
				|int64| v = .µReffed(p!, args[i]!).reg
				sh -= 5
				rz  |=  v << sh
				ic += ints
				fc += !ints
			i++
	
	rz >>= 64-((n*5)+12)
	if fc>8 or ic>8			// hmmm
	rz |= fn.ASMReturn.SpecialRegs << 11
	if fc
		rz |= (8-fc) << 6
		rz |= (8-ic) << 0
	  else
		rz |= (17-ic) << 6
		

function CallFunc (|message| exp,  |asmreg| dest,  |scfunction| fn,  |asmreg|)
	.ASMReach(fn)
	|| vd = .VDecls
	|| v = vd.log2
	|| diff = (!v or dest.reg != v)
	v += diff
	
	vd |= 1<<v
	.Vdecls = vd
	
	check ((v < 32) and !(vd & .vtemps)) (exp, "Too many registers in use. No space for result.")
	if (dest is ExitAtAll)
		if .state.return
			v = 1 max (.state.parentvars|uint|.log2) // a simple max will fix this?
	dest.reg = v
	dest.µtype = fn.ASMRegType
	return dest.ReallySimplify


function RegClear (|message| exp, |&fatasm| C, |int| i)
	c.prms[5] = 0
	|| L = c.Const
	|| signed = L < 0
		L = -L
	exp.BFLG(i.asm, i.asm, L, L, signed|int|)


function ClearGRABbedAndTrampled (|message| prms,  |asmreg| Dest,  |&fatasm| Start)
	// asmtodo: unnecessary? Values are always 32 or 64-bit. everthing else should be
	// set correctly, right? remove later?
	opt norefcounts
	if 0: prms.FNC3, prms.FNCX, prms.FNCX3			// MARK USED

	|| c = .Last - 1
	while C >= Start
		if (c isa asm.GRAB)
			|| id = c.Prms[5]
			if id == .CurrFuncGrab
				.RegClear(prms, c, c.RegOnly(0))
		c--
	if 1
		return
	// still need this tho.	caused an error tho?
	|| i = dest.reg
	while ++i <= 31
		.setRegister(i, nil, nil)
		
}




function SCFunction.HasCVersion (|bool|)
	if .IsLibrary
		return true
	require self is wrapper

	if .IsCppInBuilt == 1	// cpp_inbuilt. These normally have no address? but perhaps we made a wrapper for it in the exec? we should check if it still exists.
		debugat
		return true

	if .IsCppInBuilt == 2	// cpp_nothing: cpp_spd might sound better?
		debugat
		return false // need to be replaced with ASM intrinsics.

	if self Is ExternalLib	// cpp_libwrapper ?   // Speedie_Main in perry, counts as one!
		debugat
		return false  // i think only perry used this and only in debug mode within Xcode

	return true


function @ASMType.ASMFunction (fn_asm)				// dofunction function
	opt norefcounts
	|| prms = exp.last!
	|| fn = prms.AsFunc
	|| TableID = 0
	if fn
		|| intrin = fn.Intrinsic
			return .DoIntrinsic(exp, dest, intrin)
		|| MiniDest = .AskForInline(prms, dest, fn)
			return MiniDest
		TableID = fn.tableid ?? 0xFFFF				// 0xffff means unknown?
		TableID += 31
	  else
		// asmtodo: we never get here?? hmmm. that can't be right? need an asm_test for that!
		|| f = exp.first!
		TableID = .µ(f).Reg
		|| dcl = f.ASMDecl
		// need to execute exp.first
/		fn = dcl.Type.FuncProto						#expect (exp)

	dest = .CallFunc(exp, dest, fn)
	if !fn.ASMReturn
		(dest is Const)
	
	|| Start = .curr
	++.CurrFuncGrab
	
	|| Closer = .OpenVars
	|| P = .PrmCollect(prms, fn)
	.CloseVars(Closer)
	
	|| PExt = P >> 32
	(dest isnt Const) // why would it be?
	|| fat = prms.FNC(dest, TableID, P,  PExt)		// prms.fncx
	if fn.HasCVersion
		fat._op = asm.FNCX
	fat._op += PExt > 0

	.ClearGRABbedAndTrampled(exp, dest, Start)		// comment out? once tests work?
	
	fat.µRefCount += fn isnt STATELESS				// NOICE!
	if fn is Killer									// return just to be safe
		fat = exp.RET()
		fat.µRefCount++
		dest = asmreg.exit
	
	.CurrFuncGrab--
	return fat * dest



function assembler.ASMReach (|scfunction| fn)
	if .out.MyReacher
		(fn is usedbyasm)


//function PrmPrint (|string| s)
//	opt norefcounts
//	
//	print s
//	print " "
//	printline .fn.exportname
//	
//	for a in .fn.Args
//		print a.name
//		print ": "
//		print (a is const).render
//		print ", "
//		print (a is reference).render
//		print ", "
//		printline (a.wholetype.reg).render
//	printline s
//	printline
//	printline
