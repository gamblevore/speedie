


extend Assembler {

function IsASMConst (|message| exp, |bool|)
	|| fn = exp.func
	if fn == @num
		return true
	if fn == @thg // now what?
		return ASMType.ThgSub(self, exp, ASMReg.ConstRequest)


function PrmCollectSpd (|message| prms,  |SCFunction| fn,  |uint64|) // paramcollect, paramscollect
	opt norefcounts
	|int64| sh
	|| args = fn.args
	|| i = 0
	for p.fast in prms
		|int64| v = .µReffed(p!, args[i++]!).reg
		sh += 5
		rz |= v << sh
	
	rz |= i


function PrmCollect (|message| prms,  |SCFunction| fn,  |uint64|)
	opt norefcounts
	
	if !fn.HasCVersion
		return .PrmCollectSpd(prms, fn)
	
	|int64| sh = 64
	|| fc = 0
	|| ic = 0
	|| args = fn.args
	|| n = args.Length
	for Ints in 2
		|| i = 0
		for p.fast in prms
			|| ty = p.ASMDecl
			if ty.SpecialReg|int| != Ints
				|int64| v = .µReffed(p!, args[i]!).reg
				sh -= 5
				rz  |=  v << sh
				ic += ints
				fc += !ints
			i++
	
	rz >>= 64-((n*5)+12)
	if fc>8 or ic>8			// hmmm
	rz |= fn.ASMReturn.SpecialReg << 11
	if fc
		rz |= (8-fc) << 6
		rz |= (8-ic) << 0
	  else
		rz |= (17-ic) << 6



function CallFunc (|message| exp,  |asmreg| dest,  |scfunction| fn,  |asmreg|)
	opt norefcounts
	.ASMReach(fn)
	|| vd = .VDecls
	|| v = vd.log2					// we can't use .declareme, .log2 is used to protect the vars. 
	|| diff = (!v or dest.reg != v)
	v += diff
	
	vd |= 1<<v
	.Vdecls = vd
	
	check ((v < 32) and !(vd & .vtemps)) (exp, "Too many registers in use. No space for result.")
	if (dest is ExitAtAll)
		if .state.return
			v = 1 max (.state.parentvars|uint|.log2) // a simple max will fix this?
	dest.reg = v
	
	|| ty = fn.ASMReturn(dest)
	return ty.ReallySimplify


function RegClear (|message| exp, |&fatasm| C, |int| i)
	c.prms[5] = 0
	|| L = c.Const
	|| signed = L < 0
		L = -L
	.BFLG_Sub(exp, i.asm, i.asm, L, L, signed)


function ClearGRABbedAndTrampled (|message| prms,  |asmreg| Dest,  |&fatasm| Start)
	// asmtodo: unnecessary? Values are always 32 or 64-bit. everthing else should be
	// set correctly, right? remove later?
	opt norefcounts
	if 0: prms.FNC3, prms.FNCX3			// MARK USED

	|| c = .Last - 1
	while C >= Start
		if (c isa asm.GRAB)
			|| id = c.Prms[5]
			if id == .CurrFuncGrab
				.RegClear(prms, c, c.RegOnly(0))
		c--
	if 1
		return
	// still need this tho.	caused an error tho?
	|| i = dest.reg
	while ++i <= 31
		.SetRegister(i, nil, nil)
		
}




function SCFunction.HasCVersion (|bool|)
	if .IsCppInBuilt == 2						// cpp_nothing: For JB_Decr, JB_Ternary, etc
		debugat
		return false

	if .IsLibrary
		return true

	return self is wrapper


function assembler.Killed (|message| exp, |fatasm| fat, |asmreg|)
	// needs the encoder set first, this is a 8-byte code!
	// not ideal! its a loss of a 8 byte code. Not sure theres
	// another way... use the last 32? scatter them?
	
	fat.µrefcount++
	return fat * asmreg.exit
	
//	|| fat2 = exp.HALT(nil, nil, 3)
//	fat2.µRefCount++
//	return fat2 * asmreg.exit



function @ASMType.ASMFunction (fn_asm)				// dofunction function
	opt norefcounts
	|| prms = exp.last!
	|| TableID = 0
	|| fn = prms.AsFunc
		|| intrin = fn.Intrinsic
			return .DoIntrinsic(exp, dest, fn, intrin)
		if fn isnt CantInline
			|| MiniDest = .AskForInline(prms, dest, fn)
				return MiniDest
		check (fn isnt LinkInline) (exp, "Unable to inline function")
		
		TableID = fn.FPackID + 31
		if tableid <= 31							// failed!
			if !fn.islibrary or !.state.fn.islibrary
				error (exp, "Missing PackID[1]")
			tableid = 0xFFFF
		
	  else // function pointers
		|| f = exp.first!
		TableID = .µ(f).Reg
		|| dcl = f.ASMDecl
		fn = dcl.Type.FuncProto						#expect (exp)

	dest = .CallFunc(exp, dest, fn)
	|| Start = .curr
	.CurrFuncGrab++
	
	|| Closer = .OpenVars
	|| P = .PrmCollect(prms, fn)
	.CloseVars(Closer)
	
	|| PExt = P >> 32
	(dest isnt Const) // why would it be?
	|| fat = exp.FNC(dest, TableID, P,  PExt)		// prms.fncx
	if fn.HasCVersion
		if 0: exp.fncx
		fat._op = asm.FNCX
	fat._op += PExt > 0
	fat.µRefCount += fn isnt STATELESS				// NOICE!

	.ClearGRABbedAndTrampled(exp, dest, Start)		// comment out? once tests work?
	.CurrFuncGrab--
	
	if fn isnt Killer
		return fat * dest
	return .Killed(exp, fat)



function assembler.ASMReach (|SCFunction| fn)
	opt norefcounts
	|| orig = .out
	if Orig.MyReacher and !orig.IsLibrary
		(fn is usedbyasm)
		if fn is Constructor // gotta reach the destructor also
			fn = fn.cls!.DestructorFunc
			if fn
				(fn is usedbyasm)


