

function fatasm.KNST_Encoder (Asm_encoder2)
	if curr >= after-2
		return curr

// Put the LongestBitStretch into it. As an optional approach. Do this later!
/*
	|| V = .r[1]|uint64| << 32
	V |= 0
	|| Inv = V|uint64|.countbits > 32 
		V = ~V
	|| R = (~V|uint64|).LongestBitStretch	// longest false-stretch
	if r.x >= 50		// OK so we have the longest stretch in r.x
		V = V rotl 63-r.y
		.r[2] = inv|int|
		.r[3] = V|int|
*/

	|| v = .const
	|| inv = v>>63					// We only need to store 63 bits then? if the top is always false.
		v = ~v	  					// Opportunity to reclaim the top bit. I'll do it later.
	|asm| knst = .op << 24
	knst.R1 = .R[0]
	knst.ConstStretchy_Inv = inv
	knst.ConstStretchy_Value = v
	v >>= 17

	|| Orig = curr++
	if v
		curr++[] = v
		knst += 1<<24
		v >>= 32
		if v
			knst += 1<<24
			curr++[] = v
	orig[] = knst
			
	return Curr



extend ASMState
	function MakeConst2 (|&ASMState| self, |asmreg| dest, |asmreg| L, |asmreg| R, |message| exp, |fn_ASMConstifier| fn,  |asmreg|)
		|| knst = .NumToFat(exp, 0, dest as asmreg.Textual)
		(fn)(knst,l,r)
		l.nop
		r.nop
		return .makeconst(knst, dest)


	function MakeConst (|&fatasm| fat, |asmreg| reg, |asmreg|)
		(reg is ConstAny)
		return fat*reg
	
	function NumToFat (|message| exp, |int64| V, |asmreg| Reg, |&fatasm|)
		|| DestType = Reg.µtype
		Reg = .TempTyped(exp, Reg) // could we do this without typing?
		|| fat = exp.KNST(reg, 0, 0, 0)
		fat.Const = v
		|| SrcType = reg.µtype
		if  srctype!=desttype  and (reg is ForCast) // ooop
			fat.ConvertConst(srctype, desttype)
			reg.µtype = desttype
		
		.Makeconst(fat, reg)
		return fat
	
	function NumToReg (|message| exp, |int64| V, |asmreg| Reg=ASMReg(), |asmreg|)
		return .NumToFat(exp, v, reg).info

	function SetConst (|Message| List,  |message| Orig,  |bool|)
		opt norefcounts								// set1: r1, 123
		|| RegMsg = list[@thg]
		|| ValMsg = regmsg.Next				#require
		|| Value  = ValMsg.ASMConst
		
		.NumToReg(orig, value, RegMsg.Reg.textasm)
		return true
	
	
function message.ASMConst (|uint64|) 
	opt norefcounts
	if (self == @unit)
		.expect(@nil, "d")$
		return .first.float.AsInt
	.expect(@num)$
	if (.name contains '.')
		return .float32.asint
	return .int


function uint64.LongestBitStretch (|ivec2|)
	if self == -1
		return (64,0)
	|uint64| last
	while self
		last = self
		self &= self rotl 1
		rz.x++
	rz.y = last.log2


// needs refcount upgrade.
function uint.isconst (|bool|)


function uint.ConstValue (|int64|)


function int64.CanStoreAsIntImmediate (|bool|)
	return ((self << 50)>>50) == self


function uint64.CanStoreAsFloatImmediate (|bool|)
	return ((self << 50)>>50) == self


function asmreg.CanAddK (|int64| T, |bool|) // used to be used from .plus()... works now from render
	if (self is constany) and .isint
		return t.CanStoreAsIntImmediate




function fatasm.ConstifyIntDiv (fn_ASMConstifier)
	|int64| C
	if l.FourBytes
		if l.Signed
			C = l.const|int| / r.const|int|
		  else
			C = l.const|uint| / r.const|uint|
	  else
		if l.Signed
			C = l.const|int64| / r.const|int64|
		  else
			C = l.const|uint64| / r.const|uint64|
	.Const = C


function fatasm.ConstifyIntMul (fn_ASMConstifier)
	if l.FourBytes
		.const = l.const|int| * r.const|int|
	  else
		.const = l.const|int64| * r.const|int64|


function fatasm.ConstifyIntPlus (fn_ASMConstifier)
	if l is alternate
		.const = l.const - r.const
	  else
		.const = l.const + r.const


function fatasm.ConstifyFloatPlus (fn_ASMConstifier)
	if l.fourbytes
		|| rf = r.F32
		|| lf = l.F32
		if l is alternate
			lf -= rf
		  else
			lf += rf
		.f32 = lf
	  else
		|| rf = r.F64
		|| lf = l.F64
		if l is alternate
			lf -= rf
		  else
			lf += rf
		.f64 = lf


function fatasm.ConstifyFloatDiv (fn_ASMConstifier)
	if l.FourBytes
		.f32 = l.f32 / r.f32
	  else
		.f64 = l.f64 / r.f64


function fatasm.ConstifyFloatMul (fn_ASMConstifier)
	if l.FourBytes
		.f32 = l.f32 * r.f32
	  else
		.f64 = l.f64 * r.f64
