

function fatasm.KNST_Encoder (Asm_encoder2)
/*  // put the longestbitstretch into it. As an optional approach. Do this later!
	function FatASM.FixConst
		|| V = .r[1]|uint64| << 32
		V |= 0
		|| Inv = V|uint64|.countbits > 32 
			V = ~V
		|| R = (~V|uint64|).LongestBitStretch	// longest false-stretch
		if r.x >= 50		// OK so we have the longest stretch in r.x
			V = V rotl 63-r.y
			.r[2] = inv|int|
			.r[3] = V|int|
			return
*/

	|asm| o = .op
	|| k = .const
	|| inv = k>>63
		k = ~k
	if curr >= after-2
		return curr

	|| sh = 0
	if k >= 1|uint64|<<17
		if k < (1|uint64|<<49)
			sh = 32
			o = asm.knst2  // 1 extra
		  else
			sh = 64 // obliterate
			o = asm.knst3  // 2 extra
	|| rz = o << 24
	rz.R1 = .R[0]
	rz.ConstStretchy_Inv = inv
	if sh < 64
		rz.ConstStretchy_Value = k<<sh

	Curr++[] = Rz
	if sh >= 32
		if sh == 64
			curr++[] = k>>32
		curr++[] = k
			
	return Curr



extend ASMState
	function asmstate.GenericNumFinder (|message| exp, |uint64| Value, |asmreg| TypeInfo=asmreg(), |asmreg|)
		opt norefcounts
		|| r = .FindConst(value, typeinfo)
		if r != nil
			return r
		return .NumToReg(exp, Value, TypeInfo)

	function MakeConst (|&fatasm| fat, |asmreg| reg, |asmreg|)
		(reg is ConstAny)
//		.regconsts[reg.reg] = fat // look at the regconsts definition (still remains ;_;)
		return fat*reg
	
	function NumToFat (|message| exp, |int64| V, |asmreg| Reg, |&fatasm|)
		|| DestType = Reg.µtype
		Reg = .TempMe(exp, Reg)
		|| fat = exp.KNST(reg, 0, 0, 0)
		fat.Const = v
		|| SrcType = reg.µtype
		if  srctype!=desttype  and (reg is ForCast) // ooop
			fat.ConvertConst(srctype, desttype)
			reg.µtype = desttype
		
		.Makeconst(fat, reg)
		return fat
	
	function NumToReg (|message| exp, |int64| V, |asmreg| Reg=ASMReg(), |asmreg|)
		return .NumToFat(exp, v, reg).info

	function f (|ASMReg| r, |Float64|)
		|| p = .GetConst(r.reg)
		if r.FourBytes
			return p|&float|[]|Float64|
		return p|&f64|[]


/*  // we don't do it this way. we could put the longestbitstretch into it, though?
	// as an optional approach. Do this later!
	function FatASM.FixConst
		|| V = .r[1]|uint64| << 32
		V |= 0
		|| Inv = V|uint64|.countbits > 32 
			V = ~V
		|| R = (~V|uint64|).LongestBitStretch	// longest false-stretch
		if r.x >= 50		// OK so we have the longest stretch in r.x
			V = V rotl 63-r.y
			.r[2] = inv|int|
			.r[3] = V|int|
			return
*/

	function SetConst (|Message| List,  |message| Orig,  |bool|)
		opt norefcounts								// set1: r1, 123
		|| RegMsg = list[@thg]
		|| ValMsg = regmsg.Next				#require
		|| Value  = ValMsg.ASMConst
		
		.NumToReg(orig, value, RegMsg.Reg.textasm)
		return true
	
	
function message.ASMConst (|uint64|) 
	opt norefcounts
	if (self == @unit)
		.expect(@nil, "d")$
		return .first.float.AsInt
	.expect(@num)$
	if (.name contains '.')
		return .float32.asint
	return .int


function uint64.LongestBitStretch (|ivec2|)
	if self == -1
		return (64,0)
	|uint64| last
	while self
		last = self
		self &= self rotl 1
		rz.x++
	rz.y = last.log2


// needs refcount upgrade.
function uint.isconst (|bool|)


function uint.ConstValue (|int64|)


function int64.CanStoreAsIntImmediate (|bool|)
	return ((self << 50)>>50) == self


function uint64.CanStoreAsFloatImmediate (|bool|)
	return ((self << 50)>>50) == self


function asmreg.CanAddK (|int64| T, |bool|) // used to be used from .plus()... works now from render
	if (self is constany) and .isint
		return t.CanStoreAsIntImmediate

