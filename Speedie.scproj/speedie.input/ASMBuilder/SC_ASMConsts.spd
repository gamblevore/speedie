


function ASMState.DoConsts (|asmreg| D,  |asmreg| L,  |asmreg| R,  |&uint64| RImm=nil,  |asmreg|)
	|| LL = self[L],  || RR = self[R],  || DD = self[D]
	|| m = d.math
	if l.isfloat
		if l.fourbytes
			return .DoF32Const(D, DD|&float|, LL|&float|, RR|&float|, M)
		return .DoF64Const(D, DD|&f64|, LL|&f64|, RR|&f64|, M)
	
	if rimm
		RR = rimm
	if l.fourbytes
		return .DoI32Const(D, DD|&int|, LL|&int|, RR|&int|,   M)
	return .DoI64Const(D, DD|&int64|, LL|&int64|, RR|&int64|, M)



function asmstate.DoF32Const (|asmreg| D, |&float| DD, |&float| LL, |&float| RR, |opmode| M, |asmreg|)
	|| LLL = LL[]
	|| RRR = RR[]
		
	if 0
		0
	  elseif M == ASMMath.Add
		LLL += RRR 
	  elseif M == ASMMath.Sub
		LLL -= RRR 
	  elseif M == ASMMath.Mul
		LLL *= RRR 
	  elseif M == ASMMath.Div
		LLL /= RRR 
	  elseif M == ASMMath.Mod
		(LLL mod= RRR)
	  else
		debugger // missed one!

	(DD|&uint64|)[] = 0 // clear high bits
	if LLL.abs
		DD[] = LLL
		return D
	DD[] = 0
	return asmreg.zero



function asmstate.DoF64Const (|asmreg| D, |&f64| DD, |&f64| LL, |&f64| RR, |opmode| M, |asmreg|)
	|| LLL = LL[]
	|| RRR = RR[]
		
	if 0
		0
	  elseif M == ASMMath.Add
		LLL += RRR 
	  elseif M == ASMMath.Sub
		LLL -= RRR 
	  elseif M == ASMMath.Mul
		LLL *= RRR 
	  elseif M == ASMMath.Div
		LLL /= RRR 
	  elseif M == ASMMath.Mod
		(LLL mod= RRR)
	  else
		debugger // missed one!

	if LLL.abs
		DD[] = LLL
		return D
	DD[] = 0
	return asmreg.zero



function asmstate.DoI32Const (|asmreg| D, |&int| DD, |&int| LL, |&int| RR, |opmode| M, |asmreg|)
	if M != ASMMath.div and ASMMath.mod
		return .DoI64Const(D, DD|&int64|, LL|&int64|, RR|&int64|, M|opmode|)
	|| LLL = LL[]
	|| RRR = RR[]
		
	if M == ASMMath.Div
		LLL /= RRR 
	  elseif M == ASMMath.Mod
		(LLL mod= RRR)		
	  else
		debugger // missed one!

	(DD|&uint64|)[] = 0 // clear high bits
	DD[] = LLL
	if LLL
		return D
	return asmreg.zero



function asmstate.DoI64Const (|asmreg| D, |&int64| DD, |&int64| LL, |&int64| RR, |opmode| M, |asmreg|)
	|| LLL = LL[]
	|| RRR = RR[]
		
	if 0
		0
	  elseif M == ASMMath.Add
		LLL += RRR 
	  elseif M == ASMMath.Sub
		LLL -= RRR 
	  elseif M == ASMMath.Mul
		LLL *= RRR 
	  elseif M == ASMMath.Div
		LLL /= RRR 
	  elseif M == ASMMath.Mod
		(LLL mod= RRR)
	  elseif M == ASMMath.Shru
		LLL = LLL|uint64|>>RRR|uint64|
	  elseif M == ASMMath.Shrs
		if !d.signed
			LLL >>= RRR
		  else
			|| bc = 64 - d.bitcount
			LLL <<= bc
			LLL >>= (bc+RRR)
	  elseif M == ASMMath.Shl
		LLL <<= RRR
	  elseif M == ASMMath.Bnt
		LLL = ~LLL
	  elseif M == ASMMath.Ban
		LLL &= RRR
	  elseif M == ASMMath.Xor
		LLL ^= RRR
	  elseif M == ASMMath.Xnr
		LLL = ~(LLL ^ RRR)
	  elseif M == ASMMath.ROL
		LLL = LLL|uint64| rol RRR
	  elseif M == ASMMath.ROR
		LLL = LLL|uint64| ror RRR
	  else
		debugger // missed one!

	DD[] = LLL
	if LLL
		return D
	return asmreg.zero





extend asmstate
	function NumToReg (|int64| V, |message| exp, |int| Reg)
		.AddASM(asm.KNST, exp, reg, (V << 32) >> 32, V>>32, -1, -1)
		.consts[reg] = v


	function NumToEgg (|int64| V, |message| exp, |asmreg|)
		rz = .TempMe(exp)
		.NumToReg(v, exp, rz)

	
	function FatASM.FixConst
		|| V = .r[1]|uint64| << 32
		V |= 0
		|| Inv = V|uint64|.countbits > 32 
			V = ~V
		|| R = (~V|uint64|).LongestBitStretch	// longest false-stretch
		if r.x >= 50		// OK so we have the longest stretch in r.x
			V = V rotl 63-r.y
			.r[2] = inv|int|
			.r[3] = V|int|
			return

		debugat
		|| signed = (v|int64| < 0)|int|
			v = ~v

		.op = asm.KNST
		.r[1] = 0
		.r[2] = signed
		.r[3] = v|int|
		if v >= (1 << 48)
			if v >= 64K
				//.op = asm.setn2
				.r[3] = v >> 32
				.R[4] = v & 0xFFFFffff
			  else
				//.op = asm.setn3
				.r[3] = 0
				.R[4] = v >> 32
				.R[5] = v & 0xFFFFffff
				
			
	function SetConst (|Message| List,  |message| Orig,  |bool|)
		opt norefcounts								// set1: r1, 123
		|| RegMsg = list[@thg]				#require
		|| ValMsg = regmsg.Next				#require
		|| Value  = ValMsg.ASMConst
		
		.NumToReg(value, orig, RegMsg.reg)
		return true
	
	
function message.ASMConst (|uint64|) 
	opt norefcounts
	if (self == @unit)
		.expect(@nil, "d")$
		return .first.float.AsInt
	.expect(@num)$
	if (.name contains '.')
		return .float32.asint
	return .int


function uint64.LongestBitStretch (|ivec2|)
	if self == -1
		return (64,0)
	|uint64| last
	while self
		last = self
		self &= self rotl 1
		rz.x++
	rz.y = last.log2
	

// how to tell where the range is? we only know how long it is?

// 0101010000000000101010101-->
// 1010101111111111010101010
// 0000001111111110000000000
// OK now what? where is the range? we really want the last value!
// whhere does the range start/end?

