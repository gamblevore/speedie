

// ADDC? optimise stages... OR special-case it specifically.

struct ASMFuncState // why not just be a subclass of memory?
	linkage: cpp_part flat
	|SCFunction--|				fn       
	|µFunc|						Out      
	|&IR|						Start    
	|int|						Written  
	|uint|						MaxLength
	|bool|						OK       
	|byte|						LabelCount
	
	|uint|						FreeRegs
	|uint64[32]|				TrueBits 
	|uint64[32]|				FalseBits
	|uint|						AnyTrue	 

	function AddFuncParams (|scfunction| fn)
		opt norefcounts
		for a in fn.Args
			a.dreg = .NeedSomewhere(nil, a.RegType, false)


	function Last (|&IR|)
		return .start + .Written-1
	
	
	
	function AddASM (|int| SM, |message| dbg, |int| a, |int| b=0, |int| c=0, |int| d=0, |&IR|)
		pragma inline,  opt norefcounts
		rz = self <~ (sm, dbg)
		rz.r[0] = a
		rz.r[1] = b
		rz.r[2] = c
		rz.r[3] = d
		target debug
			rz.print


	function AddExtended (|message| err, |uint| Bits)
		pragma inline
		|| B = 1<<31
		expect !(Bits&B) (err)
		bits |= b
		(self <~ (asm.extended, err)).rest = bits
		

	syntax append (|uint| code, |message| dbg, |&IR|)
		cpp_part RequestOp
		if .Written < .MaxLength
			|| P = .Start + .Written++
			P.op = code
			p.debug = dbg
			return p
		if .OK
			error "ASM is out of memory."
			.OK = false
		return ASMFuncState.Dummy
	
		
	function NeedSomeWhere (|Message| where, |asmreg| T,  |bool| Tmp=true,  |asmreg|) // .needreg
		if t.reg
			return t
		
		|| i = .FreeRegs|int|			#expect (where, "No free registers.")
		|| L = i.log2
		if !tmp
			L = i.LowestBit.log2
		t.reg = l
		.freeregs &= ~(1<<L)
		return t


	function OpenVars (|int|)
		rz = .freeregs
		if !(rz&1)


	function CloseVars (|int| Old)
		if !(old&1)
		.freeregs = old


///////////////////////////////////////////////////////////////////////////////////////////////////

	function µ (|message| exp,  |AsmReg| reg = 0.reg, |AsmReg|)
		opt norefcounts
		pragma inline
		cpp_part Reg
		|| T = exp.ASMType
		|| fn = fn_asm_table[T]!
		target debug
			if !T
				fn = fn_asm_table[exp.func|int|]!
				debugger
		return (fn)(self, exp, reg)


	function µ2 (|message| exp, |AsmReg|)
		cpp_part RegSaved
		rz = .µ(exp)
		.freeregs |= ~(1<<rz.reg)

	function AllocReg (|message| exp, |AsmReg|)
		debugger


	function WriteReg (|AsmReg| exp, |AsmReg| out,  |AsmReg|)
		// write something to memory... :)
		debugger


	function ArgLine (|message| exp, |AsmReg|)
		opt NoRefCounts
		if exp != @rel
			return .µ(exp)
			
		debugger
		// A REL
		|| L = exp.first
		|| R = L.next(@opp, "=").Next$
		
		|| Dest = .AllocReg(L)$
		|| result = .µ( r, dest )$

		if !Dest.µType.IsPointer
			return result						// x = a+b
		return .WriteReg(Dest, result)			// str.fld = a+b


	function FuncPrms (|message| pr, |int| Remain, |uint| Bits, |Message|)
		opt norefcounts
		|| fn = pr.parent!
		while pr
			|| reg = .µ2(pr)
			pr++
			Remain -= 5
			Bits |= reg.reg << Remain
			loop Remain >= 5
		.addextended(fn, Bits)
		return pr


	function DoFunc (|message| prms, |asmreg| dest, |asmreg|)
		opt norefcounts
		|| fn = prms.asfunc					#debug_require

		dest = .NeedSomeWhere(prms, dest)
		dest.µtype = fn.RegType
		.AddASM(asm.fnc, prms.parent!, 0).rest = fn.TableId

		|| OV     = .OpenVars
		|| Bits   = Dest.reg<<25 ||| ov.log2<<20					// 6+5 bits, 20 left.
		|| Remain = 20
		|| p      = prms.first
		while
			p = .FuncPrms(p, Remain, Bits) #loop
			Remain = 31
			Bits = 0
		.closevars(OV)

		return dest


	function DoRels (|message| L, |asmreg| dest, |asmreg|)
		opt norefcounts

		|| op = L.next!
		|| OV = .OpenVars
		|| mL = .µ2(L)			// µ2 stops mR breaking mL
		|| mR = .µ(op.next!)
		.CloseVars(OV)			// allow overwriting either!
		require ml.reg ||| mr.reg
		
		dest = .NeedSomewhere(op, dest)
		dest.µtype = ml.µtype
		// assignment conversion needs to be done also.
		|| scop = op.obj|scoperator|
			|| fn = scop.ASM
				return (fn)(self, dest, ml, mr, op)
		error (op, "No ASM for this operator?")

	module
		|IR|					Dummy
		|IR[]|					JSMSpace = IR[0]!
		

function ASMFuncState.TotalInit 
	opt norefcounts
	|| j = ASMFuncState.JSMSpace
	j.Capacity = 4MB
	.maxlength = j.Capacity
	.start = j.ptr
	.Written = 0
	.AddASM(asm.RET, compiler.InternalFile.ast!, 0)


function ASMFuncState.InitState (|scfunction| fn)
	.out = µfunc(fn, JSMSpace.ptr + .written)
	.out.length = -.written
	.LabelCount = 0
	.fn  = fn
	.ok  = true
	.FreeRegs = ~1
	.AddFuncParams(fn)


function ASMFuncState.FinishASM
	opt norefcounts
	.out.length += .written
	ifn .last isa asm.ret
		.AddASM(asm.RET, .fn.source!, 0)


function @fn_asm.Default (fn_asm)
