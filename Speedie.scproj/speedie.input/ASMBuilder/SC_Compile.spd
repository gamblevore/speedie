

// ADDC? optimise stages... OR special-case it specifically.

struct ASMFuncState
	linkage: cpp_part Vac
	|SCFunction--|				fn       
	|µFunc|						Out      
	|&FatASM|					Start    
	|int|						Written  
	|uint|						MaxLength
	|bool|						OK       
	|byte|						LabelCount
	
	|byte|						VDecls
	|byte|						VTmps
	|uint64[32]|				TrueBits 
	|uint64[32]|				FalseBits
	|uint|						AnyTrue	 

	function AddFuncParams (|SCFunction| fn)
		opt norefcounts
		for a in fn.Args
			a.dreg = .DeclareMe(nil, a.RegType|asmreg|)


	function Last (|&FatASM|)
		return .start + .Written-1
	
	
	function AddASM (|int| SM, |message| dbg, |int| a, |int| b, |int| c, |int| d, |&FatASM|)
		pragma inline,  opt norefcounts,  cpp_part AddASM4
		rz = self <~ (sm, dbg)
		rz.r[0] = a
		rz.r[1] = b
		rz.r[2] = c
		rz.r[3] = d
		target debug: rz.print

	function AddASM (|int| SM, |message| dbg, |int| a, |int| b, |int| c, |&FatASM|)
		pragma inline,  opt norefcounts,  cpp_part AddASM3
		rz = self <~ (sm, dbg)
		rz.r[0] = a
		rz.r[1] = b
		rz.r[2] = c
		target debug: rz.print

	function AddASM (|int| SM, |message| dbg, |int| a, |int| b, |&FatASM|)
		pragma inline,  opt norefcounts,  cpp_part AddASM2
		rz = self <~ (sm, dbg)
		rz.r[0] = a
		rz.r[1] = b
		target debug: rz.print

	function AddASM (|int| SM, |message| dbg, |int| a, |&FatASM|)
		pragma inline,  opt norefcounts,  cpp_part AddASM2
		rz = self <~ (sm, dbg)
		rz.r[0] = a
		target debug: rz.print

		

	syntax append (|uint| code, |message| dbg, |&FatASM|)
		cpp_part RequestOp
		if .Written < .MaxLength
			|| P = .Start + .Written++
			P.op = code
			p.debug = dbg
			return p
		if .OK
			error "ASM is out of memory."
			.OK = false
		return JSMSpace[0]
	
		
	function DeclareMe (|Message| where,  |asmreg| T,  |asmreg|)
		if t.var
			return t
		
		|| d = .VDecls|int| + 1
		expect (d + .vtmps <= 31) (where, "No free local variables.")
		t.var = d
		.vdecls = d
		return t
	
	
	function TempMe (|Message| where,  |asmreg| T,  |asmreg|) // .needreg
		if t.var
			return t
		
		|| d = .vtmps|int| + 1
		expect (d + .vdecls <= 31) (where, "No free local variables.")
		t.var = d
		.vdecls = d
		return t


	function OpenVars (|uint|)
		return .vdecls ||| (.vtmps << 8)


	function CloseVars (|uint| Old)
		.vdecls = old & 255
		.vtmps  = old >> 8


///////////////////////////////////////////////////////////////////////////////////////////////////

	function µ (|message| exp,  |AsmReg| var = 0.var, |AsmReg|)
		opt norefcounts
		pragma inline
		cpp_part Var
		|| T = exp.ASMType
		|| fn = fn_asm_table[T]!
		target debug
			if !T
				fn = fn_asm_table[exp.func|int|]!
				debugger
		return (fn)(self, exp, var)


/*
	Tempvars... hmmm... the problem is... that anything that is going into a func.
	We need to make sure it stays? We need to allocate it properly. or have it already allocated.
*/

	function prm (|message| prm, |asmreg|)
		|| r = asmtmp.simplevar(self, prm)
		if r != 0
			return r
		return .µ(prm, .DeclareMe(prm, 0))
		
		

	function DoFunc (|message| prms, |asmreg| dest, |asmreg|)
		opt norefcounts
		|| fn = prms.asfunc
		expect (fn and fn.args <= 16) (prms, "Too many parameters")

		if dest is discard
			dest = 0
		  else
			dest = .tempme(prms, dest)
			dest.µtype = fn.RegType

		|byte[16]| Regs
		|| i = 0

		|| OV = .OpenVars
		for p.fast in prms
			regs[i++] = .prm(p)
		.closevars(OV)

		|| Fnc = .AddASM(asm.fnc, prms.parent!, .vdecls, fn.TableId) 

// so... lets make function call 64-bit flat. No extension.
// and have a "push" instruction... that we call BEFORE the func. It can push 4 vars
// 


		|uint64| B
		while i > 0
			B <<= 5
			B |= regs[--i]
		// what if there are more than 6 regs passed?
			// we need to fill this in
/*
	Func
		SaveRegs	5 
		Incr		1 // parent can fill this in.
		JUMP		j
*/
		return dest


	module
		|FatASM[]|					JSMSpace = FatASM[0]!
		

function ASMFuncState.TotalInit 
	opt norefcounts
	|| j = ASMFuncState.JSMSpace
	j.Capacity = 4MB
	.maxlength = j.Capacity
	.start = j.ptr
	.Written = 0
	.AddASM(asm.EROR, compiler.InternalFile.ast!, 0)


function ASMFuncState.InitState (|scfunction| fn)
	.out = µfunc(fn, JSMSpace.ptr + .written)
	.out.length = -.written
	.LabelCount = 0
	.fn  = fn
	.ok  = true
	.vdecls = 0
	.vtmps = 0
	.AddFuncParams(fn)


function ASMFuncState.FinishASM
	opt norefcounts
	.out.length += .written
	ifn .last isa asm.ret
		.AddASM(asm.RET, .fn.source!, 0)

