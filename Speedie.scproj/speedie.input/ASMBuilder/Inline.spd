
struct InlineInfo
	|asmreg[10]|	Items
	|uint|			Altered
	|uint|			References
	|uint|			Normal
	
	function DoImmediates (|?message| p, |[scdecl]| args)
		opt norefcounts
		|| sh = Assembler.sh
		for (a in args) (i)
			.Items[i] = .PreInlineOneParam(p!, a, sh)
			p++

		.CleanupClash(args)


	function NopParams (|int| n, |asmreg| Ret)
		|| sh = Assembler.sh
		while  --n >= 0
			|| r = .Items[n] // now what to do?
			|| v = r.reg
			if !v
				0
			  elseif r is Const 
				sh.Decr(r.needfat, false)
			  elseif r iz Ret
				0
			  else
				|| s = r.fat
				if s  and  !s.µrefcount  and  s.guesssize
					sh.nop(s) 

	
	function PreInlineOneParam (|message| p, |scdecl| a, |assembler| sh, |asmreg|)
		opt norefcounts
		p = p.ASMUnbra
		require (p.func == @thg)
		|| d = p.ASMDecl
		require d is local
		|| v = sh.LocalThg(d)
		|| vr = 1<<v.reg
		if a is Reference
			.References |= vr
		  elseif a is Altered
			if .Altered & vr
				.Normal |= vr
			.Altered |= vr
		  else
			.Normal |= vr

		(a is reference) = (d is reference)
		return v	
	
	
	function CleanupClash (|[scdecl]| args)
		|| AR = .References & .Altered
		|| AN = .Normal & .Altered
		if AR ||| AN
			.ClearInlineParamClash(args, AR, AN)


	function ClearInlineParamClash (|[scdecl]| args, |int| AR, |int| AN)
		opt norefcounts
		|| n = args.Length
		while n-- > 0
			|| V = .items[n]
				|| a = args[n]!
				|| r = 1<<v.reg
				if (AR & r) and (a isnt reference)
					.items[n] = asmreg.ForceInto				// needs copy to save other regss
				  elseif (AN & r) and (a is altered)
					.Items[n] = asmreg.ForceInto
	


extend assembler {
function TryInline (|message| prms, |asmreg| dest, |SCFunction| fn, |int| AllowedGain, |asmreg|)
	opt norefcounts
	|| OV = .OpenVars
	|int| ID = .inlinedepth
	|| st = .inlinestate[ID+1]
	st[0] = .inlinestate[ID]
	if dest isnt discard
		if (!dest.reg or dest is temp)
			|| type = fn.ASMReturn
				dest = .declarebody(prms, type) // asmtodo: mark this as a declaration?
												// (shouldn't all declaremes be like that?)
	if dest isnt ExitFunction
		.state.TailInlineable = false
	
	.InlineDepth = ++ID
	.DeepestInline = ID max .DeepestInline
	
	dest = dest.simplify
	dest.µtype = fn.ASMReturn.ASMRegType
	if !dest.reg
		(dest is discard)
	st.fn = fn
	st.Return = dest
	st.ParentVars = .openvars
	st.BranchDepth = 0
	
	|| Start = .curr
	|fatrange| LL
	|| r = .TryInlineSub(prms, fn, AllowedGain, LL)
		if fn is constructor
			|| des = fn.cls!.DestructorFunc
				.asmreach(des)
	
	.inlinestate[ID] = nil
	.inlinedepth = --ID
	if !ID
		.InlineEnd = nil
	return .CloseVars(OV, nil, r)				// Should closevars come before restore?



function TryInlineSub (|Message| prms, |SCFunction| fn, |int| AllowedGain, |fatrange| LL, |asmreg|)
	opt norefcounts
	LL.Start = .curr

	|SavedRegisters| regs 
	|InlineInfo| Info

	regs.Collect(fn.args, self)
	.InlineParameters(prms, info)
	|| RealStart = .curr							// Params need to be done anyhow... so don't count them.
	asmtype.ArgumentSub(self, fn.SourceArg!)
	info.NopParams(fn.args.length, .state.return)
	regs.Restore(fn.args)
	
	ll.after = .curr
	rz = .InlineFinish(ll)
	|| Grown = .CurrGain(RealStart)
	if (Grown > AllowedGain)
		regs.Rewind(self)
		.SoftNopRange(ll.start, .curr)				// rewind
		return nil
	
	if !rz
		(rz is Const)								// no longer zero
	|| last = .last
	if (last == RealStart) and last.IsFunc
		|| P = prms.parent!							// cleanup
		last.Msg = P								// right? or else the autocomplete goes wrong? Or not?
		last.srcmap = P.srcmap


	
function InlineParameters (|message| prms, |InlineInfo| Info)
	opt norefcounts
	|| p = prms.first$

	|| args = .fn.args
	target debug: if asmtrapper == -1
	info.DoImmediates(p, args)
	
	for (a in args) (i)
		|| V = info.Items[i]
		if !(V asnt ASMReg.ForceInto) // its nil or into
			info.items[i] = .µInlineParam(p, a, V)
		p = p.next!
		
		a.AsmReg = info.Items[i] // a is the output, nt the input decls.


	
function CurrGain (|&fatasm| Start, |int|)
	|| C = .curr
	while Start < C
		rz += start.GuessSize
		start++



function AskForInline (|Message| prms, |ASMReg| dest, |SCFunction| fn, |ASMReg|)
	opt norefcounts
	require fn isnt cpp

	require .InlineDepth < 7 // for LinkInline funcs
	|| N = fn.µfatlength
	if fn isnt LinkInline
		require N and (N < 64)
		require .InlineDepth < .InlineDepthLimit
		|| MaxEnd = .InlineEnd
			|| SubInline = .curr + (N / 3)
			require SubInline < MaxEnd
	
	|| AllowedGain = 5 + (fn is OptInline) * 23		// Assume that functions have 5 instruction overhead.
	|| Grace = 2 + (fn isnt constructor)<<2			// 2 grace for constructors, 6 for others.
	if fn is LinkInline
		allowedgain += 5
	  elseif fn.IsLibrary
		AllowedGain -= 1 + (fn is OptInline)<<2

	AllowedGain -= .inlinedepth
	
	for p.fast in prms
		Grace += .IsASMConst(p)<<2

	if (AllowedGain + Grace)|uint| <= N
		require fn is linkinline
		problem (prms, "Inline function oversized")

	if !.InlineDepth
		.InlineDepthLimit = 3
		.DeepestInline = 0
		.InlineEnd = .curr + AllowedGain
	
	|| I = .TryInline(prms, dest, fn, AllowedGain)
		return I

	// try weaker inline
	require !.InlineDepth and (.DeepestInline > 1)

	.InlineDepthLimit = 1
	return .TryInline(prms, dest, fn, AllowedGain)



function InlineFinish (|fatrange| R, |ASMReg|)
	target debug: || inlinetrap = ++asmtrapper,  if inlinetrap == -1
	for s in R
		if s isa asm.ret
			if rz
				rz = rz.simplify
			  else
				|| dest = s.inputfat(0)
					rz = dest.info 
				  else
					rz = s.prms[0]|int|.asm
					rz.µType = .state.return.µType
			s.SetOp = asm.jump
			s.JumpPrm = 1
			s.JumpFix(.curr)
	
	rz &= ~ASMReg.Exit
	|| dest = .state.return
	(rz as= dest&asmreg.exit)
	rz = rz.ExpectSameType(dest)
	if !rz.reg
		(rz is const) // make compiler happy


}

