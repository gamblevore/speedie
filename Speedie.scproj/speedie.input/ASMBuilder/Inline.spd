
struct InlineInfo
	|asmreg[10]|	Items
	|uint|			Altered
	|uint|			References
	|uint|			Normal
	
	function DoImmediates (|?message| p, |[scdecl]| args)
		opt norefcounts
		|| sh = Assembler.sh
		for (a in args) (i)
			.Items[i] = .PreInlineOneParam(p!, a, sh)
			p++

		.CleanupClash(args)


	function NopConsts (|int| n)
		|| sh = Assembler.sh
		while  --n >= 0
			|| r = .Items[n] // now what to do?
			if r.reg and r is Const 
				sh.Decr(r.needfat, false)

	
	function PreInlineOneParam (|message| p, |scdecl| a, |assembler| sh, |asmreg|)
		opt norefcounts
		p = p.ASMUnbra
		require (p.func == @thg)
		|| d = p.ASMDecl
		require d is local
		|| v = sh.LocalThg(d)
		|| vr = 1<<v.reg
		if a is Reference
			.References |= vr
		  elseif a is Altered
			if .Altered & vr
				.Normal |= vr
			.Altered |= vr
		  else
			.Normal |= vr

		(a is reference) = (d is reference)
		return v	
	
	
	function CleanupClash (|[scdecl]| args)
		|| AR = .References & .Altered
		|| AN = .Normal & .Altered
		if AR ||| AN
			.ClearInlineParamClash(args, AR, AN)


	function ClearInlineParamClash (|[scdecl]| args, |int| AR, |int| AN)
		opt norefcounts
		|| n = args.Length
		while n-- > 0
			|| V = .items[n]
				|| a = args[n]!
				|| r = 1<<v.reg
				if (AR & r) and (a isnt reference)
					.items[n] = asmreg.ForceInto				// needs copy to save other regss
				  elseif (AN & r) and (a is altered)
					.Items[n] = asmreg.ForceInto
	


extend assembler {
function TryInline (|message| prms, |asmreg| dest, |scfunction| fn, |int| AllowedGain, |asmreg|)
	opt norefcounts
	|| Start = .curr
	|| OV = .OpenVars
	|ASMState| Old = .State						// can't use implicit types for barestructs
	if dest isnt discard
		if (!dest.reg or dest is temp)
			|| type = fn.ASMReturn
				dest = .declarebody(prms, type) // asmtodo: mark this as a declaration?
												// (shouldn't all declaremes be like that?)
	
	if dest isnt ExitFunction
		.state.TailInlineable = false
	
	|int| D = ++.state.InlineDepth
	.DeepestInline = D max .DeepestInline
	
	dest = dest.simplify
	dest.µtype = fn.ASMReturn.ASMRegType
	.state.fn = fn
	if !dest.reg
		(dest is discard)
	.state.Return = dest
	.state.ParentVars = .openvars
	.state.BranchDepth = 0
	
	|fatrange| LL
	|| r = .TryInlineSub(prms, fn, AllowedGain, LL)
	if !r
		.SoftNopRange(start, .curr)				// rewind
	
	.state = old
	if old.InlineDepth == 0
		.InlineEnd = nil
	return .CloseVars(OV, nil, r) // should closevars come before restore? sigh. idk.



function TryInlineSub (|Message| prms, |SCFunction| fn, |int| AllowedGain, |fatrange| LL, |asmreg|)
	opt norefcounts
	LL.Start = .curr

	|SavedRegisters| regs 
	|InlineInfo| Info

	regs.Collect(fn.args, self)
	.InlineParameters(prms, info)
	|| RealStart = .curr						// Params need to be done anyhow... so don't count them.
	asmtype.ArgumentSub(self, fn.SourceArg!)
	info.NopConsts(fn.args.length)
	regs.Restore(fn.args)
	
	ll.after = .curr
	rz = .InlineFinish(ll)
	|| Grown = .CurrGain(RealStart)
	if Grown > AllowedGain
		regs.Rewind(self)
		return nil
	
	if !rz
		(rz is Const)							// no longer zero
	|| last = .last
	if (last == ll.start) and last.IsFunc
		last.msg = prms.parent! // cleanup		


	
function InlineParameters (|message| prms, |InlineInfo| Info)
	opt norefcounts
	|| p = prms.first$

	|| args = .fn.args
	target debug: if asmtrapper == 0
	info.DoImmediates(p, args)
	
	for (a in args) (i)
		|| V = info.Items[i]
		if !(V asnt ASMReg.ForceInto) // its nil or into
			info.items[i] = .µInlineParam(p, a, V)
		p = p.next!
		
		a.AsmReg = info.Items[i] // a is the output, nt the input decls.


	
function CurrGain (|&fatasm| Start, |int|)
	|| C = .curr
	while Start < C
		rz += start.GuessSize
		start++ 
		

function AskForInline (|Message| prms, |ASMReg| dest, |SCFunction| fn, |ASMReg|)
	opt norefcounts
	|| N = fn.µlength	
	require N and (N < 128) and (fn isnt cpp)
	require .state.InlineDepth < .InlineDepthLimit

	|| MaxEnd = .InlineEnd
		|| SubInline = .curr + (N / 3)
		require SubInline < MaxEnd

	|| AllowedGain = 5 + (fn is inline) * 23		// Assume that functions have 5 instruction overhead.
	|| Grace = 2 + (fn isnt constructor)<<2			// 2 grace for constructors, 6 for others.
	if fn.IsLibrary
		AllowedGain -= 1 + (fn is inline)<<2

	AllowedGain -= .State.inlinedepth
	
	for p.fast in prms
		Grace += .IsASMConst(p)<<2

	require (AllowedGain + Grace)|uint| > N

	if !.state.InlineDepth
		.InlineDepthLimit = 3
		.DeepestInline = 0
		.InlineEnd = .curr + AllowedGain
	
	|| I = .TryInline(prms, dest, fn, AllowedGain)
		return I
	
	// try weaker inline
	require !.state.InlineDepth and (.DeepestInline > 1)

	.InlineDepthLimit = 1
	return .TryInline(prms, dest, fn, AllowedGain)



function DoIntrinsic (|Message| where, |ASMReg| dest, |message| trin,   |ASMReg|)
	// so what about this, then?
	opt norefcounts
	|| name = trin[@thg]
	trin = name.next(@prm)$
	|| op = instruction[name!]$
	
	|| form = op.Sizes
	expect (trin.HasChildCount(form.Count))    (trin, "Expected paramcount: " + form.Count.render)
	|| fat = .RequestOp(op.OpCode, where)
		
	.Trintrin(trin, nil, fat)
	.Trintrin(trin, dest, fat)
	return fat*dest


function InlineFinish (|fatrange| R, |ASMReg|)
	target debug: || inlinetrap = ++asmtrapper,  if inlinetrap == -1
	for s in R
		if s isa asm.ret
			if rz
				rz = rz.simplify
			  else
//				rz = s.asmreg(0) // better if asmreg contains type. Requires asmreg be supetset of asmparam
				|| dest = s.inputfat(0)
					rz = dest.info 
				  else
					rz = s.prms[0]|int|.asm
					rz.µType = .state.Return.µType
			s.SetOp = asm.jump
			s.JumpPrm = 1
			s.JumpFix(.curr)
	
	rz &= ~ASMReg.Exit
	|| dest = .state.return
	(rz as= dest&asmreg.exit)
	rz = rz.ExpectSameType(dest)
	if !rz.reg
		(rz is const) // make compiler happy


function Trintrin (|message| out, |asmreg| dest, |fatasm| fat)
	opt norefcounts
	// (rz, r1, r2, r3)
	|| i = 0
	for s in out
		if s.func!=@num
			s.Expect(@thg)
		|| n = s.name
		if (n ~= "rz") == (dest != nil)
			if dest
				fat.Dest(i, dest, self)
			  else
				|uint| l = n[].lowercase 
				if l == 'r'
					l = s.Int(1, 0, 31)
					fat.RegInput(i) = .ASMRegister(l)
				  else
					fat.numinput(i) = s.int
			
		i++


}

