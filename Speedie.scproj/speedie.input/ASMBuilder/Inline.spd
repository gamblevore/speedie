
struct InlineInfo
	|asmreg[10]|	Items
	|uint|			Altered
	|uint|			References
	|uint|			Normal
	
	function Fix (|?message| p, |[scdecl]| args)
		opt norefcounts
		|| sh = Assembler.sh
		for (a in args) (i)
			.Items[i] = .PreInlineOneParam(p!, a, sh)
			p++

		.Cleanup(args)

	function PreInlineOneParam (|message| p, |scdecl| a, |assembler| sh, |asmreg|)
		opt norefcounts
		p = p.ASMUnbra
		require (p.func == @thg)
		|| d = p.ASMDecl
		if (a isnt alteredorref) and (d is Const) and !d.mu.ExportPosition
			return asmreg()
		
		require d is local
		|| v = sh.LocalThg(d)
		require  a is reference  or  a isnt altered  or  sh.state.return iz v
		|| vr = 1<<v.reg
		
		
		if a is Reference
			.References |= vr
		  elseif a is Altered
			if .Altered & vr
				.Normal |= vr
			.Altered |= vr
		  else
			.Normal |= vr
		(a is reference) = (d is reference)
		return v	
	
	
	function Cleanup (|[scdecl]| args)
		|| AR = .References & .Altered
		|| AN = .Normal & .Altered
		if AR ||| AN
			.ClearInlineParamClash(args, AR, AN)


	function ClearInlineParamClash (|[scdecl]| args, |int| AR, |int| AN)
		opt norefcounts
		|| n = args.Length
		while n-- > 0
			|| V = .items[n]
				|| a = args[n]!
				|| r = v.reg
				if (AR & r) and (a isnt reference)
					.items[n] = asmreg.set				// needs copy to save other regss
				  elseif (AN & r) and (a is altered)
					.Items[n] = asmreg.set				
	


extend assembler {
function TryInline (|message| prms, |asmreg| dest, |scfunction| fn, |int| AllowedGain, |asmreg|)
	opt norefcounts
	|| Start = .curr
	|| OV = .OpenVars
	
	|ASMState| Old = .State				// can't use implicit types for barestructs
	if dest isnt discard
		if (!dest.reg or dest is temp)
			|| type = fn.ASMReturn
				dest = .declareme(prms, type)
	
	if dest isnt ExitFunction
		.state.TailInlineable = false
	
	|int| D = ++.state.InlineDepth
	.DeepestInline = D max .DeepestInline
	
	dest = dest.simplify
	dest.µtype = fn.ASMRegType
	.state.fn = fn
	.state.Return = dest
	.state.ParentVars = .openvars
	.state.BranchDepth = 0
	
	|fatrange| LL
	rz = .TryInlineSub(prms, fn, AllowedGain, LL)
	if !rz
		.SoftNopRange(start, .curr)				// rewind
	
	.state = old
	if .state.InlineDepth == 0
		.InlineEnd = nil
	.CloseVars(OV) // should closevars come before restore? sigh. idk.



function TryInlineSub (|Message| prms, |SCFunction| fn, |int| AllowedGain, |fatrange| LL, |asmreg|)
	opt norefcounts
	LL.Start = .curr

	|SavedRegisters| regs 
	regs.Collect(fn.args, self)
	
	.InlineParameters(prms)
	|| RealStart = .curr					// Params need to be done anyhow... so don't count them.
	asmtype.ArgumentSub(self, fn.SourceArg!)
	regs.Restore(fn.args)
	
	ll.after = .curr
	|| Result = .InlineFinishWithConsts(ll)
	|| Grown = .CurrGain(RealStart)
	if Grown <= AllowedGain
		if !result
			(result is ConstOutput)			// no longer zero
		return Result
	
	regs.Rewind(self)


function UpdateInlineReg (|asmreg| V, |scdecl| D)
	(d is const) = (v is ConstOutput) and (d isnt Altered)
	v.TmpCheck
	D.AsmReg = v												// update reg!

	
function InlineParameters (|message| prms)
	opt norefcounts
	|| p = prms.first$
	|InlineInfo| Info
	info.Fix(p, .fn.args)

	for (a in .fn.args) (i)
		|| V = info.Items[i]
		if !(V asnt asmreg.set)
			V = .µgetReal(p, a, V)
		.UpdateInlineReg(V, a)
		p = p.next!


	
function CurrGain (|&fatasm| Start, |int|)
	|| C = .curr
	while Start < C
		rz += start.GuessSize
		start++ 
		

function AskForInline (|Message| prms, |ASMReg| dest, |SCFunction| fn, |ASMReg|)
	opt norefcounts
	require .state.InlineDepth < .InlineDepthLimit
	|| N = fn.µlength
	require N and !fn.HasCVersion

	|| MaxEnd = .InlineEnd
		|| SubInline = .curr + (N / 3)
		require SubInline < MaxEnd

	|| AllowedGain = 5 + (fn is inline) * 23		// Assume that functions have 5 instruction overhead.
	|| Grace = 2 + (fn isnt constructor)<<2			// 2 grace for constructors, 6 for others.

	if .length < 16K								// Don't risk overflowing max-size
		AllowedGain += (fn.LinkFrom == 1)<<6		// Allow bigger functions inlined if called once.
													// (needs marked as removed!!)
	AllowedGain -= .State.inlinedepth
	
	for p.fast in prms
		Grace += .IsASMConst(p)<<2

	require (AllowedGain + Grace)|uint| > fn.µlength

	if !.state.InlineDepth
		.InlineDepthLimit = 3
		.DeepestInline = 0
		.InlineEnd = .curr + AllowedGain
	
	|| I = .TryInline(prms, dest, fn, AllowedGain)
		return I
	
	// try weaker inline
	require !.state.InlineDepth and (.DeepestInline > 1)

	.InlineDepthLimit = 1
	return .TryInline(prms, dest, fn, AllowedGain)

}

