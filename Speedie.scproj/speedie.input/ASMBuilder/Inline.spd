
struct InlineInfo
	|asmreg[10]|	Items
	|uint|			Altered
	|uint|			References
	|uint|			Normal
	
	function DoImmediates (|?message| p, |[scdecl]| args)
		opt norefcounts
		|| sh = Assembler.sh
		for (a in args) (i)
			.Items[i] = .PreInlineOneParam(p!, a, sh)
			p++

		.CleanupClash(args)


	function NopConsts (|int| n)
		|| sh = Assembler.sh
		while  --n >= 0
			|| r = .Items[n] // now what to do?
			if r.reg and r is Const 
				sh.Decr(r.needfat, false)

	
	function PreInlineOneParam (|message| p, |scdecl| a, |assembler| sh, |asmreg|)
		opt norefcounts
		p = p.ASMUnbra
		require (p.func == @thg)
		|| d = p.ASMDecl
		require d is local
		|| v = sh.LocalThg(d)
		|| vr = 1<<v.reg
		if a is Reference
			.References |= vr
		  elseif a is Altered
			if .Altered & vr
				.Normal |= vr
			.Altered |= vr
		  else
			.Normal |= vr

		(a is reference) = (d is reference)
		return v	
	
	
	function CleanupClash (|[scdecl]| args)
		|| AR = .References & .Altered
		|| AN = .Normal & .Altered
		if AR ||| AN
			.ClearInlineParamClash(args, AR, AN)


	function ClearInlineParamClash (|[scdecl]| args, |int| AR, |int| AN)
		opt norefcounts
		|| n = args.Length
		while n-- > 0
			|| V = .items[n]
				|| a = args[n]!
				|| r = 1<<v.reg
				if (AR & r) and (a isnt reference)
					.items[n] = asmreg.ForceInto				// needs copy to save other regss
				  elseif (AN & r) and (a is altered)
					.Items[n] = asmreg.ForceInto
	


extend assembler {
function TryInline (|message| prms, |asmreg| dest, |scfunction| fn, |int| AllowedGain, |asmreg|)
	opt norefcounts
	|| Start = .curr
	|| OV = .OpenVars
	
	|ASMState| Old = .State				// can't use implicit types for barestructs
	if dest isnt discard
		if (!dest.reg or dest is temp)
			|| type = fn.ASMReturn
				dest = .declarebody(prms, type) // asmtodo: mark this as a declaration?
											  // (shouldn't all declaremes be like that?)
	
	if dest isnt ExitFunction
		.state.TailInlineable = false
	
	|int| D = ++.state.InlineDepth
	.DeepestInline = D max .DeepestInline
	
	dest = dest.simplify
	dest.µtype = fn.ASMRegType
	.state.fn = fn
	.state.Return = dest
	.state.ParentVars = .openvars
	.state.BranchDepth = 0
	
	|fatrange| LL
	|| r = .TryInlineSub(prms, fn, AllowedGain, LL)
	if !r
		.SoftNopRange(start, .curr)				// rewind
	
	.state = old
	if old.InlineDepth == 0
		.InlineEnd = nil
	return .CloseVars(OV, nil, r) // should closevars come before restore? sigh. idk.



function TryInlineSub (|Message| prms, |SCFunction| fn, |int| AllowedGain, |fatrange| LL, |asmreg|)
	opt norefcounts
	LL.Start = .curr

	|SavedRegisters| regs 
	|InlineInfo| Info

	debugat 4268
	regs.Collect(fn.args, self)
	.InlineParameters(prms, info)
	|| RealStart = .curr					// Params need to be done anyhow... so don't count them.
	asmtype.ArgumentSub(self, fn.SourceArg!)
	info.NopConsts(fn.args.length)
	regs.Restore(fn.args)
	
	ll.after = .curr
	rz = .InlineFinish(ll)
	|| Grown = .CurrGain(RealStart)
	if Grown <= AllowedGain
		if !rz
			(rz is Const)			// no longer zero
	  else
		regs.Rewind(self)
		rz = nil


	
function InlineParameters (|message| prms, |InlineInfo| Info)
	opt norefcounts
	|| p = prms.first$

	|| args = .fn.args
	target debug: if asmtrapper == 0
	info.DoImmediates(p, args)
	
	for (a in args) (i)
		|| V = info.Items[i]
		if !(V asnt ASMReg.ForceInto) // its nil or into
			info.items[i] = .µInlineParam(p, a, V)
		p = p.next!
		
		a.AsmReg = info.Items[i] // a is the output, nt the input decls.


	
function CurrGain (|&fatasm| Start, |int|)
	|| C = .curr
	while Start < C
		rz += start.GuessSize
		start++ 
		

function AskForInline (|Message| prms, |ASMReg| dest, |SCFunction| fn, |ASMReg|)
	opt norefcounts
	|| N = fn.µlength//real
	require N and (N < 128) and !fn.HasCVersion
	require .state.InlineDepth < .InlineDepthLimit

	|| MaxEnd = .InlineEnd
		|| SubInline = .curr + (N / 3)
		require SubInline < MaxEnd

	|| AllowedGain = 5 + (fn is inline) * 23		// Assume that functions have 5 instruction overhead.
	|| Grace = 2 + (fn isnt constructor)<<2			// 2 grace for constructors, 6 for others.

	AllowedGain -= .State.inlinedepth
	
	for p.fast in prms
		Grace += .IsASMConst(p)<<2

	require (AllowedGain + Grace)|uint| > N

	if !.state.InlineDepth
		.InlineDepthLimit = 3
		.DeepestInline = 0
		.InlineEnd = .curr + AllowedGain
	
	|| I = .TryInline(prms, dest, fn, AllowedGain)
		return I
	
	// try weaker inline
	require !.state.InlineDepth and (.DeepestInline > 1)

	.InlineDepthLimit = 1
	return .TryInline(prms, dest, fn, AllowedGain)

}

