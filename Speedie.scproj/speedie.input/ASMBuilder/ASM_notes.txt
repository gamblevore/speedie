

OK... how how to do the consts... I guess there are 3 routes. Lets look at advantages/drawbacks


todo:
	* type-casting needs constifiying
	* everything else


awesome fun but difficult problems:

* current (generate if needed, but otherwise inline)
	+ keeps existing code... generates already good inlined consts, less opt passes needed
	- doesnt handle multi-line consts


* constants stored in FATASM... so always generated
	+ Simpler generation idea
	+ Perhaps easier to optimise, as all consts are just in the ASM
	+ Perhaps more consistant consts?
	- Harder to know where does one block begin or end, and what depends on what
		- Instructions need their parentblock
	- More instructions generated


* constants simply refered to, not generated until render
	+ cleaner ASM. Seems simpler to understand and process
	* but how to remove constants? how to turn ADD into ADDK.
		* on render?
			- We'll be leaving some consts lying around then
			* how to insert the consts? They could be inserted multiple times.
				- hard to optimise something that doesnt exist
			* we want to move the consts up, to merge them if used in multiple branches. Cant do that if they arent in the code
				- COULD put them in the code, but thats more steps and more confusion. Is it simply now a const phase?
	* Where do they exist then?
		* how to refered? which way?
			* Refer to a FATASM stored somewhere
			* Refer via a code that could be a const or a FAT.
	* Multiple ways to refer to a const doesnt seem fun. NO FUN.
	* We COULD just put the ADDK initially... like we do right now...
		* But still, what if we CAN'T. We still have the same issues.
			


* So whats stopping me? Well... why do we have 32 consts? Are those consts in registers? but don't we just fold consts... into instructions? so why there? Is it just to match up... so we can see the result of previous consts, and add them together? Like pretty much just mostly temp-vars?

* Let's assume these are temp-vars...

|| x = 1
|| y = x * 2

// OK... how do we handle this? Does x have a const? I think tempvars won't branch... however, what about terns? Terns CAN branch and CAN use consts!?!?

x = (1+2, 3+4)(y)

Basically... my const system assumes we are working within a block. So no branching. This way, we definitely know what a value is. However... this isnt true anymore. We want this to be better.

Perhaps my const system is just fine... then? its only for simple block-consts... it can just be kept. seems like it?


So why do I wanna store consts in instructions? Well... for multi-line consts?

	b = 1
	a = b * 2
	c = b
	
Sees ok? how do I know it actually HAS a const? like b? I can read the previous value... and check if it is a multi-value.

* could we just dump-const production except for directly in blocks? that is... remove them from the FATASM?
	* Why do we need consts in FATASM anyhow?
	* to replace the existing system... i think? so we ONLY need FATASM to store consts.
		* This way we can use a thing where each thing refers to a previous FATASM.
		* So we can still store consts in regs?

	
	
	b = 1
	if x
		b = 2 // refers to previous b
	a = b // relies on 1 and 2
	
	
	b = 1
	if x
		b = 2 // refers to prev b
	b = 3 // wipes out 1 and 2. But how to know this? Chains, right??
	
	
	
	
	