
// Never marking early-closes as closing a var is the way
// Otherwise, I have to mark some early-close before return, as "not valid after x-instructions"

// pos, reg, name, class, type

function jbin.DebugCloseVar (|int| Pos, |int| Reg)
	debugger
	.AppendHInt(pos)
	self <~ '\1'
	self <~ '\0'
	.AppendHInt(Reg)


function FATASM.DumpDecl
	opt norefcounts
	|| j = Assembler.DebugDecls!
	if .GuessSize
/		.msg.FastDecl.DumpDecl(j, .asmindex)
	  elseif self is Discard
		for i.bits in ._Const
/			j.DebugCloseVar(.asmindex, i.log2)


function scdecl.DumpCls (|int|)
	if .IsNormalObject or .IsBareStruct
		return (.type.tableid<<1) + .IsNormalObject


function SCDecl.DumpDecl (|jbin!| j, |int| Pos)
	opt norefcounts
	|| Reg = .ExportPosition
	if self is local
		reg = .mu.DataType|asmreg|.Reg

	|| Mark = j.Length
	j <~ '\0' // for speed
	j.AppendHInt(pos)
	j <~ .name
	j <~ '\0'
	j.AppendHInt(Reg)
	j.AppendHInt(.dumpcls)
	
	if .Type == TypeByte
		debugat
		#!Compare byte pointers, byte-carray, byte reference!
		#!we want the final typeinfo. Not the wierdness along the way.
		if self is Reference
		if .pointercount
		if .C_Array

	j.AppendHInt(.typeinfo & DataTypeCode.possiblebits) // please be simple!
	
	.DumpWierdness(j)
	
	j[mark] = j.length - mark


function SCDecl.DumpWierdness (|jbin| j)
	opt norefcounts
	while
		|| Wierdness = ((self is reference) << 1)  |||  (.pointercount > 0)
		Wierdness |= .C_Array<<2
		if !Wierdness
			j.AppendHInt(0)
			exit
		j.AppendHInt(Wierdness)
		self = .Internal!
	

function Assembler.MarkCloseInfo (|int| Reg)
	debugger 
	|| Nop = .curr
	if (nop != asm.noop) or (nop isnt discard) or (nop isnt NewlyDeclared)
		nop = .curr.Msg.NOOP
	(nop is discard)
	(nop is newlydeclared)
	nop._Const |= 1<<reg

