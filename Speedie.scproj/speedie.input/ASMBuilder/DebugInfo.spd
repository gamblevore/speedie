


function SCDecl.DumpCode (|int| Pos, |syntax|)
	opt norefcounts
	if pos >= 0 and self is Reference
		return @tmp
	if .PointerCount					// @msg, @arg, @tmp, have names and children.
		return @msg
	if .C_Array
		return @arg
	|| ty = .type
	if ty.IsObject
		return @bin
	if ty.IsStruct
		return @str
	return @char						// a plain old data-type


function jbin.DebugCloseVar (|int| Pos, |int| Reg)
	.WriteType(@back)				// close spd-var	// type
	.Appendhint(1 + pos.hintsize)						// size
	.AppendHint(pos)									// data
/	.AppendByte(reg)


function SCDecl.DumpDecl (|jbin| j, |int| Pos, |int| depth=0)
	opt norefcounts
	
	|| W = .DumpCode(pos)
	|| Reg = 0
	|| s = ""
	if pos >= 0
		if self isnt classobj
			s = .name
		if self is local
			reg = .mu.DataType|asmreg|.Reg

//	|| fn = scfunction.currfunc
//	if fn
		
	j.add(W, s, true)
	j.AddDecl(self, Pos, W, Reg)
	
	|| C = .C_Array						// carray... we need the length of the carray
		j.AddInt(C)
		self = .internal!
	  elseif w == @msg					// pointer
		self = .internal!
	  elseif w != @tmp					// not a reference
		j.exit(depth+1)
		return
	
	.DumpDecl(j, -1, depth+1)


function jbin.AddDecl (|scdecl| D, |int| Pos, |syntax| W, |int| Reg)
	opt norefcounts
	|| t = d.type.DebugTypeInfo(W)
	|| Alloc = t.HIntsize + (reg > 0)
	if pos >= 0
		alloc += pos.hintsize
	.WriteType(@back)	// type
	.Appendhint(alloc)	// size
	.AppendHint(t)		// data
	if pos >= 0
		.AppendHint(pos)
		if reg > 0
			.AppendByte(reg)			
	

function scclass.DebugTypeInfo (|syntax| W, |int|)
	opt norefcounts
	if w == @bin or @str				// an object or struct
		return .TableID
	return .typeinfo.DebugCode


function int.HIntSize (|int|)
	if self >= 0
		if self > 0
			self = .log2/7
		return 1 + self


