

function jbin.DebugCloseVar (|int| Pos, |int| Reg)
	|| Mark = .Length
	self <~ '\0'					// range-length states that theres no name/type. So it must be a close!
	.AppendHInt(pos)
	.AppendHInt(Reg)
	self[mark] = .length - mark


function SCDecl.DumpDecl (|jbin!| dd, |int| Pos)
	opt norefcounts
	|| Reg = .ExportPosition
	if self is local
		reg = .mu.DataType|asmreg|.Reg

	|| Mark = dd.Length
	dd <~ '\0'						// range-length
	dd.AppendHInt(pos)
	dd.AppendHInt(Reg)
	dd <~ .name
	dd <~ '\0'
	dd.AppendHInt(.DumpCls)
	
	if .Type == TypeByte
		debugat
		#!Compare byte pointers, byte-carray, byte reference!
		#!we want the final typeinfo. Not the wierdness along the way.
		if self is Reference
		if .pointercount
		if .C_Array

	dd.AppendHInt(.TypeInfo & DataTypeCode.PossibleBits) // please be simple!
	.DumpWierdness(dd)
	
	dd[mark] = dd.length - mark


function FATASM.OutputDebugVars
	opt norefcounts
	|| dd = Assembler.DebugDecls!
	for i.bits in ._Const
		dd.DebugCloseVar(.ASMIndex, i.log2)
	
	if ._outputs
		|| ty = .msg.NilDecl #debug_require
		ty.DumpDecl(dd, .ASMIndex)


function scdecl.DumpCls (|int|)
	if .IsNormalObject or .IsBareStruct
		return (.type.tableid<<1) + .IsNormalObject


function SCDecl.DumpWierdness (|jbin| j)
	opt norefcounts
	while
		|| Wierdness = ((self is reference) << 1)  |||  (.pointercount > 0)
		Wierdness |= .C_Array<<2
		j.AppendHInt(Wierdness)
		loop Wierdness
		self = .Internal!
	

function FatASM.CanCloseRegs (|int| R, |bool|)
	if .Index|int| <= 0 // oof
	|| op = ._Op
	if op == asm.ret or asm.RFRT or asm.MARK
		return true
	if (op == asm.rfun) and (R&(R-1) == 0)
		|| v = R.log2
		if  .RegOnly(0) == v  and  .regonly(1) == v  and  .regonly(2) == 0
			return true
	
	
function Assembler.MarkVarClosed (|int| RegBits)
	if "DeRefTest".trap or "JB_App__CWDSet".trap
	.RegDebugInfo &= ~RegBits
	|| Mark = .last
	if !mark.CanCloseRegs(RegBits)
		mark = mark.Msg.MARK()
		mark.µrefcount = 1
		
	(mark is DebugVars)
	mark._Const |= RegBits



function fatasm.CanMarkSomething (|message| Exp, |ASMReg| Declared, |scdecl| Ty, |bool|)
	opt norefcounts
	require (self isnt DebugVars) or (self isa asm.mark)
	if (.Output.Reg == Declared.reg)
		|| msg = .msg
		if (msg.NilDecl == ty)
			return true
//		if exp.MsgOwningFunc == msg.MsgOwningFunc
		if msg.func != @func	// fatrenderer needs @func
			.msg = exp
					
			return true


function assembler.MarkVarOpen (|message| Exp, |ASMReg| Declared, |scdecl| Ty, |!&FatASM| Start, |ASMReg|)
	|| Last = .Last
	if Start > Last	and start > .funcstart	// It could have nopped a .gtab if its an inlined param 
		start -= .IsCurr(start-1)|int|		// and it gets replaced into a .gobj
	
	while Start <= Last
		if Last.CanMarkSomething(exp, Declared, ty)
			(Last is DebugVars)
			return declared
		Last--

	last = exp.mark()
	last._Outputs = 1,  last.µrefcount = 1,  last.prms[0] = Declared.reg
	(last is DebugVars)	
	return Declared


