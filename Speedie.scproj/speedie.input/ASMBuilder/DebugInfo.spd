

function jbin.DebugCloseVar (|int| Pos, |int| Reg)
	|| Mark = .Length
	self <~ '\0'			// for speed
	.AppendHInt(pos)
	.AppendHInt(Reg)
	self <~ '\0'			// no name means we destroy the reg.
	self[mark] = .length - mark


function SCDecl.DumpDecl (|jbin!| j, |int| Pos)
	opt norefcounts
	|| Reg = .ExportPosition
	if self is local
		reg = .mu.DataType|asmreg|.Reg

	|| Mark = j.Length
	j <~ '\0' // for speed
	j.AppendHInt(pos)
	j.AppendHInt(Reg)
	j <~ .name
	j <~ '\0'
	j.AppendHInt(.DumpCls)
	
	if .Type == TypeByte
		debugat
		#!Compare byte pointers, byte-carray, byte reference!
		#!we want the final typeinfo. Not the wierdness along the way.
		if self is Reference
		if .pointercount
		if .C_Array

	j.AppendHInt(.TypeInfo & DataTypeCode.PossibleBits) // please be simple!
	.DumpWierdness(j)
	
	j[mark] = j.length - mark


function FATASM.OutputDebugVars
	opt norefcounts
	|| dd = Assembler.DebugDecls!
	for i.bits in ._Const
/		dd.DebugCloseVar(.ASMIndex, i.log2)
	
	if ._outputs
		|| ty = .msg.NilDecl #debug_require
/		ty.DumpDecl(dd, .ASMIndex)


function scdecl.DumpCls (|int|)
	if .IsNormalObject or .IsBareStruct
		return (.type.tableid<<1) + .IsNormalObject


function SCDecl.DumpWierdness (|jbin| j)
	opt norefcounts
	while
		|| Wierdness = ((self is reference) << 1)  |||  (.pointercount > 0)
		Wierdness |= .C_Array<<2
		j.AppendHInt(Wierdness)
		loop Wierdness
		self = .Internal!
	

function FatASM.CanCloseRegs (|int| R, |bool|)
	if .Index|int| <= 0 // oof
	|| op = ._Op
	if op == asm.ret or asm.RFRT or asm.MARK
		return true
	if (op == asm.rfun) and (R&(R-1) == 0)
		|| v = R.log2
		if  .RegOnly(0) == v  and  .regonly(1) == v  and  .regonly(2) == 0
			return true
	
	
function Assembler.MarkVarClosed (|int| RegBits)
	if "DeRefTest".trap or "JB_App__CWDSet".trap
	.RegDebugInfo &= ~RegBits
	|| Mark = .last
	if !mark.CanCloseRegs(RegBits)
		mark = mark.Msg.MARK()
		mark.µrefcount = 1
		
	(mark is DebugVars)
	mark._Const |= RegBits


function assembler.MarkVarOpen (|message| Exp, |ASMReg| Declared, |scdecl| Ty, |!&FatASM| Start, |ASMReg|)
	|| Last = .Last
	if Start > Last	and start > .funcstart	// It could have nopped a .gtab if its an inlined param 
		start -= .IsCurr(start-1)|int|		// and it gets replaced into a .gobj
	
	while Start <= Last
		if (Last.Output.Reg == Declared.reg) and (last.msg.NilDecl == ty)
			(Last is DebugVars)
			return declared
		Last--

	last = exp.mark()
	last._Outputs = 1,  last.µrefcount = 1,  last.prms[0] = Declared.reg
	(last is DebugVars)	
	return Declared


