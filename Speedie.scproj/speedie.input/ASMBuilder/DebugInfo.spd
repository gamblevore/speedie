

function jbin.DebugCloseVar (|int| Pos, |int| Reg)
	|| Mark = .Length
	self <~ '\0'					// range-length states that theres no name/type. So it must be a close!
	.AppendHInt(pos)
	.AppendHInt(Reg)
	self[mark] = .length - mark


function SCDecl.MiniName (|faststring| fs)
	.name.MiniName(fs, self is classobj)


function string.MiniName (|faststring| fs, |bool| IsClass)
	opt norefcounts
	|| n = .name
	|| i = 0
	|| after = int.max
	if IsClass
		fs <~ "("
		if n.EndsWith("data", true)
			after = n.Length - 4 // ErrorData --> (Error)
	if n[0, "JB_", true]
		i = 3
	fs.AppendRange(n, i, after)
	if IsClass
		fs <~ ")"


function SCDecl.DumpDecl (|jbin!| dd, |int| Pos)
	opt norefcounts
	|| Mark = dd.Length
	dd <~ '\0'						// range-length
	dd.AppendHInt(pos)
	dd.AppendHInt(.Reg * (self is local))
	.mininame(dd)
	dd <~ '\0'
	dd.AppendHInt(.DumpCls)
	
	|| T = .inner.TypeInfo & DataTypeCode.PossibleBits
	if .NilDeclared is Nilish
		T |= DataTypeCode.PossibleBits+1
	dd.AppendHInt(T)
	.DumpWierdness(dd)
	
	dd[mark] = dd.length - (mark + 1)


function FATASM.OutputDebugVars
	opt norefcounts
	|| dd = Assembler.DebugDecls!
	for i.bits in ._Const
		dd.DebugCloseVar(.ASMIndex, i.log2)
	
	if ._outputs
		|| ty = .msg.NilDecl #debug_require
		ty.DumpDecl(dd, .ASMIndex)


function scdecl.DumpCls (|int|)
	opt norefcounts
	|| t = .type
	if t.isobject or t.isstruct
		return (t.tableid<<1) + t.isobject


function SCDecl.Wierdness (|int|)
	rz = (self is reference) << 1
	rz |= .pointercount > 0
	rz |= .C_Array<<2


function SCDecl.DumpWierdness (|jbin| j)
	opt norefcounts
	|| Count = 0
	while (|| W = .Wierdness)
		expect (++Count < 5) (.source, "Too much wierdness")
		j.AppendHInt(W)
		self = .Internal$
	

function FatASM.CanCloseRegs (|int| R, |bool|)
	if .Index|int| <= 0 // oof
	|| op = ._Op
	if op == asm.ret or asm.RFRT or asm.MARK
		return true
	if (op == asm.rfun) and (R&(R-1) == 0)
		|| v = R.log2
		if  .RegOnly(0) == v  and  .regonly(1) == v  and  .regonly(2) == 0
			return true
	
	
function Assembler.MarkVarClosed (|int| RegBits)
	if "DeRefTest".trap or "JB_App__CWDSet".trap
	.RegDebugInfo &= ~RegBits
	|| Mark = .last
	if !mark.CanCloseRegs(RegBits)
		mark = mark.Msg.MARK()
		mark.µrefcount = 1
		
	(mark is DebugVars)
	mark._Const |= RegBits


function fatasm.CanMarkSomething (|message| Exp, |ASMReg| Declared, |scdecl| Ty, |bool|)
	opt norefcounts
	require (self isnt DebugVars) or (self isa asm.mark)
	if (.Output.Reg == Declared.reg)
		|| msg = .msg
		if (msg.NilDecl == ty)
			return true
		if msg.func != @func	// fatrenderer needs @func
			.msg = exp
			return true


function assembler.MarkVarOpen (|message| Exp, |ASMReg| Declared, |scdecl| Ty, |!&FatASM| Start, |ASMReg|)
	|| Last = .Last
	if Start > Last	and start > .funcstart	// It could have nopped a .gtab if its an inlined param 
		start -= .IsCurr(start-1)|int|		// and it gets replaced into a .gobj
	
	while Start <= Last
		if Last.CanMarkSomething(exp, Declared, ty)
			(Last is DebugVars)
			return declared
		Last--

	last = exp.mark()
	last._Outputs = 1,  last.µrefcount = 1,  last.prms[0] = Declared.reg
	(last is DebugVars)	
	return Declared



function SCDecl.Inner (|scdecl|)
	opt norefcounts
	visible
	rz = self
	while
		self = .internal
		if !self
			exit

