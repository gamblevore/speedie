
// Never marking early-closes as closing a var is the way
// Otherwise, I have to mark some early-close before return, as "not valid after x-instructions"

// pos, reg, name, class, type

function jbin.DebugCloseVar (|int| Pos, |int| Reg)
	debugger
	.AppendHInt(pos)
	self <~ '\1'
	self <~ '\0'
	.AppendHInt(Reg)


function FATASM.DumpDecl (|&jbin| Dbg, |&jbin|)
	opt norefcounts
	|| j = Assembler.DebugDecls!
	if .GuessSize
/		.msg.FastDecl.DumpDecl(j, .asmindex)
	  elseif self is Discard
		ifn self isa asm.noop // how?
		for i.bits in ._Const
/			j.DebugCloseVar(.asmindex, i.log2)

	return dbg


function scdecl.DumpCls (|int|)
	if .IsNormalObject or .IsBareStruct
		return (.type.tableid<<1) + .IsNormalObject


function SCDecl.DumpDecl (|jbin!| j, |int| Pos)
	opt norefcounts
	|| Reg = .ExportPosition
	if self is local
		reg = .mu.DataType|asmreg|.Reg

	|| Mark = j.Length
	j <~ '\0' // for speed
	j.AppendShort(pos)
	j.AppendShort(0) // finish
	j <~ .name
	j <~ '\0'
	j.AppendHInt(Reg)
	j.AppendHInt(.dumpcls)
	
	if .Type == TypeByte
		debugat
		#!Compare byte pointers, byte-carray, byte reference!
		#!we want the final typeinfo. Not the wierdness along the way.
		if self is Reference
		if .pointercount
		if .C_Array

	j.AppendHInt(.typeinfo & DataTypeCode.possiblebits) // please be simple!
	.DumpWierdness(j)
	
	j[mark] = j.length - mark


function SCDecl.DumpWierdness (|jbin| j)
	opt norefcounts
	while
		|| Wierdness = ((self is reference) << 1)  |||  (.pointercount > 0)
		Wierdness |= .C_Array<<2
		if !Wierdness
			j.AppendHInt(0)
			exit
		j.AppendHInt(Wierdness)
		self = .Internal!
	

function Assembler.MarkVarClosed (|int| RegBits)
	if "DeRefTest".trap or "JB_App__CWDSet".trap
	.RegDebugInfo &= ~RegBits
	|| Mark = .last
	if Mark.Index|int| <= 0 // oof
	
	|| op = mark._Op
	if (op == asm.rfun) and .CanMarkDecr(regbits, mark)
		0
	  elseif op == asm.ret or asm.RFRT
		0
	  elseif op != asm.MARK
		mark = mark.Msg.MARK()
		
	(mark is newlydeclared)
	mark._Const |= (RegBits|uint64|<<32)


function assembler.CanMarkDecr (|int| R, |&FATASM| fat, |bool|)
	require !(R&(R-1))   // pow2
	|| v = R.log2
	if  fat.regOnly(0) == v  and  fat.regonly(1) == v  and  fat.regonly(2) == 0
		return true

