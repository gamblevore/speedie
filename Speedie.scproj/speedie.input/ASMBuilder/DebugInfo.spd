
// Never marking early-closes as closing a var is the way
// Otherwise, I have to mark some early-close before return, as "not valid after x-instructions"

// pos, reg, name, class, type

function jbin.DebugCloseVar (|int| Pos, |int| Reg)
	debugger
	.AppendHInt(pos)
	self <~ '\1'
	self <~ '\0'
	.AppendHInt(Reg)


function FATASM.DumpDecl (|&jbin| Dbg, |&jbin|)
	opt norefcounts
	|| j = Assembler.DebugDecls!
	if .GuessSize
/		.msg.FastDecl.DumpDecl(j, .asmindex)
	  elseif self is Discard
		ifn self isa asm.noop // how?
		for i.bits in ._Const
/			j.DebugCloseVar(.asmindex, i.log2)

	return dbg


function scdecl.DumpCls (|int|)
	if .IsNormalObject or .IsBareStruct
		return (.type.tableid<<1) + .IsNormalObject


function SCDecl.DumpDecl (|jbin!| j, |int| Pos)
	opt norefcounts
	|| Reg = .ExportPosition
	if self is local
		reg = .mu.DataType|asmreg|.Reg

	|| Mark = j.Length
	j <~ '\0' // for speed
	j.AppendShort(pos)
	j.AppendShort(0) // finish
	j <~ .name
	j <~ '\0'
	j.AppendHInt(Reg)
	j.AppendHInt(.dumpcls)
	
	if .Type == TypeByte
		debugat
		#!Compare byte pointers, byte-carray, byte reference!
		#!we want the final typeinfo. Not the wierdness along the way.
		if self is Reference
		if .pointercount
		if .C_Array

	j.AppendHInt(.typeinfo & DataTypeCode.possiblebits) // please be simple!
	.DumpWierdness(j)
	
	j[mark] = j.length - mark


function SCDecl.DumpWierdness (|jbin| j)
	opt norefcounts
	while
		|| Wierdness = ((self is reference) << 1)  |||  (.pointercount > 0)
		Wierdness |= .C_Array<<2
		if !Wierdness
			j.AppendHInt(0)
			exit
		j.AppendHInt(Wierdness)
		self = .Internal!
	

function Assembler.MarkVarClosed (|int| RegBits)
	if "DeRefTest".trap or "JB_App__CWDSet".trap
	.RegDebugInfo &= ~RegBits
	|| Nop = .last
	if nop.Index|int| <= 0 // oof
	
	if !.CanMarkDecr(regbits, nop)
		if !(nop isa asm.noop) or (nop isnt discard) or (nop isnt NewlyDeclared)
			nop = nop.Msg.NOOP
		
	(nop is discard)
	(nop is newlydeclared)
	nop._Const |= RegBits


// I think RFUN should be changed...
// decr should be set reg to 0.
// rfun isnt very fun really. You wouldn't combine these things with incr:
// incr + freeifdead (Well its not dead is it)
// incr + decr (whats the point?)
// So you could do like... incr OR freeifdead
// thats all really.

function assembler.CanMarkDecr (|int| R, |&FATASM| decr, |bool|)
	require  (decr isa asm.rfun)  and  !(R&(R-1))   // pow2
	|| v = R.log2
	if  decr.regOnly(0) == v  and  decr.regonly(1) == v  and  decr.regonly(2) == 0
/		return true

