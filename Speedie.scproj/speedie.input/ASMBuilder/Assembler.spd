

struct ASMState
	|scfunction!--|	Fn    
	|asmreg|		Return
	|uint64|		ParentVars
	|byte|			BranchDepth
	|byte|			InlineDepth
	|bool|			TailInlineable


struct Assembler
	linkage: cpp_part Pac
	|uint16| 					BasicBlock

	|ASMState|					State
	|byte|						DeepestInline
	|byte|						InlineDepthLimit
	target debug
		|byte|					StackSize
	|uint|						VDecls
	|uint|						VTemps
	|int|						CurrFuncGrab
    |uint16|                    BranchID
    |uint16|                    NextBranchID
	|bool|						Inited
	|bool|						NeedsRework

	|scfunction--|				Out

	|?&FatASM|					InlineEnd
	|int|						KnownValuesMap
	|?&FatASM|					Orig
	|&FatASM|					FuncStart
	|&FatASM|					Start		// a "slice" feature would be nice    
	|&FatASM|					_Curr    
	|&FatASM|					End    

	|(?&FATASM)[32]|			Registers
	|FatASM| 					Zero

	constants
		kContinue		= 254
		kExit			= 255
	

	module
		|Assembler|					Sh
		|memory of fatasm|			JSM = FatASM[0]!
		|memory of fatasm|			HoistSpace = FatASM[0]!


	function fn (|scfunction!--|)
		return .state.fn
	

    function Curr (|&fatasm|)
        return ._curr

	function Length (|int|)
		return .curr - .funcstart
	
	function AddFuncParams (|SCFunction| fn)
		opt NoRefCounts
//		.References = 0
		for a in fn.Args
			.DeclReset(a)
			.DeclareMe(a.source, a)
//			.references |= (a is Reference) << (i+1)

	
	function Index (|int|)
		return ._curr - .start
	
	
	function Last (|&FatASM|)
		return ._curr - 1


	function Last (|asm| type, |&FatASM|)
		|| L = ._curr - 1
		if (l isa type) and .IsCurr(L)
			return L
	
	
	function IsCurr (|&fatasm| f, |bool|)
		return .basicblock == f.basicblock

	
	function IntPowerOfTwo (|asmreg| r, |int| Sub=0, |FailableInt|)
		// -1 --> -1,  0 --> 0,  1 --> 1,  2 --> 2,  4 --> 3,  8 --> 4
		// this is used for multiplication mostly. like x*-1, or x*0, or x*1
		|| v = r.const
		if v == -1
			if sub
			.NopConst(r)
			return v
		v -= Sub
		if v.IsPow2
			.NopConst(r)
			if !v
				return 0
			return v.Log2+1


	function IncrPost (|message| exp,  |AsmReg| Dest,  |AsmReg| ToGrow,  |int64| Value,  |asmreg|)
		if togrow.isint and value.CanStoreAsAddK and !dest.IsVec
			return exp.ADAK(dest, ToGrow, Value) * Dest
		.Assign(exp, dest, ToGrow)
		rz = .IncrPre(exp, togrow, ToGrow, value)


	function AddToReg (|message| exp, |asmreg| Dest, |asmreg| Orig, |int64| Amount, |asmreg|) // addnum
		if !dest or dest == asmreg()
			dest.µtype = orig.µtype
		dest = .TempOnly(dest)
		|| Where = orig • dest
		(where is ConstOutput)
		|| K = .NumToReg(exp, where, amount, orig.µtype)
		return .Plus(exp, dest, Orig, K)
	
	
	function IncrPre (|message| exp,  |AsmReg| Dest,  |AsmReg| Src,  |int64| Value,  |asmreg|)
		if !src.reg // what?
		if !dest.reg
			dest = src
		src = .AddToReg(exp, src, src, value) 
		return src
		
		// why? that violates the entire design?
		// why did I add this? It adds extra bflgs!
		if dest.reg==src.reg
			return src
		return .Assign(dest, src, exp)


	function DeclareMe (|Message| where,  |scdecl?| Type=nil,  |asmreg|)
		if type
			rz = Type.CalculateASMType
			|| ret = .state.return
			if  ret.reg  and  (type is VarThatGotReturned)  and  (.state.fn.ReturnedVars == 1)
				ret.µtype = rz|DataTypeCode|
				Type.wholetype = ret
				return ret
		
		|| d = .VDecls
		check (d != -1) (where, "No free local variables.")
		
		|| FreeBit = (~d).LowestBit		// Find lowest free bit.
		d |= FreeBit
		rz.reg = freeBit.log2

		if type
			Type.WholeType = rz
			target debug: Type.ASMSanity
			(rz is notalteredinbranch) = (type isnt alteredinbranch)

		.Vdecls = d
		check (!(.vdecls & .VTemps)) (where, "No free local variables.")	// entirely full


	function TempTyped (|scdecl| Type, |asmreg| T,  |asmreg|)
		if type
			t.µtype = type.mu.DataType
		return .TempOnly(t)
	
	
	function TempTyped (|Message| where, |asmreg| T=asmreg.Temp, |asmreg|)				// .needreg
		opt norefcounts
		if t isnt textual
			// what if there is a type and its different?
			// and if its NEVER different... why add it?
			t.µtype = where.asmdecl.mu.DataType
		return .TempOnly(t)


	function TempOnly (|asmreg| T=asmreg.Temp, |asmreg|)				// .needreg
		opt norefcounts
		if t.reg
			return t

		|| r = .VTemps
		if r&1 // how?
/			r&=~1
		
		
		|| Free = (~r).Log2		// Find lowest free bit.
		r |= 1<<Free
		t.reg = Free
		.VTemps = r
		(t isnt ConstOutput) // why would it be?
		(t is temp)
		check (!(.vdecls & .VTemps)) (.fn.sourcearg, "No free local variables.")	// entirely full
		return t
	
	
	function NopReg (|asmreg| R)
		|| f = r.fat
			return .Nop(f)
		if r.reg and r isnt param
			debugat // we don't know what made it, but we should!!
	
	
	function Nop2Consts (|asmreg| A, |asmreg| B)
		|| Further = a.FatIndex > b.FatIndex
			.NopConst(A)
		.NopConst(B)
		if !Further
			.NopConst(A) // in case of swapped order
	
	
	function Const (|asmreg| R, |int| bits, |bool| signed, |ind|)
		if r.reg == 0
			return 0 // sigh. I DIE.
		
		if R is ConstOutput
			|| k = R.const
			if k.fits(bits, signed)
				.NopConst(R, AnyBlock)
				return k|uint64|.trim(bits)


	constants
		AnyBlock = 1

	
	function NopConst (|asmreg| R, |int| NopMode = 0)
		require r.reg
		target debug: if r isnt ConstOutput //hah
		|| f = r.NeedFAT

		(NopMode)
//		if NopMode&AnyBlock
//			require .IsMostlyCurr(F)
		if .IsCurr(F)
			.AskNop(f)
	
	
	function Nop (|FATASM| ToNop)
		opt inline
		return .nopsub(ToNop, false, 0)
	
	
	function SoftNop (|FATASM| Fat)
		opt inline
		return .nopsub(fat, true, 0)
	
	
	helper NopSub (|FATASM| Fat, |bool| Soft,  |int| Depth)
		|| C = .curr - 1
		if fat == C
			._curr = C // do it before both kinds of nop...

		depth++
		if depth > 7
		
		for f.fatinputs in fat
			.Decr(f, Soft, depth)
		
		for v.regoutputs in fat
			v &= 31
			.RemoveReg(v, fat)
		|| Type = asm.noop * (fat < ._curr)
		fat.setop = Type


	function Register (|int| i, assigns:|?&FATASM|)
		if value isa asm.WR8U or asm.WR4U or asm.WR2U or asm.WR1U
		.Registers[i] = value


	function RegIsConst (|asmreg| R, |int64| k, |bool|)
		|| f = .registers[r.reg]
		if f is constoutput
			return f.const == k
	
	
	function Decr (|?&fatasm| f, |bool| Soft, |int| Depth=0)
		if f
			|| C = f.µrefcount
			C -= (C > 0)
			f.µrefcount = C
			if !soft and C <= 0
				.NopSub(f, soft, depth)
	
	
	function AskNop (|fatasm| ToNop)
		if ToNop.µRefCount <= 0
			.nop(ToNop)
	
	
	function SoftNopRange (|fatasm| Start, |fatasm| After)
		// todo: should this not be merged with rewind?
		while start < After
			.SoftNop(--after)
	
	
///////////////////////////////////////////////////////////////////////////////////////////////////
	
	function µBoolInto (|message| exp, |AsmReg| Dest, |asmreg|)
		dest.µType = DataTypeCode.bool
		(dest as= asmreg.PreferEqul)						// easier to optimise.
		|| x = .µ(exp, dest)
		if x.IsBool
			return .Into(exp, dest, x)
		return .Exists(dest, X, exp)
	
	
	function message.FoundFunc (|bool|)
		opt norefcounts
		
		while self
			if (.func == @prm)
				target debug: ifn .obj isa scfunction		// it must be, right?
				return true
			|| c = .first
				|| r = c.FoundFunc
					return r
			self++
	
	
	function message.SaveForward (|asmreg|)
		return ASMReg.temp * (!.FoundFunc)
	
	
	function message.ContainsFunc (|bool|)
		opt norefcounts
		if .func == @prm // what the?
		|| f = .first
			return f.FoundFunc
			
		
	function GetRealDest (|message| exp,  |scdecl| A,  |asmreg| dest,  |asmreg|)
		if dest is Declaration							// || x = (y + 1) + (z + 1)
			return dest asnt asmreg.Declaration
		if dest is temp									//    x = (y + 1) + (z + 1)
			return .TempTyped(a, dest asnt asmreg.temp)
		return .DeclareMe(exp, a)


	function µGetReal (|message| exp,  |scdecl| A,  |asmreg| Mode,  |asmreg|)
		if mode is into
			|| Dest = .getrealdest(exp, a, mode)
			return .µgetasm(Exp, dest)
		
		|| OV = .OpenVars
		|| Dest = .getrealdest(exp, a, mode)
		(dest as= mode & asmreg.into)
		rz = .µgetasm(Exp, dest)
		if rz iz Dest
			return rz
		.CloseVars(ov)
		
	
	
	function µInto (|message| exp, |AsmReg| Dest, |asmreg|)
		target debug: if dest is discard, if !dest.reg, || t = ++asmtrapper, if t == 0

		return .µ(Exp, dest as asmreg.Into)
		
	
	function Into (|message| exp, |asmreg| dest, |asmreg| t, |asmreg|)
		if  dest isnt into  or  t iz dest
			return t
		return .Assign(exp, dest, t)
		
	
	
	function µ (|message| exp, |AsmReg| Dest = asmreg(), |asmreg|)
		description "Same as µGetASM, except this closes temp vars for reuse." 
		|| Closer = .OpenVars
		|| v = .µGetASM(exp, dest)
		if "Incr".trap
		return .CloseVars(Closer, nil, v)


	function µArg (|message| exp, |asmreg|)
		if exp.func == @decl
			return ASMType.Decl(self, exp, AsmReg.RealDiscard) 
		return .µ(exp, asmreg.realdiscard)	// closes vars, but decls don't want close.
											// we'd have to return a flag from .decl to tell
											// .µ to not close it.


	function µReffed (|message| exp, |scdecl!| A, |asmreg|)
		|| Mode = exp.SaveForward
		(Mode is AddrNeed) = (a is Reference)
		|| r = .µGetReal(exp, nil, Mode)
		if (a is reference  and  r isnt containsaddr)
			error (exp|object|)
		return r.incr


	function µGetASM (|message| exp, |AsmReg| Dest = asmreg(), |asmreg|)
		opt norefcounts
		cpp_part GetASM 
		
		|| fn = fn_asm_table[exp.ASMType]!
		target debug
			dest.TmpCheck
			|| StartStackSize = ++.stacksize
			if StartStackSize > 20 // ugh
			|| trap = ++ASMTrapper
		  else
			opt inline
		
		|| ss = (fn)(self, exp, dest)

		target debug
			.StackSize--
			if ((dest is into) and !(ss iz dest)) or (ss is into)
				if (ss is into) { "into" } else {"wrong dest"}
/				(fn)(self, exp, dest)
			if (ss is constoutput) and (ss.reg and !ss.fatindex) // huh?
				debugger
				PrintProgress()
				(fn)(self, exp, dest)
			if !ss.tmpcheck
				(fn)(self, exp, dest)
			if !ss  or  (dest is set)  or  (ss is set or ok)
				return ss // no need test.
			if !ss.reg and (ss isnt condanswer)
				if !(ss & asmreg.exit) and (ss isnt constoutput)
					debugger
					PrintProgress()
					(fn)(self, exp, dest)
		return ss
	
	
	function PackMakerInit
		opt norefcounts
		require !.Inited
		.inited = true
		VM_Builder.JustDefineInstructions
		instruction.InstructionInit
		ASMType.InitAccess
		Instruction[asm.KNSR].Const
		Instruction[asm.KNST].Const
		asm.encoders[asm.KNST] = fatasm.KNST_Encoder
		asm.encoders[asm.noop] = fatasm.NOOP_Encoder
		return 
		TextAssembler.Requests		?= dictionary()
		TextAssembler.RequestTable	?= array()
	
	
	function InitAndStartFunc (|scfunction| fn) // init 
		// can't we just zero the entire thing?
		opt norefcounts
		
		target debug
			asm.noisyasm = 3

		|| j = jsm
		.end = j.NeedSpare(256K, j.Size)
		.start = j.ptr
		._curr = .start + j.Length
		
		// after zeroing, we could just set everything normally? It seems ._curr is set from jsm.
		HoistSpace.Length = 0
		
		.out = fn
		.state.fn = fn
		SCFunction.CurrFunc = fn
		.state.Return = nil
		.state.inlinedepth = 0
		.state.BranchDepth = 0
		.state.TailInlineable = true
		.InlineDepthLimit = 3
		.BasicBlock = 0
		.VDecls = 1
		.VTemps = 0
		.BranchID = 0
		.NextBranchID = 0
		.NeedsRework = false
		.zero = nil
		.zero.info = AsmReg()
		.KnownValuesMap = nil
		for i in 32
			.registers[i] = nil

		.Guard
		fn.StartASM
		.InlineEnd = nil
		.FuncStart = .curr
		.AddFuncParams(fn)


	function CapASM
		.out.µlength = .length
		jsm!.length = .curr - .start 

		
	function FinishASM 
		opt norefcounts
		if .zero.Const // what?
		|| l = .last
		if !l.IsFinisher
			debugger !.fn.ASMReturn
			|| dl = .fn.Source!.DeepLast
			.closevars(1, dl)
			|asmreg| dest = nil
			if !ASMType.ReturnOpt(self, dest)
				dl.RET()
		.Optimise


	function Guard
		opt norefcounts
		|| arg = .fn.SourceArg!
		target debug
			if arg.position < 0
				arg.position = 0 // skip error detection
		Arg.EROR.BasicBlock = -1

/* The .asint/.asfloat functions should be recognised as working on constants? Or is that just a general case of inline functions? Technically, its an inline func that does nothing, just returns the original... with a different type. */


	iterator
		|| h = .KnownValuesMap
		while h
			|| h2 = h.LowestBit
			yield .Registers[h2.log2]!
			h &= ~h2


target debug
	|| ASMTrapper = 0
// Speedie's function histogram:  0:410, 1:1656, 2:1464, 3:713, 4:167, 5:61, 6:10, 7:4, 8:0
// There are only 4 above 6!, only 14 above 5, 75 above 4
// almost all lib functions have 4 or less. 5 is for proj funcs.
	


function Assembler.Rework (|SCFunction| fn,  |bool|)
	HoistSpace.NeedSpare(.Length)
	HoistSpace.CopyFrom(.FuncStart, .Length)
	.Orig = .FuncStart
	.InitAndStartFunc(fn)
	asmtype.ArgumentSub(self, fn.SourceArg!)
	.FinishASM
	.Orig = nil


function Assembler.GenerateASM (|scfunction| fn,  |bool|) // AsmGenerate
	opt norefcounts
	
	.InitAndStartFunc(fn)
	asmtype.ArgumentSub(self, fn.SourceArg!)
	.FinishASM
	if .NeedsRework
		.Rework(fn)
	.CapASM
	compiler.stASMTotalOps += fn.GuessLength

	if StdErr.ok
		|| max = fn.maxasm
			check (fn.µlength <= max) (fn.sourcearg, "ASM too large")
		target debug
			fn.µprint(++CountASMFuncPrint)
		return true


target debug
	|| CountASMFuncPrint = 0

