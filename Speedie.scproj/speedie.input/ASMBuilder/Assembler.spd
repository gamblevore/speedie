

struct ASMState
	|scfunction!--|	Fn    
	|asmreg|		Return
	|uint64|		ParentVars
	|byte|			BranchDepth
	|byte|			InlineDepth
	|bool|			TailInlineable


struct Assembler
	linkage: cpp_part Pac
	|uint16| 					BasicBlock

	|ASMState|					State
	|byte|						DeepestInline
	|byte|						InlineDepthLimit
	target debug
		|byte|					StackSize
	|uint|						VDecls_
	|uint|						VTemps
	|int|						CurrFuncGrab
    |uint16|                    BranchID
    |uint16|                    NextBranchID
	|bool|						Inited
	|bool|						NeedsRework

	|scfunction--|				Out

	|?&FatASM|					InlineEnd
	|int|						KnownValuesMap
	|?&FatASM|					Orig
	|&FatASM|					FuncStart
	|&FatASM|					Start		// a "slice" feature would be nice    
	|&FatASM|					Curr_
	|&FatASM|					End    

	|(?&FATASM)[32]|			Registers_
	|FatASM| 					Zero

	constants
		kContinue		= 254
		kExit			= 255
	

	module
		|Assembler|					Sh
		|memory of fatasm|			JSM = FatASM[0]!
		|memory of fatasm|			HoistSpace = FatASM[0]!


	function fn (|scfunction!--|)
		return .state.fn
	

    function Curr (|&fatasm|)
        return .curr_

	function Length (|int|)
		return .curr_ - .funcstart
	
	function AddFuncParams (|SCFunction| fn)
		opt NoRefCounts
//		.References = 0
		for a in fn.Args
			.DeclReset(a)
			.DeclareMe(a.source, a)
//			.references |= (a is Reference) << (i+1)

	
	function Index (|int|)
		return .curr_ - .start
	
	
	function Last (|&FatASM|)
		return .curr_ - 1


	function Last (|asm| type, |&FatASM|)
		|| L = .curr_ - 1
		if (l isa type) and .IsCurr(L)
			return L
	
	
	function IsCurr (|&fatasm| f, |bool|)
		// needs to take loops into account
		// also, perhaps BlockIDs instead.
		// this could be nicer. Assuming its not altered in a branch... the blockID could work.
		
		return .basicblock == f.basicblock

	
	function IntPowerOfTwo (|asmreg| r, |int| Sub=0, |FailableInt|)
		// -1 --> -1,  0 --> 0,  1 --> 1,  2 --> 2,  4 --> 3,  8 --> 4
		// this is used for multiplication mostly. like x*-1, or x*0, or x*1
		|| v = r.const
		if v == -1
			if sub
			.NopConst(r)
			return v
		v -= Sub
		if v.IsPow2
			.NopConst(r)
			if !v
				return 0
			return v.Log2+1


	function IncrPost (|message| exp,  |AsmReg| Dest,  |AsmReg| ToGrow,  |int64| Value,  |asmreg|)
		if togrow.isint and value.CanStoreAsAddK and !dest.IsVec
			return exp.ADAK(dest, ToGrow, Value) * Dest
		.Assign(exp, dest, ToGrow)
		rz = .IncrPre(exp, togrow, ToGrow, value)


	function AddToReg (|message| exp, |asmreg| Dest, |asmreg| Orig, |int64| Amount, |asmreg|) // addnum
		if !dest or dest == asmreg()
			dest.µtype = orig.µtype
		dest = .TempOnly(dest)
		|| Where = orig • dest
		(where is Const)
		|| K = .NumToReg(exp, where, amount, orig.µtype)
		return .Plus(exp, dest, Orig, K)
	
	
	function IncrPre (|message| exp,  |AsmReg| Dest,  |AsmReg| Src,  |int64| Value,  |asmreg|)
		if !src.reg // what?
		if !dest.reg
			dest = src
		src = .AddToReg(exp, src, src, value) 
		return src
		
		// why? that violates the entire design?
		// why did I add this? It adds extra bflgs!
		if dest.reg==src.reg
			return src
		return .Assign(dest, src, exp)


	function DeclareMe (|Message| where,  |scdecl?| Type=nil,  |asmreg|)
		if type
			rz = Type.CalculateASMType
			|| ret = .state.return
			if  ret.reg  and  (type is VarThatGotReturned)  and  (.state.fn.ReturnedVars == 1)
				ret.µtype = rz|DataTypeCode|
				Type.wholetype = ret
				return ret
		
		|| d = .VDecls
		check (d != -1) (where, "No free local variables.")
		
		|| FreeBit = (~d).LowestBit		// Find lowest free bit.
		d |= FreeBit
		rz.reg = freeBit.log2

		if type
			Type.WholeType = rz
			target debug: Type.ASMSanity

		.Vdecls = d
		check (!(.vdecls & .VTemps)) (where, "No free local variables.")	// entirely full


	function vdecls (|uint|)
		return .vdecls_


	setter vdecls (|uint|)
//		if "foreignfuncs".trap	
		.vdecls_ = value

	
	function TempTyped (|scdecl| Type, |asmreg| T,  |asmreg|)
		if type
			t.µtype = type.mu.DataType
		return .TempOnly(t)
	
	
	function TempTyped (|Message| where, |asmreg| T=asmreg.Temp, |asmreg|)				// .needreg
		opt norefcounts
		if t isnt textual
			// what if there is a type and its different?
			// and if its NEVER different... why add it?
			t.µtype = where.asmdecl.mu.DataType
		return .TempOnly(t)


	function TempOnly (|asmreg| T=asmreg.Temp, |asmreg|)				// .needreg
		opt norefcounts
		if t.reg
			return t

		|| r = .VTemps
		if r&1 // how?
/			r&=~1
		
		
		|| Free = (~r).Log2		// Find lowest free bit.
		r |= 1<<Free
		t.reg = Free
		.VTemps = r
		(t isnt Const) // why would it be?
		(t is temp)
		check (!(.vdecls & .VTemps)) (.fn.sourcearg, "No free local variables.")	// entirely full
		return t
	
	
	function NopReg (|asmreg| R)
		|| f = r.fat
			return .Nop(f)
		if r.reg and r isnt param
			debugat // we don't know what made it, but we should!!
	
	
	function Nop2Consts (|asmreg| A, |asmreg| B)
		|| Further = a.FatIndex > b.FatIndex
			.NopConst(A)
		.NopConst(B)
		if !Further
			.NopConst(A) // in case of swapped order
	
	
	function Const (|asmreg| R, |int| bits, |bool| signed, |ind|)
		if r.reg == 0
			return 0 // sigh. I DIE.
		
		if R is Const
			|| k = R.const
			if k.fits(bits, signed)
				.NopConst(R)
				return k|uint64|.trim(bits)
	
	function NopConst (|asmreg| R, |int64| K, |bool|)
		if r.Const == K
			.NopConst(R)
			return true
		
	function NopConst (|asmreg| R)
		require r.reg
		target debug: if r isnt Const //hah

//		if NopMode&AnyBlock
//			require .IsMostlyCurr(F)
		if R is temp				// don't think we can do better.
			.AskNop(r.NeedFAT)		// not easily. for example .iscurr(f) gets params used by future stuff
	
	
	function Nop (|FATASM| ToNop)
		opt inline
		return .nopsub(ToNop, false, 0)
	
	
	function SoftNop (|FATASM| Fat)
		opt inline
		return .nopsub(fat, true, 0)
	
	
	helper NopSub (|FATASM| Fat, |bool| Soft,  |int| Depth)
		|| C = .curr - 1
		if fat == C
			.curr_ = C // do it before both kinds of nop...

		depth++
		if depth > 7
		
		for f.fatinputs in fat
			.Decr(f, Soft, depth)
		
		for v.regoutputs in fat
			v &= 31
			.RemoveReg(v, fat)
		|| Type = asm.noop * (fat < .curr_)
		fat.setop = Type


	function Register (|int| i, assigns:|?&FATASM|)
		if value isa asm.WR8U or asm.WR4U or asm.WR2U or asm.WR1U
		.Registers_[i] = value
		
	function Register (|int| i, |?&FATASM|)
		return .Registers_[i] 


	function RegIsConst (|asmreg| R, |int64| k, |bool|)
		|| f = .register(r.reg)
		if f is Const
			return f.const == k
	
	
	function Decr (|?&fatasm| f, |bool| Soft, |int| Depth=0)
		if f
			|| C = f.µrefcount
			C -= (C > 0)
			f.µrefcount = C
			if !soft and C <= 0
				.NopSub(f, soft, depth)
	
	
	function AskNop (|fatasm| ToNop)
		if ToNop.µRefCount <= 0
			.nop(ToNop)
	
	
	function SoftNopRange (|fatasm| Start, |fatasm| After)
		// todo: should this not be merged with rewind?
		while start < After
			.SoftNop(--after)
	
	
///////////////////////////////////////////////////////////////////////////////////////////////////
	
	function µBoolInto (|message| exp, |AsmReg| Dest, |asmreg|)
		dest.µType = DataTypeCode.bool
		(dest as= asmreg.PreferEqul)						// easier to optimise.
		|| x = .µ(exp, dest)
		if x.IsBool
			return x
		return .Exists(dest, X, exp)
	
	
	function message.FoundFunc (|bool|)
		opt norefcounts
		
		while self
			if (.func == @prm)
				target debug: ifn .obj isa scfunction		// it must be, right?
				return true
			|| c = .first
				|| r = c.FoundFunc
					return r
			self++
	
	
	function message.SaveForward (|asmreg|)
		return ASMReg.temp * (!.FoundFunc)
	
	
	function message.ContainsFunc (|bool|)
		opt norefcounts
		if .func == @prm // what the?
		|| f = .first
			return f.FoundFunc
			
		
	function GetRealDest (|message| exp,  |scdecl| A,  |asmreg| dest,  |asmreg|)
		if dest is Declaration							// || x = (y + 1) + (z + 1)
			return dest asnt asmreg.Declaration
		
		// todo: should make these as declarations too?? I mean... they are.
		// what about doing all .declaremes/.temps?
		if dest is temp									//    x = (y + 1) + (z + 1)
			return .TempTyped(a, dest)
		return .DeclareMe(exp, a) as dest


	function µInlineParam (|message| exp,  |scdecl| A,  |asmreg| Dest,  |asmreg|)
	/*
		possible inline param cases. int A is a normal reg. int B is altered
		theres also references...
		
		A+B: nil
		A:   reg1
		B:	 asmreg.into // can't pass B, so pass a copy?
		0:   asmreg.into // if altered or ref
		0:   nil         // otherwise
	*/

		|| OV = .OpenVars
		Dest = .DeclareMe(exp, a) as dest
		|| r = .µGetASM(Exp, dest)
		if r iz dest
			return r
		if (dest isnt into2) and !(a is alteredorref and r.reg == 0)
			.CloseVars(ov)
			return r
		return .Assign(exp, dest, r)


	function µGetRealOffer (|message| exp,  |scdecl| A,  |asmreg| Dest,  |asmreg|)
		|| c = .curr
		return .µGetReal(exp, a, dest)
		// todo: check if we can re-write the output to dest
		// however its more tricky than I thought. Do later. 


	function µGetReal (|message| exp,  |scdecl| A,  |asmreg| Dest,  |asmreg|)
		|| OV = .OpenVars
		Dest = .GetRealDest(exp, a, dest)
		rz = .µgetasm(Exp, dest)
		if rz iz Dest
			return rz
		.CloseVars(ov)
		
		
	function µ (|message| exp, |AsmReg| Dest = asmreg(), |asmreg|)
		description "Same as µGetASM, except this closes temp vars for reuse." 
		|| Closer = .OpenVars
		|| v = .µGetASM(exp, dest)
		return .CloseVars(Closer, nil, v)


	function µReffed (|message| exp, |scdecl!| A, |asmreg|)
		|| Mode = exp.SaveForward
		(Mode is AddrNeed) = (a is Reference)
		|| r = .µGetReal(exp, nil, Mode)
		if (a is reference  and  r isnt containsaddr)
			error (exp|object|)
		return r.incr


	function µInto (|message| exp, |AsmReg| Dest, |asmreg|)
		|| Closer = .OpenVars
		|| v = .µGetASMInto(exp, dest)
		return .CloseVars(Closer, nil, v)
		
	
	function µGetASMInto (|message| exp, |AsmReg| Dest, |asmreg|)
		|| m = .µGetASM(Exp, dest)
		if m iz dest
			return m
		return .Assign(exp, dest, m)
		
	
	function µDebug (|message| exp, |asmreg| dest)
		target debug
			|| fn = fn_asm_table[exp.ASMType]!
			dest.debugprint
			PrintProgress()
			debugger
			|| m = (fn)(self, exp, dest)
			m.debugprint
			debugger

		
	function µGetASM (|message| exp, |AsmReg| Dest = asmreg(), |asmreg|)
		opt norefcounts
		cpp_part GetASM 
		
		|| fn = fn_asm_table[exp.ASMType]!
		target debug
			dest.TmpCheck
			if ++.stacksize > 20 // ugh
			|| trap = ++ASMTrapper, // if trap == 0
		  else
			opt inline
		
		|| ss = (fn)(self, exp, dest)

		target debug
			.StackSize--
			if (ss is Const) and (ss.reg and !ss.fatindex) // huh?
				"!Const has no fat!"
				.µdebug(exp, dest)
			if !ss.tmpcheck
				.µdebug(exp, dest)
			// dest discard means "we are telling you that we don't need the result"
			// return discard means "the result is unused, so reg0 isn't actually being set to"
			if !ss  or  (dest is set)  or  (ss is set or discard)
				return ss // no need test.
			if !ss.reg and (ss isnt condanswer)
				if !(ss & asmreg.exit) and (ss isnt Const)
					"!Zero Reg!"
					.µdebug(exp, dest)
		return ss
	
	
	function PackMakerInit
		opt norefcounts
		require !.Inited
		.inited = true
		VM_Builder.JustDefineInstructions
		instruction.InstructionInit
		ASMType.InitAccess
		Instruction[asm.KNSR].Const
		Instruction[asm.KNST].Const
		asm.encoders[asm.KNST] = fatasm.KNST_Encoder
		asm.encoders[asm.noop] = fatasm.NOOP_Encoder
		return 
		TextAssembler.Requests		?= dictionary()
		TextAssembler.RequestTable	?= array()
	
	
	function InitAndStartFunc (|scfunction| fn) // init 
		// can't we just zero the entire thing?
		opt norefcounts
		
		target debug
			asm.noisyasm = 3

		|| j = jsm
		.end = j.NeedSpare(256K, j.Size)
		.start = j.ptr
		.curr_ = .start + j.Length
		
		// after zeroing, we could just set everything normally? It seems ._curr is set from jsm.
		HoistSpace.Length = 0
		
		.out = fn
		.state.fn = fn
		SCFunction.CurrFunc = fn
		.state.Return = nil
		.state.inlinedepth = 0
		.state.BranchDepth = 0
		.state.TailInlineable = true
		.InlineDepthLimit = 3
		.BasicBlock = 1 // good to start these at 1.
		.BranchID = 1
		.NextBranchID = 1
		.VDecls = 1
		.VTemps = 0
		.NeedsRework = false
		.zero = nil
		.zero.info = AsmReg()
		.KnownValuesMap = nil
		for i in 32
			.registers_[i] = nil

		.Guard
		fn.StartASM
		.InlineEnd = nil
		.FuncStart = .curr
		.AddFuncParams(fn)


	function CapASM
		.out.µlength = .length
		jsm!.length = .curr - .start 

		
	function FinishASM 
		opt norefcounts
		if .zero.Const // what?
		|| l = .last
		if !l.IsFinisher
			debugger !.fn.ASMReturn
			|| dl = .fn.Source!.DeepLast
			.closevars(1, dl)
			|asmreg| dest = nil
			if !ASMType.ReturnOpt(self, dest)
				dl.RET()
		.Optimise


	function Guard
		opt norefcounts
		|| arg = .fn.SourceArg!
		target debug
			if arg.position < 0
				arg.position = 0 // skip error detection
		Arg.EROR.BasicBlock = -1

/* The .asint/.asfloat functions should be recognised as working on constants? Or is that just a general case of inline functions? Technically, its an inline func that does nothing, just returns the original... with a different type. */


	iterator
		|| h = .KnownValuesMap
		while h
			|| h2 = h.LowestBit
			yield .Register(h2.log2)!
			h &= ~h2


target debug
	|| ASMTrapper = 0
// Speedie's function histogram:  0:410, 1:1656, 2:1464, 3:713, 4:167, 5:61, 6:10, 7:4, 8:0
// There are only 4 above 6!, only 14 above 5, 75 above 4
// almost all lib functions have 4 or less. 5 is for proj funcs.
	


function Assembler.Rework (|SCFunction| fn,  |bool|)
	HoistSpace.NeedSpare(.Length)
	HoistSpace.CopyFrom(.FuncStart, .Length)
	.Orig = .FuncStart
	.InitAndStartFunc(fn)
	asmtype.ArgumentSub(self, fn.SourceArg!)
	.FinishASM
	.Orig = nil


function Assembler.GenerateASM (|scfunction| fn,  |bool|) // AsmGenerate
	opt norefcounts
	
	.InitAndStartFunc(fn)
	asmtype.ArgumentSub(self, fn.SourceArg!)
	.FinishASM
	if .NeedsRework
		.Rework(fn)
	.CapASM
	compiler.stASMTotalOps += fn.GuessLength

	|| err = stderr // for debug via xcode, which won't give me stderr unless its in a local
	if err.ok
		|| max = fn.maxasm
			check (fn.µlength <= max) (fn.sourcearg, "ASM too large")
		target debug
			fn.µprint(++CountASMFuncPrint)
		return true


target debug
	|| CountASMFuncPrint = 0

