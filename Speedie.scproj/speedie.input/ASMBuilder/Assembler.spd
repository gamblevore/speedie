

struct ASMState
	|scfunction!--|	Fn    
	|asmreg|		Return
	|uint64|		ParentVars
	|byte|			BranchDepth
	|byte|			InlineDepth
	|bool|			TailInlineable


struct RegFile
	|uint16[32]|				Setters
	|int|						KnownMap


struct Assembler
	linkage: cpp_part Pac
	|uint16| 					BasicBlock

	|ASMState|					State
	|byte|						DeepestInline
	|byte|						InlineDepthLimit
	target debug
		|byte|					StackSize
	|uint|						VDecls_
	|uint|						VTemps
	|int|						CurrFuncGrab
    |uint16|                    BranchID
    |uint16|                    NextBranchID
	|bool|						Inited
	|bool|						NeedsRework

	|scfunction--|				Out

	|?&FatASM|					InlineEnd
	|?&FatASM|					Orig
	|&FatASM|					FuncStart_
	|&FatASM|					Start
	|&FatASM|					Curr_
	|&FatASM|					End    

	|RegFile|					Regs
	|FatASM| 					Zero

	constants
		kContinue		= 254
		kExit			= 255
	

	module
		|Assembler|					Sh
		|memory of fatasm|			JSM = FatASM[0]!
		|memory of fatasm|			HoistSpace = FatASM[0]!


	function fn (|scfunction!--|)
		return .state.fn
	

    function Curr (|&fatasm|)
        return .curr_

	function FuncStart (|&fatasm|)
		return .FuncStart_ + 1
		
	function FnLength (|int|)
		return .curr_ - .funcstart
	
	function AddFuncParams (|SCFunction| fn)
		opt NoRefCounts
//		.References = 0
		for a in fn.Args
			.DeclReset(a)
			.DeclareVar(a.source, a)
//			.references |= (a is Reference) << (i+1)

	
	function Index (|int|)
		return .curr_ - .start
	
	
	function Last (|&FatASM|)
		return .curr_ - 1


	function Last (|asm| type, |&FatASM|)
		|| L = .curr_ - 1
		if (l isa type) and .IsCurr(L)
			return L

	function Last (|asm| type, |asm| type2, |&FatASM|)
		|| L = .curr_ - 1
		if (l isa type or type2) and .IsCurr(L)
			return L
	
	
	function IsCurr (|&fatasm| f, |bool|)
		// needs to take loops into account
		// also, perhaps BlockIDs instead.
		// Assembler.RefCountSub doesn't seem to need that complexity and literally just wants the basicblock?
		// this could be nicer. Assuming its not altered in a branch... the blockID could work.
			
		return .basicblock == f.basicblock

	
	function IntPowerOfTwo (|asmreg| r, |int| Sub=0, |FailableInt|)
		// -1 --> -1,  0 --> 0,  1 --> 1,  2 --> 2,  4 --> 3,  8 --> 4
		// this is used for multiplication mostly. like x*-1, or x*0, or x*1
		|| v = r.const
		if v == -1
			if sub
			.NopConst(r)
			return v
		v -= Sub
		if v.IsPow2
			.NopConst(r)
			if !v
				return 0
			return v.Log2+1


	function IncrPost (|message| exp,  |AsmReg| Dest,  |AsmReg| ToGrow,  |int64| Value,  |asmreg|)
		if togrow.isint and value.CanStoreAsAddK and !dest.IsVec
			return exp.ADAK(dest, ToGrow, Value) * Dest
		.Assign(exp, dest, ToGrow)
		rz = .IncrPre(exp, togrow, ToGrow, value)


	function AddToReg (|message| exp, |asmreg| Dest, |asmreg| Orig, |int64| Amount, |asmreg|) // addnum
		if !dest or dest == asmreg()
			dest.µtype = orig.µtype
		dest = .TempOnly(dest)
		|| Where = orig • dest
		(where is Const)
		|| K = .NumToReg(exp, where, amount, orig.µtype)
		return .Plus(exp, dest, Orig, K)
	
	
	function IncrPre (|message| exp,  |AsmReg| Dest,  |AsmReg| Src,  |int64| Value,  |asmreg|)
		if !dest.reg
			dest = src
		return .AddToReg(exp, src, src, value) 


	function IsOnlyVarThatWeReturn (|scdecl| D, |asmreg|)
		// A param/body var, that we return.
		// .DeclareMe is also called from inlines. What does it do there, then?
		// does it still make sense?
		
		|| ret = .state.return
		if  ret.reg  and  (D is VarThatGotReturned)  and  (.state.fn.ReturnedVars == 1)
/			ret.µtype = rz|DataTypeCode|
			D.wholetype = ret
			return ret

	
	function DeclareBody (|Message| where,  |scdecl| Type,  |asmreg|)
		return .DeclareVar(where, type) // as asmreg.Declaration	// this makes AddAK_K and others bigger?
		// Generally this uses less registers tho! Needs marked as temp+decl sometimes!

							
	function DeclareMe (|Message| where, |asmreg| V=nil, |asmreg|)
		|| d = .VDecls
		|| FreeBit = (~d).LowestBit		// Find lowest free bit.
		d |= FreeBit
		v.reg = freeBit.log2

		.Vdecls = d
		check (freebit and !(d & .VTemps)) (where, "No free local variables.")	// entirely full
		return v
	

	function DeclareVar (|Message| where,  |scdecl| Type,  |asmreg|)
		rz = Type.CalculateASMType
		|| ret = .IsOnlyVarThatWeReturn(type)
			return ret
		
		rz = .DeclareMe(where, rz)
		Type.WholeType = rz
		target debug: Type.ASMSanity


	function vdecls (|uint|)
		return .vdecls_


	setter vdecls (|uint|)
//		if "whatever".trap	
		.vdecls_ = value

	
	function TempTyped (|scdecl| Type, |asmreg| T,  |asmreg|)
		if type
			t.µtype = type.mu.DataType
		return .TempOnly(t)
	
	
	function TempTyped (|Message| where, |asmreg| T=asmreg.Temp, |asmreg|)				// .needreg
		opt norefcounts
		if t isnt textual
			// what if there is a type and its different?
			// and if its NEVER different... why add it?
			t.µtype = where.asmdecl.mu.DataType
		return .TempOnly(t)


	function TempOnly (|asmreg| T=asmreg.Temp, |asmreg|)				// .needreg
		opt norefcounts
		if t.reg
			return t

		|| r = .VTemps
		target debug: if r&1: r&=~1 // how?
		
		|| Free = (~r).Log2		// Find lowest free bit.
		r |= 1<<Free
		t.reg = Free
		.VTemps = r
		(t isnt Const) // why would it be?
		(t is temp)
		t.fatindex = 0
		check (!(.vdecls & .VTemps)) (.fn.sourcearg, "No free local variables.")	// entirely full
		return t
	
	
	function AskNopTemp (|asmreg| R)
		if R is temp
			|| f = r.fat
				return .AskNop(f)
	

	function NopReg (|asmreg| R)
		|| f = r.fat
			return .Nop(f)
		target debug
			if r.reg and r isnt param
				debugat // we don't know what made it, but we should!!
	
	
	function Nop2Consts (|asmreg| A, |asmreg| B)
		|| Further = a.FatIndex > b.FatIndex
			.NopConst(A)
		.NopConst(B)
		if !Further
			.NopConst(A) // in case of swapped order
	
	
	function Const (|asmreg| R, |int| bits, |bool| signed, |ind|)
		if r.reg == 0
			return 0 // sigh. I DIE.
		
		if R is Const
			|| k = R.const
			if k.fits(bits, signed)
				.NopConst(R)
				return k|uint64|.trim(bits)
	
	
	function NopConst (|asmreg| R, |int64| K, |bool|)
		if r.Const == K
			.NopConst(R)
			return true
	
	
	function NopConst (|asmreg| R)
		require r.reg
		target debug: if r isnt Const //hah

		if R is temp				// don't think we can do better.
			.AskNop(r.NeedFAT)		// not easily. for example .iscurr(f) gets params used by future stuff
	
	
	function Nop (|FATASM| ToNop)
		opt inline
		return .NopSub(ToNop, false, 0)
	
	
	function SoftNop (|FATASM| Fat)
		opt inline
		return .NopSub(fat, true, 0)
	
	
	helper NopSub (|FATASM| Fat, |bool| Soft,  |int| Depth)
		|| C = .curr - 1
		if fat == C
			.curr_ = C // do it before both kinds of nop...

		depth++
		if depth > 7
		
		for f.fatinputs in fat
			.Decr(f, Soft, depth)
		
		for v.regoutputs in fat
			v &= 31
			if .Register(v) == fat
				.SetRegister(v, nil, fat.FindOlder)
		|| Type = asm.noop * (fat < .curr_)
		fat.setop = Type
			
		
	function Register (|int| i, |?&FATASM|)
// If a var is altered in a loop, and we're in a loop, its not a known value.
		|| r = .Regs.Setters[i]
			return .funcstart_ + r


	function ASMRegister (|int| i, |asmreg|)
		|| f = .Register(i)
			if .IsCurr(f)
				return f.info
		return i.asm

	
	function KnownValues (|int| changed, assigns:|bool|)
		|| M = .regs.KnownMap
		changed = 1 << changed
		if Value
			m |=  changed
		  else
			m &=~ changed
		.regs.KnownMap = M
			

	function SetRegister (|int| changed, |asmreg| info, |?&FATASM| Value, |asmreg|)
		|| n = 0
		|| start = .FuncStart_
		if value
			n = value - start
		
		.KnownValues(changed) = value is Const
		|| where = &sh.regs.Setters[changed]
		|| oldi = where[]
		where[] = n // set value
		
		if oldi and (info is AllowNopDest)
			|| old = start + oldi
			if (old.µRefCount <= 0) and (old.BasicBlock == .BasicBlock)
				sh.nop(old)
		(info isnt AllowNopDest)
		return info


	function FatASM.Dest (|uint| a, |asmreg| info, |&assembler| sh, |asmreg|)
		|| changed = info.prm
		.prms[a] = changed
		._Outputs |= 1 << a
		changed &= 31
		info.FatIndex = self - sh.funcstart_
		if info
			.info = info
		if !changed
			return info
		if info
			(info is AllowNopDest)
		return sh.SetRegister(changed, info, self)
	
	
	function RegIsConst (|asmreg| R, |int64| k, |bool|)
		|| f = .register(r.reg)
		if f is Const
			return f.const == k
	
	
	function Decr (|?&fatasm| f, |bool| Soft, |int| Depth=0)
		if f
			|| C = f.µrefcount
			C -= (C > 0)
			f.µrefcount = C
			if !soft and C <= 0
				.NopSub(f, soft, depth)
	
	
	function AskNop (|fatasm| ToNop)
		if ToNop.µRefCount <= 0
			.nop(ToNop)
	
	
	function SoftNopRange (|fatasm| Start, |fatasm| After)
		while start < After
			.SoftNop(--after)
	
	
///////////////////////////////////////////////////////////////////////////////////////////////////
	
	function µBoolInto (|message| exp, |AsmReg| Dest, |asmreg|)
		dest.µType = DataTypeCode.bool
		(dest as= asmreg.PreferEqul)						// easier to optimise.
		|| x = .µ(exp, dest)
		if x.IsBool
			return x
		return .Exists(dest, X, exp)
	
	
	function message.FoundFunc (|bool|)
		opt norefcounts
		
		while self
			if (.func == @prm)
				target debug: ifn .obj isa scfunction		// it must be, right?
				return true
			|| c = .first
				|| r = c.FoundFunc
					return r
			self++
	
	
	function message.AllowsTemp (|asmreg|)
		return ASMReg.temp * (!.FoundFunc)
	
	
	function message.ContainsFunc (|bool|)
		opt norefcounts
		if .func == @prm // what the?
		|| f = .first
			return f.FoundFunc
			

	function µInlineParam (|message| exp,  |scdecl| A,  |asmreg| Dest,  |asmreg|)
	/*
		possible inline param cases. int A is a normal reg. int B is altered
		theres also references...
		
		A+B: nil
		A:   reg1
		B:	 asmreg.into // can't pass B, so pass a copy?
		0:   asmreg.into // if altered or ref
		0:   nil         // otherwise
	*/

		|| OV = .OpenVars
		Dest = .DeclareBody(exp, a) as dest
		|| r = .µGetASM(Exp, dest)
		if r iz dest
			return r
		if (dest isnt ForceInto) and !(a is alteredorref and r.reg == 0)
			return .CloseVars(ov, nil, r)
		return .Assign(exp, dest, r)


	function µGetRealOffer (|message| exp, |asmreg| Dest,  |asmreg|)
		|| c = .curr
		if dest isnt UnusedSoFar
			dest = nil // clear for .GetReal
		return .µGetReal(exp, dest)
		// asmtodo: check if we can re-write the output to dest
		// however its more tricky than I thought. Do later. 


	function µGetReal (|message| exp,  |asmreg| ModeOnly,  |asmreg|)
		// the result should be considered "temp-like"?
		// that means... it can be optimised away. maybe just allow temps on normal vars?
		// like have another bit that says "its allowed"... but everything just checks
		// "is temp" like normal.
		
		|| OV = .OpenVars
		if ModeOnly is UnusedSoFar									// || x = (y + 1) + (z + 1)
			ModeOnly = ModeOnly asnt asmreg.UnusedSoFar
		  elseif ModeOnly is temp									//    x = (y + 1) + (z + 1)
			ModeOnly = .TempOnly(ModeOnly)
			// asmtodo: what about doing all .declareme? simpler?
		  else
			ModeOnly = .DeclareMe(exp, ModeOnly) as ModeOnly
		
		|| r = .µGetASM(Exp, ModeOnly)
		if r iz ModeOnly
			return r
		return .CloseVars(ov, nil, r)
		
		
	function µ (|message| exp, |AsmReg| Dest = asmreg(), |asmreg|)
		description "Same as µGetASM, except this closes temp vars for reuse." 
		|| Closer = .OpenVars
		|| v = .µGetASM(exp, dest)
		return .CloseVars(Closer, nil, v)


	function µReffed (|message| exp, |scdecl!| A, |asmreg|)
		// asmtodo: if this gets nopped... we need to decr all the params!
		// but we don't have the fats. Could we make an extended fat?
		// like a fat that... holds params just for storing? and then
		// we refer to that fatter fat?
		
		|| Mode = exp.AllowsTemp
		(Mode is AddrNeed) = (a is Reference)
		|| r = .µGetReal(exp, Mode) // why not passing A here?
		if (a is reference  and  r isnt containsaddr)
			error (exp|object|)
		return r.incr


	function µInto (|message| exp, |AsmReg| Dest, |asmreg|)
		|| Closer = .OpenVars
		|| v = .µGetASM(Exp, dest)
		ifn v iz dest
			v = .Assign(exp, dest, v)
		return .CloseVars(Closer, nil, v)
		
	
	function µDebug (|message| exp, |asmreg| dest)
		target debug
			|| fn = fn_asm_table[exp.ASMType]!
			dest.debugprint
			PrintProgress()
			debugger
			|| m = (fn)(self, exp, dest)
			m.debugprint
			debugger

		
	function µGetASM (|message| exp, |AsmReg| Dest = asmreg(), |asmreg|)
		opt norefcounts
		cpp_part GetASM 
		
		|| fn = fn_asm_table[exp.ASMType]!
		target debug
			dest.TmpCheck
			if ++.stacksize > 20 // ugh
			|| trap = ++ASMTrapper//, if trap == 177072
		  else
			opt inline
		
		|| ss = (fn)(self, exp, dest)

		target debug
			.StackSize--
			if (ss is Const) and (ss.reg and !ss.fatindex) // huh?
				"!Const has no fat!"
				.µdebug(exp, dest)
			if !ss.tmpcheck
				.µdebug(exp, dest)
			// dest discard means "we are telling you that we don't need the result"
			// return discard means "the result is unused, so reg0 isn't actually being set to"
			if !ss  or  (dest is set)  or  (ss is set or discard)
				return ss // no need test.
			if !ss.reg and (ss isnt condanswer)
				if !(ss & asmreg.exit) and (ss isnt Const)
					"!Zero Reg!"
					.µdebug(exp, dest)
		return ss
	
	
	function PackMakerInit
		opt norefcounts
		require !.Inited
		.inited = true
		VM_Builder.JustDefineInstructions
		instruction.InstructionInit
		ASMType.InitAccess
		Instruction[asm.KNSR].Const
		Instruction[asm.KNST].Const
		asm.encoders[asm.KNST] = fatasm.KNST_Encoder
		asm.encoders[asm.noop] = fatasm.NOOP_Encoder
		return 
		TextAssembler.Requests		?= dictionary()
		TextAssembler.RequestTable	?= array()
	
	
	function InitAndStartFunc (|scfunction| fn) // init 
		// can't we just zero the entire thing?
		opt norefcounts
		
		target debug
			asm.noisyasm = 3

		|| j = jsm
		.end = j.NeedSpare(256K, j.Size)
		.start = j.ptr
		.curr_ = .start + j.Length
		
		// after zeroing, we could just set everything normally? It seems ._curr is set from jsm.
		HoistSpace.Length = 0
		
		.out = fn
		.state.fn = fn
		SCFunction.CurrFunc = fn
		.state.Return = nil
		.state.inlinedepth = 0
		.state.BranchDepth = 0
		.state.TailInlineable = true
		.InlineDepthLimit = 3
		.BasicBlock = 1						// good to start these at 1.
		.BranchID = 1
		.NextBranchID = 1
		.NeedsRework = false
		.zero = nil
		.zero.info = AsmReg()
		.regs = nil
		.Guard
		fn.StartASM
		.InlineEnd = nil
		.FuncStart_ = .curr - 1
		.VTemps = 0
		.VDecls = 1							// set after .FuncStart
		.AddFuncParams(fn)


	function CapASM
		opt norefcounts
		|| fn = .out
		fn.µlength = .fnlength
		|| L = fn.GuessLength
		fn.µLengthGuess = L
		compiler.stASMTotalOps += L
		jsm!.length = .curr - .start 

		
	function FinishASM 
		opt norefcounts
		if .zero.Const // what?
		|| l = .last
		if !l.IsFinisher
			debugger !.fn.ASMReturn
			|| dl = .fn.Source!.DeepLast
			.closevars(1, dl)
			|asmreg| dest = nil
			if !ASMType.ReturnOpt(self, dest)
				dl.RET()
		.Optimise


	function Guard
		opt norefcounts
		|| arg = .fn.SourceArg!
		target debug
			if arg.position < 0
				arg.position = 0 // skip error detection
		Arg.EROR.BasicBlock = -1

/* The .asint/.asfloat functions should be recognised as working on constants? Or is that just a general case of inline functions? Technically, its an inline func that does nothing, just returns the original... with a different type. */


	iterator Known
		|| h = .regs.KnownMap
		while h
			|| h2 = h.LowestBit
			yield .Register(h2.log2)!
			h &= ~h2


target debug
	|| ASMTrapper = 0
// Speedie's function histogram:  0:410, 1:1656, 2:1464, 3:713, 4:167, 5:61, 6:10, 7:4, 8:0
// There are only 4 above 6!, only 14 above 5, 75 above 4
// almost all lib functions have 4 or less. 5 is for proj funcs.
	


function assembler.RootGen (|scfunction| fn)
	opt norefcounts
	asmtype.ArgumentSub(self, fn.SourceArg!, nil)


function Assembler.Rework (|SCFunction| fn,  |bool|)
	HoistSpace.NeedSpare(.FnLength)
	HoistSpace.CopyFrom(.FuncStart, .FnLength)
	.Orig = .FuncStart
	.InitAndStartFunc(fn)
	.RootGen(fn)
	.FinishASM
	.Orig = nil


function Assembler.GenerateASM (|scfunction| fn,  |bool|) // AsmGenerate
	opt norefcounts
	
	.InitAndStartFunc(fn)
	.RootGen(fn)
	.FinishASM
	if .NeedsRework
		.Rework(fn)
	.CapASM

	|| err = stderr // debug in perry via xcode, which won't give me stderr unless in local
	if err.ok
		|| max = fn.MaxASM
			check (fn.µlengthguess <= max) (fn.sourcearg, "ASM too large")
		target debug
			fn.µprint(++CountASMFuncPrint)
		return true


target debug
	|| CountASMFuncPrint = 0

