

struct ASMState
	|scfunction!--|	Fn    
	|asmreg|		Return
	|uint64|		ParentVars
	|byte|			BranchDepth
	|bool|			TailInlineable


struct RegFile
	|uint16[32]|				Setters
	|int|						KnownMap



struct Assembler
	contains asmreg
	linkage: cpp_part Pac
	|uint16| 					BasicBlock

	|ASMState[8]|				InlineState
	|byte|						InlineDepth
	|byte|						DeepestInline
	|byte|						InlineDepthLimit
	target debug
		|byte|					StackSize
	|uint|						RegDebugInfo
	|uint|						VDecls_
	|uint|						VTemps_
	|int|						CurrFuncGrab
    |uint16|                    BranchID
    |uint16|                    NextBranchID
	|bool|						NeedsRework
	|bool|						Inited
	|scfunction--|				Out

	|?&FatASM|					InlineEnd
//	|?&FatASM|					Orig
	|&FatASM|					FuncStart_
	|&FatASM|					Start
	|&FatASM|					Curr_
	|&FatASM|					End    

	|RegFile|					Regs
	|FatASM| 					Zero

	constants
		kContinue		= 254
		kExit			= 255

	module
		|Assembler|					Sh
		|memory of fatasm|			JSM = FatASM[0]!
		|memory of fatasm|			HoistSpace = FatASM[0]!
		|int|						StringsOutOfRange
		|jbin?|						DebugDecls

		
		function ClassLayout (|jbin| j)
			opt norefcounts
			for c in Compiler.ReachedClassTable
				if !c.isbehaviourtable and (c.IsLibrary == options.MakeExec)
					j.Enter(@msg, c.ExportName)
					c.ListLayout(j)
					j.exit

		function DebugClassesAndGlobals (|string|) 
			opt norefcounts
			if !options.MakeExec
				require options.TargetDebug
			
/			|| j = jbin()
			
			j.Enter(@msg, "class")
			.ClassLayout(j)
			j.exit
			
			j.Enter(@msg, "glob")
			if Options.MakeExec
				j.PropertyLayout(packmaker.libglobs)
			  else
				j.PropertyLayout(packmaker.PackGlobs)
			j.exit
			
			|| info = j.GetResult
			if !info.ParseJbin 
				error "Generated invalid debug info (jbin)"
				info = ""
			return info

	
	function State (|&ASMState|)
		return .inlinestate[.inlinedepth]
	
	function fn (|scfunction!--|)
		return .state.fn
	
    function Curr (|&fatasm|)
        return .curr_

	function FuncStart (|&fatasm|)
		return .FuncStart_ + 1
		
	function FnLength (|int|)
		return .curr_ - .funcstart
	
//	function ActualLength (|int|)
//		return .curr_ - .Start

	function Index (|int|)
		return .curr_ - .start
	
	function Last (|&FatASM|)
		return .curr_ - 1

	function AddFuncParams (|SCFunction| fn)
		opt NoRefCounts
		for a in fn.Args
			.DeclReset(a)
			.DeclareVar(a.source, a)

	function Last (|asm| type, |&FatASM|)
		|| L = .curr_ - 1
		if (l isa type) and .IsCurr(L)
			return L

	function Last (|asm| type, |asm| type2, |&FatASM|)
		|| L = .curr_ - 1
		if (l isa type or type2) and .IsCurr(L)
			return L
	
	
	function IsCurr (|&fatasm| f, |bool|)
		// needs to take loops into account
		// also, perhaps BlockIDs instead.
		// Assembler.RefCountSub doesn't seem to need that complexity and literally just wants the basicblock?
		// this could be nicer. Assuming its not altered in a branch... the blockID could work.
			
		return .basicblock == f.basicblock

	
	function IntPowerOfTwo (|asmreg| r, |int| Sub=0, |FailableInt|)
		// -1 --> -1,  0 --> 0,  1 --> 1,  2 --> 2,  4 --> 3,  8 --> 4
		// this is used for multiplication mostly. like x*-1, or x*0, or x*1
		|| v = r.const
		if v == -1
			if sub
			.NopConst(r)
			return v
		v -= Sub
		if !v or v.IsPow2
			.NopConst(r)
			if !v
				return 0
			return v.Log2+1


	function AddToReg (|message| exp, |asmreg| Dest, |asmreg| Orig, |int64| Amount, |asmreg|) // addnum
		if !dest or dest == asmreg()
			dest.µtype = orig.µtype
		dest = .TempOnly(dest)
		|| Where = orig • dest
		(where is Const)
		(where isnt containsaddr)
		|| K = .NumToReg(exp, where, amount, orig.µtype)
		return .Plus(exp, dest, Orig, K)
	
	
	function IncrPre (|message| exp,  |AsmReg| Dest,  |AsmReg| Src,  |int64| Value,  |asmreg|)
		if !dest.reg // more about keeping the type, I guess.
			dest = src
		return .AddToReg(exp, dest, src, value) 


	function IncrPost (|message| exp,  |AsmReg| Dest,  |AsmReg| Src,  |int64| Value,  |asmreg|)
		if  Src.isint  and  value.CanStoreAsAddK  and  !dest.IsVec
			return exp.ADAK(dest, Src, Value) * Dest
		rz = .Assign(exp,  .temponly(dest),  Src)
		.IncrPre(exp, Src, Src, value)


	function IsOnlyVarThatWeReturn (|scdecl| D, |asmreg|)
		// A param/body var, that we return.
		// .DeclareMe is also called from inlines. What does it do there, then?
		// does it still make sense?
		
		// VarThatGotReturned isnt set anywhere?
		// remove this?
		|| st = .state
		|| ret = st.return
		if  ret.reg  and  (D is VarThatGotReturned)  and  (st.fn.ReturnedVars == 1)
/			ret.µtype = rz|DataTypeCode|
			D.wholetype = ret
			return ret

	
	function DeclareBody (|Message| where,  |scdecl| Type,  |asmreg|)
		return .DeclareVar(where, type) // as asmreg.Declaration	// this makes AddAK_K and others bigger?
		// Generally this uses less registers tho! Needs marked as temp+decl sometimes!

							
	function DeclareMe (|Message| where, |asmreg| V=nil, |asmreg|)
		|| d = .VDecls
		|| FreeBit = (~d).LowestBit		// Find lowest free bit.
		d |= FreeBit
		v.reg = freeBit.log2

		.Vdecls = d
		check (freebit and !(d & .VTemps)) (where, "No free local variables.")	// entirely full
		return v
	

	function DeclareVar (|Message| where,  |scdecl| Type,  |asmreg|)
		rz = Type.CalculateASMType
		|| ret = .IsOnlyVarThatWeReturn(type)
			return ret
		
		rz = .DeclareMe(where, rz)
		Type.WholeType = rz
		target debug: Type.ASMSanity

	function vdecls (|uint|)
		return .vdecls_

	function vtemps (|uint|)
		return .vtemps_

	setter vdecls (|uint|)
		if value & .vtemps_ // huh?
		.vdecls_ = value

	setter vtemps (|uint|)
		if value & .vdecls_ // huh?
		.vtemps_ = value

	function TempTyped (|scdecl| Type, |asmreg| T,  |asmreg|)
		if type
			t.µtype = type.mu.DataType
		return .TempOnly(t)
	
	function TempTyped (|Message| where, |asmreg| T=asmreg.Temp, |asmreg|)				// .needreg
		opt norefcounts
		if t isnt textual
			// what if there is a type and its different?
			// and if its NEVER different... why add it?
			t.µtype = where.asmdecl.mu.DataType
		return .TempOnly(t)

	function TempOnly (|asmreg| T=asmreg.Temp, |asmreg|)				// .needreg
		opt norefcounts
		if t.reg
			return t

		|| r = .VTemps
		target debug: if r&1: r&=~1 // how?
		
		|| Free = (~r).Log2		// Find lowest free bit.
		r |= 1<<Free
		t.reg = Free
		.VTemps = r
		(t isnt Const) // why would it be?
		(t is temp)
		t.fatindex = 0
		check (!(.vdecls & .VTemps)) (.fn.sourcearg, "No free local variables.")	// entirely full
		return t
	
	
	function AskNopTemp (|asmreg| R)
		if R is temp
			|| f = r.fat
				return .AskNop(f)
	

	function NopReg (|asmreg| R)
		|| f = r.fat
			return .Nop(f)
		target debug
			if r.reg and r isnt param
				debugat // we don't know what made it, but we should!!
	
	
	function Nop2Consts (|asmreg| A, |asmreg| B)
		|| Further = a.FatIndex > b.FatIndex
			.NopConst(A)
		.NopConst(B)
		if !Further
			.NopConst(A) // in case of swapped order
	
	
	function Const (|asmreg| R, |int| bits, |bool| signed, |ind|)
		if r.reg == 0
			return 0 // sigh. I DIE.
		
		if R is Const
			|| k = R.const
			if k.fits(bits, signed)
				.NopConst(R)
				return k|uint64|.trim(bits)
	
	
	function NopConst (|asmreg| R, |int64| K, |bool|)
		if r.Const == K
			.NopConst(R)
			return true
	
	
	function NopConst (|asmreg| R)
		require r.reg
		target debug: if r isnt Const 		// hah

		if R is temp and r isnt blocknop	// don't think we can do better. not easily. 
			.AskNop(r.NeedFAT)				// for example .iscurr(f) gets params used by future stuff
	
	
	function Nop (|FATASM| ToNop)
		return .nop_sub(ToNop, false, 0)
	
	
	function SoftNop (|FATASM| Fat)
		return .nop_sub(fat, true, 0)
	
	
	function nop_sub (|FATASM| Fat, |bool| Soft,  |int| Depth)
		if fat is temp
			.CloseOneVar(nil, 1<<fat.info.reg) // why did I comment this out? // testin speedie first?
		|| C = .curr - 1
		if fat == C
			.curr_ = C // do it before both kinds of nop...

		depth++
		if depth > 7
		
		for f.fatinputs in fat
			.Decr(f, Soft, depth)
		
		for v.regoutputs in fat
			v &= 31
			if .Register(v) == fat
				.SetRegister(v, nil, fat.FindOlder)
			
		|| Type = asm.noop * (fat < .curr_)
		fat.setop = Type
			
		
	function Register (|int| i, |?&FATASM|)
// If a var is altered in a loop, and we're in a loop, its not a known value.
		|| r = .Regs.Setters[i]
			return .funcstart_ + r

	
	function KnownValues (|int| changed, assigns:|bool|)
		|| M = .regs.KnownMap
		changed = 1 << changed
		if Value
			m |=  changed
		  else
			m &=~ changed
		.regs.KnownMap = M
			

	function SetRegister (|int| changed, |asmreg| info, |?&FATASM| Value, |asmreg|)
		|| n = 0
		|| start = .FuncStart_
		if value
			n = value - start
			
		.KnownValues(changed) = value is Const
		|| where = &sh.regs.Setters[changed]
		|| oldi = where[]
		where[] = n // set value
		target debug
			if .Register(changed) != value // huh?
		
		if oldi and (info is AllowNopDest)
			|| old = start + oldi
			if (old.µRefCount <= 0) and (old.BasicBlock == .BasicBlock)
				sh.nop(old)
		(info isnt AllowNopDest)
		return info


	function FatASM.Dest (|uint| a, |asmreg| info, |&assembler| sh, |asmreg|)
		|| changed = info.prm
		.prms[a] = changed
		changed &= 31
		info.FatIndex = self - sh.funcstart_
		if info
			.info = info
		if !changed
			return info
		._Outputs |= 1 << a
		if info
			(info is AllowNopDest)
		return sh.SetRegister(changed, info, self)
	
	
	function RegIsConst (|asmreg| R, |int64| k, |bool|)
		|| f = .register(r.reg)
		if f is Const
			return f.const == k
	
	
	function Decr (|?&fatasm| f, |bool| Soft, |int| Depth=0)
		if f
			|| C = f.µrefcount
			C -= (C > 0)
			f.µrefcount = C
			if !soft and C <= 0
				.nop_sub(f, soft, depth)
	
	
	function AskNop (|fatasm| ToNop)
		if ToNop.µRefCount <= 0
			.nop(ToNop)
	
	
	function SoftNopRange (|fatasm| Start, |fatasm| After)
		while start < After
			.SoftNop(--after)
	
	
///////////////////////////////////////////////////////////////////////////////////////////////////
	
	function µBoolInto (|message| exp, |AsmReg| Dest, |asmreg|)
		dest.µType = DataTypeCode.bool
		(dest as= asmreg.PreferEqul)						// easier to optimise.
		|| x = .µ(exp, dest)
		if x.IsBool
			return x
		return .Exists(dest, X, exp)
	
	
	function message.FoundFunc (|bool|)
		opt norefcounts
		
		while self
			if (.func == @prm)
				target debug: ifn .obj isa scfunction		// it must be, right?
				return true
			|| c = .first
				|| r = c.FoundFunc
					return r
			self++
	
	
	function message.AllowsTemp (|asmreg|)
		return ASMReg.temp * (!.FoundFunc)
	
	
	function message.ContainsFunc (|bool|)
		opt norefcounts
		if .func == @prm // what the?
		|| f = .first
			return f.FoundFunc
			

	function µInlineParam (|message| exp,  |scdecl| A,  |asmreg| Dest,  |asmreg|)
	/*
		possible inline param cases. int A is a normal reg. int B is altered
		theres also references...
		
		A+B: nil
		A:   reg1
		B:	 asmreg.into // can't pass B, so pass a copy?
		0:   asmreg.into // if altered or ref
		0:   nil         // otherwise
	*/

		|| OV = .OpenVars
		Dest = .DeclareBody(exp, a) as dest
		|| r = .µGetASM(Exp, dest)
		if r iz dest
			return r
		if (dest isnt ForceInto) and !(a is alteredorref and r.reg == 0)
			return .CloseVars(ov, nil, r)
		(dest isnt forceinto)
		return .Assign(exp, dest, r)


	function µGetRealOffer (|message| exp, |asmreg| Dest,  |asmreg|)
		#!"There could be a function call that smashes the first temp"
		#!"for example:  y = (x+1) - .func()"
		// (but what if there is not? Can we tell ahead of time?)

		|| R = .ExistingVar(exp)
		if r and (r isnt temp or r is okastemp)
			return r
		
		if dest isnt NewlyDeclared
			dest = nil // clear for .GetReal
		
		return .µGetReal(exp, dest)


	function µGetReal (|message| exp,  |asmreg| ModeOnly,  |asmreg|)
		target debug
			|| trap = ++ASMTrapper
		|| OV = .OpenVars
		if ModeOnly is NewlyDeclared									// || x = (y + 1) + (z + 1)
			ModeOnly = ModeOnly asnt asmreg.NewlyDeclared
		  elseif ModeOnly is temp										//    x = (y + 1) + (z + 1)
			ModeOnly = .TempOnly(ModeOnly)
			// asmtodo: what about doing all .declareme? simpler?
		  else
			ModeOnly = .DeclareMe(exp, ModeOnly) as ModeOnly
			(modeonly is OKAsTemp)
			(modeonly is Temp)
		
		target debug
			ModeOnly.TmpCheck
		|| r = .µGetASM(Exp, ModeOnly)
		if r iz ModeOnly
			return r
		return .CloseVars(ov, nil, r)
		
		
	function µ (|message| exp, |AsmReg| Dest = asmreg(), |asmreg|)
		description "Same as µGetASM, except this closes temp vars for reuse." 
		|| Closer = .OpenVars
		|| v = .µGetASM(exp, dest)
		return .CloseVars(Closer, nil, v)


	function µReffed (|message| exp, |scdecl!| A, |asmreg|)
		// asmtodo: if this gets nopped... we need to decr all the params!
		// but we don't have the fats. Could we make an extended fat?
		// like a fat that... holds params just for storing? and then
		// we refer to that fatter fat?
		
		|| Mode = exp.AllowsTemp
		(Mode is AddrNeed) = (a is Reference)
		|| r = .µGetReal(exp, Mode)
		if (a is reference  and  r isnt containsaddr)
			error (exp|object|)
		return r.incr


	function µTrin (|message| exp, |asmreg|)
		opt norefcounts
		return .µGetReal(exp, exp.AllowsTemp) as asmreg.Textual


	function µInto (|message| exp, |AsmReg| Dest, |asmreg|)
		|| Closer = .OpenVars
		|| v = .µGetASM(Exp, dest)
		ifn v iz dest
			v = .Assign(exp, dest, v)
		return .CloseVars(Closer, nil, v)
		
	
	target debug
		function µDebug (|message| exp, |asmreg| dest)
			|| fn = fn_asm_table[exp.ASMType]!
			dest.DebugPrint
			PrintProgress()
			debugger
			|| m = (fn)(self, exp, dest)
			m.debugprint
			debugger

		
	function µGetASM (|message| exp, |AsmReg| Dest = asmreg(), |asmreg|)
		opt norefcounts
		cpp_part GetASM 
		
		target debug
			dest.TmpCheck
			|| StackSize = ++.stacksize
			|| trap = ++ASMTrapper
			if asmtrapper == -1 or stacksize > 20 // ugh
		  else
			opt inline
		
		|| fn = fn_asm_table[exp.ASMType]!
		|| ss = (fn)(self, exp, dest)

		target debug
			.StackSize--
			if (ss is Const) and (ss.reg and !ss.fatindex) // huh?
				"!Const has no fat!"
				.µdebug(exp, dest)
			if !ss.tmpcheck
				.µdebug(exp, dest)
			// dest discard means "we are telling you that we don't need the result"
			// return discard means "the result is unused, so reg0 isn't actually being set to"
			if !ss  or  (dest is set)  or  (ss is set or discard)
				return ss // no need test.
			if !ss.reg and (ss isnt condanswer)
				if !(ss & asmreg.exit) and (ss isnt Const)
					"!Zero Reg!"
					.µdebug(exp, dest)
		return ss
	
	
	function scclass.ListLayout (|jbin| j)
		opt norefcounts
		|| s = .super
			s.ListLayout(j)
		j.PropertyLayout(.Properties)
			
			
	function jbin.PropertyLayout (|[scdecl]| List)
		opt norefcounts
		for p in list
			p.DumpDecl(self, p.exportposition)

		
	function FillDebugInfo 
		opt norefcounts
		if Options.TargetDebug
			SourceMap.Positions = FastString()
	
	
	function ASMInit
		opt norefcounts
		require !.Inited
		.Inited = true
		if options.targetdebug
			debugdecls = faststring()
		VM_Builder.JustDefineInstructions
		instruction.InstructionInit
		ASMType.InitAccess

		Instruction[asm.KNSR].Const
		asm.encoders[asm.noop] = fatasm.Nop_Encoder

		.Knst(asm.KNST)
		.Knst(asm.KNST2)
		.Knst(asm.KNST3)

		return 

		TextAssembler.Requests		?= dictionary()
		TextAssembler.RequestTable	?= array()

	
	function Knst (|asm| op)
		Instruction[op].Const
		asm.encoders[op] = fatasm.KNST_Encoder
		
	
	function InitAndStartFunc (|scfunction| fn) // init 
		// can't we just zero the entire thing?
		opt norefcounts
		
		target debug
			asm.noisyasm = 3

		|| j = jsm
		.end = j.NeedSpare(64K, 64K)
		.start = j.ptr
		.curr_ = .start + j.Length
		.FuncStart_ = .curr
		
		// After zeroing, we could just set everything normally? It seems ._curr is set from jsm.
		HoistSpace.Length = 0
		
		.inlinestate[0] = nil // the rest get auto-cleared
		.out = fn
		.state.fn = fn
		SCFunction.CurrFunc = fn
		.InlineDepthLimit = 3
		.inlinedepth = 0
		.BasicBlock = 1						// good to start these at 1.
		.BranchID = 1
		.NextBranchID = 1
		.NeedsRework = false
		.zero = nil
		.zero.info = AsmReg()
		.regs = nil
		.Guard
		.InlineEnd = nil
		fn.µstart = .Index
		.VTemps = 0
		.VDecls = 1							// set after .FuncStart
		.AddFuncParams(fn)
//		.TestAllFats
//	
//	function TestAllFats
//		|| S = .Start
//		|| A = .End
//		While (S < A)
//			S.Info++
//			S.Info--
//			S++


	function CapASM 
		opt norefcounts
		|| fn = .out
		|| n = .fnlength
		fn.µfatlength = n
		jsm!.length = .curr - .start 

	
	function FinishReturn 
		opt norefcounts
		debugger !.fn.ASMReturn
		|| dl = .fn.Source!.FlatLast
		.CloseVars(1, dl)
		|asmreg| dest = nil
		if !ASMType.ReturnOpt(self, dest)
			dl.RET

	
	function FinishASM 
		opt norefcounts
		if !.last.IsFinisher
			.FinishReturn
		.FinishMost


	function Guard
		opt norefcounts
		|| arg = .fn.SourceArg!
		target debug
			if arg.position < 0
				arg.position = 0 // skip error detection
		Arg.EROR.BasicBlock = -1

/* The .asint/.asfloat functions should be recognised as working on constants? Or is that just a general case of inline functions? Technically, its an inline func that does nothing, just returns the original... with a different type. */


	iterator Known
		|| h = .regs.KnownMap
		while h
			|| h2 = h.LowestBit
			yield .Register(h2.log2)!
			h &= ~h2


target debug
	|| ASMTrapper = 0
// Speedie's function histogram:  0:410, 1:1656, 2:1464, 3:713, 4:167, 5:61, 6:10, 7:4, 8:0
// There are only 4 above 6!, only 14 above 5, 75 above 4
// almost all lib functions have 4 or less. 5 is for proj funcs.
	


function assembler.RootGen (|scfunction| fn)
	opt norefcounts
	asmtype.ArgumentSub(self, fn.SourceArg!, nil)


function Assembler.Rework (|SCFunction| fn, |bool|)
	HoistSpace.NeedSpare(.FnLength)
	HoistSpace.CopyFrom(.FuncStart, .FnLength)

	.InitAndStartFunc(fn)
	.RootGen(fn)
	.FinishASM


target debug
	function Assembler.PrintASM (|SCFunction| fn, |int| i, |bool|)
		// printline "µFunc: $i", (fn)
		fn.µprint


function Assembler.FatterCompile (|SCFunction| fn, |bool|) // AsmGenerate, ASMRender, GenerateASM, ASMCompile, RenderASM
// if you are looking for the other render, look for ASMBake
	opt norefcounts
	scfunction.currfunc = fn
	
	.InitAndStartFunc(fn)
	.RootGen(fn)
	.FinishASM
	if .NeedsRework
		.Rework(fn)
	.CapASM
	
	target debug
		ifn options.silent or compiler.InPerry or options.perryoutput
			.PrintASM(fn, packmaker.PackFuncIndex)
	
	|| err = StdErr // debug in perry via xcode, which won't give me stderr unless in local
	require err.ok
	|| max = fn.MaxASM
		check (fn.µasmlength <= max) (fn.SourceArg, "ASM too large")
	return true


