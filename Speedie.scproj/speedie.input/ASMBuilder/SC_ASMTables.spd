

dispatch fn_asm_table (fn_asm)
	@arg:
		opt norefcounts
		|| M = asmreg.discard
		if !mode
			dest = m
		|| OV = .OpenVars
		for ch.fast in exp
			if ch.islast
				m = dest
			dest = .µ(ch, M)
		.CloseVars(OV)
		return dest


	@decl: // yay
		opt norefcounts
		|| rel = exp.last!
		|| ty = rel.first!.fastdecl
		dest = ty.dreg
		(dest is ReallyTemp)
		|| reg = .DeclareMe(Exp, dest)
		return .µ(rel.last!, reg)


	@num:
		opt norefcounts
		|| d = exp.fastdecl
		Dest = .TempMe(exp, dest)
		|| X = d.exportposition
		if d.isfloat
			|| f8 = exp.float
			if d.DeclSize == 4
				|| f4 = f8|float|
				x = f4.asint
			  else
				debugger
				x = f8.asint
		.NumToReg(X, exp, Dest)
		return dest
		// loadconst?


	@rel: asmtmp.DoMath


	@thg: ASMTmp.Thg


	@bra:
		opt norefcounts
		return .µ(exp.first!, dest)

	@sheb: ASMtmp.Ignore
		

	@list: // vectors
		debugger

	@func:
		opt norefcounts
		return .DoFunc(exp.last!, dest)


	@dot:	ASMTmp.Dot
	@acc:	ASMTmp.Access


	@brel: asmtmp.Brel		// ++, --, -, &


	@arel: asmtmp.arel      // ++, --, 


	@type:					asmtmp.TypeCast


	@tmp:					asmtmp.unexpected

	(ASMtmp.kDebugger):		ASMtmp.Debugger
	(ASMtmp.kif):			ASMtmp.If
	(ASMtmp.krejoin):		ASMtmp.Rejoin
	(ASMtmp.kreturn):		ASMtmp.return
	(ASMtmp.kwhile):		ASMtmp.While
	(asmtmp.kTern):			ASMtmp.Tern

	(asmtmp.kContinue):		ASMtmp.Continue
	(asmtmp.kExit):			ASMtmp.Exit

	(asmtmp.ksetvar):		ASMtmp.SetRel
	(asmtmp.kStatExpr): 	ASMtmp.StatExpr
	(asmtmp.kPointer):		asmtmp.Pointer

	(asmtmp.kIgnore):		ASMtmp.Ignore
	(asmtmp.kFail):			ASMtmp.Ignore

	63:
		0



// for some reason, replacing this will cause speedie to generate bad code
// I guess I am setting the Flags somewhere, or testing them? but I can't see where.
function Message.ASMType (|ASMTmp|)
	rz = .FLAGS & 63

function Message.ASMType (assigns:|ASMTmp|)
	target debug: if .objectid == 0
	value = (.FLAGS &~ 63) ||| value
	.FLAGS = value 


datatype ASMtmp (uint16)
	syntax is (|asmtmp| t, |bool|)
		return self == t

	constants
		|asmtmp| 
		kElseIf = 48
		kIf
		kWhile
		kContinue
		kExit
		kReturn
		kRejoin
		kSwap
		kTern
		kStatExpr
		kSetVar
		kPointer
		kIgnore
		kDebugger
		kFail = 63
	

	module {

|asm_mem[10]| ReadASM
|asm_mem[5]| WriteASM

function InitAccess
	|| R = &ASMtmp.ReadASM[0]
	|| W = &ASMtmp.WriteASM[0]
	*R++ = ASM.RD1U, *W++ = ASM.WR1U
	*R++ = ASM.RD1S, *W++ = ASM.WR2U
	*R++ = ASM.RD2U, *W++ = ASM.WR4U
	*R++ = ASM.RD2S, *W++ = ASM.WR8U
	*R++ = ASM.RD4U, *W++ = ASM.WR16
	*R++ = ASM.RD4S
	*R++ = ASM.RD8U
	*R++ = ASM.RD8U
	*R++ = ASM.RD16
	*R++ = ASM.RD16	


function Debugger		(fn_asm)
	.addasm(asm.TRAP, exp, 0)


function If				(fn_asm)
	opt norefcounts
	debugger
	
	|| cond = exp.first!
	|| Where = .µ(cond, asmreg.Cond)
	|| Start = .curr
	if Where isnt cond
		Start = .AddASM(asm.CMPN, exp, where)					// comparison against 0
	|| arg = cond.next
	fn_asm_table_arg(self, arg)
	|| ElseIf = arg.next
		if mode // what?
		IF(self, elseif, 0.reg, 1)
	Start.r[3] = (mode + .curr) - Start
	
	
function While			(fn_asm)
	opt norefcounts
	debugger
	|| write = .WhileStart
	.WhileStart = .curr
	IF(self, exp, 0.reg, 1)
	|| finish = .curr
	.AddASM(asm.JUMP, exp, .whilestart - finish)				// jump back
	.WhileStart = write

	while write < finish
		if write.Op == 255 // exit
			write.op = ASM.Jump
			write.r[0] = finish - write
		write++

	
function Exit			(fn_asm)
	opt norefcounts
	self <~ (255, exp)											// request jump fwd


function Continue		(fn_asm)
	opt norefcounts
	.AddASM(asm.JUMP, exp, .whilestart - .curr)					// jump back
	

function StatExpr		(fn_asm)
	return fn_asm_table_arg(self, exp, dest, 1)

function Tern			(fn_asm): debugger
function Rejoin			(fn_asm): debugger

function Ignore			(fn_asm)
function Unexpected		(fn_asm)
	"Bad asmtmp"
	debugger


function Return			(fn_asm)
	opt norefcounts
	|| f = exp.first
		|| Where = asmreg.forreturn
		where.µtype = asmstate.sh.ReturnType
		rz = .µ(f, Where)
	.AddASM(asm.RET, exp, rz, 0.reg, 1)


function TypeCast		(fn_asm)		// 
	opt norefcounts
	debugger
	|| src = .µ(exp.first!, dest)
	|| T = src.µtype

	|| OldDecl = exp.first!.fastdecl
	|| OldType = olddecl.regtype
	|| OS = T.BitCount
	if oldtype.bitcount != OS // hmmm. How? they should match up.

	|| NewType = exp.second!.fastdecl
	|| NS = newtype.Regtype
	|| FloatDiff = T.isfloat != newtype.isfloat
	if !FloatDiff and (ns == os)
		return src

	dest = .tempme(exp, dest)
	if t.isfloat or newtype.isfloat
		|| Conv = .AddASM(asm.CONV, exp, dest, src)
		debugger,   #!put in actual numbers later
		if floatdiff
			Conv.r[2] = 1
		  else
			Conv.r[2] = 3
	  else
		|| A = .AddASM(asm.BFLG, exp, dest, src)
		a.r[2] = 64-os
		a.r[3] = 64-os
		a.r[4] = NS.issigned|int|
	
	return dest
		// extend bits if signed int?


function Pointer		(fn_asm)
	// *a, x = *(a.b) 
	opt	NoRefCounts
	dest = .tempme(exp, dest)
	|| Ptr = .µ(exp.first!, dest)
	|| A = Dest.ReadOrWrite(exp)
	.AddASM(A, exp, dest,  Ptr)
	return dest


function Access		(fn_asm)						// a[b], struct.mem[b], func()[func2()]
	opt	NoRefCounts
	dest = .tempme(exp, dest)

	|| Ptr = .µ(exp.first!, dest.requestpos)		// x = a.b[0]
	|| Ind = .µ(exp.second!, ptr.unrequest • dest)
	|| A = Dest.ReadOrWrite(exp)

	.AddASM(A, exp, dest,  Ptr, ind)
	return dest

		

function Dot		(fn_asm)						// a.b
	opt	NoRefCounts
	dest = .tempme(exp, dest)
	|| Obj = .µ(exp.first!, dest)
	|| prop = exp.fastdecl
	|| T = prop.typeinfo
	dest.µtype = T
	debugger
	
	|| B = t.ByteSize.log2
	|| A = Dest.ReadOrWriteSub(exp, t, b)			 #require

	|| Pos = prop.exportposition >> B
	if !pos // what?
	|| WantAddr = dest is positionrequest
	if WantAddr or pos >= 128						// oof
		.AddASM(asm.ADDC, exp, dest, obj, pos)
		if WantAddr
			return dest
		pos = 0
	
	.AddASM(A, exp, dest: dest,  ptr: Obj,  index: 0, Pos)
	return dest
		
		

function SetRel	(fn_asm)
	opt	norefcounts
	|| Var = exp.first!.SimpleVar	
	|| R = .µ(exp.last!, var)
	if r isnt discard							// x = 1, already done!
		(r is set)
		return .µ(exp.first!, R)


function Thg (fn_asm)
	opt norefcounts
												// what if this is a constant?
	|| d = exp.FastDecl
	if d is local
		if dest is set							// copy a reg
			debugger
			if !d.dreg.reg						// what?
			.AddASM(asm.BOR, exp, dest, d.dreg)
			return dest
		return d.dreg
	
	if d is const								// We want a number, really
		|| R = dest.reg
		expect (R and dest isnt set) (exp)
		|| val = d.exportposition
			.NumToReg(val, exp, R)
			return dest
		return 0.reg

	expect (d is global) (Exp)
	if dest isnt discard
		return DoGlobal(self, exp, dest, d)


function DoGlobal (|&ASMState| self, |message| exp, |AsmReg| Value, |scdecl| D, |AsmReg|)
	|| addr = value
	if value isnt set							// a = glob
		addr = .tempme(exp, value)

	.AddASM(asm.tabl,  exp, addr,   d.IsLib|int|)

	|| i = d.exportposition
	if !i
	.AddASM(Value.ReadOrWrite(Exp), exp, Value,  addr, i)
	return addr
	

function ARel		(fn_asm)
	return brel(self, exp, dest, 1)


function BRel		(fn_asm)					//  --a,  ++a,  &a,  --glob,  --a.b
	opt	NoRefCounts
	|| n = exp.name.first
	|| F = exp.first!
	if n == '&'
		return .µ(F, dest.requestpos)

	|| Src = .µ(F, dest)						// src has the old value.
	if (mode == 1)								// we want the old value, which is in src.
		dest = src
	  else
		dest = .TempMe(exp, dest)	
		
	|| D = F.FastDecl
	|| Incr = (D.DeclSize, 1)(D.typesuffers)
	if n == '-'
		Incr = -Incr
	
	.AddASM(ASM.ADDC, exp, dest, src, incr)
	if d isnt local
		.µ(F, dest.set)							// we need to write it back again.
	
	return dest



function DoMath (fn_asm)
	opt norefcounts

	|| F = exp.first!
	|| op = F.next!

	|| OV = .OpenVars
	|| ml = .µ(F)
	|| mr = .µ(op.next!)
	.CloseVars(OV)
	dest = .tempme(op, dest) 
	
	dest.µtype = ml.µtype						// assignment conversion needs to be done also.
	|| scop = op.obj|scoperator|
		|| fn = scop.ASM
			return (fn)(self, dest, ml, mr, op)
	error (op, "No ASM for this operator?")


}


helper ASMReg.ReadOrWriteSub (|message| m, |datatypecode| t, |int| bytes, |asm|)
	if self is set
		if bytes <= 4
			return ASMtmp.WriteASM[bytes]
		error (m, "Object to large to write")
	  else
		|| B = (bytes<<1) + t.issigned
		if b <= 9
			return ASMtmp.ReadASM[b]
		error (m, "Object to large to read")


function ASMReg.ReadOrWrite (|message| m, |asm|)
	|| T = .µtype
	|| bytes = t.bytesize.log2
	return .ReadOrWriteSub(m, t, bytes)


function message.SimpleVar (|asmreg|)
	opt	norefcounts
	real self
	|| fn = .func 
	while fn == @bra or @type
		self = .first!
		fn = .func
	if fn == @thg
		return asmtmp.thg(asmstate.sh, self)
	if fn == @num
		|| d = .FastDecl
		if !d.exportposition
			return 0.reg
