

dispatch fn_asm_table (fn_asm)
	@arg:
		opt norefcounts
		|| OV = .openvars
		for ch.fast in exp
			.µ(ch, AsmReg.discard)
		.closevars(OV)


	@decl: // yay
		debugger


	@num:
		debugger


	@rel: asmtmp.DoMath


	@thg: ASMTmp.Thg


	@bra:
		opt norefcounts
		return .µ(exp.first!, dest)

	@sheb: ASMtmp.Ignore
		

	@list: // vectors
		debugger


/*
	we need the new system... this will be 1,2,3,4 per item below 16
	we need some way to modify
*/

	@func:
		opt norefcounts
		// 0, a, b, fn(), b*b, a*a
		// 0, a, b, b*b, a*a, fn()
		return .DoFunc(exp.last!, dest)


	@acc: // pointers?
		debugger


	@brel: // ++, --, -
		debugger


	@arel: // ++, --, 
		debugger


	@type: // 
		// bit narrowing, float conversion, etc?
		// could be others too? vectors?
		debugger

	(ASMtmp.kDebugger):		ASMtmp.Debugger
	(ASMtmp.kif):			ASMtmp.If
	(ASMtmp.krejoin):		ASMtmp.Rejoin
	(ASMtmp.kreturn):		ASMtmp.return
	(ASMtmp.kwhile):		ASMtmp.While

	(asmtmp.kContinue):		ASMtmp.Continue
	(asmtmp.kExit):			ASMtmp.Exit
	(asmtmp.ksetvar):		ASMtmp.SetRel
	(asmtmp.kStatExpr): 	ASMtmp.StatExpr
	(asmtmp.kPointer):		asmtmp.Pointer
	(asmtmp.kTern):			ASMtmp.Tern

	(asmtmp.kIgnore):		ASMtmp.Ignore
	(asmtmp.kFail):			ASMtmp.Ignore

	@tmp:
		#!the tmp type should have already been set
		debugger
	63:
		0



// for some reason, replacing this will cause speedie to generate bad code
// I guess I am setting the Flags somewhere, or testing them? but I can't see where.
function Message.ASMType (|ASMTmp|)
	rz = .FLAGS & 63

function Message.ASMType (assigns:|ASMTmp|)
	target debug: if .objectid == 0
	value = (.FLAGS &~ 63) ||| value
	.FLAGS = value 


datatype ASMtmp (uint16)
	syntax is (|asmtmp| t, |bool|)
		return self == t

	constants
		|asmtmp| 
		kElseIf = 48
		kIf
		kWhile
		kContinue
		kExit
		kReturn
		kRejoin
		kSwap
		kTern
		kStatExpr
		kSetVar
		kPointer
		kIgnore
		kDebugger
		kFail = 63
	

	module {

|asm_mem[10]| ReadASM
|asm_mem[5]| WriteASM

function InitAccess
	|| R = &ASMtmp.ReadASM[0]
	|| W = &ASMtmp.WriteASM[0]
	*R++ = ASM.RD1U, *W++ = ASM.WR1U
	*R++ = ASM.RD1S, *W++ = ASM.WR2U
	*R++ = ASM.RD2U, *W++ = ASM.WR4U
	*R++ = ASM.RD2S, *W++ = ASM.WR8U
	*R++ = ASM.RD4U, *W++ = ASM.WR16
	*R++ = ASM.RD4S
	*R++ = ASM.RD8U
	*R++ = ASM.RD8U
	*R++ = ASM.RD16
	*R++ = ASM.RD16	


function Debugger		(fn_asm): debugger
function Continue		(fn_asm): debugger
function Exit			(fn_asm): debugger
function StatExpr		(fn_asm): debugger
function Tern			(fn_asm): debugger
function If				(fn_asm): debugger
function Rejoin			(fn_asm): debugger
function While			(fn_asm): debugger

function Ignore			(fn_asm)
function Unexpected		(fn_asm)
	"Bad asmtmp"
	debugger


function Return			(fn_asm)
	opt norefcounts
	|| f = exp.first
		|| Where = asmreg.forreturn
		where.µtype = asmstate.sh.ReturnType
		rz = .µ(f, Where)
	.AddASM(asm.RET, exp, rz, 0.reg, 1)


function Pointer		(fn_asm)
	opt	NoRefCounts
	|| Addr = .µ(exp.first!)
	
	|| A = Dest.ReadOrWrite // does this work?
	.AddASM(A, exp, dest,  addr)
		

function SetRel	(fn_asm)
	opt	norefcounts
	|| Var = exp.first!.SimpleVar	
	|| R = .µ(exp.last!, Var)
	if r isnt discard    // x = 1, already done!
		(r is set)
		.µ(exp.first!, R)
	// seems simple?


function Thg (fn_asm)
	opt norefcounts
												// what if this is a constant?
	|| d = exp.FastDecl
	if d is local
		if dest is set							// copy a reg
			debugger
			if !d.dreg.reg						// what?
			.AddASM(asm.BOR, exp, dest, d.dreg)
			return dest
		return d.dreg
	
	if d is const								// We want a number, really
		|| R = dest.reg
		expect (R and dest isnt set) (exp)
		|| val = d.exportposition
			.NumToReg(val, R, exp)
			return dest
		return 0.reg

	expect (d is global) (Exp)
	if dest isnt discard
		return DoGlobal(self, exp, dest, d)



// how to compile:    pglob++, pglob2++
// without loading the address of the pack glob table 4x?
// pre-allocate a position (after the decls) containing our global?
// and load on the first use of any global? otherwise just optimise.


function DoGlobal (|&ASMState| self, |message| exp, |AsmReg| Value, |scdecl| D, |AsmReg|)
	|| addr = value
	if value isnt set				// a = glob
		addr = .tempme(exp, value)

	.AddASM(asm.tabl,  exp, addr,   d.IsLib|int|)
		// exec takes the exportpos and alters it to the new exportpos

	|| i = d.exportposition
	if !i
	.AddASM(Value.ReadOrWrite, exp, Value,  addr, i)
	return addr
	

function DoMath (fn_asm)
	opt norefcounts

//	debugger
	|| F = exp.first!
	|| op = F.next!
	dest = .tempme(op, dest)

	|| OV = .OpenVars
	|| ml = .µ(F, dest)
	|| mr = .µ(op.next!, ml • dest)
	.CloseVars(OV)
	
	dest.µtype = ml.µtype						// assignment conversion needs to be done also.
	|| scop = op.obj|scoperator|
		|| fn = scop.ASM
			return (fn)(self, dest, ml, mr, op)
	error (op, "No ASM for this operator?")


}

function asmreg.operator• (|asmreg| dest, |asmreg|)
	if .reg == dest.reg
		return 0.reg
	return dest

function ASMReg.ReadOrWrite (|asm|)
	|| T = .µtype
	|| bytes = t.bytesize.log2
	if self is set
		return ASMtmp.WriteASM[bytes]
	return ASMtmp.ReadASM[(bytes<<1) + t.issigned]

function message.SimpleVar (|asmreg|)
	opt	norefcounts
	real self
	|| fn = .func 
	while fn == @bra or @type
		self = .first!
		fn = .func
	if fn == @thg
		return asmtmp.thg(asmstate.sh, self)
	if fn == @num
		|| d = .FastDecl
		if !d.exportposition
			return 0.reg
