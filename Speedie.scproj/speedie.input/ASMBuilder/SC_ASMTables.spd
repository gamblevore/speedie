

dispatch fn_asm_table (fn_asm)
	@arg:
		opt norefcounts
		|| OV = .openvars
		|| DiscardResult = 128.reg
		for ch.fast in exp
			.µ(ch, DiscardResult)
		.closevars(OV)


	@decl: // yay
		debugger


	@num:
		debugger


	@rel:
		opt norefcounts
		|| OV = .openvars
		rz = .DoRels(exp.first!, reg)
		.closevars(OV)


	@thg:
		opt norefcounts
									// what if this is a constant?
		|| d = exp.fastDecl
		if d is local
			if !d.dreg.reg // what?
			// Only setrel uses .isset. SetRel never calls local regs.
			// So we don't need to copy registers HERE.
			return d.dreg
		
		if d is const				// we want a number, really
			debugger

		// only setvar will try to set anything...
		// however... if it finds either side has a register... it won't come here (for that side)
		// so we won't ever get something like setting a (specified) register from a global.
		// meaning... we wont get "set" except TO a global
		// so we will be reading a global... and putting it somewhere
		// probably into a reg... but lets make sure we have one.
		// register 0 is a real register. how do we tell that apart from "unused"?
		// hmmmmm... We could refer to it as register 1... which isnt great
		// or have a different way to refer to "unused register". probably the second.
		
		// what if our "reg" is a setreg... and we are setting from reg 0. 0 is a valid register.
		// many things might want to read from a register?
		if reg.isset
			// Setting global to 'Reg'.  If reg is 0... explicitly clear mem.
		  else
			require !reg.isdiscard
			reg = .NeedSomewhere(exp, reg)
			.AddASM(asm.RD1U, exp, 0)
			// now put that global into the reg!

/*
RD1U
RD1S
RD2U
RD2S
RD4U
RD4S
RD8U
*/


	@bra:
		opt norefcounts
		|| f = exp.first
			if f.func != @arg
				return .µ(f, reg)
			return ASMtmp.StateExpr(self, f)

	@sheb: ASMtmp.Ignore
		

	@list: // vectors
		debugger


	@func:
		opt norefcounts
		// 0, a, b, fn(), b*b, a*a
		// 0, a, b, b*b, a*a, fn()
		rz = .DoFunc(exp.last!, reg)


	@acc: // pointers?
		debugger


	@brel: // ++, --, -
		debugger


	@arel: // ++, --, 
		debugger


	@type: // 
		// bit narrowing, float conversion, etc?
		// could be others too? vectors?
		debugger

	(ASMtmp.kDebugger):		ASMtmp.Debugger
	(ASMtmp.kif):			ASMtmp.If
	(ASMtmp.krejoin):		ASMtmp.Rejoin
	(ASMtmp.kreturn):		ASMtmp.return
	(ASMtmp.kwhile):		ASMtmp.While

	(asmtmp.kContinue):		ASMtmp.Continue
	(asmtmp.kExit):			ASMtmp.Exit
	(asmtmp.ksetvar):		ASMtmp.SetRel
	(asmtmp.kStatExpr): 	ASMtmp.StatExpr
	(asmtmp.kTern):			ASMtmp.Tern

	(asmtmp.kIgnore):		ASMtmp.Ignore
	(asmtmp.kFaille):		ASMtmp.Ignore

	@tmp:
		#!the tmp type should have already been set
		debugger
	63:
		0


datatype ASMtmp (uint16)
	module {
function StateExpr		(fn_asm): debugger
function Debugger		(fn_asm): debugger
function Continue		(fn_asm): debugger
function Exit			(fn_asm): debugger
function SetRel			(fn_asm): debugger
function StatExpr		(fn_asm): debugger
function Tern			(fn_asm): debugger
function If				(fn_asm): debugger
function Rejoin			(fn_asm): debugger
function While			(fn_asm): debugger

function Ignore			(fn_asm)
function Unexpected		(fn_asm)
	"Bad asmtmp"
	debugger

function Return			(fn_asm)
	opt norefcounts
	|| f = exp.first
		rz = .µ(f)
	.AddASM(asm.RET, exp, rz)
	
}
	
	syntax is (|asmtmp| t, |bool|)
		return self == t

	constants
		|asmtmp| 
		kElseIf = 48
		kIf
		kWhile
		kContinue
		kExit
		kReturn
		kRejoin
		kSwap
		kTern
		kStatExpr
		kSetVar
		kIgnore
		kDebugger
		kFaille = 63
	

// for some reason, replacing this will cause speedie to generate bad code
// I guess I am setting the Flags somewhere, or testing them? but I can't see where.
function Message.ASMType (|ASMTmp|)
	rz = .FLAGS & 63

function Message.ASMType (assigns:|ASMTmp|)
	target debug: if .objectid == 0
	value = (.FLAGS &~ 63) ||| value
	.FLAGS = value 

