
// check for four/eightbytes... how do they handle 1/2???

dispatch fn_asm_table (fn_asm)
	@arg:
		opt norefcounts
		for ch.fast in exp
			.µ(ch, asmreg.discard)


	@decl: // yay
		opt norefcounts
		|| rel = exp.last!
		|| ty = rel.first!.fastdecl
		|| reg = .DeclareMe(Exp, ty.reg)
		return .µ(rel.last!, reg)


	@num:
		opt norefcounts
		|| d = exp.fastdecl
		Dest = .TempMe(exp, dest)
		|| X = d.exportposition
		if d.isfloat
			|| f8 = exp.float
			if d.DeclSize == 4
				|| f4 = f8|float|
				x = f4.asint
			  else
				debugger
				x = f8.asint
		.NumToReg(X, exp, Dest)
		(Dest is const)
		return dest
		// loadconst?


	@rel: asmtmp.DoMath


	@thg: ASMTmp.Thg


	@bra: ASMTmp.First

	@sheb: ASMtmp.Ignore
		

	@list: // vectors
		debugger

	@func:
		opt norefcounts
		return .DoFunc(exp.last!, dest)


	@dot:	ASMTmp.Dot
	@acc:	ASMTmp.Access


	@brel: asmtmp.Brel		// ++, --, -, &


	@arel: asmtmp.arel      // ++, --, 


	@type:					asmtmp.TypeCast


	@tmp:					asmtmp.unexpected

	(ASMtmp.kDebugger):		ASMtmp.Debugger
	(ASMtmp.kif):			ASMtmp.If
	(ASMtmp.krejoin):		ASMtmp.First
	(ASMtmp.kreturn):		ASMtmp.return
	(ASMtmp.kwhile):		ASMtmp.While
	(asmtmp.kTern):			ASMtmp.Tern

	(asmtmp.kContinue):		ASMtmp.Continue
	(asmtmp.kExit):			ASMtmp.Exit

	(asmtmp.ksetvar):		ASMtmp.SetRel
	(asmtmp.kStatExpr): 	ASMtmp.StatExpr
	(asmtmp.kPointer):		asmtmp.Pointer

	(asmtmp.kIgnore):		ASMtmp.Ignore
	(asmtmp.kFail):			ASMtmp.Ignore

	63:
		0



extend_module ASMTmp {

|asm_mem[10]| ReadASM
|asm_mem[5]| WriteASM

function InitAccess
	|| R = &ASMtmp.ReadASM[0]
	|| W = &ASMtmp.WriteASM[0]
	*R++ = ASM.RD1U, *W++ = ASM.WR1U
	*R++ = ASM.RD1S, *W++ = ASM.WR2U
	*R++ = ASM.RD2U, *W++ = ASM.WR4U
	*R++ = ASM.RD2S, *W++ = ASM.WR8U
	*R++ = ASM.RD4U, *W++ = ASM.WR16
	*R++ = ASM.RD4S
	*R++ = ASM.RD8U
	*R++ = ASM.RD8U
	*R++ = ASM.RD16
	*R++ = ASM.RD16	


function Debugger		(fn_asm)
	.addasm(asm.TRAP, exp, 0)

	
function If				(fn_asm)
	opt norefcounts
	debugger
	
	|| cond = exp.first!
	|| Start = .NeedCond(cond)
	|| arg = cond.next!
	.µ(arg)
	|| ElseIf = arg.next
		if mode // what?
		IF(self, elseif, asmreg(), 1)
	Start.r[3] = (mode + .curr) - Start
	
	
function While			(fn_asm)
	opt norefcounts
	debugger
	|| write = .WhileStart
	.WhileStart = .curr
	IF(self, exp, asmreg(), 1)
	|| finish = .curr
	.AddASM(asm.JUMP, exp, .whilestart - finish)				// jump back
	.WhileStart = write

	while write < finish
		if write.Op == 255 // exit
			write.op = ASM.Jump
			write.r[0] = finish - write
		write++

	
function Exit			(fn_asm)
	opt norefcounts
	self <~ (255, exp)											// request jump fwd


function Continue		(fn_asm)
	opt norefcounts
	.AddASM(asm.JUMP, exp, .whilestart - .curr)					// jump back
	

function StatExpr		(fn_asm)
	opt norefcounts
	for ch.fast in exp
		if ch.islast
			return .µ(ch, dest)
		.µ(ch, asmreg.discard)


function Tern			(fn_asm)
	opt norefcounts
	|| prms = exp.second
	|| cond = prms.first!
	|| A = cond.next!
	|| B = A.next!
	dest = .TempMe(exp, dest)

	|| FailToSecond = .NeedCond(cond)
	.µ(A, dest)
	|| Exit = .AddASM(asm.jump, exp)

	FailToSecond.r[3] = .curr - FailToSecond

	.µ(B, dest)
	Exit.r[3] = .curr - Exit	

	return dest
	

	
function First			(fn_asm)
	opt norefcounts
	return .µ(exp.first!, dest)


function Return			(fn_asm)
	opt norefcounts
	|| f = exp.first
		|| Where = asmreg.ForReturnReg
		where.µtype = asmstate.sh.ReturnType
		rz = .µ(f, Where)
	.AddASM(asm.RET, exp, rz, asmreg(), 1)


function TypeCast		(fn_asm)		// 
	opt norefcounts
	debugger
	|| src = .µ(exp.first!, dest)
	|| T = src.µtype

	|| OldDecl = exp.first!.fastdecl
	|| OldType = olddecl.regtype
	|| OS = T.BitCount
	if oldtype.bitcount != OS // hmmm. How? they should match up.

	|| NewType = exp.second!.fastdecl
	|| NS = newtype.Regtype
	|| FloatDiff = T.isfloat != newtype.isfloat
	if !FloatDiff and (ns == os)
		return src

	dest = .TempMe(exp, dest)
	ifn t.isfloat or newtype.isfloat
		|| Sh = 64 - os
		.AddASM(asm.BFLG, exp, dest, src, sh, sh).r[4] = NS.issigned|int|
		return dest
	
	|| Conv = .AddASM(asm.CONV, exp, dest, src)
	debugger,   #!put in actual numbers later
	if floatdiff
		Conv.r[2] = 1
	  else
		Conv.r[2] = 3
	
	return dest


function Pointer		(fn_asm)
	// *a, x = *(a.b) 
	opt	NoRefCounts
	dest = .tempme(exp, dest)
	|| Ptr = .µ(exp.first!, dest)
	|| A = Dest.ReadOrWrite(exp)
	.AddASM(A, exp, dest,  Ptr)
	return dest


function Access		(fn_asm)						// a[b], struct.mem[b], func()[func2()]
	opt	NoRefCounts
	dest = .tempme(exp, dest)

	|| Ptr = .µ(exp.first!, dest.requestpos)		// x = a.b[0]
	|| Ind = .µ(exp.second!, ptr.unrequest • dest)
	|| A = Dest.ReadOrWrite(exp)

	.AddASM(A, exp, dest,  Ptr, ind)
	return dest

		

function Dot		(fn_asm)						// a.b
	opt	NoRefCounts
	dest = .tempme(exp, dest)
	|| Obj = .µ(exp.first!, dest)
	|| prop = exp.fastdecl
	|| T = prop.typeinfo
	dest.µtype = T
	debugger
	
	|| B = t.ByteCount.log2
	|| A = Dest.ReadOrWriteSub(exp, t, b)			 #require

	|| Pos = prop.exportposition >> B
	if !pos // what?
	|| WantAddr = dest is positionrequest
	if WantAddr or pos >= 128						// oof
		.AddASM(asm.ADDK, exp, dest, obj, pos)
		if WantAddr
			return dest
		pos = 0
	
	.AddASM(A, exp, dest: dest,  ptr: Obj,  index: 0, Pos)
	return dest
		

function SetRel	(fn_asm)
	opt	norefcounts
	|| Var = exp.first!.SimpleVar	
	|| R = .µ(exp.last!, var)
	if r isnt discard								// x = 1, already done!
		(r is set)
		return .µ(exp.first!, R)


function Thg (fn_asm)
	opt norefcounts
													// what if this is a constant?
	|| d = exp.FastDecl
	if d is local
		|| reg = d.reg
		if dest is set								// copy a reg
			debugger
			if !reg.reg					// what?
			.AddASM(asm.BOR, exp, dest, reg)
			return dest
		return reg
	
	if d is const									// We want a number, really
		|| R = dest.reg
		expect (R and dest isnt set) (exp)
		|| val = d.exportposition
			.NumToReg(val, exp, R)
			(dest is const)
			return dest
		return asmreg.Zero

	expect (d is global) (Exp)
	if dest isnt discard
		return DoGlobal(self, exp, dest, d)
 

function DoGlobal (|&ASMState| self, |message| exp, |AsmReg| Value, |scdecl| D, |AsmReg|)
	|| addr = value
	if value isnt set								// a = glob
		addr = .tempme(exp, value)

	.AddASM(asm.tabl,  exp, addr,   d.IsLib|int|)

	|| i = d.ExportPosition				#check (exp, "Internal error: No global address")
	.AddASM(Value.ReadOrWrite(Exp), exp, Value,  addr, i)
	return addr
	

function Not		(fn_asm)
	opt	NoRefCounts
	
	if dest is cond // if !x
		// use compe... can encode as bra/jump if it needs


	// y = !x
	|| src = .µ(exp.first!, dest)
	if src.isfloat // need to use asm.cmpe instead
		debugger
	  else
		.addasm(asm.BCMP, exp, dest, 0, src, 64-src.µtype.bitcount, 1)

	dest.µtype = DataTypeCode.bool
	return dest
	

function ARel		(fn_asm)
	|| Sub = exp.name.first == '-'
	return Precrement(self, exp.first!, dest, 2 + Sub)
	

function Minus			(fn_asm)					// -a
	opt	NoRefCounts
	return asmtmp.DoSingleMath(self, exp, dest, scoperator.minus)
		


function Precrement		(fn_asm)					// --a, ++a
	opt	NoRefCounts
	|| Src = .µ(exp, dest)							// src has the old value.
	if (mode & 2)									// we want src.
		dest = src
	  else
		dest = .TempMe(exp, dest)	
	
	|| D = exp.FastDecl
	|| Incr = (D.DeclSize, 1)(D.typesuffers)
	if mode & 1
		Incr = -Incr

	/*		r1		r
			r2		r
			D		1
			High	13		*/
	if dest.isfloat
		incr = (incr == 1)|int|
		|| big = dest.fourbytes
			incr =  127 + (incr<<7)
		  else
			incr = 1023 + (incr<<10)
		
		.AddASM(ASM.FADK, exp.parent!, dest, src, big|int|, incr<<5)
	  else
		.AddASM(ASM.ADDK, exp.parent!, dest, src, incr)
	if d isnt local
		.µ(exp, dest.set)							// write it back again
	
	return dest
	
	
function BRel		(fn_asm)						//  --a,  ++a,  &a,  --glob,  --a.b, -a
	opt	NoRefCounts
	|| n = exp.name.first
	|| F = exp.first!
	if n == '&'
		return .µ(F, dest.requestpos)
	if n == '~'
		return dosinglemath(self, exp, dest, scoperator.bnot)
	if n == '!'
		return Not(self, F, dest)

	if exp.name == 1								// -a
		return Minus(Self, f, dest)
	
	|| Sub = n == '-'
	return Precrement(self, F, dest, Sub|int|)


function MathConst (|&ASMState| self, |AsmReg| Dest, |asmreg| ml, |asmreg| mr, |message| Op, |fn_opasm| fn, |AsmReg|)
	(Dest is const)
	|| R = (fn)(self, dest, ml, mr, op)
	if r isnt const // hmm?
		debugger 
		(fn)(self, dest, ml, mr, op)
	return R


function DoSingleMath (|&ASMState| self, |message| exp, |AsmReg| Dest, |scoperator| Scop, |AsmReg|)
	|| Src = .µ(exp, dest)
	return DoMathSub(self, exp, dest, asmreg(), src, scop)


function DoMath (fn_asm)
	opt norefcounts

	|| F = exp.first!

	|| OV = .OpenVars
	|| ml = .µ(F, 		 asmreg.StayOpen)
	|| mr = .µ(exp.last!, asmreg.StayOpen)
	.CloseVars(OV)

	|| op = F.next!
	|| scop = op.obj|scoperator|
		return DoMathSub(self, op, dest, ml, mr, scop)
	error (op, "No ASM for this operator?")


function DoMathSub (|&ASMState| self,  |message| op,  |AsmReg| Dest,  |asmreg| ml,  |asmreg| mr,  |scoperator| Scop, |AsmReg|)
	|| fn = scop.ASM
		dest = .tempme(op, dest) 
		dest.µtype = ml.µtype							// assignment conversion needs doing?	
		dest = dest as scop.code
		(dest is frommath)
		ifn ml is const and mr is const
			return (fn)(self, dest, ml, mr, op)
		return MathConst(self, dest, ml, mr, op, fn)
	error (op, "No ASM for this operator?")
	


function Ignore			(fn_asm)


function Unexpected		(fn_asm)
	"Bad asmtmp"
	debugger


}


helper ASMReg.ReadOrWriteSub (|message| m, |datatypecode| t, |int| bytes, |asm|)
	if self is set
		if bytes <= 4
			return ASMtmp.WriteASM[bytes]
		error (m, "Object to large to write")
	  else
		|| B = (bytes<<1) + t.issigned
		if b <= 9
			return ASMtmp.ReadASM[b]
		error (m, "Object to large to read")


function ASMReg.ReadOrWrite (|message| m, |asm|)
	|| T = .µtype
	|| bytes = t.ByteCount.log2
	return .ReadOrWriteSub(m, t, bytes)


function message.SimpleVar (|asmreg|)
	opt	norefcounts
	real self
	|| fn = .func 
	while fn == @bra or @type
		self = .first!
		fn = .func
	if fn == @thg
		return asmtmp.thg(asmstate.sh, self)
	if fn == @num
		|| d = .FastDecl
		if !d.exportposition
			return asmreg()


