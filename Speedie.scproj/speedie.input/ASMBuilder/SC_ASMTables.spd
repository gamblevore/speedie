


dispatch fn_asm_table (fn_asm)
	@arg:
		opt norefcounts
		for ch.fast in exp
			.µ(ch, asmreg.Arg)

	@decl: // yay
		opt norefcounts
		|| rel = exp.last!
		|| ty = rel.first!.fastdecl
		|| reg = .DeclareMe(Exp, ty.reg)
		(reg is NotYetUsed)
		return .µ(rel.last!, reg)

	@num:  ASMTmp.num

	@rel:  ASMTmp.DoMath

	@thg:  ASMTmp.Thg

	@bra:  ASMTmp.First

	@sheb: ASMtmp.Ignore
		
	@list: // vectors
		debugger

	@func: asmtmp.DoFunc

	@dot:  ASMTmp.Dot
	
	@acc:  ASMTmp.Access

	@brel: asmtmp.Brel		// ++, --, -, &

	@arel: asmtmp.arel      // ++, --, 

	@type:					asmtmp.TypeCast

	@tmp:					asmtmp.unexpected

	(ASMtmp.kDebugger):		ASMtmp.Debugger
	(ASMtmp.kif):			ASMtmp.If
	(ASMtmp.krejoin):		ASMtmp.First
	(ASMtmp.kreturn):		ASMtmp.return
	(ASMtmp.kwhile):		ASMtmp.While
	(asmtmp.kTern):			ASMtmp.Ternary

	(asmtmp.kContinue):		ASMtmp.Continue
	(asmtmp.kExit):			ASMtmp.Exit

	(asmtmp.ksetvar):		ASMtmp.SetRel
	(asmtmp.kStatExpr): 	ASMtmp.StatExpr
	(asmtmp.kPointer):		asmtmp.Pointer

	(asmtmp.kIgnore):		ASMtmp.Ignore
	(asmtmp.kFail):			ASMtmp.Ignore

	63:
		0




function asmstate.SimpleTernary (|asmreg| dest, |asmreg| ma, |asmreg| mb, |message| cond, |asmreg|)
	opt norefcounts
	|| dr = dest.reg
	|| mc = (asmreg(), dest)(dr == ma.reg or mb.reg)
	mc = .µ(cond, mc)
	.addasm(asm.TERN, cond, dest, mc, ma, mb)
	return dest


function asmstate.AddToReg (|asmreg| addr, |int| add, |message| exp)
	if add
		.plus(addr, addr, .numtoegg(add, exp), exp)



extend_module ASMTmp {
constants
	IncrAfter = 2
	IncrBefore = 0
	
|asm_mem[10]| ReadASM
|asm_mem[5]| WriteASM

function InitAccess
	|| R = &ASMtmp.ReadASM[0]
	|| W = &ASMtmp.WriteASM[0]
	*R++ = ASM.RD1U, *W++ = ASM.WR1U
	*R++ = ASM.RD1S, *W++ = ASM.WR2U
	*R++ = ASM.RD2U, *W++ = ASM.WR4U
	*R++ = ASM.RD2S, *W++ = ASM.WR8U
	*R++ = ASM.RD4U, *W++ = ASM.WR16
	*R++ = ASM.RD4S
	*R++ = ASM.RD8U
	*R++ = ASM.RD8U
	*R++ = ASM.RD16
	*R++ = ASM.RD16	


function Debugger		(fn_asm)
	.addasm(asm.TRAP, exp)


	
function If				(fn_asm)
	opt norefcounts
	debugger
	
	|| cond = exp.first!
	|| arg = cond.next!
	|| F = arg.first
//	if !mode and f and (f.asmtype == kreturn) and IfAsReturn(self, F, exp) // we can do an optional return? but only if returning a reg or true/false
//		return nil // too fiddly. I hate writing this :)
			
	|| Start = .Branch(cond)
	.µSync(arg)
	|| ElseIf = arg.next
		if mode // what?
		IF(self, elseif, asmreg(), 1)
	Start.r[3] = (mode + .curr) - Start
	
	
function While			(fn_asm)
	opt norefcounts
	debugger
	|| write = .WhileStart
	.WhileStart = .curr
	IF(self, exp, asmreg(), 1)
	|| finish = .curr
	.AddASM(asm.JUMP, exp, .whilestart - finish)				// jump back
	.WhileStart = write

	while write < finish
		if write.Op == 255 // exit
			write.op = ASM.Jump
			write.r[0] = finish - write
		write++

	
function Exit			(fn_asm)
	opt norefcounts
	self <~ (255, exp)											// request jump fwd


function Continue		(fn_asm)
	opt norefcounts
	.AddASM(asm.JUMP, exp, .whilestart - .curr)					// jump back
	

function StatExpr		(fn_asm)
	opt norefcounts
	for ch.fast in exp
		if ch.islast
			return .µ(ch, dest)
		.µ(ch, asmreg.Arg)


function Ternary		(fn_asm)
	opt norefcounts
	
	|| prms = exp.second
	|| cond = prms.first!
	|| A = cond.next!
	|| B = A.next!
	
	|| mA = .ExistingVar(a) // shouldn't allow globals
	|| mB = .ExistingVar(b)
	if ma and mb
		return .SimpleTernary(dest, ma, mb, cond)
	
	#! we'll need to protect registers...  x = (1,1+2)(cond)
	#! x can be set to 1, then we find the number 1 as a constant in a register
	#! Except its not really there cos it hasnt been done yet!
	#! Its actually quite good that we set it directly, though.
	#! We need some kinda way to block off "unknown registers" 

	dest = .TempMe(exp, dest)
	|| FailToSecond = .Branch(cond)
	.µ(A, dest)
	|| Exit = .AddASM(asm.jump, exp)

	FailToSecond.r[3] = .curr - FailToSecond

	.µ(B, dest)
	Exit.r[3] = .curr - Exit	

	return dest
	

	
function First			(fn_asm)
	opt norefcounts
	return .µ(exp.first!, dest)


function Return			(fn_asm)
	opt norefcounts
	|| f = exp.first
		|| Where = asmreg.ForReturn
		where.reg = 1
		where.µtype = asmstate.sh.ReturnType
		rz = .µ(f, Where)
	.AddASM(asm.RET, exp, rz, asmreg(), 1)


function TypeCast		(fn_asm)		// 
	opt norefcounts
	debugger
	|| src = .µ(exp.first!, dest)
	|| T = src.µtype
	if t is bool
		return .NotEq(dest, asmreg(), src, exp)

	|| OldDecl = exp.first!.fastdecl
	|| NewDecl = exp.second!.fastdecl
	|| OldType = olddecl.regtype
	|| NewType = newdecl.regtype
	|| OC = T.BitCount
	|| NC = newtype.BitCount
	if  oldtype.BitCount != OC  or  newtype.BitCount != NC  // hmmm. How? they should match up.

	|| FloatDiff = T.isfloat != newtype.isfloat
	if !FloatDiff and (nc == oc)
		return src

	dest = .TempMe(exp, dest)
	ifn t.isfloat or newtype.isfloat
		|| Sh = 64 - oc
		.AddASM(asm.BFLG, exp, dest, src, sh, sh, src.signed|int|)
		return dest as ASMMath.bitcorrect
	
	|| Conv = .AddASM(asm.CONV, exp, dest, src)
	debugger,   #!put in actual numbers later
	if floatdiff
		Conv.r[2] = 1
	  else
		Conv.r[2] = 3
	
	return dest


function Pointer		(fn_asm)
	// *a, x = *(a.b) 
	opt	NoRefCounts
	if dest is AddrRequest // hmmm?
	dest = .tempme(exp, dest)
	|| Ptr = .µ(exp.first!, dest)
	|| A = Dest.ReadOrWrite(exp)
	.AddASM(A, exp, dest,  Ptr)
	return dest as asmmath.Bitcorrect


function Access		(fn_asm)						// a[b], struct.mem[b], func()[func2()]
	opt	NoRefCounts
	dest = .tempme(exp, dest)

	|| Ptr = .µ(exp.first!, dest.RequestPos)		// x = a.b[0]
	expect (ptr is ContainsAddr) (exp)
	|| Ind = .µ(exp.second!, ptr • dest)
	if (dest is addrrequest)
		return .plus(dest.HaveAddr, ptr, ind, exp)
	
	|| A = Dest.ReadOrWrite(exp)
	.AddASM(A, exp, dest,  Ptr, ind)
	return dest asnt asmreg.containsaddr as asmmath.Bitcorrect 


function Dot		(fn_asm)						// a.b
	opt	NoRefCounts
	dest = .tempme(exp, dest)
	|| Obj = .µ(exp.first!, dest)
	|| prop = exp.fastdecl
	|| T = prop.typeinfo
	dest.µtype = T
	debugger
	
	|| B = t.ByteCount.log2
	|| A = Dest.ReadOrWriteSub(exp, t, b)			 #require

	|| Pos = prop.exportposition >> B
	if !pos // what?
	if (dest is addrrequest) or (pos >= 128)						// read/write only allows up to 127
		.AddASM(asm.ADDK, exp, dest, obj, pos)
		if dest is addrrequest
			return dest.haveaddr
		pos = 0
	
	.AddASM(A, exp, dest: dest,  ptr: Obj,  index: 0, Pos)
	return dest
		

function SetRel	(fn_asm)
	opt	norefcounts					//   x[func()] = y++
	|| Var = .ExistingVar(exp.first!)	
	(Var is StayOpen)
	|| R = .µ(exp.last!, var)
	if !r.reg						// what?
	if var.reg != r.reg
		(r is set)
		return .µ(exp.first!, R)


function Num (fn_asm)
	opt norefcounts
	|| d = exp.fastdecl
	|| X = d.exportposition
	target debug
		if x == 0 != exp.iszero // argh
	|| r = asmstate.sh.FindConst(x)
		return r
	Dest = .TempMe(exp, dest)
	.NumToReg(X, exp, Dest)
	(Dest is constany)
	return dest


function Thg (fn_asm)
	opt norefcounts
													// what if this is a constant?
	|| d = exp.FastDecl
	if d is local
		|| reg = d.reg
		if dest is set								// copy a reg
			debugger
			if !reg.reg					// what?
			.AddASM(asm.BOAR, exp, dest, reg)
			return dest
		return reg

	if d is const
		|| R = dest.reg
		check (R and dest isnt set) (exp)
		|| val = d.exportposition
			require !(mode & asmtmp.ImmediatesOnly)
			.NumToReg(val, exp, R)
			(dest is constany)
			return dest
		return asmreg.Zero

	require !(mode & asmtmp.ImmediatesOnly)
	check (d is global) (Exp)
	return DoGlobal(self, exp, dest, d)
 

function DoGlobal (|&ASMState| self, |message| exp, |AsmReg| Dest, |scdecl| D, |AsmReg|)
	opt	NoRefCounts
	|| addr = dest
	if dest isnt set								// a = glob
		addr = .tempme(exp, dest)

	|int64| iTable = d.ExportPosition
	expect (iTable > 0)      (exp, "No global address".internal)
	expect (iTable < 16MB)   (exp, "Too much global data")

	if dest is AddrRequest
		|| iAdd = iTable
		if itable >= 16K
			debugger // does this ever happen?
			itable &= 16K-1
		.AddASM(asm.tabl,  exp,  addr,  (!d.IsLib)|int|,  itable)
		.addtoreg(addr, iadd-itable, exp)
		return addr.haveaddr


	|| iRead = iTable
	|| iOld = iRead
	if iTable < 128
		iTable = 0		// keep the current table. More optimisable.
	  elseif iTable < 16K
		iRead = 0		// itable has a bigger range... so use that. 
	  else
		itable = 0		// Make this optimisable.
		iRead = 0

	.AddASM(asm.TABL,  exp,  addr,  (!d.IsLib)|int|, iTable)
	if !itable and !iread
		.addtoreg(addr, iold, exp)
	.AddASM(dest.ReadOrWrite(Exp), exp, dest, addr, iRead)
	return addr as asmmath.Bitcorrect
	

function Not		(fn_asm)
	opt	NoRefCounts
	dest = dest.negate
	|| src = .µ(exp.first!, dest)
	if src is AlreadyNegated
		return src
	return .Equals(dest, asmreg(), src, exp)
	

function Minus			(fn_asm)					// -a
	opt	NoRefCounts
	return ASMTmp.DoSingleMath(self, exp, dest, scoperator.minus)
/*
	DONE:
		* discard vars: y++
		* discard mem:  a.b++, *x++, a[y]++
		* ++y
*/


/*
	seems easy
		x = y++
		*x = y++
		x = y++ * 3 // --> x = y*3, y++
		
	non optimiseables?
		x = y++ * y++ --> || tmp = y,  y++,  x = y * tmp,  y++
		func(y++, 7)
	

	Easy cases:
		x =  y++								// can special-case
		x = *y++								// special-case also
		func(*y++)								// similar special-case
		x[0] = y++								// probably not too hard.

	Other cases?
		x < y++									// just do the opp, then add after all is done.
		while *x++ == *y++
		x = y++ * 3 // --> x = y*3, y++


	blocked cases: // boolean logic
		func(y++, y++)
		x = y++ * y++
		*func(y++) = *func2(y++)
		x < y++ - y
		if  x  and  z++ < y
*/


/*
	possible read/write ++ cases (Excluding floats)
	TABL gets the address of a global.
	// do these during optimise? seems better.
	
	glob++,  		x = glob++,		++glob,		// TABL, CNTC			// what if glob is float?
	(*pglb)++,		x = ++(*pglb),	++(*pglb)	// TABL, CNTD

	
	++obj.prop,  	obj.prop++					// READ, CNTC
	(*obj.gprp)++,	++(*obj.gprp)				// READ, READ, CNTC

	x = ++glob									// TABL, CNTD
	local++,	++ local						// .plus()				// gen diff ops per float/int
	x = local++									// assign, .plus()
	
	*(pglb++)									// TABL, READ+
									
	x = *(obj.gprp++),	x = *(pglb++)			// READ, READ+, WRIT (read val, use read for *val++, then write new val)
	x = *(++pglb)								// TABL, .plus(), READ
	++(*obj.gprp)								// READ, CNTD		// what if is float-ptr
	(*plocal)++	/ ++(*plocal)					// CNTC
	*(plocal++)									// READ+
	
	*(++plocal)									// .plus(), READ
	
	
	x = (*pglb)++								// TABL, READ, CNTC
	*(pglb++) = x								// TABL, WRIT+, 
	*(++pglb) = x								// TABL, CNTD, WRIT
	x = *(plocal++)								// READ+
	x = (*plocal)++								// CNTC
	*(plocal++) = x								// WRIT+
	
	*(++pglb) = x								// TABL, CNTD, WRIT
	x = ++(*plocal)								// CNTD
	x = *(++plocal)								// .plus(), READ
	*(++plocal) = x								// .plus(), WRIT
*/


		
function SlowerCountOnAddr (|&ASMState| self, |message| f, |AsmReg| Dest, |int| Mode, |AsmReg| src, |int64| Amount, |asmreg|)
	if mode & IncrAfter
		// still need to read and write
		.Assign(dest, src, asmreg(), f)
		|| b = .AddConstant(f, src, src, amount )
		if b!=src // what?
	  else
		|| b = .AddConstant(f, src, src, amount )
		if b!=src // what?
		.Assign(dest, src, asmreg(), f)
		
		
	.µ(f, dest.set)


function CountOnAddr (|&ASMState| self, |message| f, |AsmReg| Dest, |int| Mode, |AsmReg| src, |int64| Amount, |asmreg|)
	ifn  dest.isint  and  amount <= 63  and  amount >= -64
		return SlowerCountOnAddr(self, f, dest, mode, src, amount)
	|| opp = (ASM.CNTC, ASM.CNTD)(mode & IncrAfter)	
	|| bc  = dest.µtype.ByteCount
	|| log = bc.Log2
	if dest.BitCount * (1<<log) != bc // hmm? maths bug?
	.AddASM(opp, f, src, dest, 0, amount, log)
	return dest


function IncrAmount (|asmreg| dest, |int| mode, |scdecl| D,  |int64|)
	opt norefcounts
	rz = (1,-1)(mode & 1)
	if dest.isfloat
		if dest.FourBytes
			rz = rz|float|.asint
		  else
			rz = rz|f64|.asint
	  elseif D.TypeSuffers
		rz *= D.PointerIncrement



function Incrementatulatorifier		(fn_asm)				// --a++
	visible
	opt	NoRefCounts
	|| f = exp.first!
	|| Src = .µ(f, dest.RequestPos)
	|| Amount = IncrAmount(src, mode, f.FastDecl)
	if src is ContainsAddr
		return CountOnAddr(self, f, dest, mode, src, amount)
	
	expect (src isnt temp) (exp, "Can't increment temporary value.")
	ifn mode & IncrAfter
		return .AddConstant(exp, src, src, Amount)	// ++x,	 y = ++x

	f = f.RemoveTypeCasts!							// x++,	 y = x++
	if f!=@thg
	if .µ(f)!=src
		debugger, .µ(f)
	PostIncrementNil <~ exp							// process later.
	if 0: .DoPostIncr
	return src



function ARel		(fn_asm)
	opt	NoRefCounts
	|| M = (exp.name.first == '+')|int|
	if dest
		M += IncrAfter
	return Incrementatulatorifier(self, exp.first!, dest, M)



function BRel		(fn_asm)						//  --a,  ++a,  &a,  --glob,  --a.b, -a
	opt	NoRefCounts
	|| n = exp.name.first
	|| F = exp.first!
	if n == '&'
		return .µ(F, dest.requestpos)
	if n == '~'
		return dosinglemath(self, exp, dest, scoperator.bnot)
	if n == '!'
		return Not(self, F, dest)

	if exp.name == 1								// -a
		return Minus(Self, f, dest)
	
	|| PlusPlus = n == '+'
	return Incrementatulatorifier(self, F, dest, PlusPlus|int|)



function DoSingleMath (|&ASMState| self, |message| exp, |AsmReg| Dest, |scoperator!| Scop, |AsmReg|)
	|| Src = .µ(exp, dest)
	(src is SingleExpr)
	return DoMathSub(self, exp, dest, src, scop)


function DoMath (fn_asm)
	|| op = exp.second!
	|| scop = op.obj|scoperator|
		return domathsub(self, exp, dest, 0.reg, scop)
	debugger // what?
		

function DoMathSub (|&ASMState| self,  |message| exp,  |AsmReg| Dest,  |asmreg| mr,  |scoperator!| Scop, |AsmReg|)
	opt norefcounts

	|| F = exp.first!
	|| op = f.next!
	
	|| ml = AsmReg()
	if mr isnt singleexpr
		|| OV = .OpenVars
		ml = .µOpen(F)
		mr = .µopen(exp.last!)
		.CloseVars(OV)

	|| fn = scop.asm					#expect (op, "No ASM for this operator?")
	dest = .TempMe(exp, dest) 
	dest.µtype = ml.µtype				// assignment conversion needs doing?	
	(dest as= scop!.code)
	(dest is frommath)

	|| ConstInput = ml is constany  and  mr is constany
		(Dest is mathconst)
	|| R = (fn)(self, dest, ml, mr, op)
	if Constinput and (r isnt mathconst) // hmm?
		debugger 
		(fn)(self, dest, ml, mr, op)
	return .DoConsts(dest, ml, mr)


function Ignore			(fn_asm)


function Unexpected		(fn_asm)
	"Bad asmtmp"
	debugger


}


helper ASMReg.ReadOrWriteSub (|message| m, |datatypecode| t, |int| bytes, |asm|)
	if self is set
		if bytes <= 4
			return ASMtmp.WriteASM[bytes]
		error (m, "Object to large to write")
	  else
		|| B = (bytes<<1) + t.issigned
		if b <= 9
			return ASMtmp.ReadASM[b]
		error (m, "Object to large to read")


function ASMReg.ReadOrWrite (|message| m, |asm|)
	|| T = .µtype
	|| bytes = t.ByteCount.log2
	return .ReadOrWriteSub(m, t, bytes)


function asmstate.ExistingVar (|message| m, |asmreg|)
	opt	norefcounts
	real self
	|| fn = m.func 
	while fn == @bra or @type
		m = m.first!
		fn = m.func
	if fn == @thg
		return asmtmp.thg(asmstate.sh, m, asmtmp.ImmediatesOnly)
	if fn == @num // only if 0.
		|| d = m.fastdecl
		if !d.exportposition
			return asmreg.zero()


function int64.CanStoreAsIntImmediate (|bool|)
	return ((self << 50)>>50) == self


function uint64.CanStoreAsFloatImmediate (|bool|)
	return ((self << 50)>>50) == self

