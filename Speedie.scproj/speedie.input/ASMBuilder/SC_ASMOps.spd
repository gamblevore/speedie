

prototype fn_OpASM (|&ASMState| self, |asmreg| dest, |asmreg| L, |asmreg| R, |message| dbg, |asmreg|)

// do add+mul during opt_phase
// theres a lot more we can do there too.


module asmOps
	function Equals (fn_opasm)
		debugger
		.AddASM(asm.CMPE, dbg, L, R, 1, 0)
		return dest
	function NotEq  (fn_opasm)
		debugger
		.AddASM(asm.CMPN, dbg, L, R, 1, 0)
		return dest
	function Less   (fn_opasm)
		debugger
		.AddASM(asm.CMPI, dbg, L, R, 0, 1)
		return dest
	function LessEq (fn_opasm)
		debugger
		.AddASM(asm.CMPI, dbg, L, R, 0, 1)
		return dest
	function More   (fn_opasm)
		debugger
		.AddASM(asm.CMPI, dbg, L, R, 0, 1)
		return dest
	function MoreEq (fn_opasm)
		debugger
		.AddASM(asm.CMPI, dbg, L, R, 0, 1)
		return dest


	// MATH
	function ASMState.CanAddC (|asmreg| V, |int64| T, |bool|)
		if (V is const) and v.isint
			|| B = (t << 50)>>50
			return B == t
	
	
	function PlusInt     (fn_opasm)
		|| LL = self[L][0],  || RR = self[R][0]
		// a - 1,  a + 1
		// 1 - a,  1 + a
		|| subtract = l is alternate
			RR = -RR
		|| OPP = asm.ADD + subtract
		dest = dest as asmmath.add + subtract

		if (opp == asm.add) and .CanAddC(L, LL)			// 1 + a
			// can we step back one?
			if L is mathconst
				// OK so... what if it is?
				// we can step back one? 
				debugger 
				.curr--
			.AddASM(asm.ADDK, dbg, dest, R, LL)

		  elseif .CanAddC(R, RR)						// a - 1, a + 1
			if L is mathconst
				debugger // same
				.curr--
			.AddASM(asm.ADDK, dbg, dest, L, RR)

		  else
			.AddASM(OPP, dbg, dest, L, R, 0)
		
		if dest is const
			return .DoConsts(dest, L, R)
		return dest

		
	function PlusFloat   (fn_opasm)
		|| SubTract = (l is alternate)
		|| Double = dest.EightBytes
		if !Subtract
			if (l is FromMath) and (l isa ASMMath.Mul)
				// 
		
		|| F = .AddASM(asm.fADD, dbg, dest, l)
		f.r[2+subtract] = r
		f.r[4] = double|int|
		
		if dest is const
			dest = dest as ASMMath.add+subtract
			return .doconsts(dest, L, R)
		return dest

		
	function Plus   (fn_opasm)
		if !r.reg
			return assign(self, dest, l, AsmReg(), dbg)
		if !l.reg and (l isnt alternate)
			return assign(self, dest, R, AsmReg(), dbg)
		if l.isint
			return PlusInt(self, dest, l, r, dbg)
		return PlusFloat(self, dest, l, r, dbg)


	function Subtract  (fn_opasm)
		(l is alternate) // the logic ismostly shared...
		return plus(self, dest, l, r, dbg)

			
	function QuickMul    (fn_opasm)
		|| PToi = .Ptoi(r)
		require ptoi >= 0

		if ptoi <= 1
			if ptoi == 0
				l = asmreg()
			return assign(self, dest, l, asmreg(), dbg)
	
		.AddASM(asm.SHLU , dbg, dest, l, ptoi - 1)
		if dest is const
			|| Val = 1|uint64| << (ptoi-1)
			(Dest as= asmmath.shl)
			return .DoConsts(dest, L, R, val)
		return dest // we just lost a const? we are shifting by a const!

	
	function Mul    (fn_opasm)
		if l.isint
			|| D1 = QuickMul(self, dest, R, L, dbg)
				return D1
			|| D2 = QuickMul(self, dest, L, R, dbg)
				return D2
			.AddASM(asm.MUL , dbg, dest, L, R)
		  else
			.AddASM(asm.FMUL, dbg, dest, L, R).r[4] = l.eightbytes|int|
		if dest is const
			return .doconsts(dest, L, R)
		return dest
	

	function Div    (fn_opasm)
		if dest.isint
			return divint(self, dest, l, r, dbg)
		return divfloat(self, dest, l, r, dbg)
	
	
	function DivFloat    (fn_opasm)
		|| big = dest.eightbytes|int|
		.AddASM(asm.FDIV, dbg, dest, big, L, R)
		|| Alt = l is alternate
			.AddASM(asm.FFRC, dbg, dest, big, dest, R)
		
		if dest is const
			dest = dest as ASMMath.div + alt
			return .doconsts(Dest, L, R)
		return dest
	

	function DivInt    (fn_opasm)
		|| Fat = .AddASM(asm.div, dbg, 0, 0, L, R, dest.intdivtype)
		|| Alt = l is alternate
		fat.r[alt] = dest
		
		if dest is const
			dest = dest as ASMMath.div + alt
			return .doconsts(dest, l, r)
		return dest
	
	
	function Mod    (fn_opasm)
		(l is Alternate)
		return div(self, dest, l, r, dbg)


	// BITS
	function BitXnor (fn_opasm)
		debugat
		return SimpleOp(self, dest, l, r, dbg, asm.BXOR)
	
	function BitXor (fn_opasm)
		return SimpleOp(self, dest, l, r, dbg, asm.BXOR)
	
	function BitOr  (fn_opasm)
		return SimpleOp(self, dest, l, r, dbg, asm.BOR)
	
	function BitAnd (fn_opasm)
		return SimpleOp(self, dest, l, r, dbg, asm.BAND)
	
	function ROL    (fn_opasm)
		return SimpleOp(self, dest, l, r, dbg, asm.BROL)
	
	function ROR    (fn_opasm)
		return SimpleOp(self, dest, l, r, dbg, asm.BROR)
	
	function SHR    (fn_opasm)
		|| shop = asm.SHRU
		if l.signed
			shop = asm.SHRS
			|| bc = l.Âµtype.bitcount 
			expect (bc == 32 or bc == 64) (dbg, "Can't sign-shift this type. (todo)")
			// we could but its gonna add so much complexity... We need to also change how the constants are
			// I'll need to add a bit-masking instruction to the constlist
			// lets just fix this later!
				
		return SimpleOp(self, dest, l, r, dbg, shop)
	
	function SHL    (fn_opasm)
		return SimpleOp(self, dest, l, r, dbg, asm.SHLU)
	
	function Assign (fn_opasm)
		return bitor(self, dest, l, asmreg(), dbg)

	function SimpleOp (|&ASMState| self, |asmreg| dest, |asmreg| L, |asmreg| R, |message| dbg,  |ASM| ASM, |asmreg|)
		.AddASM(asm, dbg, dest, L, R)
		if dest is const
			return .doconsts(dest, l, r)
		return dest
		

