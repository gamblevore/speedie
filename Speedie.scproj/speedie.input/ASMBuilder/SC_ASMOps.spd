

prototype fn_OpASM (|&ASMState| self, |asmreg| dest, |asmreg| L, |asmreg| R, |message| dbg, |asmreg|)

// do add+mul during opt_phase
// theres a lot more we can do there too.


module asmOps
	function Equals (fn_opasm)
		debugger
		.AddASM(asm.CMPE, dbg, L, R, 1, 0)
		return dest
	function NotEq  (fn_opasm)
		debugger
		.AddASM(asm.CMPN, dbg, L, R, 1, 0)
		return dest
	function Less   (fn_opasm)
		debugger
		.AddASM(asm.CMPI, dbg, L, R, 0, 1)
		return dest
	function LessEq (fn_opasm)
		debugger
		.AddASM(asm.CMPI, dbg, L, R, 0, 1)
		return dest
	function More   (fn_opasm)
		debugger
		.AddASM(asm.CMPI, dbg, L, R, 0, 1)
		return dest
	function MoreEq (fn_opasm)
		debugger
		.AddASM(asm.CMPI, dbg, L, R, 0, 1)
		return dest


	// MATH
	function Plus   (fn_opasm)
		.AddASM(asm.ADD, dbg, dest, L, R, 0)
		if dest is const
			|| T = dest.µtype
			|| LL = &.consts[L.reg], || RR = &.consts[R.reg]
			if !T.isfloat
				*LL += *RR
			  elseif t._shift == 2
				*(LL|&float|) += *(RR|&float|)
			  else
				*(LL|&f64  |) += *(RR|&f64  |)
			.consts[dest.reg] = *LL
		return dest
	function Minus  (fn_opasm)
		.AddASM(asm.SUB, dbg, dest, L, R)
		if dest is const
			|| T = dest.µtype
			|| LL = &.consts[L.reg], || RR = &.consts[R.reg]
			if !T.isfloat
				*LL -= *RR
			  elseif t._shift == 2
				*(LL|&float|) -= *(RR|&float|)
			  else
				*(LL|&f64  |) -= *(RR|&f64  |)
			.consts[dest.reg] = *LL
		return dest
	function Mul    (fn_opasm)
		.AddASM(asm.MUL, dbg, dest, L, R)
		if dest is const
			|| T = dest.µtype
			|| LL = &.consts[L.reg], || RR = &.consts[R.reg]
			if !T.isfloat
				*LL *= *RR
			  elseif t._shift == 2
				*(LL|&float|) *= *(RR|&float|)
			  else
				*(LL|&f64  |) *= *(RR|&f64  |)
			.consts[dest.reg] = *LL
		return dest
	function Div    (fn_opasm)
		|| Alt = l is alternate
			.AddASM(asm.div, dbg, dest, 0, L, R)
		  else
			.AddASM(asm.div, dbg, 0, dest, L, R)
		
		//|| x = 0.5 mod 0.1
		if dest is const
			|| T = dest.µtype
			|| LL = &.consts[L.reg], || RR = &.consts[R.reg]
			if !T.isfloat
				if L.signed or R.signed
					if alt
						*(LL|&int64 |) /= *(RR|&int64 |)
					  else
						*(LL|&int64 |) mod= *(RR|&int64 |)
				  else
					if alt
						*(LL|&uint64|) /= *(RR|&uint64|)
					  else
						*(LL|&uint64|) mod= *(RR|&uint64|)
			  elseif t._shift == 2
				*(LL|&float|) /= *(RR|&float|)
			  else
				*(LL|&f64  |) /= *(RR|&f64  |)
			.consts[dest.reg] = *LL
		return dest
	function Mod    (fn_opasm)
		(l is Alternate)
		return div(self, dest, l, r, dbg)


	// BITS
	function BitAnd (fn_opasm)
		.AddASM(asm.BAND, dbg, dest, L, R)
		if dest is const
			.consts[dest.reg] = .consts[L.reg] & .consts[R.reg]
		return dest
	function BitXor (fn_opasm)
		.AddASM(asm.Bxor, dbg, dest, L, R)
		if dest is const
			.consts[dest.reg] = .consts[L.reg] xor .consts[R.reg]
		return dest
	function BitOr  (fn_opasm)
		.AddASM(asm.bor,  dbg, dest, L, R)
		if dest is const
			.consts[dest.reg] = .consts[L.reg] ||| .consts[R.reg]
		return dest
	function ROL    (fn_opasm)
		.AddASM(asm.brol, dbg, dest, L, R)
		return dest
	function ROR    (fn_opasm)
		.AddASM(asm.bror, dbg, dest, L, R)
		return dest
	function SHR    (fn_opasm)
		.AddASM(asm.SHRU, dbg, dest, L, R)
		if dest is const
			|| LL = .consts[L.reg], || RR = .consts[R.reg]
			if dest.µtype.issigned
				.consts[dest.reg] = LL| int64| >> RR|uint64|
			  else
				.consts[dest.reg] = LL|uint64| >> RR|uint64|
		return dest
	function SHL    (fn_opasm)
		.AddASM(asm.SHLS, dbg, dest, L, R)
		if dest is const
			.consts[dest.reg] = .consts[L.reg] << .consts[R.reg]
		return dest
	function Assign (fn_opasm)
		.AddASM(asm.bor,  dbg,  Dest,   L)
		if dest is const
			.consts[dest.reg] = .consts[L.reg]
		return dest

