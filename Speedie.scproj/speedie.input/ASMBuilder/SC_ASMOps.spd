

prototype fn_OpASM (|&ASMState| self, |asmreg| dest, |asmreg| L, |asmreg| R, |message| exp, |asmreg|)


function asmreg.CanAddK (|int64| T, |bool|)
	if (self is const) and .isint
		|| B = (t << 50)>>50
		return B == t


function ASMReg.boolasm (|asmreg|)
	.µtype = DataTypeCode.bool
	
	is AlreadyNegated			// speedie crashing somehow but it is used OK elsewhere?
	if self is CondRequest
		isnt condrequest
		is cond
	return self 
	
	
extend ASMState
	function asmreg.BitsAreCorrect (|int| gap, |bool|)
		return  gap == 0  or   .math is bitcorrect  or   .reg == 0  or  .µtype is bool


	function asmreg.BadBits (|asmreg| r, |errorint|)
		|| gl = .GapBits
		|| gr = r.GapBits
		|| cl =  .BitsAreCorrect(gl)
		|| cr = r.BitsAreCorrect(gr)
		if (cl and cr)
			return 0
		if (gl == gr)
			return gl
		if (gl < gr) and cr
			return gl
		if (gl > gr) and cl
			return gr
		
		return -1
			
		// if the smaller one is bit-correct... its ok? lets see:
		// byte GB vs int  OK	// needs correct
		// int  OK vs byte GB 	// needs correct
		// byte OK vs int  GB 	// can CMPI
		// int  GB vs byte OK	// can CMPI


	function EqualsInt (|asmreg| dest, |asmreg| L, |asmreg| R, |message| exp, |bool| negate, |&FATASM|)
		|| badness = l.BadBits(r) 

		if (dest is condrequest) and (badness >= 0)
			if badness > 0
				dest = .TempMe(exp, dest)
				.AddASM(asm.BCMP, exp, dest, L, R, badness, Negate|int|)
				r = dest
				l = 0.reg
			if !l.reg
				return .AddASM(asm.BRA • negate, exp, R, 1)
			return .AddASM(asm.CMPE • Negate, exp, L, R)

		
		if badness > 0
			return .AddASM(asm.BCMP, exp, dest, L, R, badness, negate|int|)

		if badness == -1
			|| gl = l.GapBits
			|| gr = r.GapBits
			.AddASM(asm.BCLR, exp, L, R, gl, gr, (l.signed|int|) + (r.signed|int|<<1))
		return .AddASM(asm.CMPE • Negate, exp, L, R, dest)
				
	
	function EqualsFloat (|asmreg| dest, |asmreg| L, |asmreg| R, |message| exp, |bool| negate, |&FATASM|)
		|| M = 10
		|| sh = l.GapBits
			m -= 2
		M += negate
		if r.GapBits != sh
			m += 4
		return .AddASM(asm.CMPF, exp, L, R, M, dest) // it is cmpf either way
		
	
	function Equals (fn_opasm)
		if r.reg == 0  and  l.reg != 0
			|| t = l, l = r, r = t // put reg 0 into the left... more convenient.

		|| negate = dest is negate
		target debug
			if !dest.reg and dest isnt CondRequest // shouldn't happen... domathsub allocates a dest!
		
		if dest.IsInt
			.equalsint(dest, l, r, exp, negate)
		  else
			.equalsfloat(dest, l, r, exp, negate)
		return dest.boolasm
	
		
	function NotEq  (fn_opasm)
		(dest is Negate) = (dest isnt Negate)
		return .Equals(dest, l, r, exp)


	function CompareInt (|asmreg| dest, |asmreg| L, |asmreg| R, |message| exp, |int| Mode, |&FATASM|)
/*
		|| bl = l.µtype.bitcount
		|| br = r.µtype.bitcount
		|| bm = bl max br
		
		if bm <= 16
			if bm == 16
				mode += 8
			if !dest.signed
				mode += 4
			.AddASM(asm.CMPS, exp, L, R, mode, dest)
		  else
			if bm == 8
				mode += 8
			if !dest.signed
				mode += 4
			.AddASM(asm.CMPI, exp, L, R, mode, dest)
*/		
		|| negate = false
		|| badness = l.BadBits(r) 

		if (dest is condrequest) and (badness >= 0)
			if badness > 0
				dest = .TempMe(exp, dest)
				.AddASM(asm.BCMP, exp, dest, L, R, badness, Negate|int|)
				r = dest
				l = 0.reg
			return .AddASM(asm.CMPI, exp, L, R)

		
		if badness > 0
			return .AddASM(asm.BCMP, exp, dest, L, R, badness, negate|int|)

		if badness == -1
			|| gl = l.GapBits
			|| gr = r.GapBits
			.AddASM(asm.BCLR, exp, L, R, gl, gr, (l.signed|int|) + (r.signed|int|<<1))
		return .AddASM(asm.CMPI, exp, L, R, dest)


	function CompareFloat (|asmreg| dest, |asmreg| L, |asmreg| R, |message| exp, |int| Mode, |&FATASM|)
/*
	|| bl = l.µtype.bitcount
	|| br = r.µtype.bitcount
	|| bm = bl max br
	
	if bm <= 16 // what?
	if dest.IsBig
		mode += 4
	.AddASM(asm.CMPF, exp, L, R, Mode, dest) // it is cmpf either way
*/	
		|| negate = false
		|| M = 10
		|| sh = l.GapBits
			m -= 2
		M += negate
		if r.GapBits != sh
			m += 4
		return .AddASM(asm.CMPF, exp, L, R, M, dest) // it is cmpf either way


	function Compare (|asmreg| dest,  |asmreg| L,  |asmreg| R,  |message| exp,  |int| Mode,  |asmreg|)
		if dest.IsInt
			.compareint(dest, l, r, exp, mode)
		  else
			.comparefloat(dest, l, r, exp, mode)
		
		return dest.BoolASM
	
	
/*
	0 :		iA >= iB
	1 :		iA <  iB
	2 :		iA <= iB
	3 :		iA >  iB
	4 :		uA >= uB
	5 :		uA <  uB
	6 :		uA <= uB
	7 :		uA >  uB
	8 :		A  >= B 
	9 :		A  <  B 
	10:		A  <= B 
	11:		A  >  B 
	12:		UA >= UB
	13:		UA <  UB
	14:		UA <= UB
	15:		UA >  UB
	0 :		FA >= FB
	1 :		FA <  FB
	2 :		FA <= FB
	3 :		FA >  FB
	4 :		DA >= DB
	5 :		DA <  DB
	6 :		DA <= DB
	7 :		DA >  DB
*/

	function Less   (fn_opasm)
		return .compare(dest, l, r, exp, 0 + (dest isnt Negate))
			
	function MoreEq (fn_opasm)
		return .Compare(dest, l, r, exp, 0 + (dest is Negate))

	function LessEq (fn_opasm)
		(dest is Negate) = (dest isnt Negate)
		return .compare(dest, l, r, exp, 2 + (dest is Negate))

	function More   (fn_opasm)
		return .compare(dest, l, r, exp, 2 + (dest isnt Negate))
	


	// MATH
	
	function f (|asmreg| r, |f64|)
		|| p = self[r]
		if r.fourbytes
			return p|&float|[0]
		return p|&f64|[0]


	function QuickFloatPlus    (fn_opasm)
		require r is const
		|| v = .f(r)
		if v == 0.0
			return .assign(dest, l, asmreg(), exp)
		
		if r.fourbytes
			return .quickfloatop(asm.FADK, exp, dest, l, r)


	function QuickFloatOp (|&asmstate| self, |asm| Op, |message| exp, |asmreg| dest, |asmreg| l, |asmreg| r, |asmreg|)
		|| x = .consts[r.reg]							// how can we test this?
		|| y = x >> 18
		if x == y << 18
			.AddASM(op, exp, dest, l, y)
			return dest

		
	function QuickFloatDiv    (fn_opasm)
		require r is const
		|| p = self[r]
		|ivec2| ex
		// we could optimise f/-1.0 or f/-0.5... but who cares. dont write such dumb code.
		if l.IsBig
			|| f = p|&f64|[0]
			require f > 0
			ex = f.exponent
		  else
			|| f = p|&float|[0]
			require f > 0
			ex = f.exponent
		
		if ex.y == 1
			.AddASM(asm.FEXK, exp, dest, L, 0, ex.x, l.IsBig|int|)
			return dest


	function QuickIntMul    (fn_opasm)
		|| PToi = .IntPowerOftwo(r)$

		if ptoi <= 1
			if ptoi == -1							//   y = x * -1  -->  y = 0-x 
				return .subtract(dest, asmreg(), l, exp)
			if ptoi == 0    						//   y = x * 0   -->  y = 0
				l = asmreg()						//   y = x * 1   -->  y = x 
			return .assign(dest, l, asmreg(), exp)
	
		.AddASM(asm.SHLU , exp, dest, l, ptoi - 1)  // y = x * 4 --> y = x << 2
		return dest


	function QuickFloatMul    (fn_opasm)
		require r is const
		|| v = .f(r)
		if  v == -1.0
			return .Subtract(dest, asmreg(), l, exp)
		
		if  v == 1.0  or  v == 0.0
			if v == 0.0
				l = asmreg()
			return .assign(dest, l, asmreg(), exp)
		
		if  v == 2.0
			return .plus(dest, l, l, exp)
		
		if r.Fourbytes
			return .QuickFloatOp(asm.FMLK, exp, dest, l, r)

	
	function PlusInt     (fn_opasm)
		|| LL = self[L][0],		|| RR = self[R][0]
		//		a - 1,		a + 1
		//		1 - a,		1 + a
		|| subtract = l is alternate
			RR = -RR
			ll = -LL
		|| OPP = asm.ADD + subtract
		(dest as= ASMMath.add + subtract)

		if (opp == asm.add) and l.CanAddK(LL)			// 1 + a
			.AddASM(asm.ADDK, exp, dest, R, LL)

		  elseif r.CanAddK(RR)							// a - 1, a + 1
			.AddASM(asm.ADDK, exp, dest, L, RR)

		  else
			.AddASM(OPP, exp, dest, L, R, 0)
		
		return dest


	function PlusFloat   (fn_opasm)
		|| IsFloat = dest.FourBytes
			if .QuickFloatPlus(dest, r, l, exp)
				return dest
			if .QuickFloatPlus(dest, l, r, exp)
				return dest

		|| SubTract = (l is alternate)
		if !Subtract
			if (l is FromMath) and (l isa ASMMath.Mul)
				// 
		
		|| F = .AddASM(asm.fADD, exp, dest, l)
		f.r[2+subtract] = r|uint|
		f.r[4] = (!IsFloat)|int|
		
		return dest


	function BoolMul (|asmreg| dest, |asmreg| Boo, |asmreg| R, |message| exp, |asmreg|)
		.addasm(asm.TERN, exp, dest, boo, r, 0)
		return dest

		
	function Plus   (fn_opasm)
		if !r.reg
			return .assign(dest, l, AsmReg(), exp)
		if !l.reg and (l isnt alternate)
			return .assign(dest, R, AsmReg(), exp)
		if l.isint
			return .PlusInt(dest, l, r, exp)
		return .PlusFloat(dest, l, r, exp)


	function Subtract  (fn_opasm)
		(l is alternate) // the logic ismostly shared...
		return .plus(dest, l, r, exp)


	function Mul    (fn_opasm)
		|| b = DataTypeCode.bool
		if l isa b
			return .BoolMul(dest, l, r, exp)
		if r isa b
			return .BoolMul(dest, r, l, exp)
			
		if l.isint
			|| D1 = .QuickIntMul(dest, R, L, exp)
				return D1
			|| D2 = .QuickIntMul(dest, L, R, exp)
				return D2
			.AddASM(asm.MUL , exp, dest, L, R)
		  else
			|| D1 = .QuickFloatMul(dest, R, L, exp)
				return D1
			|| D2 = .QuickFloatMul(dest, L, R, exp)
				return D2
			.AddASM(asm.FMUL, exp, dest, L, R, l.IsBig|int|) 
		return dest
	

	function Div    (fn_opasm)
		if dest.isint
			return .DivInt(dest, l, r, exp)
		return .DivFloat(dest, l, r, exp)
	
	
	function DivFloat    (fn_opasm)
		|| D1 = .QuickFloatDiv(dest, R, L, exp)
			return D1
		|| D2 = .QuickFloatDiv(dest, L, R, exp)
			return D2
		|| big = dest.IsBig|int|
		.AddASM(asm.FDIV, exp, dest, big, L, R)
		|| Alt = l is alternate
			.AddASM(asm.FFRC, exp, dest, big, dest, R)
		
		return dest
	

	function DivInt    (fn_opasm)
		|| Fat = .AddASM(asm.div, exp, 0, 0, L, R, dest.IntDivType)
		|| Alt = l is alternate
		fat.r[alt] = dest|uint|
		return dest
	
	
	function Mod    (fn_opasm)
		(l is Alternate)
		return .div(dest, l, r, exp)


	// BITS
	function BitXnor (fn_opasm)
		.AddASM(asm.BXNR, exp, dest, L, R), return dest
	
	function BitXor (fn_opasm)
		.AddASM(asm.BXOR, exp, dest, L, R), return dest

	function BitOr  (fn_opasm)
		.AddASM(asm.BOR, exp, dest, L, R), return dest
	
	function BitAnd (fn_opasm)
		.AddASM(asm.BAND, exp, dest, L, R), return dest
	
	function ROL    (fn_opasm)
		.AddASM(asm.BROL, exp, dest, L, R), return dest
	
	function ROR    (fn_opasm)
		.AddASM(asm.BROR, exp, dest, L, R), return dest
	
	function SHR    (fn_opasm)
		|| up = 64 - l.µtype.bitcount
		if r is const
			|| sh = self[r][0]
			if l.signed
				.AddASM(asm.BFLG, exp, dest, l, up, sh+up)
			  else
				.AddASM(asm.BFLG, exp, dest, l,  0, sh, 1)
			return dest

		|| FAT = .AddASM(asm.SHRS • !l.signed, exp, dest, L, R)
		if l.signed
			FAT.r[3] = up
		return dest
	
	function SHL    (fn_opasm)
		.AddASM(asm.SHLU, exp, dest, L, R), return dest
	
	function Assign (fn_opasm)
		return .bitor(dest, l, asmreg(), exp)


