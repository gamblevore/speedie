

prototype fn_OpASM (|&ASMState| self, |asmreg| dest, |asmreg| L, |asmreg| R, |message| exp, |asmreg|)


function asmreg.CanAddK (|int64| T, |bool|)
	if (self is const) and .isint
		|| B = (t << 50)>>50
		return B == t


function ASMReg.boolasm (|asmreg|)
	.µtype = DataTypeCode.bool
	
	is AlreadyNegated			// speedie crashing somehow but it is used OK elsewhere?
	if self is CondRequest
		isnt condrequest
		is cond
	return self 
	
	
extend ASMState
/*
	// this needs to be put back in!!
		|| tb = t.bitcount
		// why not just call the compare vs 0 function?
		if t.isint
			if  tb == 64 // just because one is 64... doesnt mean both are.
				// of course... we could be comparing to 0.
				// so if we are comparing a 64-bit number to a const... then what?
				// both should be OK really? What if its a 32-bit const? I think not :D
				debugat
				return .AddASM(asm.BRA • Negated, cond, Src, 1)
			
			if (lt is bool or rt is bool)
				.AddASM(asm.BRA • negate, dbg, L, 1)
		  
			if  tb == 32
				debugat
				return .AddASM(asm.CMPI, cond, src, 0, 6 + Negated)

			debugat			// 16 or 8
			|| dest = .AsTemp(src, cond)
			|| Sh = 64 - tb
			.AddASM(asm.BFLG, cond, dest, src, sh, sh, src.signed|int|)
			return .AddASM(asm.CMPE • !Negated, cond, 0, dest)


		|| M = 8 + (tb==64)<<1
		M += Negated
		return .AddASM(asm.CMPF, cond, 0, Src, M)					// comparison against 0
*/


	function asmreg.Compareability (|asmreg| r, |ASMCompareability|)
		|| bl =  .µtype.bitcount
		|| br = r.µtype.bitcount
		if 64 == bl and br
			return -1
		|| cl =  .math is bitcorrect  or   .reg == 0  
		|| cr = r.math is bitcorrect  or  r.reg == 0
		if (cl and cr)
			return ASMCompareability.both  +  (.reg == 0) * ASMCompareability.bra 

		if (bl == br)
			if (br == 32)
				return ASMCompareability.both
			return ASMCompareability.bcmp // 8/16bit compares... may have garbage.
		
		if (bl < br)
			if cl and (br == 32)
				return ASMCompareability.cmpi
		  else
			if cr and (bl == 32)
				return ASMCompareability.cmpi
			
		// if the smaller one is bit-correct... its ok? lets see:
		// byte    vs int OK	// needs correct
		// char    vs int OK	// needs correct
		// byte OK vs int   	// can CMPI
		// char OK vs int		// can CMPI


	function EqualsInt (|asmreg| dest, |asmreg| L, |asmreg| R, |message| exp, |bool| negate, |&FATASM|)
		|| lt = l.µtype
		|| rt = r.µtype
		|| bl = lt.bitcount
		|| br = rt.bitcount
		|| BitsOK = l.Compareability(r) 
		if dest isnt CondRequest  and  bitsok is bcmp
			if !dest.reg // what?? doMathSub???
			return .AddASM(asm.BCMP, exp, dest, L, R, 64 - bl, negate|int|)

		if dest is CondRequest
			if (bitsok is bra)
				return .AddASM(asm.BRA • negate, exp, R, 1)

			if (bitsok is cmpi)
				return .AddASM(asm.CMPE • Negate, exp, L, R, dest)

			if (bitsok is bcmp)											// just... bcmp and then branch
				if dest.reg												// What? Dest should be 0!				
				dest = .tempme(exp, dest)
				.AddASM(asm.BCMP, exp, dest, L, R, 64 - bl, negate|int|)
				return .AddASM(asm.BRA • negate, exp, dest, 1)

		if bitsok is bcmp
			return .AddASM(asm.BCMP, exp, dest, L, R, 64 - bl, negate|int|)
		if bitsok isnt cmpi
			.AddASM(asm.BCLR, exp, L, R, 64-bl, 64-br, (l.signed|int|) + (r.signed|int|<<1))
		return .AddASM(asm.CMPE • Negate, exp, L, R, dest)

				
	
	function EqualsFloat (|asmreg| dest, |asmreg| L, |asmreg| R, |message| exp, |bool| negate, |&FATASM|)
		|| lt = l.µtype
		|| rt = r.µtype
		|| bl = lt.bitcount
		if bl != r.µtype.bitcount, #!l and r have different bitcounts?
		|| sh = 64 - bl
		// depends if this is floats or not. as -0.0 == 0.0
		|| M = 8 + (!sh)<<1
		M += negate
		.AddASM(asm.CMPF, exp, L, R, M, dest) // it is cmpf either way
		
	
	function Equals (fn_opasm)
		if r.reg == 0  and  l.reg != 0
			|| t = l, l = r, r = t // put reg 0 into the left... more convenient.

		|| negate = dest is negate
		target debug
			if !dest.reg and dest isnt condrequest // shouldn't happen... domathsub allocates a dest!
		
		if dest.IsInt
			.equalsint(dest, l, r, exp, negate)
		  else
			.equalsfloat(dest, l, r, exp, negate)
		return dest.boolasm
	
		
	function NotEq  (fn_opasm)
		(dest is Negate) = (dest isnt Negate)
		return .equals(dest, l, r, exp)


	function Compare (|asmreg| dest,  |asmreg| L,  |asmreg| R,  |message| exp,  |int| Mode,  |asmreg|)
		|| bl = l.µtype.bitcount, if bl != r.µtype.bitcount

		mode ^= (dest is negate)
		
		if dest.IsInt
			if dest.IsBig
				mode += 8
			if !dest.signed
				mode += 4
			.AddASM(asm.CMPI, exp, L, R, mode, dest)
		  else
			if dest.IsBig
				mode += 4
			.AddASM(asm.CMPF, exp, L, R, Mode, dest) // it is cmpf either way
	
		return dest.BoolASM
/*
	0 :		iA >= iB
	1 :		iA <  iB
	2 :		iA <= iB
	3 :		iA >  iB
	4 :		uA >= uB
	5 :		uA <  uB
	6 :		uA <= uB
	7 :		uA >  uB
	8 :		A  >= B 
	9 :		A  <  B 
	10:		A  <= B 
	11:		A  >  B 
	12:		UA >= UB
	13:		UA <  UB
	14:		UA <= UB
	15:		UA >  UB
	0 :		FA >= FB
	1 :		FA <  FB
	2 :		FA <= FB
	3 :		FA >  FB
	4 :		DA >= DB
	5 :		DA <  DB
	6 :		DA <= DB
	7 :		DA >  DB
*/

	function Less   (fn_opasm)
		(dest is Negate) = (dest isnt Negate)
		return .moreeq(dest, l, r, exp)
			
	function LessEq (fn_opasm)
		(dest is Negate) = (dest isnt Negate)
		return .more(dest, l, r, exp)

	function More   (fn_opasm)
		debugat // put in actual numbers
		return .Compare(dest, l, r, exp, 3)
	
	function MoreEq (fn_opasm)
		debugat // put in actual numbers
		return .Compare(dest, l, r, exp, 0)


	// MATH
	
	function f (|asmreg| r, |f64|)
		|| p = self[r]
		if r.fourbytes
			return p|&float|[0]
		return p|&f64|[0]


	function QuickFloatPlus    (fn_opasm)
		require r is const
		|| v = .f(r)
		if v == 0.0
			return .assign(dest, l, asmreg(), exp)
		
		if r.fourbytes
			return .quickfloatop(asm.FADK, exp, dest, l, r)


	function QuickFloatOp (|&asmstate| self, |asm| Op, |message| exp, |asmreg| dest, |asmreg| l, |asmreg| r, |asmreg|)
		|| x = .consts[r.reg]							// how can we test this?
		|| y = x >> 18
		if x == y << 18
			.AddASM(op, exp, dest, l, y)
			return dest

		
	function QuickFloatDiv    (fn_opasm)
		require r is const
		|| p = self[r]
		|ivec2| ex
		// we could optimise f/-1.0 or f/-0.5... but who cares. dont write such dumb code.
		if l.IsBig
			|| f = p|&f64|[0]
			require f > 0
			ex = f.exponent
		  else
			|| f = p|&float|[0]
			require f > 0
			ex = f.exponent
		
		if ex.y == 1
			.AddASM(asm.FEXK, exp, dest, L, 0, ex.x, l.IsBig|int|)
			return dest


	function QuickIntMul    (fn_opasm)
		|| PToi = .IntPowerOftwo(r)$

		if ptoi <= 1
			if ptoi == -1							//   y = x * -1  -->  y = 0-x 
				return .subtract(dest, asmreg(), l, exp)
			if ptoi == 0    						//   y = x * 0   -->  y = 0
				l = asmreg()						//   y = x * 1   -->  y = x 
			return .assign(dest, l, asmreg(), exp)
	
		.AddASM(asm.SHLU , exp, dest, l, ptoi - 1)  // y = x * 4 --> y = x << 2
		return dest


	function QuickFloatMul    (fn_opasm)
		require r is const
		|| v = .f(r)
		if  v == -1.0
			return .Subtract(dest, asmreg(), l, exp)
		
		if  v == 1.0  or  v == 0.0
			if v == 0.0
				l = asmreg()
			return .assign(dest, l, asmreg(), exp)
		
		if  v == 2.0
			return .plus(dest, l, l, exp)
		
		if r.Fourbytes
			return .QuickFloatOp(asm.FMLK, exp, dest, l, r)

	
	function PlusInt     (fn_opasm)
		|| LL = self[L][0],		|| RR = self[R][0]
		//		a - 1,		a + 1
		//		1 - a,		1 + a
		|| subtract = l is alternate
			RR = -RR
			ll = -LL
		|| OPP = asm.ADD + subtract
		(dest as= ASMMath.add + subtract)

		if (opp == asm.add) and l.CanAddK(LL)			// 1 + a
			.AddASM(asm.ADDK, exp, dest, R, LL)

		  elseif r.CanAddK(RR)							// a - 1, a + 1
			.AddASM(asm.ADDK, exp, dest, L, RR)

		  else
			.AddASM(OPP, exp, dest, L, R, 0)
		
		return dest


	function PlusFloat   (fn_opasm)
		|| IsFloat = dest.FourBytes
			if .QuickFloatPlus(dest, r, l, exp)
				return dest
			if .QuickFloatPlus(dest, l, r, exp)
				return dest

		|| SubTract = (l is alternate)
		if !Subtract
			if (l is FromMath) and (l isa ASMMath.Mul)
				// 
		
		
		|| F = .AddASM(asm.fADD, exp, dest, l)
		f.r[2+subtract] = r|uint|
		f.r[4] = (!IsFloat)|int|
		
		return dest


	function BoolMul (|asmreg| dest, |asmreg| Boo, |asmreg| R, |message| exp, |asmreg|)
		.addasm(asm.TERN, exp, dest, boo, r, 0)
		return dest

		
	function Plus   (fn_opasm)
		if !r.reg
			return .assign(dest, l, AsmReg(), exp)
		if !l.reg and (l isnt alternate)
			return .assign(dest, R, AsmReg(), exp)
		if l.isint
			return .PlusInt(dest, l, r, exp)
		return .PlusFloat(dest, l, r, exp)


	function Subtract  (fn_opasm)
		(l is alternate) // the logic ismostly shared...
		return .plus(dest, l, r, exp)


	function Mul    (fn_opasm)
		|| b = DataTypeCode.bool
		if l isa b
			return .BoolMul(dest, l, r, exp)
		if r isa b
			return .BoolMul(dest, r, l, exp)
			
		if l.isint
			|| D1 = .QuickIntMul(dest, R, L, exp)
				return D1
			|| D2 = .QuickIntMul(dest, L, R, exp)
				return D2
			.AddASM(asm.MUL , exp, dest, L, R)
		  else
			|| D1 = .QuickFloatMul(dest, R, L, exp)
				return D1
			|| D2 = .QuickFloatMul(dest, L, R, exp)
				return D2
			.AddASM(asm.FMUL, exp, dest, L, R, l.IsBig|int|) 
		return dest
	

	function Div    (fn_opasm)
		if dest.isint
			return .DivInt(dest, l, r, exp)
		return .DivFloat(dest, l, r, exp)
	
	
	function DivFloat    (fn_opasm)
		|| D1 = .QuickFloatDiv(dest, R, L, exp)
			return D1
		|| D2 = .QuickFloatDiv(dest, L, R, exp)
			return D2
		|| big = dest.IsBig|int|
		.AddASM(asm.FDIV, exp, dest, big, L, R)
		|| Alt = l is alternate
			.AddASM(asm.FFRC, exp, dest, big, dest, R)
		
		return dest
	

	function DivInt    (fn_opasm)
		|| Fat = .AddASM(asm.div, exp, 0, 0, L, R, dest.IntDivType)
		|| Alt = l is alternate
		fat.r[alt] = dest|uint|
		return dest
	
	
	function Mod    (fn_opasm)
		(l is Alternate)
		return .div(dest, l, r, exp)


	// BITS
	function BitXnor (fn_opasm)
		.AddASM(asm.BXNR, exp, dest, L, R), return dest
	
	function BitXor (fn_opasm)
		.AddASM(asm.BXOR, exp, dest, L, R), return dest

	function BitOr  (fn_opasm)
		.AddASM(asm.BOR, exp, dest, L, R), return dest
	
	function BitAnd (fn_opasm)
		.AddASM(asm.BAND, exp, dest, L, R), return dest
	
	function ROL    (fn_opasm)
		.AddASM(asm.BROL, exp, dest, L, R), return dest
	
	function ROR    (fn_opasm)
		.AddASM(asm.BROR, exp, dest, L, R), return dest
	
	function SHR    (fn_opasm)
		|| up = 64 - l.µtype.bitcount
		if r is const
			|| sh = self[r][0]
			if l.signed
				.AddASM(asm.BFLG, exp, dest, l, up, sh+up)
			  else
				.AddASM(asm.BFLG, exp, dest, l,  0, sh, 1)
			return dest

		|| FAT = .AddASM(asm.SHRS • !l.signed, exp, dest, L, R)
		if l.signed
			FAT.r[3] = up
		return dest
	
	function SHL    (fn_opasm)
		.AddASM(asm.SHLU, exp, dest, L, R), return dest
	
	function Assign (fn_opasm)
		return .bitor(dest, l, asmreg(), exp)


