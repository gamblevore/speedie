

prototype fn_OpASM (|&ASMState| self, |asmreg| dest, |asmreg| L, |asmreg| R, |message| dbg, |asmreg|)

// do add+mul during opt_phase
// theres a lot more we can do there too.


module asmOps
	function Equals (fn_opasm)
		debugger
		.AddASM(asm.CMPE, dbg, L, R, 1, 0)
		return dest
	function NotEq  (fn_opasm)
		debugger
		.AddASM(asm.CMPN, dbg, L, R, 1, 0)
		return dest
	function Less   (fn_opasm)
		debugger
		.AddASM(asm.CMPI, dbg, L, R, 0, 1)
		return dest
	function LessEq (fn_opasm)
		debugger
		.AddASM(asm.CMPI, dbg, L, R, 0, 1)
		return dest
	function More   (fn_opasm)
		debugger
		.AddASM(asm.CMPI, dbg, L, R, 0, 1)
		return dest
	function MoreEq (fn_opasm)
		debugger
		.AddASM(asm.CMPI, dbg, L, R, 0, 1)
		return dest


	// MATH
	function asmstate.CanAddC (|asmreg| V, |int64| T, |bool|)
		if (V is const) and v.isint
			|| B = (t << 50)>>50
			return B == t
	
	
	function PlusInt     (fn_opasm)
		|| LL = self[L][0], || RR = self[R][0]
		// a - 1,  a + 1
		// 1 - a,  1 + a
		|| Addition = (l isnt alternate)
		if !Addition
			RR = -RR

		if Addition and .CanAddC(L, LL)	// 1 + a
			.AddASM(asm.ADDK, dbg, dest, R, LL)

		  elseif .CanAddC(R, RR)			// a - 1, a + 1
			.AddASM(asm.ADDK, dbg, dest, L, RR)

		  else
			|| OPP = (asm.ADD, asm.SUB)(Addition)
			.AddASM(OPP, dbg, dest, L, R, 0)
		
		if dest is const
			return .doconsts(dest, L, R, opmode.add)
		return dest

		
	function PlusFloat   (fn_opasm)
		|| SubTract = (l is alternate)
		|| Double = dest.EightBytes
		|| F = .AddASM(asm.fADD, dbg, dest, l)
		f.r[2+subtract] = r
		f.r[4] = double|int|
		
		if dest is const
			return .doconsts(dest, L, R, opmode.add+subtract)
		return dest

		
	function Plus   (fn_opasm)
		if !r.reg
			return assign(self, dest, l, asmreg(), dbg)
		if !l.reg and (l isnt alternate)
			return assign(self, dest, R, asmreg(), dbg)
		if l.isint
			return PlusInt(self, dest, l, r, dbg)
		return PlusFloat(self, dest, l, r, dbg)


	function Minus  (fn_opasm)
		(l is alternate) // the logic ismostly shared...
		return plus(self, dest, l, r, dbg)

	
	function Mul    (fn_opasm)
		if l.isint
			.AddASM(asm.MUL , dbg, dest, L, R)
		  else
			.AddASM(asm.FMUL, dbg, dest, L, R).r[4] = l.eightbytes|int|
		if dest is const
			return .doconsts(dest, L, R, opmode.mul)
		return dest
	

	function Div    (fn_opasm)
		if dest.isint
			return divint(self, dest, l, r, dbg)
		return divfloat(self, dest, l, r, dbg)
	
	
	function DivFloat    (fn_opasm)
		|| big = dest.eightbytes|int|
		.AddASM(asm.FDIV, dbg, dest, big, L, R)
		|| Alt = l is alternate
			.AddASM(asm.FFRC, dbg, dest, big, dest, R)
		
		if dest is const
			return .doconsts(Dest, L, R, OpMode.div + alt)
		return dest
	
	

	function DivInt    (fn_opasm)
		|| Fat = .AddASM(asm.div, dbg, 0, 0, L, R, dest.divtype)
		|| Alt = l is alternate
		fat.r[alt] = dest
		
		if dest is const
			return .doconsts(dest, l, r, opmode.div + alt)
		return dest
	
	
	function Mod    (fn_opasm)
		(l is Alternate)
		return div(self, dest, l, r, dbg)


	// BITS
	function BitAnd (fn_opasm)
		.AddASM(asm.BAND, dbg, dest, L, R)
		if dest is const
			return .doconsts(dest, l, r, opmode.ban)
		return dest
	function BitXor (fn_opasm)
		.AddASM(asm.Bxor, dbg, dest, L, R)
		if dest is const
			return .doconsts(dest, l, r, opmode.xor)
		return dest
	function BitOr  (fn_opasm)
		.AddASM(asm.bor,  dbg, dest, L, R)
		if dest is const
			return .doconsts(dest, l, r, opmode.bor)
		return dest
	function ROL    (fn_opasm)
		.AddASM(asm.brol, dbg, dest, L, R)
		return dest
	function ROR    (fn_opasm)
		.AddASM(asm.bror, dbg, dest, L, R)
		return dest
	function SHR    (fn_opasm)
		.AddASM(asm.SHRU, dbg, dest, L, R)
		if dest is const
			return .doconsts(dest, l, r, opmode.shr)
		return dest
	function SHL    (fn_opasm)
		.AddASM(asm.SHLS, dbg, dest, L, R)
		if dest is const
			return .doconsts(dest, l, r, opmode.shl)
		return dest
	function Assign (fn_opasm)
		if dest.reg == l.reg
			return dest // haha!
		return bitor(self, dest, l, asmreg(), dbg)

