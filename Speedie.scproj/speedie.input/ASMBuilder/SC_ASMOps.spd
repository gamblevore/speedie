

prototype fn_OpASM (|&ASMState| self, |asmreg| dest, |asmreg| L, |asmreg| R, |message| dbg, |asmreg|)

// do add+mul during opt_phase
// theres a lot more we can do there too.


module asmOps
	function Plus	(fn_opasm)
		// what about the type? i think we just figure iout.
		debugger
		.AddASM(asm.ADD, dbg, dest, L, R, 0)
		return dest
		
	function Equals (fn_opasm)
		debugger
		.AddASM(asm.CMPE, dbg, L, R, 1, 0)
		return dest
	function NotEq	(fn_opasm)
		debugger
		.AddASM(asm.CMPN, dbg, L, R, 1, 0)
		return dest
	function Less	(fn_opasm)
		debugger
		.AddASM(asm.CMPI, dbg, L, R, 0, 1)
		return dest
	function LessEq (fn_opasm)
		debugger
		.AddASM(asm.CMPI, dbg, L, R, 0, 1)
		return dest
	function More	(fn_opasm)
		debugger
		.AddASM(asm.CMPI, dbg, L, R, 0, 1)
		return dest
	function MoreEq (fn_opasm)
		debugger
		.AddASM(asm.CMPI, dbg, L, R, 0, 1)
		return dest
	function Mod	(fn_opasm)
		debugger
		.AddASM(asm.div, dbg, dest, 31, L, R)
		return dest
	function Div	(fn_opasm)
		debugger 
		.AddASM(asm.div, dbg, 31, dest, L, R)
		return dest
	function Minus	(fn_opasm)
		debugger
		.AddASM(asm.SUB, dbg, dest, L, R)
		return dest
	function Mul	(fn_opasm)
		.AddASM(asm.MUL, dbg, dest, L, R)
		return dest
	function BitAnd (fn_opasm)
		.AddASM(asm.BAND, dbg, dest, L, R)
		return dest
	function BitXor (fn_opasm)
		.AddASM(asm.Bxor, dbg, dest, L, R)
		return dest
	function BitOr	(fn_opasm)
		.AddASM(asm.bor, dbg, dest, L, R)
		return dest
	function ROL	(fn_opasm)
		.AddASM(asm.brol, dbg, dest, L, R)
		return dest
	function ROR	(fn_opasm)
		.AddASM(asm.bror, dbg, dest, L, R)
		return dest
	function SHR	(fn_opasm)
		.AddASM(asm.SHRU, dbg, dest, L, R)
		return dest
	function SHL	(fn_opasm)
		.AddASM(asm.SHLS, dbg, dest, L, R)
		return dest
	function Assign	(fn_opasm)
		.AddASM(asm.bor, dbg, L, R)
		return dest

