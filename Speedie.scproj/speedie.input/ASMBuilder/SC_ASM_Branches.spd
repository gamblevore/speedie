	

extend ASMState {


// abc(), if (x) return, def()   -->   abc(), if !x {def()}, return
function If				(fn_asm)
	opt norefcounts
	debugger
	
	|| cond = exp.first!,  || arg1 = cond.next!
	|| Else = arg1.next!,  || arg2 = else.first
	|message| ElseIfCond
	if arg2 and arg2 != @arg
		ElseIfCond = arg2
		arg2 = arg2.next
	
	|| Flip = !arg1.HasAsmStuff
		if ElseIfCond		// if (x) {} elseif (y) {yy} else {zz} --> if (!x) {if (y) {yy} else {zz}}
			arg1 = ElseIfCond
		  elseif arg2		// if (x) {} else {y()}                --> if (!x) {y()}...
			arg1 = arg2
		  else				// if (X) --> {x} // with discard
			return .µ(cond, asmreg.arg)
		ElseIfCond = nil
		arg2 = nil

	|| B = .Branch(cond, Flip)
	rz = .µ(arg1)
	B.fill(.curr)
	
	if ElseIfCond or arg2.HasAny
		|| AfterFirst = arg1.jump(0) // marks as ended... to prevent opts. can be removed later during optimisation
		if ElseIfCond
			|| a = asmreg()
			rz = .IF(ElseIfCond, a)
		  else
			rz = asmtmp.ARG(self, arg2)
		AfterFirst.jumpto = .curr


function While			(fn_asm)
	opt norefcounts
	.LoopClearUnreliableConsts
	|| BEGIN = exp.JUMP(0)								// jump to end... THEN EMIT arg and jump back.
	ASMTmp.arg(self, exp.second)						// arg

	|| CONTINUE = .curr
	BEGIN.jumpto = CONTINUE
	|| GOBACK = .branch(exp.first!)						// cond
	|| EXIT = .curr
	GOBACK.fill(BEGIN+1)
	|| C = BEGIN

	while C < CONTINUE
		#!ClearExits
		|| op = C.Op
		if op >= kContinue
			C.op = ASM.Jump
			if op == kContinue // continue
				C.jumpto = CONTINUE
			  else       // exit
				C.jumpto = EXIT
		C++
	


function Exit			(fn_asm)
	opt norefcounts
	self <~ (kexit, exp)											// request jump fwd


function Continue		(fn_asm)
	opt norefcounts
	self <~ (kcontinue, exp)										// request jump fwd a little less


function Ternary		(fn_asm)
	opt norefcounts
	
	|| prms = exp.second
	|| cond = prms.first!
	|| A = cond.next!
	|| B = A.next!
	
	|| destType = exp.ASMDecl.typeonly
	|| mA = .ExistingVar(a, desttype)
	|| mB = .ExistingVar(b, desttype)
	if ma!=nil and mb!=nil
		return .SimpleTernary(dest, ma, mb, cond)

	dest = .TempTyped(exp, dest)
	|| FailToSecond = .Branch(cond)
	.µ(A, dest)
	|| Exit = exp.jump(0)

	FailToSecond.fill(.curr)

	rz = .µ(B, dest)
	Exit.r[3] = .curr - Exit
	


function Branch (|message| cond,  |bool| neg=false,  |fatrange|)
	return .branch(cond, ASMReg.negate * neg)


function Branch (|message| cond,  |asmreg| mode,  |fatrange|)
	cpp_Part BranchSub
	rz.x = .curr.index
	(mode as= asmreg.CondRequest)
	|| answer = .µ(cond, mode)
	if answer isnt CondAnswer
		debugat
		if answer isnt alreadynegated
			mode = mode.flip(asmreg.negate)
		answer = .equals(mode, asmreg(), answer, cond)
	rz.y = .last.index



	// if a or b
		// c
	// if TRUE1                --> jump after (b)
	// if false1 and FALSE2    --> leave to owner, on reverse condition

	// if a and b
		// c
	// if false1 --> leave to owner
	// if false2 --> leave to owner


helper DoAndOr (|message| exp,  |ASMReg| Dest,  |opmode| Opp,    |ASMReg|)
	opt norefcounts
	// if a and b
		// c()
	|| A = exp.first!
	|| B = exp.last!
	|| ml = .ExistingVar(A)
	|| mr = .ExistingVar(B)

	|| negate = dest is negate					//  !(a and b) === !a or !b
	if (ml and mr) and !negate
		if ml.reg == mr.reg						// x = a or a --> x = a|bool|
			if ml.µType is bool
				return ml
			return .Equals(dest as asmreg.negate, ml, asmreg(), A)
		if (ml.µtype is bool) and (mr.µType is bool)
			dest = .TempOnly(exp, dest)
			dest.µType = DataTypeCode.bool
			|| fat = exp.BAND(dest, ml, mr, 0)
			if (opp is or)
				fat.op = asm.BOAR
			return fat*dest
	
	if dest isnt CondRequest					// AAARGH
		dest = .NumToReg(exp, 1-negate, dest)
		(dest is alreadynegated)
		#! this works for CONDITIONALS. What about values?
		#! values... we could clear it first... run the first conditionally,
		#! the second branch could just set the value? like a cmp?
	
	  elseif negate								// simplify logic a little.
		(opp xor= OpMode.AndOr)
		(dest isnt negate)
		(dest is alreadynegated)

	if OPP is AND // did I get negate correct?
		.Branch(A, negate)
		return .DoAndPart(Exp, dest, B, negate)

	|| OrBranch = .Branch(A, !negate)
	rz = .DoAndPart(Exp, dest, B, negate)
	orbranch.fill(.curr)	
	


function DoAndPart (|message| exp,  |ASMReg| Dest,  |message|  B,  |bool| Negate,  |ASMReg|)
	if dest isnt CondRequest
		return .Equals(dest, .µ(b), asmreg(), exp)
	.Branch(B, negate)							// opposite jumpyness
	// hmmm?

}




datatype FatRange (ivec2)
	iterator
		|| curr = asmstate.sh.funcstart
		|| final = curr + .y
		curr += .x
		while (curr < final)
			yield curr
			
	function Fill (|&fatasm| curr)
		fatrange.fillconds(.x|uint|.fat, .y|uint|.fat, curr)

	module
		function New (|&fatasm| a, |&fatasm| b, |fatrange|)
			return (a.index, b.index)|fatrange|

		function FillConds (|&fatasm| s, |&fatasm| a, |&fatasm| curr)
			while s <= a
				if s is condanswer
					(s isnt condanswer)
					s.jumpto = curr
				s++

