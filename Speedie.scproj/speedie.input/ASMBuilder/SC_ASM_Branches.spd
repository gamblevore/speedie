	

extend ASMState {


// abc(), if (x) return, def()   -->   abc(), if !x {def()}, return
function If				(fn_asm)
	opt norefcounts
	debugger
	
	|| cond = exp.first!,  || arg1 = cond.next!
	|| Else = arg1.next!,  || arg2 = else.first
	|message| ElseIfCond
	if arg2 and arg2 != @arg
		ElseIfCond = arg2
		arg2 = arg2.next
	
	|| Flip = !arg1.HasAsmStuff
		if ElseIfCond		// if (x) {} elseif (y) {yy} else {zz} --> if (!x) {if (y) {yy} else {zz}}
			arg1 = ElseIfCond
		  elseif arg2		// if (x) {} else {y()}                --> if (!x) {y()}...
			arg1 = arg2
		  else				// if (X) --> {x} // with discard
			return .µ(cond, asmreg.arg)
		ElseIfCond = nil
		arg2 = nil

	|| Start = .Branch(cond, Flip)
	rz = .µ(arg1)
	Start.jumpto = .curr
	if ElseIfCond or arg2.HasAny
		|| AfterFirst = arg1.jump(0) // marks as ended... to prevent opts. can be removed later during optimisation
		if ElseIfCond
			|| a = asmreg()
			rz = .IF(elseifcond, a)
		  else
			rz = asmtmp.ARG(self, arg2)
		AfterFirst.jumpto = .curr

	

function While			(fn_asm)
	opt norefcounts
	.LoopClearUnreliableConsts
	|| BEGIN = exp.JUMP(0)								// jump to end... THEN EMIT arg and jump back.
	ASMTmp.arg(self, exp.second)						// arg

	|| CONTINUE = .curr
	BEGIN.jumpto = CONTINUE
	|| GOBACK = .branch(exp.first!)						// cond
	|| EXIT = .curr
	GOBACK.jumpto = BEGIN+1
	|| C = BEGIN

	while C < CONTINUE
		#!ClearExits
		|| op = C.Op
		if op >= kContinue
			C.op = ASM.Jump
			if op == kContinue // continue
				C.jumpto = CONTINUE
			  else       // exit
				C.jumpto = EXIT
		C++
	


function Exit			(fn_asm)
	opt norefcounts
	self <~ (kexit, exp)											// request jump fwd


function Continue		(fn_asm)
	opt norefcounts
	self <~ (kcontinue, exp)											// request jump fwd a little less


function Ternary		(fn_asm)
	opt norefcounts
	
	|| prms = exp.second
	|| cond = prms.first!
	|| A = cond.next!
	|| B = A.next!
	
	|| destType = exp.ASMDecl.typeonly
	|| mA = .ExistingVar(a, desttype)
	|| mB = .ExistingVar(b, desttype)
	if ma!=nil and mb!=nil
		return .SimpleTernary(dest, ma, mb, cond)

	dest = .TempTyped(exp, dest)
	|| FailToSecond = .Branch(cond)
	.µ(A, dest)
	|| Exit = exp.jump(0)

	FailToSecond.jumpto = .curr

	rz = .µ(B, dest)
	Exit.r[3] = .curr - Exit
	

function Branch (|message| cond,  |bool| neg=false,  |!&fatasm|)
	|| req = asmreg.CondRequest
	if neg
		req = req as asmreg.negate
	|| answer = .µ(cond, req)
	if answer is CondAnswer
		return answer.needfat
	
	// if a + b, so we got (a+b), now we compare it to 0
	if answer isnt alreadynegated
		Req = req.flip(asmreg.negate)
	debugat
	return .equals(req, asmreg(), answer, cond).NeedFAT


helper DoAndOr (|message| exp,  |ASMReg| Dest,  |opmode| Opp,    |ASMReg|)
	opt norefcounts
	// if a and b
		// c()
	|| A = exp.first!
	|| B = exp.last!
	|| ml = .ExistingVar(A)
	|| mr = .ExistingVar(B)

	|| negate = dest is negate				//  !(a and b) === !a or !b
	if (ml and mr) and !negate
		if ml.reg == mr.reg					// x = a or a --> x = a|bool|
			if ml.µType is bool
				return ml
			return .Equals(dest as asmreg.negate, ml, asmreg(), A)
		if (ml.µtype is bool) and (mr.µType is bool)
			dest = .Temponly(exp, dest)
			dest.µType = DataTypeCode.bool
			|| fat = exp.BAND(dest, ml, mr, 0)
			if (opp is or)
				fat.op = asm.BOAR
			return fat*dest
	
	
	|| TmpCloser = .VTmps
	if dest isnt CondRequest				// AAARGH
		dest = .NumToReg(exp, 1-negate, dest)
		(dest is alreadynegated)
		(dest isnt negate)
		#! this works for CONDTIONALS. What about values?
		#! values... we could clear it first... run the first conditionally,
		#! the second branch could just set the value? like a cmp?
	
	  elseif negate // simplify logic a little.
		(opp xor= OpMode.AndOr)
		(dest isnt negate)
		(dest is alreadynegated)

	// now what?
	if OPP is OR
		.Branch(A, negate).JumpTo = .curr
		negate = !negate
	  else
		|| BA = .Branch(A, negate)
		(ba is CondRequest)
	
	|| BB = .Branch(B, negate)  // opposite jumpyness
	(bb is CondRequest)		
	.CloseVTmps(TmpCloser)
	
	if dest isnt CondRequest
		.NumToReg(exp, 0+negate, dest)
//		return .FillConds(Dest)

	return bb.info


}



datatype FatRange (ivec2)
	iterator
		|| curr = asmstate.sh.funcstart
		|| final = curr + .y
		curr += .x
		while (curr < final)
			yield curr

