	

extend ASMState {

// abc(), if (x) return, def()   -->   abc(), if !x {def()}, return
function If				(fn_asm)
	opt norefcounts
	
	|| cond = exp.first!,  || arg1 = cond.next!
	|| Else = arg1.next!,  || arg2 = else.first
	|message| ElseIfCond
	if arg2 and arg2 != @arg
		ElseIfCond = arg2
		arg2 = arg2.next
	
	|| Flip = !arg1.HasAsmStuff
		if ElseIfCond		// if (x) {} elseif (y) {yy} else {zz} --> if (!x) {if (y) {yy} else {zz}}
			arg1 = ElseIfCond
		  elseif arg2		// if (x) {} else {y()}                --> if (!x) {y()}...
			arg1 = arg2
		  else				// if (X) --> {x} // with discard
			return .µ(cond, asmreg.arg)
		ElseIfCond = nil
		arg2 = nil

	|| B = .BranchConstAware(cond, Flip)
	if !b.Constness.KnownFalse
		ASMType.arg(self, arg1)
		B.fill(.curr)
		
	if !b.constness.KnownTrue and (ElseIfCond or arg2.HasAny)
		|| AfterFirst = (arg1.jump(0), nil)(!b.constness.knownfalse) // skip second branch, cos first branch ran
		if ElseIfCond
			.IF(ElseIfCond, asmreg())
		  else
			ASMType.ARG(self, arg2)
		if afterfirst
			AfterFirst.jumpto = .curr
	return asmreg()


function While			(fn_asm)
	opt norefcounts
	|| BEGIN = exp.JUMP(0)							// jump to end... THEN EMIT arg and jump back.
	ASMType.arg(self, exp.second)					// arg

	|| CONTINUE = .Curr
	BEGIN.jumpto = CONTINUE
	|| GOBACK = .BranchSub(exp.first!)
	|| EXIT = .Curr
	GOBACK.Fill(BEGIN+1)
	|| C = BEGIN

	while C < CONTINUE
		#!ClearExits
		|| op = C.Op
		if op >= kContinue
			C.op = ASM.Jump
			if op == kContinue // continue
				C.JumpTo = CONTINUE
			  else       // exit
				C.JumpTo = EXIT
		C++
	


function Exit			(fn_asm)
	opt norefcounts
	self <~ (kexit, exp)											// request jump fwd


function Continue		(fn_asm)
	opt norefcounts
	self <~ (kcontinue, exp)										// request jump fwd a little less


function Ternary		(fn_asm)
	opt norefcounts
	
	|| prms = exp.second
	|| cond = prms.first!
	|| A = cond.next!
	|| B = A.next!
	
	|| destType = exp.ASMDecl.typeonly
	|| mA = .ExistingVar(a)
	|| mB = .ExistingVar(b)
	if (ma isa desttype) and (mb isa desttype) and !desttype.isfloat
		return .SimpleTernary(dest, ma, mb, cond)

	dest = .TempTyped(exp, dest)
	|| FirstOK = .BranchConstAware(cond)
	|| KK = FirstOK.Constness
	if KK.IsKnown
		debugat, #! what about nopping? or does the branch nop?
		|| which = (A,B)(KK.Default)
		return .µInto(which, dest)
	.µInto(A, dest)
	|| Exit = exp.jump(0)

	FirstOK.fill(.curr)

	rz = .µInto(B, dest)
	Exit.r[3] = .curr - Exit


function SimpleTernary (|asmreg| dest, |asmreg| ma, |asmreg| mb, |message| cond, |asmreg|)
	opt norefcounts
	|| dr = dest.reg
	|| mc = (asmreg(), dest)(dr == ma.reg or mb.reg)
	|| µ = .µ(cond, mc)
	return cond.TERN(dest, µ, ma, mb) * dest


function BranchConstAware (|message| cond,  |bool| neg=false, |fatrange|)
	return .Branchsub(cond, neg, true)


function BranchSub (|message| cond,  |bool| neg=false, |bool| CanConst=false, |fatrange|)
	|| mode = (ASMReg.negate * neg) as asmreg.CondRequest
	rz.start = .curr
	|| answer = .µ(cond, mode)
		
	if answer isnt CondAnswer
//		if (answer is constany) and canconst // deal with these const stuff later.
		if answer isnt alreadynegated
			mode = mode.Negate
		answer = .exists(mode, answer, cond)
	rz.after = .curr
	// boolean logic is very awkward


helper ASMBoolShrink (|message| exp,  |ASMReg| Dest,  |ASMReg| ml,  |ASMReg|)
	if (ml.µType is bool) and (dest isnt negate) and (dest isnt condrequest)
		debugat
		return ml.boolanswer							// x = a or a   -->  x = a
	debugat
	return .Exists(dest.negate, ml, exp)				// if  a or a   -->  if a


helper BoolsFromBool (|message| exp, |ASMReg| Dest, |opmode| opp, |ASMReg| ml, |ASMReg| mr, |ASMReg|)
	if true: debugat
	dest = .TempTyped(exp, dest)
	|| fat = exp.BAND(dest, ml, mr, 0)
	fat.op += opp is OR
	if (dest is negate)  and  (opp is AND)
		fat.op = asm.bnot
		(dest is AlreadyNegated)
	if dest isnt negate
		(dest is AlreadyNegated)
	return fat * dest


helper ASMBoolBadnessMadness (|message| exp,  |ASMReg| Dest,  |opmode| Opp,  |ASMReg|)
	opt norefcounts // 😵‍💫 // 😵‍💫 // 😵‍💫 // 😵‍💫 	// deal with consts later!!! :O
	|| A = exp.first!
	|| B = exp.last!
	|| ml = .ExistingVar(A)
	|| mr = .ExistingVar(B)
	
	if ml and ml.reg == mr.reg
		if true: debugat
		return .ASMBoolShrink(exp, dest, ml)

	if dest is negate
		if true: debugat
		(opp xor= OpMode.AndOr)									//  !(a and b)  -->  !a or !b
	
	if dest isnt CondRequest									// 😢 😿 😢 😿 😢 😿 😢 😿 SADNESS!!
		if (ml.µtype is bool) and (mr.µType is bool)
			if true: debugat
			return .BoolsFromBool(exp, dest, opp, ml, mr)		// No consts via .existingvar		
		if true: debugat
		return .BoolValue(A, dest, opp, b)
	
	if OPP is OR
		if true: debugat
		return .BoolOr(A, B, dest)
	if true: debugat
	return .BoolAnd(A, B, Dest)


function BoolValue (|message| A, |ASMReg| Dest, |opmode| Opp, |message| B, |ASMReg|)
	opt norefcounts
	|| req = asmreg() with dest
	|| OpMsg = a.next!
	if !req.reg
		debugat
		req = .TempOnly(opmsg) // we need a shared location!
	
	|| ml = .µinto(A, req)
	if ml is ConstAny
		debugat
		return .BoolConst(b, dest, opp, ml)
	
	|| JUMP = .Exists(ASMReg.CondRequest.negate(opp is or), ml, opmsg).fat!
	|| mr = .µinto(B, req)
	if mr is ConstAny											// Wow this is frustrating!
		debugat
		jump.NOP
		return .BoolConst2(opmsg, dest, opp, mr, ml)

	JUMP.JumpTo = .curr
	
	if (ml.µType is bool and mr.µType is bool)
		debugat
		return ml

	// boolify!
	if true
		debugat
	return .Exists(req, req, opmsg)


function BoolConst2 (|message| exp, |asmreg| dest, |opmode| Opp, |asmreg| ml,  |asmreg| mr, |asmreg|)
	|| V = mr.const!=0
	if v == (opp is AND)
		if true: debugat
		mr.nop
		return .boolify(exp, dest, ml)
	
	if true: debugat
	mr.const = v|int|
	return mr


function Boolify (|message| exp, |asmreg| dest,  |asmreg| Src,   |asmreg|)
	if src.µType is bool
		if true: debugat
	// we don't need to negate... the caller will do that.
	// just needs boolification
		return src
	if true: debugat
	return .Exists(dest.negate, src, exp)
	

function BoolConst (|message| B, |asmreg| dest, |opmode| Opp, |asmreg| ml, |asmreg|)
	|| V = (ml.const!=0) != (dest is negate)
	|| expect = opp is OR
	if v == expect
		debugat
		ml.Const = v|int|		// x = 5 or  2 --> x = true
		return ml				// x = 0 and 2 --> x = false
								
	ml.nop						// x = 0 or y  --> x = y
								// x = 7 and y --> x = y
	|| mr = .µ(B, asmreg() with dest)
	if mr is ConstAny
		debugat
		mr.const = (mr.const != 0)|int|
		return mr.BoolAnswer
	
	if true: debugat
	return .boolify(B, dest, mr)
// we could delay boolification... needs a fresh mind.
// x = a or b or c or d or e     // any could happen, not all will be bools.
// y = a and b and c and d and e // only the last... but either way we do the conversion AFTER


function BoolAnd (|message| A, |message| B, |asmreg| dest, |asmreg|)
	|| FirstPart = .BranchConstAware(A, dest is negate)
	|| KK = FirstPart.Constness
	if KK.IsKnown
		if KK.KnownTrue
			debugat
			FirstPart.nop
			|| tmp = .BranchConstAware(b, dest is negate)
		debugat
		return dest.boolanswer
		
	debugat
	|| tmp2 = .BranchConstAware(B, dest is negate)
	return dest.BoolAnswer



function BoolOr (|message| A, |message| B, |asmreg| dest,   |asmreg|)
	if (true)
		debugat
	|| FirstPart = .BranchConstAware(A, dest isnt negate)
	|| KK = FirstPart.Constness
	if !KK.KnownTrue
		debugat
		|| part2 = .BranchConstAware(B, dest is negate)
		FirstPart.fill(.curr)	
	return dest.BoolAnswer

}



Struct FatRange
	|&FatASM| Start
	|?&FatASM| After
	iterator
		|| curr = .start
		while (curr < .after)
			yield curr
			curr++
	
	function Nop
		for s in self
			s.nop
	
	function Fill (|&fatasm| curr)
		|| any = false
		curr--
		for s in self
			if s is condanswer
				(s isnt condanswer)
				s.jumpto = curr
				any = true
		if !any // what?
	
	function Constness (|maybebool|)
		|| a = .After|uint64|
		if a <= 1
			return a|maybebool|
		
