	

extend ASMState {

// abc(), if (x) return, def()   -->   abc(), if !x {def()}, return
function If				(fn_asm)
	opt norefcounts
	
	|| cond = exp.first!,  || arg1 = cond.next!
	|| Else = arg1.next!,  || arg2 = else.first
	|message| ElseIfCond
	if arg2 and arg2 != @arg
		ElseIfCond = arg2
		arg2 = arg2.next
	
	|| Flip = !arg1.HasAsmStuff
		if ElseIfCond		// if (x) {} elseif (y) {yy} else {zz} --> if (!x) {if (y) {yy} else {zz}}
			arg1 = ElseIfCond
		  elseif arg2		// if (x) {} else {y()}                --> if (!x) {y()}...
			arg1 = arg2
		  else				// if (X) --> {x} // with discard
			return .µ(cond, asmreg.arg)
		ElseIfCond = nil
		arg2 = nil

	|| B = .Branch(cond, Flip)		// const aware
	if !B.Never
		ASMType.arg(self, arg1)
		B.fill(.curr)
		
	if !b.always and (ElseIfCond or arg2.HasAny)
		|| AfterFirst = (arg1.jump(0), nil)(!b.never) // skip second branch, cos first branch ran
		if ElseIfCond
			.IF(ElseIfCond, asmreg())
		  else
			ASMType.ARG(self, arg2)
		if afterfirst
			AfterFirst.jumpto = .curr
	return asmreg()


function While			(fn_asm)
	opt norefcounts
	|| BEGIN = exp.JUMP(0)							// jump to end... THEN EMIT arg and jump back.
	ASMType.arg(self, exp.second)					// arg

	|| CONTINUE = .Curr
	BEGIN.jumpto = CONTINUE
	|| GOBACK = .Branch(exp.first!, false, false)	// no const
	|| EXIT = .Curr
	GOBACK.Fill(BEGIN+1)
	|| C = BEGIN

	while C < CONTINUE
		#!ClearExits
		|| op = C.Op
		if op >= kContinue
			C.op = ASM.Jump
			if op == kContinue // continue
				C.JumpTo = CONTINUE
			  else       // exit
				C.JumpTo = EXIT
		C++
	


function Exit			(fn_asm)
	opt norefcounts
	self <~ (kexit, exp)											// request jump fwd


function Continue		(fn_asm)
	opt norefcounts
	self <~ (kcontinue, exp)										// request jump fwd a little less


function Ternary		(fn_asm)
	opt norefcounts
	
	|| prms = exp.second
	|| cond = prms.first!
	|| A = cond.next!
	|| B = A.next!
	
	|| destType = exp.ASMDecl.typeonly
	|| mA = .ExistingVar(a)
	|| mB = .ExistingVar(b)
	if (ma isa desttype) and (mb isa desttype) and !desttype.isfloat
		return .SimpleTernary(dest, ma, mb, cond)

	dest = .TempTyped(exp, dest)
	|| FirstOK = .Branch(cond)		// const aware
	if FirstOK.const
		return .µInto((A,B)(FirstOK.always), dest)
	.µInto(A, dest)
	|| Exit = exp.jump(0)

	FirstOK.fill(.curr)

	rz = .µInto(B, dest)
	Exit.r[3] = .curr - Exit


function SimpleTernary (|asmreg| dest, |asmreg| ma, |asmreg| mb, |message| cond, |asmreg|)
	opt norefcounts
	|| dr = dest.reg
	|| mc = (asmreg(), dest)(dr == ma.reg or mb.reg)
	|| µ = .µ(cond, mc)
	return cond.TERN(dest, µ, ma, mb) * dest


function Branch (|message| cond,  |bool| neg=false, |bool| CanConst=true, |fatrange|)
	cpp_Part BranchSub
	|| mode = (ASMReg.negate * neg) as asmreg.CondRequest
	rz.start = .curr
	|| answer = .µ(cond, mode)
		
	if answer isnt CondAnswer
//		if (answer is constany) and canconst // deal with these const stuff later.
		if answer isnt alreadynegated
			mode = mode.Negate
		answer = .equals(mode, asmreg(), answer, cond)
	rz.after = .curr
	// boolean logic is very awkward



helper ASMBoolShrink (|message| exp,  |ASMReg| Dest,  |ASMReg| ml,  |ASMReg|)
	if (ml.µType is bool) and (dest isnt negate) and (dest isnt condrequest)
		debugat
		return ml										// x = a or a   -->  x = a
	debugat
	return .Equals(dest.negate, ml, asmreg(), exp)		// if  a or a   -->  if a


helper ASMBoolifier (|message| exp, |ASMReg| Dest, |opmode| opp, |ASMReg| ml, |ASMReg| mr, |bool| negate, |ASMReg|)
	dest = .Temptyped(exp, dest)
	|| fat = exp.BAND(dest, ml, mr, 0)
	fat.op += opp is OR
	if negate  and  opp is AND
		fat.op = asm.bnot
		(dest is alreadynegated)
	return fat * dest



helper ASMBoolBadnessMadness (|message| exp,  |ASMReg| Dest,  |opmode| Opp,  |ASMReg|)
	opt norefcounts // 😵‍💫 // 😵‍💫 // 😵‍💫 // 😵‍💫 	// deal with consts later!!! :O
	|| A = exp.first!
	|| B = exp.last!
	|| ml = .ExistingVar(A) // OrBoolConst(A)
	|| mr = .ExistingVar(B) // OrBoolConst(B)
	
	if ml and ml.reg == mr.reg
		return .ASMBoolShrink(exp, dest, ml)

	|| negate = (dest is negate)|bool|
		(opp xor= OpMode.AndOr)		//  !(a and b)  -->  !a or !b
		(dest isnt negate)
	
	if dest isnt CondRequest		// 😢 😿 😢 😿 😢 😿 😢 😿 SADNESS!!
		if (ml.µtype is bool) and (mr.µType is bool)
			return .ASMBoolifier(exp, dest, opp, ml, mr, negate)
		
		// Now what? OK lets plan this out.
		// * we need to do branching
		// * It would be nice to handle consts too. like x = 2 and 1
		// * We can do the conversion to bool... after the set... assuming that either isn't bool.		
		
		ml = .µ(A, ml with dest)
		mr = .µ(B, ml.with(dest, ml))
	
	
	|| Neg1 = negate != (opp is OR)
	|| FirstPart = .Branch(A, neg1)			// const aware
	if OPP is AND 
		if firstpart.const
			if firstpart.always
				firstpart = .branch(b, negate)		// const aware
			return asmreg().boolanswer
			
		firstpart = .branch(B, negate)
		return dest.BoolAnswer

	if FirstPart.always
		return dest.boolanswer()
	|| part2 = .branch(B, negate)
	FirstPart.fill(.curr)	
	return dest.BoolAnswer
}




Struct FatRange
	|&FatASM| Start
	|?&FatASM| After
	iterator
		|| curr = .start
		while (curr < .after)
			yield curr
			curr++
			
	function Fill (|&fatasm| curr)
		|| any = false
		curr--
		for s in self
			if s is condanswer
				(s isnt condanswer)
				s.jumpto = curr
				any = true
		if !any // what?
	
	function Const (|bool|)
		return .after <= 1|&fatasm|
	
	function Never (|bool|)
		return .After == 0|&fatasm|
		
	function Always (|bool|)
		return .after == 1|&fatasm|


