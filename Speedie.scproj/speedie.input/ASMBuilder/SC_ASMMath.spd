

prototype fn_OpASM (|&ASMState| self, |asmreg| dest, |asmreg| L, |asmreg| R, |message| exp, |asmreg|)


extend asmreg
	function boolasm (|asmreg|)
		.µtype = DataTypeCode.bool
		
		is AlreadyNegated			// speedie crashing somehow but it is used OK elsewhere?
		if self is CondRequest
			isnt condrequest
			is cond
		return self 
		
		
	function BitsAreCorrect (|int| gap, |bool|)
		return  gap == 0  or   .math is bitcorrect  or   .reg == 0  or  .µtype is bool


	function BadBits (|asmreg| r, |errorint|)
		|| gl = .GapBits
		|| gr = r.GapBits
		|| cl =  .BitsAreCorrect(gl)
		|| cr = r.BitsAreCorrect(gr)
		if (cl and cr)
			return 0
		if (gl == gr)
			return gl
		if (gl < gr) and cr
			return gl
		if (gl > gr) and cl
			return gr
		
		return -1
			
		// if the smaller one is bit-correct... its ok? lets see:
		// byte GB vs int  OK	// needs correct
		// int  OK vs byte GB 	// needs correct
		// byte OK vs int  GB 	// can CMPI
		// int  GB vs byte OK	// can CMPI



extend ASMState
	function EqualsInt (|asmreg| dest, |asmreg| L, |asmreg| R, |message| exp, |&FATASM|)
		|| negate = dest is negate
		|| badness = l.BadBits(r) 

		if (dest is condrequest) and (badness >= 0)
			if badness > 0
				dest = .TempMe(exp, dest)
				.AddASM(asm.BCMP, exp, dest, L, R, badness, Negate|int|)
				r = dest
				l = 0.reg
			if !l.reg
				return .AddASM(asm.BRAA • negate, exp, R, 1)
			return .AddASM(asm.JMPE • Negate, exp, L, R)

		
		if badness > 0
			return .AddASM(asm.BCMP, exp, dest, L, R, badness, negate|int|)

		if badness == -1
			|| gl = l.GapBits
			|| gr = r.GapBits
			.AddASM(asm.BCLR, exp, L, R, gl, gr, (l.signed|int|) + (r.signed|int|<<1))
		return .AddASM(asm.JMPE • Negate, exp, L, R, dest)
				
	
	
	function Equals (fn_opasm)
		if r.reg == 0  and  l.reg != 0
			swap (l) (r) // put reg 0 into the left... more convenient.

		if dest.IsInt
			.equalsint(dest, l, r, exp)
		  else
			|| Mode = 2+(dest is negate)
			.Compare(dest, l, r, exp, mode)
		return dest.boolasm
	
		
	function NotEq  (fn_opasm)
		return .Equals(dest.negate, l, r, exp)


	function CompareInt (|asmreg| dest, |asmreg| L, |asmreg| R, |message| exp, |int| Mode, |&FATASM|)
		|| bb = l.bitcount max r.bitcount
		if !l.signed
			mode += 8
			if r.signed and r.bitcount >= l.bitcount // bad
		  elseif !r.signed
			if l.signed and l.bitcount >= r.bitcount // bad

		|| bigness = (bb.log2-3)<<1
		mode += bigness
		
		if l.BadBits(r) 
			|| gl = l.GapBits
			|| gr = r.GapBits
			.AddASM(asm.BCLR, exp, L, R, gl, gr, (l.signed|int|) + (r.signed|int|<<1))

		|| OPP = (asm.JMPI, asm.CMPI)(dest is condrequest)
		return .AddASM(OPP, exp, L, R, mode, dest)


	function CompareFloat (|asmreg| dest, |asmreg| L, |asmreg| R, |message| exp, |int| Mode, |&FATASM|)
		mode += 8 * l.isbig
		mode += 4 * r.isbig
		|| OPP = (asm.JMPF, asm.CMPF)(dest is condrequest)
		return .AddASM(OPP, exp, L, R, Mode, dest) // it is cmpf either way


	function Compare (|asmreg| dest,  |asmreg| L,  |asmreg| R,  |message| exp,  |int| Mode,  |asmreg|)
		if dest.IsInt
			.compareint(dest, l, r, exp, mode)
		  else
			.comparefloat(dest, l, r, exp, mode)
		
		return dest.BoolASM
	
	function Less   (fn_opasm)
		return .compare(dest, l, r, exp, 1)

	function MoreEq (fn_opasm)
		return .compare(Dest, r, l, exp, 1)

	function More   (fn_opasm)
		return .compare(dest, l, r, exp, 0)

	function LessEq (fn_opasm)
		return .compare(Dest, r, l, exp, 0)
	


	// MATH
	
	
	function TypeCast (fn_opasm)
//function DoSingleMath (|&ASMState| self, |message| exp, |AsmReg| Dest, |scoperator!| Scop, |AsmReg|)
//	|| Src = .µ(exp, dest)
//	(src is SingleExpr)
//		.AddBit( "",	"RotateRight",	&asmstate.ROR,		asmmath.ROR,	opmode.shift)
//	return DoMathSub(self, exp, dest, src, scop)
		
	
	function f (|asmreg| r, |f64|)
		|| p = self[r]
		if r.fourbytes
			return p|&float|[]
		return p|&f64|[]


	function QuickFloatPlus    (fn_opasm)
		require r is ConstAny
		|| v = .f(r)
		if v == 0.0
			return .assign(dest, l, asmreg(), exp)
		
		if r.fourbytes
			|| k = .Consts[r.reg]
			if (k >> 18) << 18 != k
				debugger, #!hmmm. const-optimiser/renderer will handle it, but lets check to make sure
			.AddASM(asm.fadk, exp, dest, l, k)
			return dest


	function QuickFloatDiv    (fn_opasm)
		require r is ConstAny
		|| p = self[r]
		|ivec2| ex
		// we could optimise f/-1.0 or f/-0.5... but who cares. dont write such dumb code.
		if l.IsBig
			|| f = p|&f64|[0]
			require f > 0
			ex = f.exponent
		  else
			|| f = p|&float|[0]
			require f > 0
			ex = f.exponent
		
		if ex.y == 1
			.AddASM(asm.FEXK, exp, dest, L, 0, ex.x, l.IsBig|int|)
			return dest


	function QuickIntMul    (fn_opasm)
		|| PToi = .IntPowerOftwo(r)$

		if ptoi <= 1
			if ptoi == -1							//   y = x * -1  -->  y = 0-x 
				return .subtract(dest, asmreg(), l, exp)
			if ptoi == 0    						//   y = x * 0   -->  y = 0
				l = asmreg()						//   y = x * 1   -->  y = x 
			return .assign(dest, l, asmreg(), exp)
	
		.AddASM(asm.BLUE , exp, dest, l, ptoi - 1)  // y = x * 4 --> y = x << 2
		return dest


	function QuickFloatMul    (fn_opasm)
		require r is ConstAny	
		|| v = .f(r)
		if  v == -1.0
			return .Subtract(dest, asmreg(), l, exp)
		
		if  v == 1.0  or  v == 0.0
			if v == 0.0
				l = asmreg()
			return .assign(dest, l, asmreg(), exp)
		
		if  v == 2.0
			return .plus(dest, l, l, exp)
		
		if r.Fourbytes
			|| x = .consts[r.reg]
			|| y = x >> 18
			if x == y << 18
				.AddASM(asm.FMLK, exp, dest, l, x)
				return dest

	
	function PlusInt     (fn_opasm)
		|| LL = self[L][0],		|| RR = self[R][0]
		//		a - 1,		a + 1
		//		1 - a,		1 + a
		|| subtract = l is alternate
			RR = -RR
			ll = -LL
		|| OPP = asm.ADD + subtract
		(dest as= ASMMath.add + subtract)

		// the const system could make this code irrelevant?
		// we just do the addk at render-time?
//		if !subtract and l.CanAddK(LL)					// 1 + a
//			.AddASM(asm.ADDK, exp, dest, R, LL)
//
//		  elseif r.CanAddK(RR)							// a - 1, a + 1
//			.AddASM(asm.ADDK, exp, dest, L, RR)
//
//		  else
		.AddASM(OPP, exp, dest, L.l(r), R.r(l))
		
		return dest


	function PlusFloat   (fn_opasm)
		|| IsFloat = dest.FourBytes
			if .QuickFloatPlus(dest, r, l, exp)
				return dest
			if .QuickFloatPlus(dest, l, r, exp)
				return dest

		|| SubTract = (l is alternate)
		|| F = .AddASM(asm.fADD, exp, dest, l)
		f.r[2+subtract] = r|uint|
		f.r[4] = (!IsFloat)|int|

// do this transform here:
// p1 = p2 * k3,  f1 = f2 + p1  -->  f1 = f2 + (p2 << log2(k3))	
// we need the info on double/float...
//	if p isa ASM.FMLK
//		|| k = p.a3|int|.asfloat.Log2
//		require !k.Fract and !.match3_2(out)
//		.op = asm.fexk
//		.a3 = p.a2
//		.a4 = k|int|
//		return true
// FEXK  (FloatAddExp)
//		f1 = FloatSh1(u2, r4) + FloatSh1(u3, r5)
		
		return dest


	function BoolMul (|asmreg| dest, |asmreg| Boo, |asmreg| V, |message| exp, |asmreg|)
		.addasm(asm.TERN, exp, dest, boo, V)
		return dest

		
	function Plus   (fn_opasm) // add (
		if !r.reg
			return .assign(dest, l, AsmReg(), exp)
		if !l.reg and (l isnt alternate)
			return .assign(dest, R, AsmReg(), exp)
		if l.isint
			return .PlusInt(dest, l, r, exp)
		return .PlusFloat(dest, l, r, exp)


	function Subtract  (fn_opasm)
		(l is alternate) // the logic ismostly shared...
		return .plus(dest, l, r, exp)


	function Mul    (fn_opasm)
		|| b = DataTypeCode.bool
		if l isa b
			return .BoolMul(dest, l, r, exp)
		if r isa b
			return .BoolMul(dest, r, l, exp)
			
		if l is ConstAny
			swap (l) (r)
		if l.isint
			|| D1 = .QuickIntMul(dest, R, L, exp)
				return D1
			|| D2 = .QuickIntMul(dest, L, R, exp)
				return D2
			.AddASM(asm.MULT , exp, dest, L, R)
		  else
			|| D1 = .QuickFloatMul(dest, R, L, exp)
				return D1
			|| D2 = .QuickFloatMul(dest, L, R, exp)
				return D2
			.AddASM(asm.FMUL, exp, dest, L, R, l.IsBig|int|) 
		return dest
	

	function Div    (fn_opasm)
		if dest.isint
			return .DivInt(dest, l, r, exp)
		return .DivFloat(dest, l, r, exp)
	
	
	function DivFloat    (fn_opasm)
		|| D1 = .QuickFloatDiv(dest, R, L, exp)
			return D1
		|| D2 = .QuickFloatDiv(dest, L, R, exp)
			return D2
		|| big = dest.IsBig|int|
		.AddASM(asm.FDIV, exp, dest, big, L, R)
		|| Alt = l is alternate
			.AddASM(asm.FFRC, exp, dest, big, dest, R)
		
		return dest
	

	function DivInt    (fn_opasm)
		|| Fat = .AddASM(asm.DIVV, exp, 0, 0, L, R, dest.IntDivType)
		|| Alt = l is alternate
		fat.r[alt] = dest|uint|
		return dest
	
	
	function Mod    (fn_opasm)
		(l is Alternate)
		return .div(dest, l, r, exp)


	// BITS
	function BitNot (fn_opasm)
		if r.reg // what?
		.AddASM(asm.BNOT, exp, dest, l, l), return dest
	
	function BitXor (fn_opasm)
		if (l.reg == r.reg)
			return .BitOr(dest, asmreg(), asmreg(), exp)
		.AddASM(asm.BXOR, exp, dest, L.l(r), R.r(l)), return dest

	function BitOr  (fn_opasm)
		if l is ConstAny
			swap (l) (r)
		|| dd = dest.reg					#debug_require
		|| rr = r.reg,  || ll = l.reg
		if ll == 0							// swap
			|| tt = ll,  ll = rr,  rr = tt
		  elseif (ll == rr)
			rr = 0							// same thing
		if rr == 0 and dd == ll
			return dest						// no need
		.AddASM(asm.BOAR, exp, dest, L, R), return dest
	
	function BitAnd (fn_opasm)		
		.AddASM(asm.BAND, exp, dest, L.l(R), R.r(l)), return dest
	
	function ROL    (fn_opasm)
		.AddASM(asm.BROL, exp, dest, L, R), return dest
	
	function ROR    (fn_opasm)
		.AddASM(asm.BROR, exp, dest, L, R), return dest
	
	function ConstForShift (|asmreg| r, |int| btc, |message| exp,  |int64|)
		rz = self[r][] #debug_require
		if rz < 0
			error (exp, "Can't negative shift")
		  elseif rz >= btc
			error (exp, "Shift too large for type")
		
		
	function SHR    (fn_opasm)
		if !r.Reg
			return l
		|| btc = l.bitcount
		|| up = 64 - btc
		if r is ConstAny
			|| sh = .ConstForShift(r, btc, exp)
			if !sh: return l // what?
			if l.signed
				.AddASM(asm.BFLG, exp, dest, l, up, sh+up)
			  else
				.AddASM(asm.BFLG, exp, dest, l,  0, sh, 1)
			return dest

		|| FAT = .AddASM(asm.BRUS • !l.signed, exp, dest, L, R)
		if l.signed
			FAT.r[3] = up
		return dest
	
	
	function SHL    (fn_opasm)
		if !r.Reg
			return l
		|| btc = l.bitcount
		|| up = 64 - btc
		if r is ConstAny
			|| sh = .ConstForShift(r, btc, exp)
			if !sh: return l // what?
			.AddASM(asm.BFLG, exp, dest, l,  sh, 0, 1)
			return dest
		.AddASM(asm.BLUE, exp, dest, L, R), return dest
	
	
	function Assign (fn_opasm)
		return .bitor(dest, l, asmreg(), exp)



function asmreg.l (|asmreg| r, |asmreg|)
	return (r, self)(self is ConstAny)


function asmreg.r (|asmreg| r, |asmreg|)
	return (r, self)(r is ConstAny)

