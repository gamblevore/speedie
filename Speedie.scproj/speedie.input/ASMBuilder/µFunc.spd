

extend SCFunction
	function µTest (|memory of asm|)
		description "Generate some code (only for testing)."
		rz = asm[.µlength|int|*3]!
		|| p = rz.ptr
		|| after = .FinalPass(P, P+rz.Size)
		rz.Size = after-p
		rz.length = rz.Size
		
	// cosmic lore unfold... into tales untold

	function FatFirst (|&fatasm|)
		return Assembler.sh.start + .µstart
	
	
	function FinalPass (|!&ASM| Where, |!&asm| After, |!&asm|)
		|uint64| HasLabel
		rz = where
		for (fat.fat in self) (i)
			haslabel |= fat.JumpPrm << (i&63)
			|| n = rz - where
			if n >= 64K
				error (.source, "Function too large (over 256K)")
			fat.ASMIndex = n
			fat.CheckHasOutput
			rz = fat.µRenderInto(rz, after)

		if HasLabel // Use this as a jump-map??? To skip huge sections?
			for fat.fat in self
				|| r = fat.JumpPrm
					fat.FillLabelRequest(where, rz, r-1)

	
	target debug
		render µRender (|bool|RenderBlocks=false)
			fs <~ "asm ${.exportname}   ${.µLengthguess*4}\n" // " asm " "asm"
			|| bb = 0
			for µ.fat in self
				if RenderBlocks and µ.BasicBlock != bb
					bb = µ.BasicBlock
					fs <~ "//$bb\n"
				µ.RenderFat(fs)
				fs <~ '\n'


/// TEXTUAL STUFF		
	function µPrint 
		target debug
			printline self
			printline .µRender


	iterator fat
		|| FirstInst = .FatFirst
		|| CurrInst = FirstInst
		|| AfterInst = Currinst + .µlength
		while currinst < Afterinst
			yield currinst (CurrInst - FirstInst)
			++currinst
	


function fatasm.FillLabelRequest (|!&asm| Start, |!&asm| After, |int| reg)
	|| SelfOut = start + .ASMIndex
	target debug: debug_require  SelfOut >= start  and  SelfOut < after 

	// this needs fixing.
	|int| J = .prms[reg]
	|| OldDest = self + J + 1
	|| DestOut = OldDest.asmindex
	|| dest = start + DestOut

	target debug: debug_require dest >= start and dest <= after
	|| J2 = (dest - SelfOut) -1
	check (J2 != -1) (self, "Infinite loop")
	.prms[reg] = J2
	.µRenderInto(SelfOut, SelfOut+1)		// rerender
	.prms[reg] = J							// restore!



function fatasm.TryRotateConst
	|| v = .const|uint64|
	|| OtherInv = (~v, v)(v>>63)
	require otherinv >> 17
	
	|| Inv = V.CountBits > 32 
		V = ~V
	|| LBS = (~V).LongestBitStretch			// longest false-stretch
	require LBS.x >= (64-12)				// can only store 12-bits
	
	|| ramount = 63-LBS.y 
	V = V.rotl(ramount)
	._op = asm.knsr							// easier to debug
	.r1 = ramount
	.r2 = inv|int|
	.r3 = v|uint|
	target debug
		|| back = .prms[3]|uint64|.rotr(.prms[1]|uint64|)
		if .prms[2]
			back = ~back
		if back!=.const // oof



function JBin.AddFunction (|SCFunction| fn)
	// need aligning each.
//	|| M = .ReserveMemory(@bin, n)
	|| f = fn.FatFirst
	|| t = 0
	for i in fn.µLength
		t += f[i].GuessSize

	// Call .MuRender? wouldn't it be better to pre-figure out where things are meant to go?
	// Like the sizes of things. I mean... it would make it easier? i think its just constants?
	// knst, knst2, knst3, knsr// how to know if its 1 2 or 3?
	// fat.KNST_Encoder could be re-written to just figure out the consts... 
	// from there, we know it's size.
	// we still need a special const encoder, of course!
	
	self <~ (0, t*4)
	fn.µLengthGuess = t
	Compiler.stTotalASMOps += t


