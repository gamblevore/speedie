

// MiniOptimisations, miniopts, optimize
function Assembler.FinishMost
	|| A = .Curr
	|| S = .FuncStart
	|| Length = 0
	
	target debug
		|ASM[4]| TestSpace
	
	if .out == "typereach"
	
	while A > S
		|| op = s.op
		if op == asm.knst
			S.ConstFinish
		  elseif S.JumpPrm
			s.JumpImprove(self)
		  elseif op == asm.FNC3 or asm.FNC
			.TryTail(s)

		|| Predicted = s.guesssize
		length += Predicted
		
		target debug
			|| Start = &TestSpace[0]
			|| After = s.µRenderInto(Start, start+4)
			|| Actual = After - Start
			if Actual != Predicted // uugh		
		S++
		
	.out.µASMLength = Length



function assembler.TryTail (|fatasm| FNC)
	opt norefcounts
	|| Ret = Fnc + 1
	require ret isa asm.ret
	|| rr = ret.regonly
	require (fnc.BasicBlock == ret.BasicBlock) and (!fnc.p3)	// no pext, won't fit in tail.
	|| ReturnType = .out.ReturnType
	require !returntype or fnc.RegOnly == rr					// returning same var, or nothing at all.

/	Fnc.prms[0] = Fnc.prms[1]
	Fnc.prms[1] = Fnc.prms[2]
	Fnc.prms[2] = 0
	Fnc._Outputs = 0
	Fnc._op = asm.tail
	(Fnc.info as= ASMReg.exit)
	ret._op = asm.noop
	if 0: nil|message|!.TAIL



function fatasm.SimpleConst (|uint64| v, |int| Space,  |bool|)
	|| negate = v|int64| < 0
		v = ~v
	|| sh = 64-Space
	if (v << sh) >> sh == v
		.prms[2] = negate|int|
		.prms[3] = v & 17~bits
		.prms[4] = v >> 17
		.prms[5] = v >> 49
		return true
//		Cond	1		// 0 == always, 1 = only if dest == 0
//		Inv		1
//		Value	17


function fatasm.ConstFinish 
	|| v = .const|uint64|
	if .SimpleConst(v, 17)
		._op = asm.KNST // already set, but its for clarity
		return
	if .RotateConst(V)
		._op = asm.KNSR
		return
	if .SimpleConst(v, 49)
		._op = asm.KNST2
		return
	.SimpleConst(v, 64)
	._op = asm.KNST3


function uint64.rotl1 (|uint64|)
	return (self << 1) ||| (self >> 63)


function fatasm.RotateConst (|uint64| v, |bool|)
	|| BC = V.CountBits
	|| inv = 64-BC <= 12
		V = ~V
	  else
		require BC <= 12

	for i in 64
		if v <= (12~bits)|uint64|
			.p1 = i
			.p2 = inv|int|
			.p3 = v|uint|
			return true
		v = v.rotl1


