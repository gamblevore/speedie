


prototype fn_asm (|&ASMState| self=asmstate.sh, |message| exp, |AsmReg| Dest=asmreg(), |int| Mode = 0, |!&FATASM|)


//datatype ASMMath (int)
//	constants
//		|ASMMath|
//		Add = (1 << 16)
//		Sub = (2 << 16)
//		Mul = (3 << 16)
//		Div = (4 << 16)
//		Mod = (5 << 16)
//
////		ROL = (6 << 16)
////		ROR = (7 << 16)
//		Shl = (8 << 16)
//		Shru = (9 << 16)
//		Shrs = (10 << 16)
//		BNt = (11 << 16)
//		BAn = (12 << 16)
//		BOr = (13 << 16)
//		Xor = (14 << 16)
//		Type = (15 << 16)
//		BitCorrect = (31 << 16) // removes garbage bits
//		All = BitCorrect
//	
//	syntax is (|asmmath| r, |bool|)
//		return self == r



// Why squeeze these in? Why not give it clear ranges?
// µtype = 1-8,  regs = 9-16,  math = 17-24,  RegStuff = 33-64
// sigh... more changes!


datatype AsmReg (int64)
	default 0|AsmReg|
	linkage
		cpp_part Reg
		numeric false
	
	Flags
		|asmreg|
		(1<<32)		// starting point
		SrcConst
		NotYetUsed	// for   || y = a + b,   y is (currently) unused.
		FromMath
		StayOpen
		AlreadyNegated
		Alternate
		Cond
		Negate
		Discard
		Set
		ForReturn
		Temp
		SingleExpr
		NewCondRequest
		ConstAny
		ContainsAddr
		AddrRequest
		BitCorrect
		CorrectAddr		= ContainsAddr ||| bitcorrect
		Arg				= Discard ||| SrcConst // ||| Discard
		CondRequest		= NewCondRequest ||| SrcConst
		MathConst		= ConstAny ||| FromMath
		Zero			= SrcConst
	
	

	
	function F32 (|float|)
		
		
	function F64 (|float|)
		

	function Const (|int64|)
		return .fat.const

	function Const (assigns:|int64|)
		.fat.const = value

	function Negate (|asmreg|)
		(self is negate) = (Self isnt negate)
		return self
	
	function BitCount (|int|)
		return .µtype.bitcount
		
	function FAT (|!&fatasm|)
		debugger //ooof
		return ASMState.Sh.Registers[.reg]!

	operator isa (|datatypecode| M, |bool|)
		return .µtype == M

	function Exists (|bool|)
		return self|int64|
		
	function FourBytes (|bool|)
		pragma inline
		return self|datatypecode|._shift == 2

	function IsBig (|bool|)
		pragma inline
		return self|datatypecode|._shift == 3

	function IsFloat (|bool|)
		pragma inline
		return self|datatypecode|.isfloat

	function IsInt (|bool|)
		pragma inline
		return self|datatypecode|.isfloat

	function IntDivType (|int|)
		|| FourBytes = .µtype._shift == 2
			rz = 2
		rz += !.signed
	
	function Signed (|bool|)
		return self|DataTypeCode|.issigned
		
	function GapBits (|int|)
		return 64 - .bitcount
	
	function µType (|DataTypeCode|)
		return self|DataTypeCode|
	
	function µType (assigns:|DataTypeCode|, |asmreg|)
		return ((self|int64| &~ 0xFFFF) ||| value)|asmreg|
	
	syntax is (|AsmReg| R, |bool|)
		return (self & R) == r
	
	syntax is (|AsmReg| R, assigns:|bool|, |AsmReg|)
		if (value)
			return self as r
		  else
			return self asnt r
			
	function RequestPos (|asmreg|)
		return self as addrrequest
	
	function Fatasm.HaveAddr (|&fatasm|)
		.info = .info.HaveAddr
		return self
		
	function HaveAddr (|asmreg|)
		rz = self asnt AsmReg.AddrRequest
		rz = rz as AsmReg.CorrectAddr
		
	function Reg (|int|)
		return .µType.Register
	
	function Reg (assigns:|int|, |AsmReg|)
		|| t = .µType
		t.Register = Value
		.µType = t
		return self
	
	syntax cast (|bool|)
		return .reg
	
	syntax cast (|int|)
		cpp_part ToInt
		return .reg

	operator bitand (|asmreg| A, |asmreg|)
		return (self|int64| & A|int64|)|asmreg|
	
	operator as (|asmreg| A, |asmreg|)
		return (self|int64| ||| A|int64|)|asmreg|

	operator asnt (|asmreg| A, |asmreg|)
		return (self|int64| &~ A|int64|)|asmreg|

	operator • (|asmreg| dest, |asmreg|)
		if .reg == dest.reg
			return asmreg()
		return dest
		
	module
		function New (|asmreg|)
			return Zero
		
	

// we could do this instead
// (self-1)&31!!
// this will "rotate" 0 back to 31 and 1 to 0.
function int.asm (|asmreg|)
	cpp_part ToASM
	rz.reg = self // (self - 1)&31 // would be better?
