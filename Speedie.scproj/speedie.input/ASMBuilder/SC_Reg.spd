

prototype fn_asm    (|&ASMState| self=asmstate.sh, |message| exp, |AsmReg| Dest=asmreg(), |int| Mode=0, |AsmReg|)
prototype fn_fatasm (|&ASMState| self=asmstate.sh, |message| exp, |AsmReg| Dest, |&FatASM|)


datatype ASMReg (uint64)
	default 0|AsmReg|
	linkage
		cpp_part Reg
		numeric false
	
	Flags
		|asmreg|
		(1<<16)		// starting point
		Negate      // dont put anything before we test for (x << 16)
		Param
		FromExistingVar
		StayOpen
		AlreadyNegated
		Alternate
		Discard
		Set
		Declaration
		ForCast
		Temp
		SingleExpr
		NoScale
		NeverAltered
		ContainsAddr
		Textual
		CondRequest
		CondAnswer
		RealConst  = [ConstInput, ConstOutput]
		AddrNeed   = [AddrRequest, AddrForceRequest]
		KindaConst = RealConst ||| NeverAltered
		SetRelRemove = KindaConst ||| StayOpen
		Arg		   = Discard				// ||| SrcConst
		Zero	   = RealConst ||| 56 ||| param		// 56 == datatypecode.uint64
		ZeroParam  = ConstOutput ||| param
	

	render
		fs <~ "r"
		fs <~ .reg
		fs <~ "("
		.µtype.render(Fs)
		fs <~ ")"
		
	function Floatness (|int|)
		return .µtype.floatness
	
	function F32 (|float|)
		if .reg
			return .needfat.F32
		
	function F64 (|Float64|)
		if .reg
			return .needfat.F64
	
	function float (|Float64|)
		if .reg
			|| f = .needfat
			if .isbig
				return f.f64
			return f.f32|float64|

	function Simplify (|asmreg|)
		return self|uint16||asmreg|
		
	function Const (|int64|)
		|| F = .FAT
			return f.const
		if self isnt param
			.needfat

	function Const (assigns:|int64|)
		.needfat.const = value

	function IsConst (|int64| val, |bool|)
		return  (self is RealConst) and (.const == val)
	
	function Negate (|bool| Neg=true, |asmreg|)
		return (self|uint64| xor (neg << 16)|uint64|)|asmreg|
	
//	function Expect (|message| where)
//		opt inline
//		check (.reg) (asmstate.sh, where, "Internal ASM Error: Setting to register 0")
	
	function BitCount (|int|)
		return .µtype.bitcount
	
	function FatIndex (|uint|)
		return self|uint64| >> 48
	
	function FatIndex (assigns:|uint|, |asmreg|)
		return (((self|uint64| << 16) >> 16) ||| (value|uint64| << 48))|asmreg|
	
	function FAT (|&fatasm|)
		|| i = .FatIndex
			return i.fat
	
	function NeedFAT (|&fatasm|)
		|| i = .FatIndex
			return i.fat
		error "anorexic register"
		return asmstate.sh.zero

	operator isa (|datatypecode| M, |bool|)
		return .µtype == M

	function FourBytes (|bool|)
		opt inline
		return self|datatypecode|._shift == 2

	function IsBig (|bool|)
		opt inline
		return self|datatypecode|._shift == 3

	function IsFloat (|bool|)
		opt inline
		return self|datatypecode|.isfloat

	function IsInt (|bool|)
		opt inline
		return self|datatypecode|.isint

	function IntDivType (|int|)
		|| FourBytes = .µtype._shift == 2
			rz = 2
		rz += !.signed
	
	function Signed (|bool|)
		return self|DataTypeCode|.issigned
		
//	function GapBits (|int|)
//		return 64 - .bitcount
	
	function IsBool (|bool|)
		opt inline
		return .µType is bool
	
	function µType (|DataTypeCode|)
		opt inline
		return self|DataTypeCode| & DataTypeCode.PossibleBits
	
	function µType (assigns:|DataTypeCode|, |asmreg|)
		|| Mask = DataTypeCode.PossibleBits|uint64| // first 10 bits
		return ((self|uint64| & ~Mask) ||| (value&Mask))|asmreg|
	
	syntax is (|AsmReg| R, |bool|)
		return (self & R) == r
	
	syntax is (|AsmReg| R, assigns:|bool|, |AsmReg|)
		if (value)
			return self as r
		  else
			return self asnt r
		
	function datatypecode.zero (|asmreg|)
		|| K = asmreg.RealConst
		K.µtype = self
		return K
	
	function Fatasm.HaveAddr (|&fatasm|)
		.info = .info.HaveAddr
		return self
		
	function HaveAddr (|asmreg|)
		rz = self asnt AddrNeed
		rz = rz as ContainsAddr
	
	function Reg (|int|)
		return (self|uint64| >> 11)&31
	
	function Reg (assigns:|int|, |AsmReg|)
		self &= ~(31<<11)|asmreg|
		(self as= (value << 11)|asmreg|)
		return self
	
	operator mul (|bool| b, |asmreg|)
		return (self, nil)(b)
	
//	syntax cast (|bool|)
//		return self|bool|
	
	syntax cast (|int|)
		cpp_part ToInt
		return .reg
		
	operator bitand (|asmreg| A, |asmreg|)
		return (self|int64| & A|int64|)|asmreg|
	
	operator as (|asmreg| A, |asmreg|)
		return (self|int64| ||| A|int64|)|asmreg|

	operator asnt (|asmreg| A, |asmreg|)
		return (self|int64| &~ A|int64|)|asmreg|

	operator • (|asmreg| dest, |asmreg|)
		if .reg == dest.reg
			return dest.µtype.zero
		return dest

	operator with (|asmreg| dest, |asmreg|)
		if dest is Declaration
			.reg = dest.reg
		return self

	function with (|asmreg| dest, |asmreg| InUse, |asmreg|)
		if InUse.reg == dest.reg				// dest is in use!
			.reg = 0
		  else									// dest is free!
			.reg = dest.reg
		return self
	
	function TmpCheck (|bool|)
		|| R = .reg
		|| IsTmp = self is temp
		|| Big = R >= 24
		if big == IsTmp // bad?
			return true
		if big
			"big reg $R unmarked"
		  else
			"low reg $R marked"
		debugger
	
			
	module
		function New (|asmreg|)
			return Zero
		
	

// we could do this instead (ON RENDER?)
// (self-1)&31!!
// this will "rotate" 0 back to 31 and 1 to 0.

//function int.asm (|asmreg|)
//	cpp_part ToASM
//	rz.reg = self // (self - 1)&31 // would be better?

function int.TextASM (|asmreg|)
	rz.reg = self // (self - 1)&31 // would be better?
	(rz is textual)

