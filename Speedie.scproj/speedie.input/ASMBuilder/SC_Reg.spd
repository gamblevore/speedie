


prototype fn_asm (|&ASMState| self, |message| exp, |AsmReg| Dest=asmreg(), |int| Mode = 0, |AsmReg|)


datatype ASMMath (int)
	constants
		|ASMMath|
		Add
		Sub
		Mul
		Div
		Mod

		ROL
		ROR
		Shl
		Shru
		Shrs
		BNt
		BAn
		BOr
		Xor
		Xnr
		BitCorrect = 31 // removes garbage bits
	
	syntax is (|asmmath| r, |bool|)
		return self == r



datatype AsmReg (int)
	default 0|AsmReg|
	linkage
		cpp_part Reg
		numeric false
	
	constants
		MathTypes		= (31 << 13)
		|asmreg|		// start at 19!
		Set = 4
		Unused 		    = (1 << 19)
		ContainsAddr    = (1 << 20)
		FromMath		= (1 << 21)
		StayOpen		= (1 << 22) // input
		AlreadyNegated	= (1 << 22) // result. what if we return the input?
		Alternate		= (1 << 23)
		Const			= (1 << 24) ||| (31 << 13)
		MathConst		= (1 << 21) ||| (1<<24)
		Cond			= (1 << 25)
		AddrRequest     = (1 << 26)
		ForReturn		= (1 << 27)
		Discard			= (1 << 28)
		SingleExpr		= (1 << 29)
		CondRequest		= (1 << 30) ||| (1 << 24) ||| (31 << 13)
		NewCondRequest	= (1 << 30)
		Negate			= (1 << 31)
		Zero			= Const
	
	function Negate (|asmreg|)
		(self is negate) = (Self isnt negate)
		return self
	
	function BitCount (|int|)
		return .µtype.bitcount
	
	function Math (|asmmath|)
		return (self|asmmath| >> 13) & 31
		
	operator isa (|ASMMath| M, |bool|)
		return .math == M

	operator isa (|datatypecode| M, |bool|)
		return .µtype == M

	operator as (|ASMMath| M, |asmreg|)
		return ((self|int| &~ MathTypes) ||| (M<<13))|ASMReg|

	function Exists (|bool|)
		return self|int|
		
	function FourBytes (|bool|)
		pragma inline
		return self|datatypecode|._shift == 2

	function IsBig (|bool|)
		pragma inline
		return self|datatypecode|._shift == 3

	function IsFloat (|bool|)
		pragma inline
		return self|datatypecode|.isfloat

	function IsInt (|bool|)
		pragma inline
		return self|datatypecode|.isfloat

	function IntDivType (|int|)
		|| FourBytes = .µtype._shift == 2
			rz = 2
		rz += !.signed
	
	function Signed (|bool|)
		return self|DataTypeCode|.issigned
		
	function GapBits (|int|)
		return 64 - .bitcount
	
	function µType (|DataTypeCode|)
		return self|int| & 13.bits
	
	function µType (assigns:|DataTypeCode|, |asmreg|)
		return ((self|int| & ~13.bits) ||| value)|asmreg|
	
	syntax is (|AsmReg| R, |bool|)
		return (self|int| & R|int|) == r|int|
	
	syntax is (|AsmReg| R, assigns:|bool|, |AsmReg|)
		if (value)
			return self as r
		  else
			return self asnt r
			
	function RequestPos (|asmreg|)
		return self as addrrequest
			
	function HaveAddr (|asmreg|)
		|| x = self|int| &~ AddrRequest|int|
		x |= ContainsAddr|int|  (|)  asmmath.Bitcorrect|int|
		return x|asmreg|
		
	// we could do this instead
	// (self-1)&31!!
	// this will "rotate" 0 back to 31 and 1 to 0.
	function Reg (|int|)
		return .µType.Register
	
	function Reg (assigns:|int|, |AsmReg|)
		|| t = .µType
		t.Register = Value
		.µType = t
		return self
	
	syntax cast (|bool|)
		return .reg
	
	syntax cast (|int|) // strange? not even to .asmadd params?
		cpp_part ToInt
		return .reg
	
	operator as (|asmreg| A, |asmreg|)
		return (self|int| ||| A|int|)|asmreg|

	operator asnt (|asmreg| A, |asmreg|)
		return (self|int| &~ A|int|)|asmreg|

	function Set (|asmreg|)
		return self as set
	
	operator • (|asmreg| dest, |asmreg|)
		if .reg == dest.reg
			return asmreg()
		return dest
		
	module
		function New (|asmreg|)
			return const
		
	

function int.Reg (|asmreg|)
	cpp_part ToReg // (self - 1)&31 // would be better?
	rz.reg = self
