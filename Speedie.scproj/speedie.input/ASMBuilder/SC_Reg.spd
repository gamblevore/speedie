

prototype fn_asm    (|&ASMState| self=asmstate.sh, |message| exp, |AsmReg| Dest=asmreg(), |int| Mode=0, |AsmReg|)
prototype fn_fatasm (|&ASMState| self=asmstate.sh, |message| exp, |AsmReg| Dest, |&FatASM|)


datatype ASMReg (uint64)
	default 0|AsmReg|
	linkage
		cpp_part Reg
		numeric false
	
	Flags
		|asmreg|
		(1<<16)		// starting point
		Negate      // dont put anything before we test for (x << 16)
		Param
		FromExistingVar
		FromZeroMemory
		AlreadyNegated
		Alternate
		Discard
		Set
		Declaration
		Temp
		NoScale
		ContainsAddr
		Textual
		ConstRequest
		CondRequest
		CondAnswer
		DeclareInlineParam
		InlinedAccess
		AlwaysSet = Textual  // reuse const
		Exit = [ExitFunction, ExitAtAll]
		RealConst  = [ConstInput, ConstOutput]
		AddrNeed   = [AddrRequest, AddrForceRequest]
		// don't go above 47
		RemoveableOutput = ConstOutput|||Temp
		Zero	   = RealConst ||| 56 ||| param		// 56 == datatypecode.uint64
		ZeroParam  = ConstOutput ||| param
		RealDiscard = RealConst ||| discard
		NotUnConst = fromexistingvar ||| ConstInput
	

	function testbit
		|| x = AddrForceRequest

		
	render
		if self is temp
			fs <~ "t"
		  else
			fs <~ "r"
		fs <~ .reg
		fs <~ "("
		.µtype.render(Fs)
		fs <~ ")"
	
	
	function Normalness (|bool|)
		return .µType.ASMUseIntRegs
	
	
	function F32 (|float|)
		if .reg
			return .needfat.F32
		
	function F64 (|Float64|)
		if .reg
			return .needfat.F64
	
	function float (|Float64|)
		if .reg
			|| f = .needfat
			if .isbig
				return f.f64
			return f.f32|float64|

	function Simplify (|asmreg|)
		return .ReallySimplify as (self & temp)

	function ReallySimplify (|asmreg|)
		return self|uint16||asmreg|
	
	function CopyConst (|asmreg| Src, |asmreg|)
		return (self &~ realconst) as (src & realconst)
		
	function Const (|int64|)
		// every single caller must check for constoutput (and does!)
		|| F = .FAT
			return f.const
		if .reg == 0
			return 0
		if self isnt param
			.NeedFAT
		

	function Const (assigns:|int64|)
		.needfat.const = value

	function IsConst (|int64| val, |bool|)
		return  (self is ConstOutput) and (.const == val)
	
	function Negate (|bool| Neg=true, |asmreg|)
		return (self|uint64| xor (neg << 16)|uint64|)|asmreg|
	
	function BitCount (|int|)
		return .µtype.bitcount
		
	function Bytes (|int|)
		return .µType._shift
	
	function FatIndex (|uint|)
		return self|uint64| >> 48
	
	function FatIndex (assigns:|uint|, |asmreg|)
		return (((self|uint64| << 16) >> 16) ||| (value|uint64| << 48))|asmreg|
	
	function FAT (|?&fatasm|)
		|| i = .FatIndex
			return i.fat
	
	function NeedFAT (|&fatasm|)
		|| f = .fatindex.fat
			return f
		error "anorexic register"
		return asmstate.sh.zero

	operator isa (|datatypecode| M, |bool|)
		return .µtype == M

	function FourBytes (|bool|)
		opt inline
		return self|datatypecode|._shift == 2

	function BasicVec (|asmreg|)
		if .IsFloat
			.µType = DataTypeCode.Vec4
		  else
			.µType = DataTypeCode.iVec4
		return self
		
	function IsVec (|bool|)
		return self|datatypecode| & 0x03
		
	function IsBig (|bool|)
		opt inline
		return self|datatypecode|._shift == 3

	function IsFloat (|bool|)
		opt inline
		return self|datatypecode|.isfloat

	function IsInt (|bool|)
		opt inline
		return self|datatypecode|.isint

	function IntDivType (|int|)
		return (!.signed)|int|
	
	function Signed (|bool|)
		return self|DataTypeCode|.issigned
		
	function BitLoss (|int|)
		if .isbool
			return 63
		return 64 - .bitcount
	
	function IsBool (|bool|)
		opt inline
		return .µType is bool
	
	function µType (|DataTypeCode|)
		opt inline
		return self|DataTypeCode| & DataTypeCode.PossibleBits
	
	function µType (assigns:|DataTypeCode|, |asmreg|)
		|| Mask = DataTypeCode.PossibleBits|uint64| // first 10 bits
		return ((self|uint64| & ~Mask) ||| (value&Mask))|asmreg|
	
	syntax is (|AsmReg| R, |bool|)
		return (self & R) == r
	
	syntax is (|AsmReg| R, assigns:|bool|, |AsmReg|)
		if (value)
			return self as r
		  else
			return self asnt r
		
	function datatypecode.zero (|asmreg|)
		|| K = asmreg.RealConst
		K.µtype = self
		return K
	
//	function Fatasm.HaveAddr (|&fatasm|)
//		.info = .info.HaveAddr
//		return self
		
	function HaveAddr (|asmreg|)
		rz = self asnt AddrNeed
		rz = rz as ContainsAddr
	
	function Reg (|int|)
		return (self|uint64| >> 11)&31
	
	function Reg (assigns:|int|, |AsmReg|)
		self &= ~(31<<11)|asmreg|
		(self as= ((value&31) << 11)|asmreg|)
		(self is temp) = (value >> 31)
		return self
	
	operator mul (|bool| b, |asmreg|)
		return (self, nil)(b)
	
	syntax cast (|int|)
		cpp_part ToInt
		return .reg
		
	operator bitand (|asmreg| A, |asmreg|)
		return (self|int64| & A|int64|)|asmreg|
	
	operator as (|asmreg| A, |asmreg|)
		return (self|int64| ||| A|int64|)|asmreg|

	operator asnt (|asmreg| A, |asmreg|)
		return (self|int64| &~ A|int64|)|asmreg|

	operator • (|asmreg| dest, |asmreg|)
		if .reg == dest.reg
			return dest.µtype.zero
		return dest

	operator with (|asmreg| dest, |asmreg|)
		if dest is Declaration
			self = .UseReg(dest)
		return self

	function UseReg (|asmreg| dest, |asmreg|)
		opt norefcounts
		.reg = dest.reg
		(self is temp) = (Dest is temp)
		return self
	
	function with (|asmreg| dest, |asmreg| InUse, |asmreg|)
		if InUse.reg == dest.reg				// dest is in use!
			.reg = 0
			isnt temp
			return self
												// dest is free!
		return .usereg(dest)
	
	
	function DebugPrint 
		target debug
			print .render
			|| f = .fat
				print " - "
				f.DebugPrint
			  else
				""
	
	function TmpCheck (|bool|)
		|| R = .reg
		|| IsTmp = self is temp
		|| Big = R >= 26
		if big == IsTmp // bad?
			return true
		if big
			"big reg $R unmarked"
		  else
			"low reg $R marked"
		debugger
	
			
	module
		function New (|asmreg|)
			return Zero
		
	

// we could do this instead (ON RENDER?)
// (self-1)&31!!
// this will "rotate" 0 back to 31 and 1 to 0.

function int.asm (|asmreg|)
	cpp_part ToASM
	rz.reg = self // (self - 1)&31 // would be better?

function int.TextASM (|asmreg|)
	rz.reg = self // (self - 1)&31 // would be better?
	(rz is textual)


