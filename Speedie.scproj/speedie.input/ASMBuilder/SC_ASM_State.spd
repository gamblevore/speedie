

struct ASMState
	linkage: cpp_part Pac
	|uint16| 					BlockNum
	|uint16| 					ParentBlock

	|byte|						VDecls
	|byte|						VTmps
	|datatypecode|				ReturnASM
	|bool|						OK    
	|bool|						Inited   

	|µFunc|						Out      
	|&FatASM|					FuncStart
	|&fatasm|					LastProgress
	|&FatASM|					Start		// a "slice" feature would be nice    
	|&FatASM|					Curr    
	|&FatASM|					End    
// constants...
	|FATASM| 					Zero
	|int[32]|					NeverAltered

	constants
		kContinue = 254
		kExit = 255
	

	module
		|FatASM[]|					JSMSpace = FatASM[0]!
		|[memory of fatasm]|		Ancients
		|ASMState|					Sh


	function CloseVDecls (|int| i, |bool|)
		|| top = .vdecls
		while top > i
			.NeverAltered[top--] = 0
		.VDecls = i

	function CloseVTmps (|int| i)
		target debug: if i < .vtmps // what?
		.VTmps = i
			
	function AddFuncParams (|SCFunction| fn)
		opt norefcounts
		for a in fn.Args
			.DeclareMe(a.source, a)

	function Last (|&FatASM|)
		return .curr-1

	function Last (|asm| type, |&FatASM|)
		|| L = .curr-1
		if l isa type
			return L
	
	function IntPowerOfTwo (|asmreg| r, |int| Sub=0, |FailableInt|)
		// -1 --> -1,  0 --> 0,  1 --> 1,  2 --> 2,  4 --> 3,  8 --> 4
		// this is used for multiplication mostly. like x*-1, or x*0, or x*1
		if r is ConstAny
			|| v = r.const
			if v == -1
				.nop(r)
				return v
			v -= Sub
			if v.IsPow2
				.nop(r)
				return v.Log2+1


	function IncrPost (|message| exp,  |AsmReg| Dest,  |AsmReg| ToGrow,  |int64| Value,  |asmreg|)
		if dest isnt discard
			dest = .TempTyped(exp, dest)
		if togrow.isint and value.CanStoreAsIntImmediate
			return exp.ADPK(dest, ToGrow, Value) * Dest
		.Assign(dest, ToGrow, exp)
		rz = .IncrPre(exp, togrow, ToGrow, value)


	function AddToReg (|message| exp, |asmreg| Dest, |asmreg| Orig, |int64| Amount, |asmreg|)
		if !dest or dest == asmreg()
			dest.µtype = orig.µtype
		dest = .temponly(exp, dest)
		|| K = .NumToReg(exp, amount, orig • dest, orig.µtype)
		return .Plus(dest, Orig, K, exp)
	
	
	function IncrPre (|message| exp,  |AsmReg| Dest,  |AsmReg| Src,  |int64| Value,  |asmreg|)
		if !src.reg // what?
		if !dest.reg
			dest = src
		src = .addtoreg(exp, src, src, value) 
		if dest.reg==src.reg
			return src
		return .Assign(dest, src, exp)


	syntax append (|int| code, |message| dbg, |&FatASM|)
		cpp_part RequestOp
		|| p = .curr
		if p < .end
			.curr = p + 1
			P.op = code
			p.debug = dbg
			p.BlockNum = .BlockNum
			p.ParentBlock = .ParentBlock
			return p
		.OK = false
		return .start


	syntax expect (|message?| where=nil, |string| msg)
		cpp_part Fail
		|| f = scfunction.currfunc!.asm
			f.length = .curr - .funcstart
			printline f.render
		debugger
		error (where, msg)


	function DeclareMe (|Message| where,  |scdecl| Type,  |asmreg|)
		|| d = .VDecls|int| + 1
		if (d < .vtmps)
			|| t = Type.CalculateASMType
			t.reg = d
			Type.wholetype = t|DataTypeCode|   		// right?
			.vdecls = d
			target debug: Type.ASMSanity
			return t
		error (self, where, "No free local variables.")


	function TempTyped (|Message| where, |asmreg| T=asmreg.Temp, |asmreg|)				// .needreg
		opt norefcounts
		if t isnt textual
			// what if there is a type and its different?
			// and if its NEVER different... why add it?
			t.µtype = where.asmdecl.datatype
		return .TempOnly(where, t)


	function TempOnly (|Message| where, |asmreg| T=asmreg.Temp, |asmreg|)				// .needreg
		opt norefcounts
		if t.reg
			return t
		|| r = .vtmps - 1
		check (r > .vdecls) (where, "No free local variables.")
		t.reg = r
		.vtmps = r
		(t isnt kindaconst) // why would it be?
		(t is temp)
		return t
	
	function Nop (|asmreg| R)
		|| f = r.fat
			return .Nop(f)
		if r.reg
			debugat // bad!
	
	function Nop2 (|asmreg| A, |asmreg| B)
		.nop(A)
		.nop(B)
		.nop(A) // in case of swapped order
	
	function Const (|asmreg| R, |int| bits, |bool| signed, |ind|)
		if R & asmreg.KindaConst
			|| k = R.const
			if k.fits(bits, signed)
				if r is ConstAny
					.nop(R)
				return k|uint64|.trim(bits)

	function NopConst (|asmreg| R)
		if r is constany
			|| f = r.fat
				.Nop(f)
	
	function Nop (|FATASM| R) //!!
		r.op = asm.noop
		r.jumpreg = 0
		|| C = .curr - 1
		if R == C
			.curr = C // nice

	function Nop (|fatrange| R)
		.nop(r.start, r.after!)


	function Nop (|fatasm| Start, |fatasm| After)
		while start < After
			.nop(--after)
			
		
///////////////////////////////////////////////////////////////////////////////////////////////////

	function µBoolInto (|message| exp, |AsmReg| Dest, |asmreg|)
		|| X = .ExistingVar(Exp)
		X ?= .µInto(exp, dest)
		if  (X.µtype isnt bool)  or  (dest is negate  and  X isnt AlreadyNegated)
			return .exists(dest as (X bitand asmreg.fromexistingvar), X, exp)
		return .Assign(dest, X, exp)
			
		
	function µInto (|message| exp, |AsmReg| Dest, |asmreg|)
		|| rz = .µ(Exp, dest)
		debugat 0
//		if rz is temp // what?
//			.µ(Exp, dest)
		dest = rz.reg(dest)
		return .Assign(Dest, rz, exp)
	
			
	function µ (|message| exp, |AsmReg| Dest = asmreg(), |asmreg|)
		opt norefcounts
		cpp_part GetASM 
		target debug
			dest.tmpcheck
			debugat 0 // keep this
		  else
			opt inline

		|| fn = fn_asm_table[exp.ASMType]!
		|| TmpCloser = .VTmps
		
		|| ss = (fn)(self, exp, dest)
		if dest isnt StayOpen
			.CloseVTmps(TmpCloser)

		target debug
			ss.tmpcheck
			check (ss) (self, exp, "µInto failed")
			if (ss is constany) and ss.reg
				if !ss.fat
					debugger
					(fn)(self, exp, dest)
			if dest is set or ss is set
				return ss // no need test.
			if !ss.reg and (ss isnt condanswer)
				if (ss isnt constany)
					debugger
					(fn)(self, exp, dest)
/*
			if exp.asmtype < ASMType.kIf and ss != asmreg()
				|| D = exp.asmdecl
				|| sst = ss.µtype
				|| dt = dest.µtype
				if dt and (sst != dt)
					D.typeinfo.debugprint
					printline exp
					sst.debugprint
					dt.debugprint
					debugger
					printline D
					(fn)(self, exp, dest)
*/
		return ss


	function FuncPrm (|message| prm, |asmreg|)
		|| r = .ExistingVar(prm)
			return r
		return .µ(prm, asmreg.stayopen)


	function ReadOrWrite (|ASMReg| dest, |message| m, |asmreg| base, |asmreg| varadd, |int| index=0, |asmreg|)
		return .ReadOrWriteSub(dest, m, base, varadd, index) * dest


	function ReadOrWriteSub (|ASMReg| dest, |message| exp, |asmreg| base, |asmreg| varadd, |int| index, |&fatasm|)
		if dest is containsaddr
			#!wait?? this is meant to be an addrrequest? not a response.
			debugger

		(dest asnt= asmreg.AddrRequest)
		|| T = dest.µtype
		|| bytes = t.ByteCount.log2
		if  (bytes|uint| > 4)
			error (exp, "Object to large to access")				// can we do struct-mem-copy?
			bytes = 0
		
		if varadd is constany
			|| CC = varadd.fat
				.nop(cc)
				index += cc.const
				varadd = asmreg()

		base = .InlineOffset(Base, bytes, index, 127)
/*
	ADDK: bs, r1, 4
	RD1U: r2, bs, value, 4, 0
*/					
		if index >= 128												// read/write only allows up to 127
			index <<= bytes
			base = .AddToReg(exp, asmreg(), base as asmreg.noscale, index)
			index = 0
		
		rz = exp.RD4U(dest, base, varadd, index, 0)
		if dest is set
			rz.op = ASMType.WriteASM[bytes]
		  else
			|| B = (bytes<<1) + t.issigned
			rz.op = ASMType.ReadASM[b]


	function Read (|asmreg| dest, |message| exp,  |asmreg| ptr,  |asmreg| varadd,  |int| index=0,  |&fatasm|)
		opt inline
		(dest isnt set)
		return .ReadOrWriteSub(dest, exp, ptr, varadd, index)
		

	function Write (|asmreg| dest, |message| exp,  |asmreg| ptr,  |asmreg| varadd,  |int| index=0,  |&fatasm|)
		opt inline
		(dest is set)
		return .ReadOrWriteSub(dest, exp, ptr, varadd, index)


		


	
function SCFunction.HasCVersion (|bool|)
	if .isstdlib
		return true
	require self is wrapper

	if .IsCppInBuilt == 1	// cpp_inbuilt. These normally have no address? but perhaps we made a wrapper for it in the exec? we should check if it still exists.
		debugat
		return true

	if .IsCppInBuilt == 2	// cpp_nothing: cpp_spd might sound better?
		debugat
		return false // need to be replaced with ASM intrinsics.

	if self Is ExternalLib	// cpp_libwrapper ?   // Speedie_Main in perry, counts as one!
		debugat
		return false  // i think only perry used this and only in debug mode within Xcode

	return true



function ASMState.PrmCollectC (|message| prms, |SCFunction| fn, |uint64|)
	// we need to do ints last, and also collect these backwards.
	opt norefcounts
	|| sh = 0
	|| fc = 0
	|| ic = 0
	|| n = fn.args.Length
	for Ints in 2
		|| p = prms.last
		while p
			|| ty = p.ASMDecl
			if ty.SpecialRegs|int| != Ints // should get .specialregs from message somehow?
				|| v = .FuncPrm(p!).reg
				rz  |=  v << sh
				sh += 5
				ic += ints
				fc += !ints
			p--
	
	if fc>8 or ic>8			// hmmm
	rz <<= 12
	rz |= fn.ReturnType.SpecialRegs << 11
	if fc
		rz |= (8-fc) << 6
		rz |= (8-ic) << 0
	  else
		rz |= (17-ic) << 6


function ASMState.PrmCollect (|message| prms, |scfunction| fn, |uint64|)
	opt norefcounts
	if fn.HasCVersion
		return .PrmCollectC(prms, fn)
	
	|| sh = 7
	|| p = prms.first
	for FnArg in fn.args
		|| v = .FuncPrm(p!).reg
		sh += 5
		rz  |=  v << sh
		rz++								// Send-count (4 bits max)
		p++


function asmreg.CallFunc (|int| v, |int|)
	if (.reg == v)
		v -= self is Set // NOICE
	return v


function @ASMType.DoFunction (fn_Asm)
	opt norefcounts
	#! The .asint/.asfloat functions should be recognised as working on constants? Or is that just a general case of inline functions? Technically, its an inline func that does nothing, just returns the original... with a different type. 
	|| prms = exp.last!
	|| fn = prms.asfunc!

	// Speedie's function histogram:  0:410, 1:1656, 2:1464, 3:713, 4:167, 5:61, 6:10, 7:4
	// There are only 4 above 6!, only 14 above 5, 75 above 4
	// almost all lib functions have 4 or less. 5 is for proj funcs.

	dest.µtype = fn.RegType
	|| vd = dest.CallFunc(.VDecls) + 1
	if dest is StayOpen // but not here.
		.vdecls++

	check (vd < 32) (exp, "Too many registers in use. No space for result.")
	dest.reg = vd

	|| TmpCloser = .VTmps
	|| P = .PrmCollect(prms, fn)
	.CloseVTmps(TmpCloser)
	
	|| PExt = P >> 32
	|| fat = exp.FNC(dest, fn.tableid+31, P,  PExt)
	if fn.HasCVersion
		fat.op = asm.FNCX
	fat.op += PExt > 0
	return fat*dest
//  Mostly I'm doing:  || x = msg.function(),  (which uses the correct position.)
		


function ASMState.PackMakerInit (|bool|)
	opt norefcounts
	if .Inited
		return true
	.inited = true
	VM_Builder.JustDefineInstructions
	SpdAssembler.InitAss
	return .alloc(ASMState.JSMSpace)



function ASMState.Alloc (|memory of fatasm| j, |bool|)
	if j.SetSize(4MB)
		.start = j.ptr
		.curr = .start
		.end = j.buffersize + .start
		spdassembler.Guard
		Ancients <~ j
		return true


function @ASMState.ExpandJSM (|bool|)
	require .Ancients < 16
	|| j = FatASM[4MB]
		.Ancients <~ .jsmspace
		.JSMSpace = j
		return sh.Alloc(j)
	

function ASMState.StartFunc (|scfunction| fn)
	if fn.ASM
		.out = fn.asm!
	  else
		.out = µfunc(fn, .curr)
	.zero = nil
	.zero.info = AsmReg()
	(.zero is NeverAltered)
	memory.Fill((&.neveraltered[0])|&byte|, –sizeof .neveraltered, 0)
	.neveraltered[0] = .zero.Index
	.FuncStart = .curr
	.LastProgress = .curr
	scfunction.currfunc = fn
	.ReturnASM = fn.ReturnType.regtype
	.OK = true
	.VDecls = 0
	.VTmps = 32
	.AddFuncParams(fn)


function ASMState.FinishASM
	opt norefcounts
	if .zero.Const // what?
	|| l = .last
	if !l.IsFinisher
		|| fn = scfunction.currfunc!
		expect (!fn.returntype) ("ASMReturn".internal) // why?
		fn.SourceArg!.RET(asmreg(), asmreg(), asmreg(), 1, 0)
	.SetLength


function fatasm.IsFinisher (|bool|)
	|| o = .op|asm|
	return o is ret or trap or reto


function ASMState.SetLength
	.out.length = .curr - .FuncStart


