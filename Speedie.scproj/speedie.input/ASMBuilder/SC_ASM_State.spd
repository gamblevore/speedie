

// ADDK? optimise stages... OR special-case it specifically. 

struct ASMState
	linkage: cpp_part Pac
	|uint16| 					BlockNum
	|uint16| 					ParentBlock
	|datatypecode|				ReturnType
	|bool|						OK    
	|bool|						Inited   
	|byte|						LabelCount
	|byte|						VDecls
	|byte|						VTmps
	|byte|						WithinBranch

	|SCFunction--|				fn       
	|µFunc|						Out      
	|&FatASM|					FuncStart
	|&FatASM|					Start		// a "slice" feature would be nice    
	|&FatASM|					Curr    
	|&FatASM|					End    
	|&FatASM|					WhileStart
	|(&FATASM)[32]|				Registers
	|FATASM| 					Zero


	function AddFuncParams (|SCFunction| fn)
		opt norefcounts
		for a in fn.Args
			.DeclareMe(a.source, a)

	function Last (|&FatASM|)
		return .curr-1
	
	function AskReg (|int| a, |?&fatasm|)
		return .RegPlace(A)[0]

	function ExpectReg (|int| a, |&fatasm|)
		|| b2 = .RegPlace(A)[0]
			return b2
		error (self, errorreceiver.NonFatal + ": Register was nil")
		return .zero

	function RegPlace (|int| a, |&(?&fatasm)|)
		if a|uint| <= 31
			if a <= .vdecls
				return &.registers[a]
			if a >= (32 - .vtmps)
				return &.registers[a]
		error (self, errorreceiver.NonFatal + ": Out of bounds register")
		return &.Registers[0]
			
		
	function GetConst (|int| a, |&uint64|)
		pragma inline
		if a|uint| > 31
			debugger // sigh
			a = 0
		|| r = .registers[a]!
		if r == .zero or r.info isnt ConstAny // now what?
		return r.Const

	
	function IntPowerOfTwo (|asmreg| r,  |FailableInt|)
		// -1 --> -1,  0 --> 0,  1 --> 1,  2 --> 2,  4 --> 3,  8 --> 4
		// this is used for multiplication mostly. like x*-1, or x*0, or x*1
		if r is ConstAny
			|| v = .GetConst(r)[]
			if v == -1
				return v
			if v.IsPow2
				return v.Log2+1

		if (!r.reg) // what?


	function AddConstantAndReturnOld (|message| exp,  |AsmReg| Dest,  |AsmReg| ToGrow,  |int64| Value,  |asmreg|)
		|| reg = .TempMe(exp, dest)
		if togrow.isint and value.CanStoreAsIntImmediate
			if 0
				exp.parent!.adpk(reg, togrow, togrow)
			return .AddASM(asm.ADPK, exp.parent!, reg, ToGrow, Value) * reg
		.Assign(reg, ToGrow, asmreg(), exp)
		rz = .AddConstant(exp, togrow, ToGrow, value)
	
	
	function AddConstant (|message| exp,  |AsmReg| Dest,  |AsmReg| Src,  |int64| Value,  |asmreg|)
		if dest.isint
			if Value.CanStoreAsIntImmediate
				return .AddASM(asm.ADDK, exp.parent!, dest, src, Value) * dest
		  elseif dest.FourBytes
			if value|uint64|.CanStoreAsfloatImmediate
				return .AddASM(asm.FADK, exp.parent!, dest, src, value) * dest
			debugger // how is this possible? we are adding a 64 bit float to a 32-bit?
		debugat
		|| where = .NumToReg(value, exp)
		return .Plus(dest, src, where, exp)
		
		
	function AddASM (|int| SM, |message| dbg, |int| a, |int| b, |int| c, |int| d, |int| e, |&FatASM|)
		pragma inline,  opt norefcounts,  cpp_part AddASM5
		rz = self <~ (sm, dbg)
		rz.r[0] = a
		rz.r[1] = b
		rz.r[2] = c
		rz.r[3] = d
		rz.r[4] = e
		
	function AddASM (|int| SM, |message| dbg, |int| a, |int| b, |int| c, |int| d, |&FatASM|)
		pragma inline,  opt norefcounts,  cpp_part AddASM4
		rz = self <~ (sm, dbg)
		rz.r[0] = a
		rz.r[1] = b
		rz.r[2] = c
		rz.r[3] = d

	function AddASM (|int| SM, |message| dbg, |int| a, |int| b, |int| c, |&FatASM|)
		pragma inline,  opt norefcounts,  cpp_part AddASM3
		rz = self <~ (sm, dbg)
		rz.r[0] = a
		rz.r[1] = b
		rz.r[2] = c

	function AddASM (|int| SM, |message| dbg, |int| a, |int| b, |&FatASM|)
		pragma inline,  opt norefcounts,  cpp_part AddASM2
		rz = self <~ (sm, dbg)
		rz.r[0] = a
		rz.r[1] = b

	function AddASM (|int| SM, |message| dbg, |int| a, |&FatASM|)
		pragma inline,  opt norefcounts,  cpp_part AddASM1
		rz = self <~ (sm, dbg)
		rz.r[0] = a
	
	function AddASM (|int| SM, |message| dbg, |&FatASM|)
		pragma inline,  opt norefcounts,  cpp_part AddASM0
		return self <~ (sm, dbg)

	syntax append (|int| code, |message| dbg, |&FatASM|)
		cpp_part RequestOp
		|| p = .curr
		if p < .end
			.curr = p + 1
			P.op = code
			p.debug = dbg
			p.BlockNum = .BlockNum
			p.ParentBlock = .ParentBlock
			return p
		.OK = false
		return .start
	
	syntax expect (|message?| where=nil, |string| msg)
		|| f = .fn.asm
			f.length = .curr - .funcstart
			printline f.render
		debugger
		error (where, msg)
		
	function DeclareMe (|Message| where,  |scdecl| Dest,  |asmreg|)
		|| d = .VDecls|int| + 1
		if (d + .vtmps <= 31)
			|| t = dest.ASMReg
			t.reg = d
			// target debug: dest.ASMSanity		// probably set to datatypecode.UnusedType (112) by default
			dest.DType = t|datatypecode|   		// right?
			target debug: dest.ASMSanity
			.vdecls = d
			return t
		error (self, where, "No free local variables.")			
	
	
	function TempMe (|Message| where,  |asmreg| T=asmreg.Temp,  |asmreg|) // .needreg
		if t.reg
			return t
		
		|| d = .vtmps|int| + 1
		if (d + .vtmps <= 31)
			t.reg = 32-d
			.vtmps = d
			return t
		error (where, "No free local variables.")

	
	function FoundCode (|int| i, |int64| code, |scdecl| d, |asmreg|)
		|| rp = .askreg(i)
		if rp and rp.const == code
			|| dest = d.asmreg
			dest.reg = i
			(Dest is constany)
			return dest

	function FindConst (|scdecl| d, |asmreg|)
		|uint64| Code = d.exportposition			
		for i in .vdecls+1
			|| f = .FoundCode(i,Code, d)
			if f != nil
				return f
				
		for i in .vtmps+0
			|| f = .FoundCode(31-i,Code, d)
			if f != nil
				return f


///////////////////////////////////////////////////////////////////////////////////////////////////
	
	function Branch (|message| cond,  |bool| neg=false,  |!&fatasm|)
		|| dest = asmreg.newCondRequest
		.WithinBranch++
		|| cmu = .µ(cond, dest)
		.WithinBranch--
		if cmu isnt cond
			(dest is negate) = (cmu isnt AlreadyNegated)
			cmu = .equals(dest, dest, cmu, cond)
		return cmu.needfat


	function µ (|message| exp, |AsmReg| Dest = asmreg(), |asmreg|)
		opt norefcounts
		pragma inline
		cpp_part Get
		|| T = exp.ASMType
		|| fn = fn_asm_table[T]!
		target debug
			if !T
				fn = fn_asm_table[exp.func|int|]!
				debugger

		|| OV = .VTmps
		rz = (fn)(self, exp, dest)
		if dest isnt StayOpen
			.VTmps = (ov)
		
		target debug
			if !rz.fatindex
				if (rz isnt constany) or rz.const
					error (self, "No asmgen!")
					rz = (fn)(self, exp, dest)
				
			  elseif !rz.µtype.isnumeric and rz.µtype is bool
				error (self, "No valid type on FAT info")
				rz = (fn)(self, exp, dest)


	function Prm (|message| prm, |asmreg|)
		|| r = .ExistingVar(prm)
		if r != nil
			return r
		// why not use tmps? won't these interfere with the function-passing??
		|| Where = .tempme(prm, asmreg())
		return .µ(prm, where)


	module
		|FatASM[]|					JSMSpace = FatASM[0]!
		|[memory of fatasm]|		Ancients
		|ASMState|					Sh
		


		
function @ASMTmp.DoFunc (fn_Asm)
	opt norefcounts
	|| prms = exp.last!
	|| fn = prms.asfunc
	ifn  fn and fn.args <= 10
		error (prms, "Too many parameters")
		return AsmReg()

	// speedie's function histogram:  0:410, 1:1656, 2:1464, 3:713, 4:167, 5:61, 6:10, 7:3, 8:1
	// there are only 4 above 6!, only 14 above 5

	if !dest
		dest = asmreg()
	  else
		dest = .TempMe(prms, dest)
		dest.µtype = fn.RegType

	|int| Reg2
	|int| Reg3
	|| sh = 0
	|| OV = .VTmps

	for p.fast in prms
		|| v = .prm(p).reg
		if sh <= 25
			reg2 |= (v << sh)
		  else
			reg3 |= (v << (sh-30))
		sh += 5
	.VTmps = (OV)
	
	|| OP = (asm.func2, asm.func3)(sh <= 25)
	if fn is Wrapper
		op = (asm.fncx2, asm.fncx3)(sh <= 25)

	|| SaveAmount = .vdecls * (dest isnt forreturn)
	return .AddASM(OP,  prms.parent!,  save: SaveAmount,  jump: fn.TableId,  reg2,  reg3) * dest


function ASMState.PackMakerInit (|bool|)
	opt norefcounts
	if sh.Inited
		return true
	sh.inited = true
	VM_Builder.JustDefineInstructions
	SpdAssembler.InitAss
	return .alloc(ASMState.JSMSpace)


function ASMState.Alloc (|memory of fatasm| j, |bool|)
	if j.SetCap(4MB)
		.start = j.ptr
		.curr = .start
		.end = j.Capacity + .start
		spdassembler.Guard
		Ancients <~ j
		return true


function @ASMState.ExpandJSM (|bool|)
	require .Ancients < 16
	|| j = FatASM[4MB]
		.Ancients <~ .jsmspace
		.JSMSpace = j
		return sh.Alloc(j)
	

function ASMState.StartFunc (|scfunction| fn)
	if fn.ASM
		.out = fn.asm!
	  else
		.out = µfunc(fn, .curr)
	for i in 32
		.Registers[i] = nil // i think its ok.
	.registers[0] = .zero
	.zero = nil
	.zero.info = AsmReg()
	.FuncStart = .curr
	.LabelCount = 0
	.fn = fn
	.ReturnType = fn.ReturnType.regtype
	.OK = true
	.VDecls = 0
	.VTmps = 0
	.AddFuncParams(fn)


function ASMState.FinishASM
	opt norefcounts
	if .zero.Const // what?
	|| l = .last
	ifn (l isa asm.ret) or (l isa asm.trap) 
		debugger
	.out.length = .curr - .out.IR


function int64.CanInt32 (|bool|)
	return  (self <<32)>>32 == self
	

function int64.CanFloat32 (|bool|)
	return  (self|uint64|>>32)<<32 == self
	
