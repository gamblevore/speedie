

// ADDK? optimise stages... OR special-case it specifically. 

//struct RegConstInfo
//	|?scdecl--| 		Type	// we only need this to check if the const is altered
								// so we only need 1 bit. Shouldn't we just store the fat anyhow?
								// we need the fat... because thats where the const lives.
//	|&FATASM|			Fat


struct ASMState
	linkage: cpp_part Pac
	|uint16| 					BlockNum
	|uint16| 					ParentBlock

	|uint|						VAvail
	|byte|						VDecls
	|byte|						VTmps
// OK, can we do this... just remove it and... make it work. We just need to be able 
// to add and remove. We also need some way to say that a regs exists, as a returned reg.
// So we can overwrite it even. But not written to. Basically a returned result.
// how to write that a reg is "Returned"? in closetmps?
	|datatypecode|				ReturnASM
	|bool|						OK    
	|bool|						Inited   

//	|SCFunction--|				fn     		// use scfunction.currfunc!
	|µFunc|						Out      
	|&FatASM|					FuncStart
	|&FatASM|					Start		// a "slice" feature would be nice    
	|&FatASM|					Curr    
	|&FatASM|					End    
	|(&FATASM)[32]|				RegConsts
	|FATASM| 					Zero

	
	function CloseVDecls (|int| i)
		|| v = .VDecls
		while v > i
			.CloseReg(v--)
		.VDecls = v

	function CloseVTmps (|int| i)
		target debug: if i < .vtmps // what?
		.VTmps = i

	function MarkAvailableValues
		|| NewV = (2<<.vdecls)-1
		|| sh = .vtmps
		if sh < 32
			NewV |= -1<<sh
		|| ToClose = .vavail &~ NewV
		.vAvail = NewV
		for (v.bits in ToClose) (i)
			.CloseReg(i)
		
	
	function CloseReg (|int| i)
		.RegConsts[i] = nil
	
			
	function AddFuncParams (|SCFunction| fn)
		opt norefcounts
		for a in fn.Args
			.DeclareMe(a.source, a)

	function Last (|&FatASM|)
		return .curr-1

	function RegPlace (|int| a, |?&uint64|)
		opt norefcounts
		|| InBounds = a|uint| <= 31
			|| fat = .RegConsts[a]
				return fat.const
			return nil

		|| msg = (": Unassigned register",  ": Out of bounds register")(InBounds)
		error (self, errorreceiver.NonFatal + msg)
			
		
	function GetConst (|int| RegNum, |&uint64|)
		// How do i say that some regs are "closed for write, but still readable".
		// Then each reg needs two bits. not just 1!
		// We can do this by using 64-bits per thingy. Or two 32-bits.
		opt inline
		|| r = .regplace(RegNum)
			if  !r[]  ==  !regnum
				return r
		debugger 
		return .zero.const


	helper FoundCode (|int| i, |uint64| Value, |asmreg| typeinfo, |asmreg|)
		opt norefcounts
		|| place = .regplace(i)$
		|| K = place[]
		if K == Value
			typeinfo.reg = i
			(typeinfo is ConstAny)
			return typeinfo

	
	function IntPowerOfTwo (|asmreg| r,  |FailableInt|)
		// -1 --> -1,  0 --> 0,  1 --> 1,  2 --> 2,  4 --> 3,  8 --> 4
		// this is used for multiplication mostly. like x*-1, or x*0, or x*1
		if r is ConstAny
			|| v = .GetConst(r)[]
			if v == -1
				return v
			if v.IsPow2
				return v.Log2+1

		if (!r.reg) // what?


	function IncrPost (|message| exp,  |AsmReg| Dest,  |AsmReg| ToGrow,  |int64| Value,  |asmreg|)
		|| reg = .TempMe(exp, dest)
		if togrow.isint and value.CanStoreAsIntImmediate
			return exp.ADPK(reg, ToGrow, Value) * reg
		.Assign(reg, ToGrow, asmreg(), exp)
		rz = .IncrPre(exp, togrow, ToGrow, value)

// a++, a + 1
// how to do this? In a magical fun beautiful adventure way
// well... Incrementatulatorifier creates the "Size", which is "Value" here.
// for &ptruint++, value is 4. But what about ptruint = ptruint + 1?
// This is tricky. We need to incrementatulatorify it. But by what? and where?
// we lost track of everything. Perhaps... we can do the work in the caller?
// it would work. Or assume that the thing we want to work on, is the left side
// but what about 1+ptruint? then once again... we lost it.
// we could make a special "Findifier" thing? Simply... if its a rel... then use correct side
// if not... use the first item. this relies on us passing in the correct exp message
// I think thats actually the cleanest.
// the next question is... "who passes in what". How can I RELY on the values passed in, being correct?
// i think for maths... it is clear. It is correct. Like a+1 or 1+a
// then lets check the others... then do a findifier.

	function IncrPre (|message| exp,  |AsmReg| Dest,  |AsmReg| Src,  |int64| Value,  |asmreg|)
		if dest.isint
			if Value.CanStoreAsIntImmediate
				return exp.ADDK(dest, src, Value) * dest
		  elseif dest.FourBytes
			if value|uint64|.CanStoreAsfloatImmediate
				return exp.FADK(dest, src, value) * dest
			debugger // how is this possible? we are adding a 64 bit float to a 32-bit?
		debugat
		|| where = .NumToReg(exp, value)
		return .Plus(dest, src, where, exp)


	syntax append (|int| code, |message| dbg, |&FatASM|)
		cpp_part RequestOp
		|| p = .curr
		if p < .end
			.curr = p + 1
			P.op = code
			p.debug = dbg
			p.BlockNum = .BlockNum
			p.ParentBlock = .ParentBlock
			return p
		.OK = false
		return .start


	syntax expect (|message?| where=nil, |string| msg)
		|| f = scfunction.currfunc!.asm
			f.length = .curr - .funcstart
			printline f.render
		debugger
		error (where, msg)


	function DeclareMe (|Message| where,  |scdecl| Type,  |asmreg|)
		|| d = .VDecls|int| + 1
		if (d < .vtmps)
			|| t = Type.CalculateASMType
			t.reg = d
			Type.wholetype = t|DataTypeCode|   		// right?
			.VAvail	|= 1 << d
			.vdecls = d
			target debug: Type.ASMSanity
			return t
		error (self, where, "No free local variables.")


	function TempMe (|Message| where, |asmreg| T=asmreg.Temp, |asmreg|)				// .needreg
		opt norefcounts
		|| r = t.reg
		if t isnt textual
			t.µtype = where.asmdecl.typeonly
		if !r
			r = .vtmps - 1
			check (r > .vdecls) (where, "No free local variables.")
			t.reg = r
			.vtmps = r
			.VAvail	|= 1 << r
		return t


	function RegMap (|int|)
		|| dcls = (.VDecls+1)~bits
		if .vtmps >= 32
			return dcls
		|| tmps = .vtmps~bits
		tmps = ~tmps
		return dcls ||| tmps


	function FindConstDecl (|scdecl| d, |asmreg|)
		return .findconst(d.exportposition, d.CalculateASMType)

	function FindConst (|uint64| Value, |asmreg| typeinfo, |asmreg|)
		// our vars will need checking by the nil-checker...
		// to see if loops/ifs harm this thing.
		// technically... the asm thing can handle the ifs...
		// but loops must be pre-checked!
		
		if !value
			typeinfo.reg = 0
			return typeinfo
		|| R = .regmap &~ 1
		for (b.bits in R) (i)
			|| f = .FoundCode(i, value, typeinfo)
			if f != nil
				return f


///////////////////////////////////////////////////////////////////////////////////////////////////
	
	function Branch (|message| cond,  |bool| neg=false,  |!&fatasm|)
		|| cmu = .µ(cond, asmreg.CondRequest)
		if cmu is CondAnswer
			return cmu.needfat
		|| req = asmreg.CondRequest
		if cmu isnt alreadynegated
			(Req is negate)
		debugger
		cmu = .equals(req, asmreg(), cmu, cond)
		return cmu.needfat


	function µ (|message| exp, |AsmReg| Dest = asmreg(), |asmreg|)
		opt norefcounts
		target !debug
			opt inline
		cpp_part Get
		|| fn = fn_asm_table[exp.ASMType]!
		|| TmpCloser = .VTmps
		|| ss = (fn)(self, exp, dest)
		if dest isnt StayOpen
			.CloseVTmps(TmpCloser)
			.MarkAvailableValues

		target debug
			|| ty = exp.ASMDecl
			if ty.typeonly != ss.µType
				printline exp
				debugger
				(fn)(self, exp, dest)
		return ss


	function FuncPrm (|message| prm, |scdecl| DestType,  |asmreg|)
		|| r = .ExistingVar(prm)
		|| OldTmps = .VTmps
		if r != nil
			return r
		return .µ(prm, r)


	module
		|FatASM[]|					JSMSpace = FatASM[0]!
		|[memory of fatasm]|		Ancients
		|ASMState|					Sh
		


		
function @ASMTmp.DoFunc (fn_Asm)
	opt norefcounts
	|| prms = exp.last!
	|| fn = prms.asfunc
	ifn  fn and fn.args <= 10
		error (prms, "Too many parameters")
		return AsmReg()

	// speedie's function histogram:  0:410, 1:1656, 2:1464, 3:713, 4:167, 5:61, 6:10, 7:3, 8:1
	// there are only 4 above 6!, only 14 above 5

	if dest.reg == 0
		dest = AsmReg()
	  else
		dest = .TempMe(prms, dest)
	dest.µtype = fn.RegType

	|int| Reg2
	|int| Reg3
	|| sh = 0
	|| TmpCloser = .VTmps

	|| p = prms.first
	for fnarg in fn.args
		expect (p) (exp, "Compiler did not fully type this function.") 
		|| v = .FuncPrm(p, FnArg).reg
		if sh <= 25
			reg2 |= (v << sh)
		  else
			reg3 |= (v << (sh-30))
		sh += 5
		p++
	.CloseVTmps(TmpCloser)
	// we still need to clear variables passed by address
	// like x = 12345, f(&x), if y == 12345 // can't reuse x as a const
	

	|| SaveAmount = .vdecls * (dest isnt forreturn)
	|| fat = exp.FNCX(SaveAmount,  fn.TableId,  reg2,  reg3) // exp.func2, exp.func3

	|| OP = (asm.FUNC2, asm.FUNC3)(sh <= 25)
	if fn is Wrapper
		op = (asm.FNCX2, asm.FNCX3)(sh <= 25)
	fat.op = op

	return fat * dest


function ASMState.PackMakerInit (|bool|)
	opt norefcounts
	if .Inited
		return true
	.inited = true
	VM_Builder.JustDefineInstructions
	SpdAssembler.InitAss
	return .alloc(ASMState.JSMSpace)


function ASMState.Alloc (|memory of fatasm| j, |bool|)
	if j.SetCap(4MB)
		.start = j.ptr
		.curr = .start
		.end = j.Capacity + .start
		spdassembler.Guard
		Ancients <~ j
		return true


function @ASMState.ExpandJSM (|bool|)
	require .Ancients < 16
	|| j = FatASM[4MB]
		.Ancients <~ .jsmspace
		.JSMSpace = j
		return sh.Alloc(j)
	

function ASMState.StartFunc (|scfunction| fn)
	if fn.ASM
		.out = fn.asm!
	  else
		.out = µfunc(fn, .curr)
	.zero = nil
	.zero.info = AsmReg()
	(.zero is NeverAltered)
	for i in 32
		.CloseReg(i)
	.VAvail = 1
	.FuncStart = .curr
	scfunction.currfunc = fn
	.ReturnASM = fn.ReturnType.regtype
	.OK = true
	.VDecls = 0
	.VTmps = 32
	.AddFuncParams(fn)


function ASMState.FinishASM
	opt norefcounts
	if .zero.Const // what?
	|| l = .last
	ifn (l isa asm.ret) or (l isa asm.trap)
		|| fn = scfunction.currfunc!
		expect (!fn.returntype) ("ASMReturn".internal) // why?
		fn.sourcearg!.RET(asmreg(), asmreg(), 1, 0)
	.SetLength


function ASMState.SetLength
	.out.length = .curr - .FuncStart


//function int64.CanInt32 (|bool|)
//	return  (self <<32)>>32 == self
//	
//
//function int64.CanFloat32 (|bool|)
//	return  (self|uint64|>>32)<<32 == self
//	
