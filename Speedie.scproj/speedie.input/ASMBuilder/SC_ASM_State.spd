

struct InlineBlock
	|scfunction!--|	Fn    
	|asmreg|		Return
	|byte|			VDecls
	|byte|			BranchDepth
	|byte|			InlineDepth


struct ASMState
	linkage: cpp_part Pac
	|uint16| 					BasicBlock
	|DataTypeCode|				ReturnASM

	|InlineBlock|				State
	|byte|						DeepestInline
	|byte|						InlineLimit
	|byte|						StackSize
	|byte|						VDecls
	|byte|						VTmps
	|bool|						Inited
	|bool|						TailInlineable

	|scfunction|				Out

	|?memory of fatasm|			JSM
	|&FatASM|					FuncStart
	|&fatasm|					LastDebug
	|&FatASM|					Start		// a "slice" feature would be nice    
	|&FatASM|					_Curr    
	|&FatASM|					End    

	|scdecl--[32]|				Vars
	|FatASM| 					Zero

	constants
		kContinue		= 254
		kExit			= 255
	

	module
//		|FatASM[]|					JSMSpace = FatASM[0]!
		|ASMState|					Sh


	function fn (|scfunction!--|)
		return .state.fn
	function Curr (|&fatasm|)
		return ._curr

	function OpenVars (|uint|)
		rz = (.VDecls|uint| << 8) ||| (.vtmps << 0)
		
	function CloseVars (|uint| V)
		|| top = .vdecls
		|| d = (v>>8)&255
		while top > d
			.Vars[top] = nil
			top--
			
		.VDecls = d
		.VTmps = v&255
			
	function AddFuncParams (|SCFunction| fn)
		opt norefcounts
		for a in fn.Args
			(a is param) // reset
			.DeclareMe(a.source, a)
	
	function Index (|int|)
		return ._curr - .start
	
	function Last (|&FatASM|)
		return ._curr - 1

	function Last (|asm| type, |&FatASM|)
		|| L = ._curr - 1
		if l isa type
			if l.blocknum == .basicblock
				return L
	
	function IntPowerOfTwo (|asmreg| r, |int| Sub=0, |FailableInt|)
		// -1 --> -1,  0 --> 0,  1 --> 1,  2 --> 2,  4 --> 3,  8 --> 4
		// this is used for multiplication mostly. like x*-1, or x*0, or x*1
		|| v = r.const
		if v == -1
			if sub
			.NopConst(r)
			return v
		v -= Sub
		if v.IsPow2
			.NopConst(r)
			if !v
				return 0
			return v.Log2+1


	function IncrPost (|message| exp,  |AsmReg| Dest,  |AsmReg| ToGrow,  |int64| Value,  |asmreg|)
		if togrow.isint and value.CanStoreAsIntImmediate
			return exp.ADPK(dest, ToGrow, Value) * Dest
		.Assign(dest, ToGrow, exp)
		rz = .IncrPre(exp, togrow, ToGrow, value)


	function AddToReg (|message| exp, |asmreg| Dest, |asmreg| Orig, |int64| Amount, |asmreg|)
		if !dest or dest == asmreg()
			dest.µtype = orig.µtype
		dest = .temponly(exp, dest)
		|| Where = orig • dest
		(where is realconst)
		|| K = .NumToReg(exp, amount, where, orig.µtype)
		return .Plus(dest, Orig, K, exp)
	
	
	function IncrPre (|message| exp,  |AsmReg| Dest,  |AsmReg| Src,  |int64| Value,  |asmreg|)
		if !src.reg // what?
		if !dest.reg
			dest = src
		src = .AddToReg(exp, src, src, value) 
		if dest.reg==src.reg
			return src
		return .Assign(dest, src, exp)


	syntax append (|asm| code, |message| dbg, |&FatASM|)
		cpp_part RequestOp
		return dbg * code

	syntax expect (|message?| where=nil, |string| msg)
		cpp_part Fail
		|| f = SCFunction.currfunc!
		f.µlength = .curr - .funcstart
		printline f.µrender
		debugger
		error (where, msg)


	function DeclareMe (|Message| where,  |scdecl| Type,  |asmreg|)
		|| t = Type.CalculateASMType
		// if we have a var, that we are returning, and we are an inline.
		if .state.Return and (type is ReturnedVar) and (.state.fn.ReturnedVars == 1)
			t = .state.Return
			Type.wholetype = t|DataTypeCode|
			return t
		
		|| d = .VDecls|int| + 1
		t.reg = d
		Type.WholeType = t|DataTypeCode|
		if (d < .vtmps)
			.Vars[d] = Type
			.Vdecls = d
			target debug: Type.ASMSanity
			return t
		error (self, where, "No free local variables.")


	function TempTyped (|Message| where, |asmreg| T, |scdecl| Type,  |asmreg|)
		t.µtype = type.datatype
		return .TempOnly(where, t)
	
	
	function TempTyped (|Message| where, |asmreg| T=asmreg.Temp, |asmreg|)				// .needreg
		opt norefcounts
		if t isnt textual
			// what if there is a type and its different?
			// and if its NEVER different... why add it?
			t.µtype = where.asmdecl.datatype
		return .TempOnly(where, t)


	function TempOnly (|Message| where, |asmreg| T=asmreg.Temp, |asmreg|)				// .needreg
		opt norefcounts
		if t.reg
			return t
		|| r = .vtmps - 1
		check (r > .vdecls) (where, "No free local variables.")
		t.reg = r
		.vtmps = r
		(t isnt realconst) // why would it be?
		(t is temp)
		return t
	
	
	function NopReg (|asmreg| R)
		|| f = r.fat
			return .Nop(f)
		if r.reg and r isnt param
			debugat // bad!
	
	
	function Nop2Consts (|asmreg| A, |asmreg| B)
		.nopconst(A)
		.nopconst(B)
		.nopconst(A) // in case of swapped order
	
	
	function Const (|asmreg| R, |int| bits, |bool| signed, |ind|)
		if R is ConstOutput
			|| k = R.const
			if k.fits(bits, signed)
				.NopConst(R)
				return k|uint64|.trim(bits)

	function NopConst (|asmreg| R)
		if (r is RemoveableOutput) or (r is realconst)
			|| f = r.fat
				.Nop(f)
	
	function Nop (|FATASM| Fat, |int| Depth=0)
		if depth > 5
		|| C = .curr - 1
		if fat == C
			._curr = C // nice
		return .SoftNop(fat, depth+1)
		
	function SoftNop (|FATASM| Fat, |int| Depth=0)
		if depth > 5
		for f.fatinputs in fat
			.decr(f, depth+1)
		fat.setop = asm.noop
	
	function Decr (|?&fatasm| f, |int| Depth=0)
		if depth > 5
		if f and --f.µRefCount <= 0
			//f.debugprint
			//debugger 
			.Nop(f, depth+1)
	
	function SofterNop (|FATASM| Fat)
		fat.setop = asm.noop
	
//	function AskSoftNop (|fatasm| f)
//		if f.µRefCount <= 0
//			.softnop(f)
	
	function AskNop (|fatasm| f)
		if f.µRefCount <= 0
			.nop(f)

	function Rewind (|fatasm| start)
		.NopRange(start, .curr)
	
	
	function NopRange (|fatasm| Start, |fatasm| After)
		while start < After
			.nop(--after)
			
		
///////////////////////////////////////////////////////////////////////////////////////////////////

	function µBoolInto (|message| exp, |AsmReg| Dest, |asmreg|)
		|| X = .ExistingVar(Exp)
		X ?= .µInto(exp, dest)
		if  (X.µtype isnt bool)  or  (dest is negate  and  X isnt AlreadyNegated)
			return .exists(dest as (X bitand ASMReg.FromExistingVar), X, exp)
		return .Assign(dest, X, exp)


	function µInto (|message| exp, |AsmReg| Dest, |asmreg|)
		|| r = .µ(Exp, dest)
		if r.reg == dest.reg
			return r
		|| dest2 = r.reg(dest)
		(dest2 is temp) = (dest is temp)
		return .Assign(Dest2, r, exp)

		
	function µ (|message| exp, |AsmReg| Dest = asmreg(), |asmreg|)
		description "Same as µGetASM, except this closes temp vars for reuse." 
		|| Closer = .OpenVars
		rz = .µGetASM(exp, dest)
		.CloseVars(Closer)


	function µReffed (|message| exp, |AsmReg| Dest = asmreg(), |asmreg|)
		rz = .µGetASM(exp, dest)
		|| f = rz.fat
			f.µRefCount++


	function µGetASM (|message| exp, |AsmReg| Dest = asmreg(), |asmreg|)
		opt norefcounts
		cpp_part GetASM 

		|| fn = fn_asm_table[exp.ASMType]!
		target debug
			dest.TmpCheck
			if ++.stacksize > 20 // ugh
			debugat 0 // keep this
				
		  else
			opt inline
		|| ss = (fn)(self, exp, dest)

		target debug
			.stacksize--
			if !ss.tmpcheck
				(fn)(self, exp, dest)
			if !ss or dest is set or ss is set
				return ss // no need test.
			if !ss.reg and (ss isnt condanswer)
				if (ss isnt ExitFunction) and (ss isnt constoutput)
					debugger
					PrintProgress()
					(fn)(self, exp, dest)
		return ss
	

	function ReadOrWrite (|ASMReg| dest, |message| m, |asmreg| base, |asmreg| VarAdd, |scdecl| Ty,  |int| index=0, |asmreg|)
		if dest is FromZeroMemory or set
			(dest is realconst) // make compiler happy
		return .ReadOrWriteSub(dest, m, base, VarAdd, ty, index) * dest


	function ZeroMemory (|int| Index, |message| Exp, |asmreg| Base, |asmreg| VarAdd, |scdecl| D, |&fatasm|)
		check (d and !index and !varadd.reg) (exp)
		if d
			index = d.SizeOfQuery
			check (index < 512K and index > 0) (exp, "Can't zero that much memory")
		return exp.MEMZ(base, index)
	
	
	function ReadOrWriteSub (|ASMReg| Dest, |message| Exp, |asmreg| Base, |asmreg| VarAdd, |scdecl| D,  |int| Index, |&fatasm|)
		if dest is containsaddr
			#!wait?? this is meant to be an addrrequest? not a response.
			debugger
		
		if dest is FromZeroMemory
			return .ZeroMemory(index, exp, base, varadd, D)
		
		
		(dest asnt= asmreg.AddrRequest)
		|| T = dest.µtype
		|| bytes = t.ByteCount.log2
		if  (bytes|uint| > 4)
			error (exp, "Object to large to access")				// can we do struct-mem-copy?
			bytes = 0
		
		if varadd is ConstOutput
			|| CC = varadd.fat
				if varadd is RealConst
					.nop(cc)
				index += cc.const
				varadd = asmreg()
		//  ADDK: bs, r1, 4
		//  RD1U: r2, bs, value, 4, 0
		base = .InlineOffsetOpt(Base, bytes, &index, 127)

/*
	// these need to be opted. Not always happening? InlineOffsetOpt seems to only do ADDK, not ADPK
	ADPK: t30, r2, 4                               /* R++ */
	WR4U: t31, t30, r0, 0, 0                       /* R++[0] */	
*/

		
//		|| Move = .TryAddPKMemory(base) // how is this different to inlineoffsetopt?
		if index >= 128												// read/write only allows up to 127
			index <<= bytes
			base = .AddToReg(exp, asmreg(), base as asmreg.noscale, index)
			index = 0
		
		rz = exp.RD4U(dest, base, varadd, index, 0)
		if dest is set
			rz._op = ASMType.WriteASM[bytes]
		  else
			|| B = (bytes<<1) + t.issigned
			rz._op = ASMType.ReadASM[b]


	function Read (|asmreg| dest, |message| exp,  |asmreg| ptr,  |asmreg| varadd,  |int| index=0,  |&fatasm|)
		opt inline
		(dest isnt set)
		return .ReadOrWriteSub(dest, exp, ptr, varadd, nil, index)
		

	function Write (|asmreg| dest, |message| exp,  |asmreg| ptr,  |asmreg| varadd,  |int| index=0,  |&fatasm|)
		opt inline
		(dest is set)
		return .ReadOrWriteSub(dest, exp, ptr, varadd, nil, index)


	function PrmCollectC (|message| prms,  |SCFunction| fn,  |&uint| Addrs,  |uint64|)
		// we need to do ints last, and also collect these backwards.
		opt norefcounts
		|int64| sh = 64
		|| fc = 0
		|| ic = 0
		|| n = fn.args.Length
		for Ints in 2
			|| p = prms.first
			while p
				|| ty = p.ASMDecl
				if ty.SpecialRegs|int| != Ints		// should get .SpecialRegs from message somehow?
					|int64| v = .µReffed(p!).reg
					sh -= 5
					rz  |=  v << sh
					ic += ints
					fc += !ints
					if .Last isa asm.GRAB
						addrs[] |= v.Log2
				p++
		
		rz >>= 64-((n*5)+12)
		if fc>8 or ic>8			// hmmm
		rz |= fn.ReturnType.SpecialRegs << 11
		if fc
			rz |= (8-fc) << 6
			rz |= (8-ic) << 0
		  else
			rz |= (17-ic) << 6


	function PrmCollect (|message| prms, |scfunction| fn, |&uint| Addrs,  |uint64|)
		opt norefcounts
		if fn.HasCVersion
			return .PrmCollectC(prms, fn, addrs)
		
		|| sh = 7
		|| p = prms.first
		for FnArg in fn.args
		// We'd like to collect bits on the SIMD/normal register file
		// for nativisation. 6 - bits per thing. Still counts as a 64-bit number
		// FuncPrmBits() also would need upgrading.
			|| v = .µReffed(p!).reg
			rz  |=  v << sh
			sh += 5
			rz++								// Send-count (4 bits max)
			p++
			if .Last isa asm.GRAB
				addrs[] |= v.Log2


	function VDeclsExit (|asmreg| dest, |int|)
		if (dest is ExitAtAll) and .state.return
			return .state.VDecls
		return .VDecls
			

	function CallFunc (|message| exp,  |asmreg| dest,  |scfunction| fn,  |asmreg|)
		|| v = .VDeclsExit(Dest)

		// needs fix
		// So... if the dest is in a temp location (r31)... well... we can't put it there.
		// So we can put it in the last, or after the last. Thats all.
		// So it seems like unless it is equal to the last one... we have to increment it.
		// Also... I think this can't be a temp, because we literally moved up the vdecls.
		
		v += (dest.reg != v)
		.Vdecls = v
		check (v < 32) (exp, "Too many registers in use. No space for result.")
		dest.reg = v
		dest.µtype = fn.RegType
		return dest.ReallySimplify


	function PackMakerInit
		opt norefcounts
		require !.Inited
		.inited = true
		VM_Builder.JustDefineInstructions
		instruction.InstructionInit
		ASMType.InitAccess
		Instruction[asm.KNSR].Const
		Instruction[asm.KNST].Const
		asm.encoders[asm.KNST] = fatasm.KNST_Encoder
		asm.encoders[asm.noop] = fatasm.NOOP_Encoder
		return 
		TextAssembler.Requests		?= dictionary()
		TextAssembler.RequestTable	?= array()
	
	
	function InitAndStartFunc (|scfunction| fn, |bool|)
		opt norefcounts
		
		target debug
			asm.noisyasm = 3
		
		.out = fn
		.state.fn = fn
		SCFunction.CurrFunc = fn
		.state.Return = nil
		.StackSize = 0
		.state.inlinedepth = 0
		.state.BranchDepth = 0
		.TailInlineable = true
		.InlineLimit = 8
		.BasicBlock = 0
		.VDecls = 0
		.VTmps = 32
		.zero = nil
		.zero.info = AsmReg()
		memory.Fill((&.vars[0])|&byte|, 32*8, 0)

		|| j = .jsm init FatASM[256K]
		require j
		.end = j.NeedSpare(64K, j.itemcount)
		.start = j.ptr
		._curr = .start + j.Length
		.Guard
		fn.StartASM
		.LastDebug = .curr
		.FuncStart = .curr
		.ReturnASM = fn.ReturnType.regtype
		.AddFuncParams(fn)
		return true


	function FinishASM
		opt norefcounts
		if .zero.Const // what?
		|| l = .last
		if !l.IsFinisher
			debugger !.fn.returntype
			.fn.SourceArg!.rEt(asmreg(), asmreg(), asmreg(), 0, asmreg())
		.Optimise

		.out.µlength = .curr - .FuncStart
		.jsm!.length = .curr - .start 


	function Guard
		opt norefcounts
		|| A = asmreg()										// GUARD
		|| arg = .fn.SourceArg!
		target debug
			if arg.position < 0
				arg.position = 0 // skip error detection
		Arg.EROR(A,A,A,A,0)

	
	function FatASM.JumpImprove (|bool|)
		|| D0 = .jumpto!
		|| D = D0
		|| n = 0
		while d isa asm.jump
			d = d.JumpTo!
			expect (++n < 30) (.msg)
		
		if  (d isa asm.ret or d isa asm.tail)  and  (self isa asm.jump)
			.CopyFrom(d) // always jumping into an exit.
			return true
		
		if D != D0 // faster jump
			.JumpTo(D, ASMState.sh)
			return true
		

	
	function SmartSecretFat (|asmreg| Thg, |&fatasm|)
		|| F = thg.fat
			return F
		
		|| Where = .last
		|| Start = .FuncStart
		|| reg = thg.reg
		while  where >= start
			require where.BlockNum == .BasicBlock
			|| X = where.SmartFatness(reg)
			require !X.KnownFalse
			if X.knowntrue
				return where
			// now what?
			Where--


/* The .asint/.asfloat functions should be recognised as working on constants? Or is that just a general case of inline functions? Technically, its an inline func that does nothing, just returns the original... with a different type. */


	function IsASMConst (|message| exp, |bool|)
		|| fn = exp.func
		if fn == @num
			return true
		if fn == @thg // now what?
			return ASMType.ThgSub(self, exp, ASMReg.ConstRequest)
	
	
	function CanReuseParam (|message| Prms, |scdecl| A, |int| vr, |bool|)
		opt norefcounts
		if a isnt altered
			return true
		require (.state.return.reg == vr)
		for p.fast in prms
			// check for the address of the same var?
			if .ExistingVar(p).reg == vr
				require !rz
				rz = true
	
	
	function TryInline (|message| prms, |asmreg| dest, |scfunction| fn, |int| AllowedGain,  |asmreg|)
		opt norefcounts
		|| Start = .curr
		|inlineblock| Old = .state
		if !dest.reg and fn.ReturnType
			if dest is discard
				debugger // hmm?
			  else
				Dest = .TempOnly(prms, dest)
		
		if dest isnt ExitFunction
			.TailInlineable = false
		  elseif .state.InlineDepth == 0
			.TailInlineable = true
		
		|int| D = ++.state.InlineDepth
		.DeepestInline = D max .DeepestInline
		.state.fn = fn
		dest = dest.simplify
		dest.µtype = fn.RegType
		.state.Return = dest
		.state.VDecls = .vdecls
		.state.branchdepth = 0
		
		rz = .TryInlineSub(prms, fn, AllowedGain)
	
		.state = old
		if !rz
			.Rewind(start)

	
	function TryInlineSub (|message| prms, |scfunction| fn, |int| AllowedGain,  |asmreg|)
		opt norefcounts
		|fatrange| LL
		LL.Start = .curr
		.InlineParameters(prms)
		|| RealStart = .curr		// Params need to be done anyhow... so don't count them.
		fn.GenASM
		.RestoreParameters
		ll.after = .curr
		|| Result = .InlineFinishWithConsts(ll)
		|| Grown = .CurrGain(RealStart)
		if Grown <= AllowedGain
			return Result
	
	
	function InlineParameters (|message| prms)
		opt norefcounts
		|| p = prms.first
		
		for a in .fn.Args
			|| v = .ExistingVar(p!)
				|| vr = v.reg
				if .CanReuseParam(prms, a, vr)
					|| f = v.fat
					|| T = a.WholeType.reg(vr)
					a.DataType = t|datatypecode|
					(a is param) = (v is param)
					(a is body) = (v isnt param)
				  else
					v = nil
			
			if !v
				v = .DeclareMe(a.source, a)
				v = .µInto(p!, v as asmreg.DeclareInlineParam)
			.MakeConstFromASM(a, V, nil)
			p++
	

	function RestoreParameters
		opt norefcounts
		for a.backwards in .fn.Args
			.MakeConstFromASM(a, nil, nil) // parameters can never be const anyhow
			a.fatconstindex = 0
			a.paramfix

	
	function CurrGain (|&fatasm| Start, |int|)
		|| C = .curr
		while Start < C
			rz += start.exists
			start++ 
			

	function AskForInline (|Message| prms, |ASMReg| dest, |SCFunction| fn, |ASMReg|)
		opt norefcounts
		require .state.InlineDepth < .InlineLimit
		require fn.µlength and !fn.HasCVersion
		|| AllowedGain = 5 + (fn is inline) * 23		// assume that functions have 5 instruction overhead.
		|| Grace = 9
		
		for p.fast in prms
			Grace += .IsASMConst(p)<<2
	
		require (AllowedGain + Grace) > fn.µlength
	

		if !.state.InlineDepth
			.InlineLimit = 8
			.DeepestInline = 0
		|| I = .TryInline(prms, dest, fn, AllowedGain)
			return I		
		if !.state.inlinedepth and .DeepestInline > 1
/			.InlineLimit = 1
			i = .TryInline(prms, dest, fn, AllowedGain)
			if i
				return i

	
function SCFunction.HasCVersion (|bool|)
	if .IsLibrary
		return true
	require self is wrapper

	if .IsCppInBuilt == 1	// cpp_inbuilt. These normally have no address? but perhaps we made a wrapper for it in the exec? we should check if it still exists.
		debugat
		return true

	if .IsCppInBuilt == 2	// cpp_nothing: cpp_spd might sound better?
		debugat
		return false // need to be replaced with ASM intrinsics.

	if self Is ExternalLib	// cpp_libwrapper ?   // Speedie_Main in perry, counts as one!
		debugat
		return false  // i think only perry used this and only in debug mode within Xcode

	return true



function asmstate.RegsBitClear (|message| exp, |int| RegAddrs, |scfunction| fn)
	opt norefcounts
	for (b.bits in RegAddrs) (i)
		|| arg = fn.args[i]
		if arg and arg.PointerCount == 1
			|| in = arg.Internal
			if in and in.IsNormal and !in.IsFloat
				|| S = 64 - in.SizeOfQuery
				if S >= 0
					exp.BFLG(i.asm, i.asm, S, S, 0)


function @ASMType.ASMFunction (fn_asm) // dofunction function
	opt norefcounts
	|| prms = exp.last!
	|| TableID = 0
	|| fn = prms.AsFunc
		|| MiniDest = .AskForInline(prms, dest, fn)
			return MiniDest
	  else
		|| f = exp.first!
		TableID = .µ(f).Reg
		|| dcl = f.ASMDecl
		// need to execute exp.first
/		fn = dcl.Type.FuncProto			#expect (exp)

	// We can put the var into a reg... if its its a FuncPointer and use that reg, as the TableID
	// we also need to get the fn from exp.first.obj

	dest = .CallFunc(exp, dest, fn)
	if !fn.returntype
		(dest is constoutput)
	
	|| Closer = .OpenVars
	|uint| RegAddrs
	|| P = .PrmCollect(prms, fn, RegAddrs)
	.CloseVars(Closer)
	
	if !TableID
		tableid = fn.tableid ?? 0xFFFF // 0xffff means unknown?
		TableID += 31
	|| PExt = P >> 32
	|| fat = prms.FNC(dest, TableID, P,  PExt)
	if fn.HasCVersion
		fat._op = asm.FNCX
	fat._op += PExt > 0
	
	if RegAddrs
		.RegsBitClear(exp, RegAddrs, fn)
	
	fat.µRefCount += fn isnt stateless
	(dest is Exit) = fn is Killer
	return fat * dest


// Speedie's function histogram:  0:410, 1:1656, 2:1464, 3:713, 4:167, 5:61, 6:10, 7:4, 8:0
// There are only 4 above 6!, only 14 above 5, 75 above 4
// almost all lib functions have 4 or less. 5 is for proj funcs.
	


function fatasm.IsFinisher (|bool|)
	|| o = .op|asm|
	return o == asm.ret or asm.trap or asm.TAIL



ignore

	// how can we optimise this.
	// the BOR can be removed
	// how to remove it?
	// we could "just do it", but what problems might that create?
	// it depends on what we are doing with our dest...
	
	if x == 1
		tmp = fnc()
	  elseif x == 2
		tmp = fnc2()
	  else
		tmp = 3
	
	// now what? how can we do this? well... we can't.
	
	// but can we easily detect this case.
	
	if func()
	
	// well... its putting it, into a temp. So that temp, is never shared
	
	
	
	asm Inline_Branch1
		KNST: r1                  /# 0 #/              /* x = 0 */
		KNST: r1                  /# 1 #/              /* x = 1 */
		...                                            /* 0 */
		KNST: t30                 /# 0.5f #/           /* 0.5 */
		FNCX: r2, 1225, 123336, 0                      /* JB_f_SyntaxAccess(0.5) */
		BOR:  t31, r2, r0, 0                           /* JB_f_SyntaxAccess(0.5) */
		JBAN: t31, 1                                   /* hhhMaybeConst(0) */
		KNST: r1                  /# 2 #/              /* x = 2 */
		RET:  r0, r0, r0, 0, 0                         
	

	
	
