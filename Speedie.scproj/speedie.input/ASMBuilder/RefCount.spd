


function Assembler.RefCountSub (|message| exp, |message| prms, |scfunction| fn, |&FatASM|)	// JB_SetRef(a, b)
	opt	NoRefCounts
	
	if fn == compiler.RefClear
		|| offset = 0
		|| A = .µ(prms.first!, ASMReg.AddrRequest)
		A = .InlineOffsetOpt(A, 3, offset, 13, nil, prms.first!)
		return exp.RFWR(A, nil, 1, offset)						// reg to mem


	if fn == Compiler.RefSetRef
		|| DestMsg = prms.first!
		|| P = prms.second!
		|| A = .µGetReal(DestMsg, ASMReg.AddrRequest temp p)
		|| B = .µ(P, ASMReg.AddrRequest)
		if A iz B
			return nil // wat?
		
		|| offset = 0
		if A isnt ContainsAddr
			if B is ContainsAddr
				B = .InlineOffsetOpt(B, 3, offset, 13, P.ASMDecl, p)
				return exp.RFRD(A, B, 1, offset)				// mem to reg
			return exp.RFST(A, B)								// reg to reg
		
		|| glob = DestMsg.ASMDecl
		if  B is ContainsAddr
			|| where = .Temponly()
			where.µtype = datatypecode._voidptr
			B = .Read(where, P, B, nil, p.ASMDecl) * where		// (mem to reg)?
		
		A = .InlineOffsetOpt(A, 3, offset, 13, glob, p)
		return exp.RFWR(A, B, 1, offset)						// reg to mem


	if fn == Compiler.RefIncr2
		|| A = .µ(prms.first!, asmreg.AddrRequest)
		target debug: if a isnt ContainsAddr					// always memory
		|| offset = 0
		A = .InlineOffsetOpt(A, 3, offset, 13, nil, prms.first!)
		|| B = .µ(prms.second!)
		target debug: if b is ContainsAddr						// always reg
		return exp.RFWR(a, b, 0, offset)

	|| Obj = .µ(prms.first!)
	require !.RegIsConst(Obj, 0)
	target debug: if Obj is ContainsAddr						// always a reg!

	if fn == Compiler.RefIncr
		|| Last = .last(asm.GOBJ)
			if (Last.r0 iz Obj) and !Last.r1
				Last.r2 = 1										// incring a gobj. Lets do it internally!
				return Last
		|| fat = exp.rfun(asmreg(), asmreg(), Obj)
		Fat._Outputs = 0
		return fat

	if fn == Compiler.RefDecr
		.CloseOneEarly(Obj)
		|| Last = .last(asm.rfun, asm.GOBJ)
			|| Ret = .CanOptDecr(obj, last)
				if ret != last
					return nil
				return ret

			if (Last isa asm.GOBJ) and (Last.r0 iz Obj)  and  Last.r1
				last.r2 = 0							// decring a global mem obj. Lets just NOT incr!
				return nil

		return exp.rfun(Obj, Obj)
	

	if fn == Compiler.RefSafeDecr
		return exp.rfun(asmreg(), Obj)

	debugger 



// dead-code stripping means this is better in ASM, than at c-level phase.
function assembler.CanOptDecr (|asmreg| Obj, |&fatasm| last, |&fatasm|)
	require (last isa asm.rfun)
	require  !last.RegOnly(0)  and  !last.regonly(1)

	|| upon = last.r2
	require (upon iz Obj)

	|| uponfat = last.InputFat(2)
		if uponfat.IsRead and (uponfat.basicblock == .basicblock)
			// incr + decr = nothing... assuming it wasn't needed
			.SoftNop(Last)
			return last + 1
	
	// safe-decr result of func that returns disowned.
	last.r1 = upon
	last.r2 = 0
	return last


function Assembler.RefCount (fn_asm)	// JB_SetRef(a, b)
	opt norefcounts
	|| prms = exp.last!
	|| fn = prms.obj|SCFunction|!
	|| pf = prms.first
	if fn == compiler.RefNew
		|| A = .µ(pf!) // merge gtab into ralo?
		return exp.RALO(dest, A) * Dest

	if fn == Compiler.RefFreeIfDead
		|| A = .µ(pf!)
		#! Disallow: if obj.X(),   when obj.X() is a disowner
		#! Then we will never freeifdead within if-branch or other tests.
		#! needs understanding of disowners!
		exp.rfun(A)
		return a

	|| fat = .RefCountSub(exp, prms, fn)
		fat.µrefcount++
		return (fat * asmreg()) as asmreg()



function fatasm.IsDecr (|asmreg|)
	|| upon = (self)(0)
		if ((self)(1) == upon) and !(self)(2)
			return upon
	

function Assembler.DecrObj (|asmreg|)
	|| fat = .last(asm.RFUN)
		|| upon = fat.isdecr
			.nop(fat)
			return upon


function Assembler.SafeDecr (|asmreg| Match=nil, |asmreg|)
	|| fat = .last(asm.RFUN)$
	|| upon = (fat)(1)$

	require !match or upon iz match

	if !(fat)(0) and !(fat)(2)
		.softnop(fat)
		return upon


function assembler.CloseOneEarly (|asmreg| a)
	if a is temp
		// surely we want to do this anyhow?
	require a isnt temp
	|| d = .VDecls
	d &=~ (1<<a.reg) // Clear
	.CloseOneVar(nil, d, true)



function FinalDecrements (fn_asm)
	|| D0 = .SafeDecr(dest)$
	|| D1 = .decrObj
	|| D2 = .decrObj
	|| D3 = .decrObj
	return exp.RFRT(d0, d1, d2, d3) * asmreg.Exit


// OK... lets assume that we got a dest that came from rfap. well... it shouldn't.
// rfap in fact does not alter anything.

// so... shouldn't nopping reverse the .registers[] back to something that was set before
// within the same block?
// then... we can check that reg and use it.
	
