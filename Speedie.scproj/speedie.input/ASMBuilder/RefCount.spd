


function Assembler.RefCountSub (|message| exp, |message| prms, |scfunction| fn, |&FatASM|)	// JB_SetRef(a, b)
	opt	NoRefCounts
	if fn == compiler.RefClear
		|| offset = 0
		|| A = .µ(prms.first!, ASMReg.AddrRequest)
		A = .InlineOffsetOpt(A, 3, offset, 13, nil, prms.first!)
		return exp.RFWR(A, nil, 1, offset)						// reg to mem


	if fn == Compiler.RefSetRef
		|| DestMsg = prms.first!
		|| P = prms.second!
		|| A = .µGetReal(DestMsg, ASMReg.AddrRequest temp p)
		|| B = .µ(P, ASMReg.AddrRequest)
		if A iz B
			return nil // wat?
		
		|| offset = 0
		if A isnt ContainsAddr
			if B is ContainsAddr
				B = .InlineOffsetOpt(B, 3, offset, 13, P.ASMDecl, p)
				return exp.RFRD(A, B, 1, offset)				// mem to reg
			return exp.RFST(A, B)								// reg to reg
		
		|| glob = DestMsg.ASMDecl
		if  B is ContainsAddr
			|| where = .Temponly()
			where.µtype = datatypecode._voidptr
			B = .Read(where, P, B, nil, p.ASMDecl) * where		// (mem to reg)?
		
		A = .InlineOffsetOpt(A, 3, offset, 13, glob, p)
		return exp.RFWR(A, B, 1, offset)						// reg to mem


	if fn == Compiler.RefIncr2
		|| A = .µ(prms.first!, asmreg.AddrRequest)
		target debug: if a isnt ContainsAddr					// always memory
		|| offset = 0
		A = .InlineOffsetOpt(A, 3, offset, 13, nil, prms.first!)
		|| B = .µ(prms.second!)
		target debug: if b is ContainsAddr						// always reg
		return exp.RFWR(a, b, 0, offset)

	|| Obj = .µ(prms.first!)
	require !.RegIsConst(Obj, 0)
	target debug: if Obj is ContainsAddr							// always a reg!

	if fn == Compiler.RefIncr
		|| Last = .last(asm.gstr)
			if (Last.r0 iz Obj) and !Last.r1
				Last.r1 = 1							// incring a gstr. Lets do it internally!
				return Last
		|| fat = exp.rfun(asmreg(), asmreg(), Obj)
		Fat._Outputs = 0
		return fat

	if fn == Compiler.RefDecr
		.CloseOneEarly(Obj)
		|| Last = .last(asm.rfun, asm.gstr)
			|| Ret = .CanOptDecr(obj, last)
				if ret != last
					return nil
				return ret

			if (Last isa asm.gstr) and (Last.r0 iz Obj)  and  Last.r1
				last.r1 = 0							// decring a global mem obj. Lets just NOT incr!
				return nil

		return exp.rfun(Obj, Obj)

	if fn == Compiler.RefSafeDecr
		return exp.rfun(asmreg(), Obj)

	debugger 



// dead-code stripping means this is better in ASM, than at c-level phase.
function assembler.CanOptDecr (|asmreg| Obj, |&fatasm| last, |&fatasm|)
	require (last isa asm.rfun)
	require  !last.RegOnly(0)  and  !last.regonly(1)

	|| upon = last.r2
	require (upon iz Obj)

	|| uponfat = last.InputFat(2)
		if uponfat.IsRead and (uponfat.basicblock == .basicblock)
			// incr + decr = nothing... assuming it wasn't needed
			.SoftNop(Last)
			return last + 1
	
	// safe-decr result of func that returns disowned.
	last.r1 = upon
	last.r2 = 0
	return last


function Assembler.RefCount (fn_asm)	// JB_SetRef(a, b)
	opt norefcounts
	|| prms = exp.last!
	|| fn = prms.obj|SCFunction|!
	if fn != Compiler.RefFreeIfDead
		|| fat = .RefCountSub(exp, prms, fn)
			fat.µrefcount++
			return (fat * asmreg()) as asmreg()
		return nil
	|| A = .µ(prms.first!)

	#! Disallow: if obj.X(),   when obj.X() is a disowner
	#! Then we will never freeifdead within if-branch or other tests.
	#! needs understanding of disowners!
	
	exp.rfun(A)
	return a



function fatasm.IsDecr (|asmreg|)
	|| upon = (self)(0)
		if ((self)(1) == upon) and !(self)(2)
			return upon
	

function Assembler.DecrObj (|asmreg|)
	|| fat = .last(asm.RFUN)
		|| upon = fat.isdecr
			.nop(fat)
			return upon


function Assembler.SafeDecr (|asmreg|)
	|| fat = .last(asm.RFUN)
		|| upon = (fat)(1)
			if !(fat)(0) and !(fat)(2)
				.softnop(fat)
				return upon



function assembler.CloseOneEarly (|asmreg| a)
	require a isnt temp
	|| d = .VDecls
	d &=~ (1<<a.reg) // Clear
	.CloseOneVar(nil, d, true)



function FinalDecrements (fn_asm)
	|| D0 = .SafeDecr$
	if d0.reg != dest.reg					// problem
	|| D1 = .decrObj
	|| D2 = .decrObj
	|| D3 = .decrObj
	return exp.RFRT(d0, d1, d2, d3) * asmreg.Exit


// OK... lets assume that we got a dest that came from rfap. well... it shouldn't.
// rfap in fact does not alter anything.

// so... shouldn't nopping reverse the .registers[] back to something that was set before
// within the same block?
// then... we can check that reg and use it.
	
