


function Assembler.RefCountSub (|message| exp, |message| prms, |scfunction| fn, |&FatASM|)	// JB_SetRef(a, b)
	opt	NoRefCounts
	if fn == compiler.RefClear
		|| offset = 0
		|| A = .µ(prms.first!, ASMReg.AddrRequest)
		A = .InlineOffsetOpt(A, 3, offset, 13, nil, prms.first!)
		return exp.RFWR(A, nil, 1, offset)						// reg to mem


	if fn == Compiler.RefSetRef
		|| DestMsg = prms.first!
		|| P = prms.second!
		|| A = .µGetReal(DestMsg, nil, ASMReg.AddrRequest * p)
		|| B = .µ(P, ASMReg.AddrRequest)
		if A iz B
			return nil // wat?
		
		|| offset = 0
		if A isnt ContainsAddr
			if B is ContainsAddr
				B = .InlineOffsetOpt(B, 3, offset, 13, P.ASMDecl, p)
				return exp.RFRD(A, B, 1, offset)				// mem to reg
			return exp.RFST(A, B)								// reg to reg
		
		|| glob = DestMsg.ASMDecl
		if  B is ContainsAddr
			|| where = .Temponly()
			where.µtype = datatypecode._voidptr
			B = .Read(where, P, B, nil, p.ASMDecl) * where		// (mem to reg)?
		
		if (a.reg == 6) and (b.reg == 2) and "RefCountTests".trap 
		A = .InlineOffsetOpt(A, 3, offset, 13, glob, p)
		return exp.RFWR(A, B, 1, offset)						// reg to mem


	if fn == Compiler.RefIncr2
		|| A = .µ(prms.first!, asmreg.AddrRequest)
		target debug: if a isnt ContainsAddr					// always memory
		|| offset = 0
		A = .InlineOffsetOpt(A, 3, offset, 13, nil, prms.first!)
		|| B = .µ(prms.second!)
		if (a.reg == 6) and (b.reg == 2) and "RefCountTests".trap 
		target debug: if b is ContainsAddr						// always reg
		return exp.RFWR(a, b, 0, offset)

	|| A = .µ(prms.first!)
	require !.RegIsConst(a, 0)
	target debug: if A is ContainsAddr							// always a reg!

	if fn == Compiler.RefIncr
		|| P = .last(asm.gstr)
			if (p.r0 samereg a.reg) and p.r1 == 0
				p.r1 = 1
				return p
		|| fat = exp.rfst(asmreg(), a)
		Fat._Outputs = 0
		return fat

	if fn == Compiler.RefDecr
		|| P = .last
		#! what
		if (p isa asm.rfst)
			|| dblinput = p.InputFat(1)
				if dblinput.isread and (dblinput.basicblock == p.basicblock)
					.SoftNop(p)
					return nil
					// in fact... we don't need this at all.
			if (p.r1 samereg a.reg) and (p.r0 == 0)
				p._op = asm.RFAP
				p.r0 = p.prms[1]
				p.r1 = 0
				return p
		  elseif (p isa asm.gstr)
			if p.r0 samereg a.reg and p.r1 == 1
				return nil
		if "TestExportName".trap
		.ClearVarEarly(a)
		return exp.RFST(a, asmreg())

	if fn == Compiler.RefSafeDecr
		return exp.RFAP(asmreg(), a, asmreg())

	debugger 


function Assembler.RefCount (fn_asm)	// JB_SetRef(a, b)
	opt norefcounts
	|| prms = exp.last!
	|| fn = prms.obj|SCFunction|!
	if fn != Compiler.RefFreeIfDead
		|| fat = .RefCountSub(exp, prms, fn)
			fat.µrefcount++
			return fat * nil
		return nil
	|| A = .µ(prms.first!)

	#! Disallow: if obj.X(),   when obj.X() is a disowner
	#! Then we will never freeifdead within if-branch or other tests.
	#! needs understanding of disowners!
	
	exp.RFAP(A, asmreg(), asmreg())
	return a


function Assembler.DecrObj (|asmreg|)
	|| fat = .last(asm.rfst)
		|| upon = fat.prms[0]
		if upon.reg and !fat.prms[1].reg
			.nop(fat)
			return upon.ASMReg


function Assembler.SafeDecr (|asmreg|)
	|| fat = .last(asm.rfap)
		|| upon = fat.prms[1]
		if upon.reg and !fat.prms[0].reg
			.softnop(fat)
			return upon.ASMReg



function assembler.ClearVarEarly (|asmreg| a)
	require a isnt temp
	|| d = .VDecls
	|| r = a.reg
	d &=~ (1<<r) // i don't know. Is this good enough? i hope so?
	.VDecls = d



function FinalDecrements (fn_asm)
	|| D0 = .SafeDecr$
	if d0.reg != dest.reg					// problem
	|| D1 = .decrObj
	|| D2 = .decrObj
	|| D3 = .decrObj
	return exp.RFRT(d0, d1, d2, d3) * asmreg.Exit


// OK... lets assume that we got a dest that came from rfap. well... it shouldn't.
// rfap in fact does not alter anything.

// so... shouldn't nopping reverse the .registers[] back to something that was set before
// within the same block?
// then... we can check that reg and use it.
	
