


function Assembler.RefCountSet (|message| exp, |message| prms, |&FatASM|)
	opt	NoRefCounts
	|| DestMsg = prms.first!
	|| P = prms.second!
	|| A = .µGetReal(DestMsg, ASMReg.AddrRequest temp p)
	|| B = .µ(P, ASMReg.AddrRequest)
	if A iz B
		return nil // wat?
	
	|| offset = 0
	if A isnt ContainsAddr
		if B is ContainsAddr
			B = .InlineOffsetOpt(B, 3, offset, 13, P.ASMDecl, p)
			return exp.RFRD(A, B, 1, offset)				// mem to reg
		return exp.RFST(A, B)								// reg to reg
	
	|| glob = DestMsg.ASMDecl
	if  B is ContainsAddr
		|| where = .Temponly()
		where.µtype = datatypecode._voidptr
		B = .Read(where, P, B, nil, p.ASMDecl) * where		// (mem to reg)?
	
	A = .InlineOffsetOpt(A, 3, offset, 13, glob, p)
	return exp.RFWR(A, B, 1, offset)						// reg to mem



function Assembler.RefCountClear (|message| exp, |message| prms, |&FatASM|)
	opt	NoRefCounts
	|| offset = 0
	|| A = .µ(prms.first!, ASMReg.AddrRequest)
	A = .InlineOffsetOpt(A, 3, offset, 13, nil, prms.first!)
	return exp.RFWR(A, nil, 1, offset)						// reg to mem


function Assembler.RefCountIncr2 (|message| exp, |message| prms, |&FatASM|)
	opt	NoRefCounts
	|| A = .µ(prms.first!, asmreg.AddrRequest)
	target debug: if a isnt ContainsAddr					// always memory
	|| offset = 0
	A = .InlineOffsetOpt(A, 3, offset, 13, nil, prms.first!)
	|| B = .µ(prms.second!)
	target debug: if b is ContainsAddr						// always reg
	return exp.RFWR(A, B, 0, offset)


function Assembler.RefCountIncr (|message| exp, |message| prms, |ASMReg| Obj,  |&FatASM|)
	opt	NoRefCounts
	|| Last = .last(asm.GOBJ)
		if (Last.r0 iz Obj) and !Last.r1
			Last.r2 = 1										// incring a gobj. Lets do it internally!
			return Last
	|| fat = exp.rfun(asmreg(), asmreg(), Obj)
	Fat._Outputs = 0
	return fat



function Assembler.RefCountDecr (|message| exp, |message| prms, |ASMReg| Obj, |&FatASM|)
	opt	NoRefCounts
	|| Last = .last(asm.rfun, asm.GOBJ)
		|| Ret = .CanOptDecr(obj, last)
			if ret != last
				return nil
			return ret

		if (Last isa asm.GOBJ) and (Last.r0 iz Obj)  and  Last.r1
			last.r2 = 0							// decring a global mem obj. Lets just NOT incr!
			return nil
	
	return exp.RFUN(Obj, Obj)



function Assembler.RefCountSub (|message| exp, |message| prms, |scfunction| fn, |&FatASM|)
	opt	NoRefCounts
	
	if fn == compiler.RefClear
		return .RefCountClear(exp, prms)

	if fn == Compiler.RefSetRef
		return .RefCountSet(exp, prms)

	if fn == Compiler.RefIncr2
		return .RefCountIncr2(exp, prms)

	|| Obj = .µ(prms.first!)
	if !.RegIsConst(Obj, 0)
		target debug: if Obj is ContainsAddr						// always a reg!
	
		if fn == Compiler.RefIncr
			return .RefCountIncr(exp, prms, Obj)
	
		if fn == Compiler.RefEarlyDecr
			return exp.RFST(Obj, asmreg())								// reg to 0
	
		if fn == Compiler.RefDecr
			|| fat = .RefCountDecr(exp, prms, obj)
			.CloseOneVar(nil, 1<<Obj.reg)
			return fat
	
		if fn == Compiler.RefSafeDecr
			return exp.rfun(ASMReg(), Obj)

		debugger


// dead-code stripping means this is better in ASM, than at c-level phase.
function assembler.CanOptDecr (|asmreg| Obj, |&fatasm| last, |&fatasm|)
	require (last isa asm.rfun) // rfst 0?
	require  !last.RegOnly(0)  and  !last.regonly(1)

	|| upon = last.r2
	require (upon iz Obj)

	|| uponfat = last.InputFat(2)
		if uponfat.IsRead and (uponfat.basicblock == .basicblock)
			// incr + decr = nothing... assuming it wasn't needed
			.SoftNop(Last)
			return last + 1
	
	// safe-decr result of func that returns disowned.
	last.r1 = upon
	last.r2 = 0
	return last


function Assembler.RefCount (fn_asm)	// JB_SetRef(a, b)
	opt norefcounts
	|| prms = exp.last!
	|| fn = prms.obj|SCFunction|!
	|| pf = prms.first
	if fn == compiler.RefNew
		|| A = .µ(pf!) // merge gtab into ralo?
		return exp.RALO(dest, A) * Dest

	if fn == Compiler.RefFreeIfDead
		|| A = .µ(pf!)
		#! Disallow: if obj.X(),   when obj.X() is a disowner
		#! Then we will never freeifdead within if-branch or other tests.
		#! needs understanding of disowners!
		exp.rfun(A)
		return a

	|| fat = .RefCountSub(exp, prms, fn)
		fat.µrefcount++
		return (fat * asmreg()) as asmreg()



function fatasm.IsDecr (|asmreg|)
	|| upon = (self)(0)
		if ((self)(1) == upon) and !(self)(2)
			return upon
	

function Assembler.DecrObj (|asmreg|)
	|| fat = .last(asm.RFUN) // rfst 0 is better?
		|| upon = fat.isdecr
			.nop(fat)
			return upon


function Assembler.SafeDecr (|asmreg| Match=nil, |asmreg|)
	|| fat = .last(asm.RFUN)$
	|| upon = (fat)(1)$

	require !match or upon iz match

	if !(fat)(0) and !(fat)(2)
		.softnop(fat)
		return upon


function FinalDecrements (fn_asm)
	|| D0 = .SafeDecr(dest)$
	|| D1 = .DecrObj
	|| D2 = .DecrObj
	|| D3 = .DecrObj
	return exp.RFRT(d0, d1, d2, d3) * asmreg.Exit

