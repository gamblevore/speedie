

/*	
* Here is the approach we will use: "Pre-compile... analyse, then rewind""
	* Can be sped up by making it more complex to avoid stuff.
*/



function message.Declable (|message!|)
	opt norefcounts
	|| fn = .func
	if fn == @decl
		self = .second!
		fn = .func
	while fn == @type
		self = .first! // no go into the type!
		fn = .func
	if fn == @func
		return .second!
	return self



extend Assembler {

function FatASM.CanGlobalGrab (|uint64| find, |uint64| range, |uint64| BS, |asmreg|)
	|uint64| Addr = .prms[2]
	require Addr <= find
	require addr + range > find
	require !(addr & ((1<<BS)-1))
	return .info


function TryGetGlob (|SCDecl| D, |asmreg| Mode, |asmreg|)
	// mode can be used to require an exact match
	|| G = d.GlobInfo
	|| B = G.ByteCount
	|uint64| range = 64 * B  // the idea is to be within N items, and before the item, and be aligned.
							 // So what should N be?  Read/Write takes 7 bits, but CNTC uses 6 bits!
	|uint64| find = d.ExportPosition

	B--	// now, lets align this shit.
	if mode is AddrNoFiddle or d is library // need exact match.
		range = 1
	
	for old.Known in Assembler.sh
		if old isa asm.gtab
			|| OK = old.CanGlobalGrab(find, range, B)
				return OK


function scdecl.IsLib (|int|)
	return (self Is Library)|int|


function GlobAddr (|SCDecl| D, |message| exp, |AsmReg| Dest, |asmreg|)
	opt norefcounts
	dest = .temptyped(d, dest)
	|| Glob = .TryGetGlob(D, dest)
		return Glob

	(Dest is GlobalMemory)
	dest = dest.haveaddr	
	dest.Âµtype = DataTypeCode._voidptr
	if !d.isLib
		return .GlobAddrSub(d, exp, dest, d.exportposition)
	
	|| fat = exp.GTAB(dest,  1,  d.gpackid)
	fat.Const = d.exportposition
	rz = fat * dest
	

	
function GlobAddrSub (|SCDecl?| D, |message| exp, |AsmReg| Dest, |int64| ExportPos, |asmreg|)
	opt norefcounts
	check (ExportPos <= 32~bits)			(exp, "Too much global data used: " + ExportPos.strsize)
	if  dest isnt AddrNoFiddle  and  d isnt ClassObj  and  d isnt Library
		ExportPos &= ~63
	
	|| Direct = ExportPos & 18~bits	
	|| fat = exp.GTAB(dest,  d.islib,  Direct)
	fat.Const = Direct
	rz = fat * dest
	
	|| Missing = ExportPos - Direct
		check (fat.r1) (exp, "Lib too big!") // should never happen!
		if missing >= 4096
			fat = exp.ADDB(dest, missing >> 12)
			fat.const = Direct + ((missing >> 12) << 12)
	/		rz = fat * dest

}



