

module Intrinsics
	|[message]| Floats
	|[message]| Vectors // both q and v


	function PullOutVecs (|bool|)
		opt norefcounts
		require stderr.ok
		|| f = .floats
		|| i = f.length
		while i > 0
			|| s = f[--i]
			|| fn = s.MsgOwningFunc #expect (s)
			|| input = fn.args[]!
			if input.IsNumeric > 1
				.Vectors <~ s
				f.FastRemove(i+1)
		return true


	function Process
		require .PullOutVecs
		|| vm = FastString()
		|| cpp = FastString()
		.ProcessTrin(vm, cpp, .Floats,  'F')
		.ProcessTrin(vm, cpp, .Vectors, 'V')
		// put into vmtrin_gen.box, despite reading vmtrin.box, so we can manually fix vmtrin.box if needed.
		// Otherwise impossible compile situations can happen. Very difficult to fix.
		// a bug exists in the one file, but we can't recompile... due to a bug that needs to be fixed
		// two recompiles down the road.
		VM_Builder.VMFile("vmtrin_gen.box").data = vm
/		VM_Builder.SafeWrite("vmtrin.h", cpp)
		

	function ProcessTrin (|faststring| vm, |faststring| cpp,  |[message]| codes, |byte| T)
		// the numbers in the map, mean nothing except for relative ordering.
		opt norefcounts
		|uint64| map
		codes.sort(TrinSort)
		
		for list in codes
			|| fn = list.MsgOwningFunc!
			|| num = list.first
			|| fn_name = fn.exportname				
			|| id = num.int
			|| AsmName = num.next.name
			|| Ty = fn.ReturnType!.Type.TypeInfo
			|| ReturnVec = Ty.NumericCount > 1
			|| RetType = ('v', 'f')(ReturnVec)
			if ty is bool
				RetType = 'u' // isnan
			
			check  !(ID &~63)		(num, "ID out of range")
			check  !((1<<ID) & map)	(num, "ID already used")
			map |= 1<<id
			|| C = fn.Args.Length
			|| T2 = t.LowerCase
			vm <~ "
/**/ $T$AsmName  (U$C)
	${RetType}1 = $fn_name("
			
			for i in C
				if i > 0
					vm <~ ", "
				vm <~ T2
				vm <~ (i+2)
			vm <~ ");\n"
			
			if !fn.IsCppInBuilt
				cpp_Export.WriteFuncSub(fn, fn.exportname, cpp)
				cpp <~ ";\n\n"


	function Message.TrinInt (|int|)
		opt norefcounts
		return .first.int
	
	
	function TrinSort (SorterComparer of Message)
		return  b.trinint - .trinint


function assembler.DoIntrinsic (|Message| where, |ASMReg| dest, |message| trin, |ASMReg|)
	opt norefcounts
	|| name = Trin[@thg]
	trin = name.next(@prm)$
	|| op = instruction[name!]$
	
	|| form = op.Sizes
	expect (trin.HasChildCount(form.Count))    				(trin, "Expected paramcount: " + form.Count)
	return .TheTrinity(where.last, trin, dest, op.opcode)


function assembler.TheTrinity (|message| SrcPrms, |message| ASMPrms, |asmreg| dest, |byte| OpCode, |asmreg|)
	opt norefcounts
	|| n = 0
	|asmreg[6]| Collection
	for s.fast in SrcPrms
		Collection[n++] = .ÂµTrin(s)
	
	|| fat = .RequestOp(OpCode, SrcPrms.parent!)
	|| DestPos = .FillTheFat(collection, fat, ASMPrms, n)
		dest = .TempOnly(dest)
		fat.Dest(destpos, dest, self)	
	return fat*dest
	

function assembler.FillTheFat (|&asmreg| Collection, |fatasm| fat, |message| Prms, |int| n, |ind|)
	opt norefcounts
	|| i = 0
	for s.fast in prms
		if s ~= "dest"
			s.expect(@thg)
			rz = i
		  else
			.Fries(Collection, fat, s, i, n)
		i++
	

function assembler.Fries (|&ASMReg| Collection, |fatasm| fat, |message| s, |int| i, |int| MaxParam)
	opt norefcounts
	if s.IsInt
		fat.NumInput(i) = s.int
		return
	require s.expect(@thg)

	|| name = s.name
	if name ~= "r0" // now what?
		fat.RegInput(i) = asmreg()
		return
	
	expect (name[] eq 'p') (s)
	
	|int| l = s.Int(1, 1, MaxParam)
		fat.RegInput(i) = collection[l-1] asnt asmreg.Textual


