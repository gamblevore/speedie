

module Intrinsics
	|[message]| Floats
	|[message]| Vectors // both q and v


	function PullOutVecs	
		opt norefcounts
		require stderr.ok
		|| f = .floats
		|| i = f.length
		while i > 0
			|| s = f[--i]
			|| fn = s.MsgOwningFunc!
			|| input = fn.args[]!
			if input.IsNumeric > 1
				.Vectors <~ s
				f.FastRemove(i+1)


	function Process
		|| fs = FastString()
		.PullOutVecs
		.ProcessTrin(fs, .floats)
		VM_Builder.SafeWrite("FTrin.i", fs)
		.ProcessTrin(fs, .vectors)
		VM_Builder.SafeWrite("VTrin.i", fs)
			
	
	function ProcessTrin (|faststring| fs, |[message]| codes, |int|)
		opt norefcounts
		codes.sort(TrinSort)
		
		for s in codes
			|| name = ""
			|| fn = s.msgowningfunc
				name = fn.exportname
			if s != @num
				name = s.firstname
				s = s.last(@num)
				if !s: continue
			
			|| id = s.int
			check  !(ID &~ 31) (s, "ID out of range")
			check  !((1<<ID) & rz) (s, "ID already used")
			rz |= 1<<id
			
			fs <~ "
	if (Mode == $id)
		return $name(R2);
"


	function Message.TrinInt (|int|)
		opt norefcounts
		if .func == @Num
			return .int
		return .last.int
	
	
	function TrinSort (SorterComparer of Message)
		return  b.trinint - .trinint


function assembler.DoIntrinsic (|Message| where, |ASMReg| dest, |message| trin, |ASMReg|)
	opt norefcounts
	|| name = Trin[@thg]
	trin = name.next(@prm)$
	|| op = instruction[name!]$
	
	|| form = op.Sizes
	expect (trin.HasChildCount(form.Count))    				(trin, "Expected paramcount: " + form.Count)
	return .TheTrinity(where.last, trin, dest, op.opcode)


function assembler.TheTrinity (|message| SrcPrms, |message| ASMPrms, |asmreg| dest, |byte| OpCode, |asmreg|)
	opt norefcounts
	|| n = 0
	|asmreg[6]| Collection
	for s.fast in SrcPrms
		Collection[n++] = .ÂµTrin(s)
	
	|| fat = .RequestOp(OpCode, SrcPrms.parent!)
	|| DestPos = .FillTheFat(collection, fat, ASMPrms, n)
		dest = .TempOnly(dest)
		fat.Dest(destpos, dest, self)	
	return fat*dest
	

function assembler.FillTheFat (|&asmreg| Collection, |fatasm| fat, |message| Prms, |int| n, |ind|)
	opt norefcounts
	|| i = 0
	for s.fast in prms
		if s ~= "dest"
			s.expect(@thg)
			rz = i
		  else
			.Fries(Collection, fat, s, i, n)
		i++
	

function assembler.Fries (|&ASMReg| Collection, |fatasm| fat, |message| s, |int| i, |int| MaxParam)
	opt norefcounts
	if s.IsInt
		fat.NumInput(i) = s.int
		return
	require s.expect(@thg)

	|| name = s.name
	if name ~= "r0" // now what?
		fat.RegInput(i) = asmreg()
		return
	
	expect (name[] eq 'p') (s)
	
	|int| l = s.Int(1, 1, MaxParam)
		fat.RegInput(i) = collection[l-1] asnt asmreg.Textual


