	

#!"if (x) return, a(), b()   -->   if !x {a(), b()}, return"


extend Assembler {

function ElseSub (|message?| other, |asmreg|)
	opt norefcounts
	if !other.HasAsmStuff
		return asmreg()
	|| T = other.ASMType
	if T == ASMType.kif
		return .IF(other, asmreg())
	if other != @arg
		other = other.first!
	  else
		debugger
	rz = ASMType.Argument(self, other)
	.NextBasicBlock


function If (fn_asm)
	|| Old = .BranchID
	.branchID = ++.NextBranchID

	.state.BranchDepth++
	rz = .ifsub(exp, dest)
	.state.BranchDepth--

	.branchID = Old
  


function IfSub (fn_asm)
	opt norefcounts

	|| cond = exp.first!,  || arg1 = cond.next!
	|| Other = arg1.next
	
	|FATRange| B
	.Branch(cond, B)
	if b.Never
		return .ElseSub(other)								// if k0 {b()} else {return}
	if b.Always
		return ASMType.Argument(self, arg1)					// if k1: return 

	|| Arg1Return = ASMType.Argument(self, arg1)
	if !other.HasAsmStuff									// if (x): func()
		|| Clamped = .MiniClampOpt(exp, b.start)
			return Clamped
		return .FinishSingleIf(b)
	
	|| AfterFirst = other.jump // basicblock ++
	.BranchToCurr(b)
	rz = .ElseSub(other) & Arg1Return						// if x {return} else {return}
	AfterFirst.JumpTo(.curr)


function LoopFill (|fatasm| C, |fatasm| S, |fatasm| A)
	while C < S
		#!ClearExits
		|| op = C.Op
		if op >= kContinue
			C._op = ASM.Jump
			if op == kContinue			// continue
				C.JumpTo(S)
			  else       				// exit
				C.JumpTo(A)
		C++
	

function While (fn_asm)
	|| Old = .BranchID
	.branchID = ++.NextBranchID
	
	.state.BranchDepth++ // loops are still branches
	rz = .WhileSub(exp)
	.state.BranchDepth--
	
	.BranchID = Old


function WhileSub (|message| exp,  |asmreg|)
	opt norefcounts
	|| InitialJump = exp.JUMP // basicblock ++								// test goes after loop
	|| Returns = ASMType.ArgumentSub(self, exp.second!)						// arg

	|FatRange| loop_test
	// how to step into this? Into the while-true
	.Branch(exp.first!, loop_test)
	if loop_test.never
		return ASMReg()
	
	if loop_test.always
		.Nop(InitialJump)		
		// now what?
		exp.JUMP.JumpTo(initialjump+1)
		loop_test.after++
	  else
		InitialJump.JumpTo(loop_test.start)
		loop_test.JumpTo(InitialJump+1)

	.loopfill(InitialJump+1 /*loop_start*/,  loop_test.start /*continue*/,  loop_test.After /*exit*/)
	
	return returns * loop_test.Always



function Exit			(fn_asm)
	opt norefcounts
	|| J = exp.jump											// request jump to exit
	J._op = kexit


function Continue		(fn_asm)
	opt norefcounts
	|| J = exp.jump											// request jump to continue
	J._op = kcontinue


function BackCond (|fatasm| start)
	|| l = .last
	require l >= start
	|| bb = l.basicblock
	.nop(l)
	--l
	if l.basicblock == bb  and  l >= start  and  l is Const
		.nop(l)


function Ternary		(fn_asm)
	opt norefcounts
	
	// I'd rather actually re-write this to be like an if-condition! Like reuse the code
	// then we can put back in, the opts... into the generalised "if" thing.
	// this will do for now.
	
	|| A = exp.second.second!
	|| B = A.next!
	
	// opt this:
	// x = JB_Ternary(Bool, 1, -1) --> 
	// x = -1
	// x += Bool << 1
	
	|| DestType = exp.ASMDecl.typeonly
	|| mA = .ExistingVar(a)
	|| mB = .ExistingVar(b)
	
	|| cond = a.prev!
	if ma isa DestType
		if (mb isa DestType) and !DestType.isfloat
			return .InbuiltTernary(dest, ma, mb, cond)
	
	dest = .TempTyped(exp, dest)
// too complex. also, miniternary starts off by assining cond to dest, which 
// might have been used in the input! Better to use some kind of asm-macro
// maybe just copy the code from "z"
//	if  ma isa DestType  and  ma isnt Const						// goes thru kk.isknown!
//		|| mC = .ExistingVar(cond)
//		if (ma == mc)
//			return .MiniTernary(dest, ma, b, cond)
	
	|FatRange| br
	.Branch(cond, Br)
	|| KK = br.Constness
	if KK.IsKnown
		|| which = (A, B)(KK.Default)
		return .ÂµInto(which, dest)

	return .RealTernary(exp, dest, a, b, br)


function RealTernary (|message| exp, |asmreg| dest, |message| A, |message| B, |fatrange| Branch, |asmreg|)
	|| ÂµA = .ÂµInto(A, dest)
	|| Exit = exp.jump // basicblock ++
	.BranchToCurr(Branch)
	rz = .ÂµInto(B, dest)
	.NextBasicBlock
	
	rz = .TernRefCount(Âµa, rz)						
	Exit.jumpto(.curr)


function TernRefCount (|asmreg| A, |asmreg| B, |asmreg|)
	// We want things that are refered to... to not disappear.
	rz = B
	|| fa = A.fat
	|| fb = B.fat		
		fb.ASMReg(5, A)			// refcount A, save from disposal
	  elseif fa
		rz = A


function InbuiltTernary (|asmreg| dest, |asmreg| ma, |asmreg| mb, |message| cond, |asmreg|)
	opt norefcounts
	|| mc = ASMReg()
	|| dr = dest.reg
		if (dr != ma.reg and mb.reg)
			mc = dest
	mc = .Âµ(cond, mc)
	
	if mc isnt Const
		return cond.TERN(dest, mc, ma, mb, mc.small) * dest

	|| t = (ma, mb)(mc.Const)
	.NopConst(mc)
	return t



function Branch (|message| Cond,  |fatrange| Range,  |bool| Neg = false,  |asmreg|)
	range.Start = .curr
	|| mode = asmreg.CondRequest.Negate(neg)

	rz = .Âµ(cond, mode)
	if rz isnt CondAnswer
		rz = .Exists(mode, rz, cond)

	if rz is Const
		range.Constness = (rz.const!=0)|maybebool|
		if rz is Const
			.BackCond(range.start)
	  else
		range.Constness = maybebool.default(false)
	
	range.after = .curr


// this was crazy complex before. We simplified it!
helper ASMBoolMaker (|message| exp,  |ASMReg| Dest,  |opmode| Opp,  |ASMReg|)
	opt norefcounts // ðŸ˜µâ€ðŸ’« // ðŸ˜µâ€ðŸ’« // ðŸ˜µâ€ðŸ’« // ðŸ˜µâ€ðŸ’«
	dest.Âµtype = DataTypeCode.bool
	
	|| A = exp.first!
	|| B = exp.last!
	if dest is CondRequest									// ðŸ˜¢ ðŸ˜¿ ðŸ˜¢ ðŸ˜¿ ðŸ˜¢ ðŸ˜¿ ðŸ˜¢ ðŸ˜¿ SADNESS!!
		if OPP is OR
			return .BranchOr(A, B, dest)
		return .BranchAnd(A, B, Dest)

	return .BoolAndOrOpt(A, b, dest, opp)
	


function FoundReg (|message| All, |int| R, |bool|)
	opt norefcounts
	all = all.Declable
	
	if all == @thg or @num	// nums used to be hoistable.
		|| d = all.FastDeclSafe
		if d is local
			|| v = d.WholeType
			if v.reg == r
				return true
		
	for s.fast in All
		if .FoundReg(s, r)
			return true


function Unchanged (|message| A, |asmreg| dest, |message| B, |bool|)
	|| Dr = dest.reg
	return !.FoundReg(a,dr) or !.FoundReg(b,dr)


function UniqueLocation (|message| A, |asmreg| dest, |message| B, |asmreg|)
	// a = a or b, can   directly set 'a' (But code isnt't smart enough?)
	// a = b or a, can't directly set 'a'
	// a = b or c, can   directly set 'a'
	if dest.reg
		if .Unchanged(A, dest, B)
			return dest
		  else
			debugger 
	rz = .TempOnly()
	(rz is negate) = (Dest is negate)
	rz.Âµtype = dest.Âµtype	


function BoolTestAndJump (|message| exp, |asmreg| req, |opmode| opp, |&fatasm|)
	|| mode = ASMReg.CondRequest.negate(opp is OR)
	return .Exists(mode, req, exp).fat!


	
function BoolAndOrOpt (|message| A, |message| B, |ASMReg| Dest, |opmode| Opp, |ASMReg|)
	opt norefcounts
	
	|| start = .curr
	|| bowl = .BoolAndOrValue(a, b, dest, opp)
	|| last = .Last
	if start + 2 != last
		return bowl
	
	|asm| middle = (start+1).Op
	ifn  (start isa asm.EQUL)  and  (last isa asm.EQUL)  and  (middle == asm.jbor or asm.jban)
		if 0: a.jbor, a.JBAN
		return bowl
	
	|| nA = start.prms[3]
	|| nB = last.prms[3]
	|| rA = start.asmreg(2)
	|| rB = last.asmreg(2)
	if !start.r1.Reg and !last.r1.reg and (ra iz rb)
		0
	  else
		ifn na.EqulInputsAreBothBool and nb.EqulInputsAreBothBool
			return bowl
	
	// equl: out, r0, in, mode
	na &= 1
	if na == nb&1
		.SoftNopRange(start+1, last+1)
		if ra iz rb				// a and/or a
			return bowl
		start.RegInput(1) = rB
		start.prms[3] = 63
		start._op = (asm.BAND, asm.BORR)((middle == asm.jban) == (na==0))
		if na
			A.parent!.BNOT(dest, nil, dest, 63)
		return start.info
	
	// do later:
	// if a and !a --> false
	// if a or !a  --> true
	
	return bowl



function BoolAndOrValue (|message| A, |message| B, |ASMReg| Dest, |opmode| Opp, |ASMReg|)
	opt norefcounts
	if dest is negate
		(opp xor= OpMode.AndOr)								//  !(a and b)  -->  !a or !b
		(dest is AlreadyNegated)

	|| Tmp = .UniqueLocation(a, dest, B)
	return .BoolAndOrValueSub(a,b,Tmp,opp)
		
	
function BoolAndOrValueSub (|message| A, |message| B, |ASMReg| Dest, |opmode| Opp, |ASMReg|)
	opt norefcounts
	
	target debug
		if asmtrapper == 211
	|| first = .ÂµBoolInto(A, dest)
	if first is Const
		return .BoolConst1(b, dest, opp, first).boolanswer			// x = 5 or Y() --> x = Y()
	
	|| JUMP = .BoolTestAndJump(a, first, opp)						// AND/OR
	|| Second = .ÂµBoolInto(B, dest)
	if Second is Const
		return .BoolConst2(first, second, opp, jump).boolanswer
	
	JUMP.JumpTo(.curr)
	
	if first.IsBool and Second.IsBool
		return dest.boolanswer

	return .Exists(dest, dest, A.next!)



function BoolConst1 (|message| B, |asmreg| dest, |opmode| Opp, |asmreg| ml, |asmreg|)
	|| V = (ml.const!=0) != (dest is negate)
	|| expect = opp is OR
	if v == expect
		ml.Âµtype = datatypecode.bool
		return .SetConst(b, v|int|, ml, dest)
									// x = 5 or  2	 --> x = true
									// x = 0 and 2	 --> x = false
	
	.NopReg(ml)						// x = 0 or y()  --> x = y()
									// x = 7 and y() --> x = y()
	|| mr = .Âµ(B, dest)
	if mr is Const
		mr.Âµtype = datatypecode.bool
		v = (mr.const!=0) != (dest is negate)
		return .SetConst(b, v|int|, mr, dest)
	
	if mr.isbool
		return mr
	return .Exists(dest, mr, B)


function BoolConst2 (|asmreg| ml, |asmreg| kr, |opmode| Opp, |FATASM| Jump, |asmreg|)
	|| V = kr.const!=0
	if v == (opp is AND)
		.softnop jump
		.NopReg(kr)
		return ml
		
	.nop jump // this also nops ml!
	return kr


function BranchAnd (|message| A, |message| B, |asmreg| dest, |asmreg|)
	|fatrange| AndTest
	|| First = .Branch(A, andtest, dest is negate)
	if AndTest.never
		return first

	|| Second = .Branch(B, AndTest, dest is negate)
	if  first isnt Const
		// a and b
		// a and 1
		// a and 0
		return first

	// 1 and 1
	// 1 and 0
	// 1 and b
	return second


function BranchOr (|message| A, |message| B, |asmreg| dest, |asmreg|)
	|FatRange| OrTest
	|| First = .Branch(A, OrTest, dest isnt negate)
	|| KF = OrTest.Constness.negate
	if kf.knowntrue
		|| fake = A.noop
		fake.const = KF|int|
		(first is condanswer)
		first.fatindex = fake.index
		return first.boolanswer						// only way around this. Cos we got asm-reg(0)

	|fatrange| Br2
	|| second = .Branch(B, Br2, dest is negate)
	.BranchToCurr(OrTest)

	if Br2.always
		// a or 1
		// 0 or 1
		return second

	if kf.KnownFalse
		// 0 or 0
		// 0 or b
		return second

	// a or 0
	// a or b
	
	return first
	
	
function NextBasicBlock
	// remove stuff in .register thats from a diff block as us? MAN i need to sleep first!
	.BasicBlock++
	// CloseOneVar does the closing right now. Which... isn't very good, because the var may still
	// be part of the same basic block, and therefor still exist!

	// shouldn't the BranchID shift with the basicblock Or not? IDK? For MegaNumFinder
	
	// or else ReDest is failing!

	
	
function MiniClampOpt (|message| exp,  |&FatAsm| compare, |float| D1=2, |float| D2=1,   |asmreg|)
	// Clamp for ints isn't used so much...
	// its actually very good for floats and vectors
	// and someday we'll have our own hardware... Might as well do this now then.
	
	|| bflg = .last(asm.bflg)!
	require (bflg - 1) == compare
	require (compare isa asm.jmpi or asm.jmpf)
	
	|| mode = compare.prms[2]
	|| Small = (mode>>2)&1
	// pretty sure this test needs fix for floats
	require (mode>>3) & 1 == Small

	if d1 > d2
		d1 = d2
	|| X = compare.ASMReg(0)
	|| Y = compare.ASMReg(1)
	|| IsMax = mode & 1
		swap (x) (y)
	|| A = bflg.ASMReg(0)
	|| B = bflg.ASMReg(1)
	if x iz b and y iz a
		ismax ^= 1
	  else
		require x iz a and y iz b
		swap (x) (y)
	.SoftNop(bflg)
	.SoftNop(compare)
	|| input = (y,x)(ismax)
	|| f = exp.clmi(a, x, input, y, small)
	if compare isa asm.jmpf // float
		f._op = asm.FCLM
		if 0: exp.FCLM
	  else
		if mode & 2
			f._op = asm.clmu
			if 0: exp.clmu
	return f * a


function FinishSingleIf (|fatrange| B, |asmreg|)
	.BranchToCurr(b)
	.NextBasicBlock
	return asmreg()

}




Struct FatRange
	|&FatASM|   Start
	|&FatASM|   After
	|maybebool| Constness
	
	
	function Always (|bool|)
		opt inline
		return .Constness.KnownTrue
	
	
	function Never (|bool|)
		opt inline
		return .Constness.KnownFalse
	
	iterator
		|| curr = .after!
		while (curr > .start)
			curr--
			yield curr


extend Assembler
	function InlineFinish (|fatrange| R, |ASMReg|)
		for s in R
			if s isa asm.ret
				if rz
					rz = rz.simplify
				  else
					|| dest = s.inputfat(0)
						rz = dest.info 
					  else
						rz = s.prms[0]|int|.asm
				s.SetOp = asm.jump
				s.JumpPrm = 1
				s.JumpFix(.curr)
		
		rz &= ~ASMReg.Exit
		(rz as= .state.return&asmreg.exit)
	
	
	function fatasm.JumpFix (|&fatasm| curr)
		isnt CondAnswer
		.JumpTo(curr) // shouldn't (s isnt CondAnswer) go inside .jumpto?
	
	
	function BranchToCurr (|FatRange| range)
		return range.JumpTo(.curr)
	
	
	function FatRange.JumpTo (|&FatAsm| curr)
		for s in self
			if (s is CondAnswer) and !(s isa asm.knst)
				s.JumpFix(curr)
	

function @assembler.PrintProgress
	cpp_name adb 
	visible
	opt norefcounts
	"---"
	|| fn = scfunction.currfunc!
	printline fn
	|| Base = assembler.sh.Start + fn.ÂµStart
	|| amount = fn.ÂµLength ?? (Assembler.sh.curr - base)
	for n in amount
		base[n].debugprint

