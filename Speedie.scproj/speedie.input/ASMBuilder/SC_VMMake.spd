

// i think the order of whats happening is wrong?
// it can't find the instructions or something?
// just step through the instruction lister thing and find out what is wrong
// 

module VM_Builder {
|[message]| 	NameList
|message|   	ModuleArg
|file|			vm_file
|faststring|	form_h = faststring()
|message|		dt_prm
|string|		parent
|byte|			NormalPos = 0


function DefineGetSub (|string| fname,  |int| up,  |int| down, |byte| c, |byte| c2)
	.form_h <~ "
#define   ${fname}${c}       (((${c2}int)((Op.Raw)<<$down))>>$Up)
#define   ${fname}${c}_(x)   (((${c2}int)((x)<<$down))>>$Up)
"


function DefineGet (|string| fname,  |int| up,  |int| down, |bool| last, |[message]|)
	if last
		.DefineGetSub(fname, up, down, 'i', ' ')
	.DefineGetSub(fname, up, down, 'u', 'u')
	rz <~ @thg + fname
	rz <~ up.msg
	rz <~ down.msg


// we need to create an array of forms...
function FillTypePrm (|string| fname, |int| pname)
	|| prop = @thg + fname
	.dt_prm <~ macros.ASMcopier.run(prop, pname.msg)


function GenAcc (|message| line, |int| bit_pos, |int| pname, |int| Max,   |int|)
	opt norefcounts
	|| n = Max - bit_pos
	|| lname = "_L"
	if line
		|| f = line.NeedFirst$
		|| f0 = *f.name
		if f0 == 'r'
			.FillTypePrm(line.name, pname)
			return 5+bit_pos
		if f0.isint
			n = f.int
		expect (n >= 1)  (line, "Too many total bits")
		expect (n <= (Max-8)) (line, "Too large field. Found: " + n.render)
		lname = "_" + line.name 
	
	lname = .Parent + lname
	|| arr = .DefineGet(lname, Max-n, bit_pos, bit_pos+n==Max)
	|| fnc_src = macros.ASMSetter.run(arr)
	SCFunction.newfunc(fnc_src, nil, line)
	
	.FillTypePrm(lname, pname)
	
	if  (bit_pos+n) > Max  or  n > (Max-8)  // bad
		error (.dt_prm, "Too many total bits")
	return n+bit_pos


function DataTypeModule 
	opt norefcounts
	|| module = "extend_module ASM:constants:"~parse
	compiler <~ module
	.modulearg = module.last.last.last


function AddForm (|message| form, |µform|)
	opt norefcounts 
	rz = µform(form)
	µform.forms.valuelower(form.name) = rz 


function string.ASMNormalise (|string|)
	|| n = 0
	for c in self
		c = c.lowercase
		if c == 'r' or 'n'	
			n++
		  elseif c == 'l' or 's' or 'j'
			0
		  else
			return self
	return "U" + ('0' + n)


function DataTypeCreate (|message| form,  |int| fnum,  |message|)
	opt norefcounts
	|| name = "ASM_" + form.name
	|| sigh = Macros.ASM_Datatype.run(
		@thg + name
		fnum.msg
	)
	rz = sigh.findnested(@list)
	rz++
	#!"This would be better if speedie grouped these, rather than spamming JB_InitCode_"
	while sigh.hasany
		compiler <~ sigh.first


function GenerateForms (|message| forms)
	opt norefcounts
	|| f = 0
	for form_msg in forms[@arg]
		if (f < 32) #check (form_msg, "Too many forms")
			using form_msg
			.GenerateOne(form_msg, ++f)


function GenerateOne (|message| form_msg, |int| f)
	opt norefcounts
	|| frm = .AddForm(form_msg)
	.dt_prm = .DataTypeCreate(form_msg, f)
	.parent = form_msg.name
	|| bit_pos = 8
	|| p    = 0
	|| arg  = form_msg[@arg,-1]							#require
	|| Max = 32
	// think the max thing basically... is still OK for 2/3/4 opcodes
	// because this only affects "normal named fields"... and the accessors it creates for them
	// but the other extra fields just take an entire opcode... so its entirely separate
	// i guess it just affects render/debug
	for l in arg
		bit_pos = .GenAcc(l, bit_pos, p++, max)
	
	if bit_pos < max and p < 5
		.GenAcc(nil, bit_pos, 5, max)
	.form_h <~ '\n'

	
function CppLibFile (|string| ch, |file|)
	return TransCompiler.CppLib[ch]
	

function BuildFiles (|bool|)
	|| v = Compiler.InputFile( nil, "vm.box", nil )	#require
	|| x = v.parse									#require
	.vm_file = v
	|| forms = x.find("forms")
	forms.remove

	|| code = faststring()
	|| jump = faststring()

	.Clean(x)
	.DataTypeModule
	.GenerateForms(forms)
	.NameList = .VMSpd(x)
	.VMCpp(code, jump)

	.CppLibFile("InstructionGetters.h")!.SmartData = form_h
	.CppLibFile("Instructions.i")!.SmartData = code
	.CppLibFile("InstructionList.h")!.SmartData = jump
	.form_h.size = 0
	return true

	
function MakeTheVM
	compiler.Project.use
	require .BuildFiles	
	treeassembler.InitAll
	asm.TestASM


function BuildInstructions (TranFunc) // __instructionlist__
	opt norefcounts
	expect !node.hasany (node.first)

	|| after = node
	for (tmp in .namelist) (pos)
		|| form = tmp[0][0].name
			|| fnc = @sdot + "add" 
			|| list = fnc.msg(@list)
			list <~ (@str, form.lowercase)
			list <~ (@str, tmp.name)
			list <~ pos
			after.next = fnc
			after = fnc

	node.saferemove


function MakeJump   (|message| msg, |FastString| jump)
	jump <~ "&&${msg.name},\n"

 
function Clean   (|message| msg)
	opt norefcounts
	for ch.flat in msg
		if ch in @arg
			ch.indent += 4
		if ch == @opp
			if ch == "mod"
				ch.name = "%"
			  elseif ch == "|||"
				ch.name = "|"


function VMSpd   (|message| list, |[message]|)
	opt norefcounts
	rz <~ (@thg+"EROR",  256)
	for ch in list
		.VMTmp(ch, rz)

	
function VMCpp (|faststring| vm, |faststring| jump)
	opt norefcounts
	for tmp in .NameList
		.MakeVM(tmp, vm)
		.MakeJump(tmp, jump)

	vm <~ "ı \n\n"


function MakeVM (|message| tmp, |faststring| vm)
	opt norefcounts
	require tmp == @tmp
	|| p = tmp.prev
	if P == @sheb
		vm <~ "	// ${P.name}\n"

	|| arg = tmp.last
	vm <~ "ı ${tmp.name}: "
	if !arg.Find(@tmp, "__")
		vm <~ "_"
	vm <~ "\n"
	for line in arg
		.VMLine(line, vm)


function VMDecl (|message| tmp, |[message]| msgs)
	opt norefcounts
	|| arg = tmp.last
	|| prms = tmp.first
	|| P1 = prms.first
	|| Counts = p1.next
	
	|| name = p1.name.ASMNormalise
	|| form = µform.forms.valuelower(name)			#require
	name = "ASM_" + name
	.ModuleArg <~ NewDecl(name)
	|| tn = tmp.name
	
	while
		|| id = .NextID(counts)
		asm.Encoders[id] = asm.Forms[form.Index]
		msgs[id] = tmp
		if !counts or counts == p1.next
			.AddASM(tn, id)
		if counts
			.AddASM(tn+counts.render, id)
		counts = counts.next #loop


function AddASM (|string| name, |int| id) 
	opt norefcounts
	|| msg = id.msg
	|| thg = @thg + name
	.ModuleArg <~ NewEqRel(thg, msg)


function NextIDWithCounts (|message!| counts, |int|)
	|| i = counts.int(0, 1, 4)
		i--
		while i < 16
			if i and !asm.Encoders[i]
				return i
			i += 4
	error (counts, "Can't find free ID for ASM")

	
function NextID (|message?| counts, |int|)
	if counts
		return .NextIDWithCounts(counts)
	rz = .normalpos
	if rz
		.normalpos = rz+1
	  else
		.normalpos = 16


function VMTmp (|message| tmp, |[message]| msgs)		
	if (tmp == @tmp) and (tmp != "forms" and "ignore")
		.VMDecl(tmp, msgs)


function VMLine (|message| line, |faststring| vm)
	if line == @sheb
		vm <~ "	// ${line.name}\n"
	  else
		vm <~ "\t"
		line.Render(vm)
		vm <~ ";"
	vm <~ "\n"
}

	
	
	
	
	
