


|| ExportPosFails = 0
function message.ASMDecl (|SCDecl!|)
	opt norefcounts
	rz = .fastdecl
	if (rz is Global) and !rz.ExportPosition
		while .func == @arel
			self = .first!
		rz = .FastDecl
		if rz.exportposition
			.parent!.obj = rz // fix it up.
		  else
			if ++ExportPosFails <= 2
				error (self, "No export position on: " + .locate)				
	
	if rz.typeonly == 0
		rz.wholetype = rz.CalculateASMType
	target debug: rz.ASMSanity


function Assembler.RequestOp (|asm| op, |message| exp, |&fatasm|)
	|| p = .Curr
	if p < .End
		target debug: if  exp.Position < 0 and exp.Position != -2
		.curr_ = p + 1
		p[0] = nil
		p.info = (p.index|uint64|<<48)|asmreg| // no need to call fat*reg now
		p._op = op
		p.debug = exp
		p.BranchID = .BranchID
		p.BasicBlock = .BasicBlock
		return p

	error (exp, "Function too large (over 64K)")
	return .start

//function Assembler.RequestOp (|asm| op, |message| exp, |&fatasm|)
//	|| p = .Curr
//	if p < .End
//		target debug: if  exp.Position < 0 and exp.Position != -2
//		p[0] = nil
//		.curr_ = p + 1
//		p._op = op
//		p.debug = exp
//		p.BranchID = .BranchID
//		p.BasicBlock = .BasicBlock
//		return p
//
//	error (exp, "Function too large (over 64K)")
//	return .start

function asmreg.ExpectSameType (|Asmreg| Dest, |asmreg|)
	|| dt = dest.ÂµType
	target debug
		|| st = .ÂµType
		if dt isnt floating and st is bool // allow
			0
		  else
			if (dt is Floating != st Is Floating) or (dt is bool != st is bool) // should never happen
		if (st.bytecount > 4)  <  (dt.bytecount > 4)		// doesn't matter unless we cross 64-32 bit anyhow
	.Âµtype = dt
	return self


target debug
	function scdecl.ASMSanity 
		ifn  .IsCarray  or  .PointerCount  or  .IsObject  or  .IsBareStruct
			|| size = .type.ClsSize
			|| T = .TypeOnly
			if T == DataTypeCode.Vec3 or DataTypeCode.ivec3
				size = 12
			if size != T.bytecount // sigh. what?
				#!"Should we have set the dtype when the decl was created? or at least verified in the nil-checker?"
				#!"We could change it if it is only 112."
				debugger
				t.debugprint




function Assembler.OpenVars (|uint64|)
	return (.VDecls|uint64| << 0) ||| (.VTemps|uint64| << 32)


function Assembler.CloseVars (|uint64| Orig,  |message| exp = nil,  |asmreg| Return=nil, |asmreg|)
	opt NoRefCounts
	
	|| OrigTemps = (Orig >> 32)
	|| OrigDecls = (Orig << 32) >> 32

	while .CloseOneVar(exp, origtemps, false)
		0
	
	while .CloseOneVar(exp, OrigDecls, true)
		0

	|| Missing = OrigDecls &~ .VDecls
	if !exp or !missing
		return return

	// asmtodo: what if the var came from a closed branch?
	// can we write that somewhere?
	// perhaps?
	// perhaps the remover can set this... so it never goes to nil
	// unless it was already nil? The remover still has to know
	// which branch something came from!
	
	.VDecls |= Missing
	
	return return



function Assembler.ClearAllStructs (|message!| exp,  |bool|)
	for i in 32
		|| fat = .Register(i)
			.ClearStruct(exp, fat, i)


function Assembler.ClearStruct (|message?| exp,  |fatasm| fat,  |int| v,  |bool|)
	opt norefcounts
	if  exp  and  fat isa asm.allo						/// DEALLOCATE STRUCTS ///
		ASMType.AllocBearStruct(-1, exp.FlatLast, v.asm, fat.RegOnly(1)<<4)
	return true


function Assembler.CloseOneVar (|message?| exp,  |uint| Orig,  |bool| IsReal,  |bool|)
	opt norefcounts										/// READ TABLE ///
	|uint| Curr = (.vdecls, .vtemps)(isreal) 
	|| Extra = Curr &~ Orig
	if Extra == -1 // huh?
	require Extra
	
	|| v = extra.log2
	|| Result = Curr &~ (1<<v)
	if isreal
		.vdecls = Result // easier to debug >:O 
	  else
		.vtemps = Result // ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥
	
	.Regs.KnownMap &=~ (1<<v)

	|| fat = .regs.Setters[v]
	if !fat: return true
	if exp
		.SetRegister(v, nil/*asmreg.AllowNopDest*/, nil) // why would I ever want to nop here?
	// .nextbasicblock should do this?

	// don't nop (most?) unused stuff here... as temps can be used after deallocating.
	// What about the code below? could it suffer the same? We had this bug in "incr".
	// The best this place could do... is warn (ME) that a function should be nopping something
	// but isn't.
	
	return .ClearStruct(exp, .funcstart + fat, v)



function scdecl.CalculateASMType (|asmreg|)
	opt norefcounts
	if .pointercount or .iscarray
		// carrays must be allocated. So this reg will store a pointer to the carray.
		return datatypecode._voidptr|ASMReg|

	|| t = .type
	|| b = t.BaseType
	if b > scnodetype.DataType
		return datatypecode._voidptr|ASMReg|
	
	|| I = t.typeinfo
	return I|asmreg|


function SCFunction.ASMReturn (|scdecl|)
	opt norefcounts
	|| T = .returntype
	if t isnt ReturnedStruct
		return T


function asmreg.incr (|asmreg|)
	|| f = .fat
		f.Âµrefcount++
		return self
	target debug
		if .reg and self is Const  // sigh
	return self


