


function message.ASMDecl (|SCDecl!|)
	opt norefcounts
	rz = .fastdecl
	if (rz is Global) and !rz.ExportPosition
		while .func == @arel
			self = .first!
		rz = .FastDecl
		if rz.exportposition
			.parent!.obj = rz // fix it up.
		  else
			error (self, "No export position on: " + .locate)				
	
	if rz.typeonly == 0										// Datatypecode.unusedtype
		rz.wholetype = rz.CalculateASMType
	target debug: rz.ASMSanity



function Assembler.RequestOp (|asm| op, |message| exp, |&fatasm|)
	|| p = .Curr
	if p < .End
		if  exp.Position < 0
		p[0] = nil
		.curr_ = p + 1
		P._op = op
		p.debug = exp
		p.BranchID = .BranchID
		p.BasicBlock = .BasicBlock
		return p

	error (exp, "Function too large (over 64K)")
	return .start



target debug
	function scdecl.ASMSanity 
		ifn  .IsCarray  or  .PointerCount  or  .IsObject  or  .IsBareStruct
			|| size = .type.Size
			|| T = .TypeOnly
			if T is Vec3 or ivec3
				size = 12
			if size != T.bytecount // sigh. what?
				#!"Should we have set the dtype when the decl was created? or at least verified in the nil-checker?"
				#!"We could change it if it is only 112."
				debugger




function Assembler.OpenVars (|uint64|)
	return (.VDecls|uint64| << 0) ||| (.VTemps|uint64| << 32)


function Assembler.CloseVars (|uint64| Orig,  |message| exp = nil,  |asmreg| Return=nil, |asmreg|)
	opt NoRefCounts
	
	|| OrigTemps = (Orig >> 32)
	|| OrigDecls = (Orig << 32) >> 32

	while .CloseOneVar(exp, origtemps, false)
		0
	
	while .CloseOneVar(exp, OrigDecls, true)
		0


	// remove these?
	|| Missing = OrigDecls &~ .VDecls
	if !exp or !missing
		return return

	// asmtodo: what if the var came from a closed branch?
	// can we write that somewhere?
	// perhaps?
	// perhaps the remover can set this... so it never goes to nil
	// unless it was already nil? The remover still has to know
	// which branch something came from!
	
	.VDecls |= Missing
	// argh
	
	return return



function Assembler.ClearAllStructs (|message!| exp,  |bool|)
	for i in 32
		|| fat = .Register(i)
			.ClearStruct(exp, fat, i)


function Assembler.ClearStruct (|message?| exp,  |fatasm| fat,  |int| v,  |bool|)
	opt norefcounts
	if  exp  and  fat isa asm.allo						/// DEALLOCATE STRUCTS ///
		ASMType.AllocBearStruct(-1, exp.DeepLast, v.asm, fat.RegOnly(1)<<4)
	return true


function Assembler.CloseOneVar (|message?| exp,  |uint| Orig,  |bool| IsReal,  |bool|)
	opt norefcounts										/// READ TABLE ///
	|uint| Curr = (.vdecls, .vtemps)(isreal) 
	|| Extra = Curr &~ Orig
	if Extra == -1 // huh?
	require Extra
	
	|| v = extra.log2
	|| Result = Curr &~ (1<<v)
	if isreal
		.vdecls = Result // easier to debug >:O 
	  else
		.vtemps = Result // ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥
	
	.Regs.KnownMap &=~ (1<<v)

	|| fat = .regs.Setters[v]
	if !fat: return true
	if exp
		.SetRegister(v, asmreg.AllowNopDest, nil) // closes at end of block only
	// .nextbasicblock should do this?

	// don't nop (most?) unused stuff here... as temps can be used after deallocating.
	// What about the code below? could it suffer the same? We had this bug in "incr".
	// the best this place could do... is warn (ME) that a function should be nopping something
	// but isn't.

		
	return .ClearStruct(exp, .funcstart + fat, v)



function scdecl.CalculateASMType (|asmreg|)
	opt norefcounts
	if .pointercount or .iscarray
		// carrays must be allocated. So this reg will store a pointer to the carray.
		return datatypecode._voidptr|ASMReg|

	|| t = .type
	|| b = t.BaseType
	if b > scnodetype.DataType
		return datatypecode._voidptr|ASMReg|
	
	|| I = t.typeinfo
	return I|asmreg|


function SCFunction.ASMReturn (|scdecl|)
	opt norefcounts
	|| T = .returntype
	if t isnt ReturnedStruct
		return T


//function SCFunction.RealReturnType (|scdecl|)
//	opt norefcounts
//	|| T = .returntype
//	// if t is returnedstruct: return typevoid // better?
//	if t and t isnt ReturnedStruct
//		return T
//	return TypeVoid


function asmreg.incr (|asmreg|)
	|| f = .fat
		f.Âµrefcount++
		return self
	target debug
		if .reg and self is Const  // sigh
	return self
		
		
datatype VarUseMode (int) // remove entire thing?
	Flags
//		Linkable
		ReturnAble
//		SetAble
		Return = ReturnAble // unused?
//		Set = SetAble
//		ExistingVar
//		ForBools
	
	syntax is (|VarUseMode| v, |bool|)
		return self&v

