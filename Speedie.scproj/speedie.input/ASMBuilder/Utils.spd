


|| ExportPosFails = 0
function message.ASMDecl (|SCDecl!|)
	opt norefcounts
	rz = .fastdecl
	if (rz is Global) and !rz.ExportPosition
		while .func == @arel
			self = .first!
		rz = .FastDecl
		if rz.exportposition
			.parent!.obj = rz // fix it up.
		  else
			if ++ExportPosFails <= 2
				error (self, "ASM Glob lacks pos: " + .locate)
	
	if rz.typeonly == 0
		|| T = rz.wholetype
		T.Âµtype = rz.CalculateASMType
		rz.wholetype = T
	target debug: rz.ASMSanity


function Assembler.RequestOp (|asm| op, |message| exp, |&fatasm|)
	|| p = .Curr
	if p < .End
		.curr_ = p + 1
		p[0] = nil
		p.info = (p.index|uint64|<<48)|asmreg| // no need to call fat*reg now
		p._op = op
		p.debug = exp
		p.BranchID = .BranchID
		p.BasicBlock = .BasicBlock
		return p

	error (exp, "Function too large (over 64K)")
	return .start


function asmreg.ExpectSameType (|Asmreg| Dest, |asmreg|)
	|| dt = dest.ÂµType
	target debug
		|| st = .ÂµType
		if dt isnt floating and st is bool // allow
			0
		  else
			if (dt is Floating != st Is Floating) or (dt is bool != st is bool) // should never happen
		if (st.bytecount > 4)  <  (dt.bytecount > 4)		// doesn't matter unless we cross 64-32 bit anyhow
	.Âµtype = dt
	return self


target debug
	function scdecl.ASMSanity 
		ifn  .IsCarray  or  .PointerCount  or  .IsObject  or  .IsBareStruct
			|| size = .type.ClsSize
			|| T = .TypeOnly
			if T == DataTypeCode.Vec3 or DataTypeCode.ivec3
				size = 12
			if size != T.bytecount // sigh. what?
				#!"Should we have set the dtype when the decl was created? or at least verified in the nil-checker?"
				#!"We could change it if it is only 112."
				debugger
				t.DebugPrint


function Assembler.OpenVars (|uint64|)
	return (.VDecls|uint64| << 0) ||| (.VTemps|uint64| << 32)


function Assembler.CloseVars (|uint64| Orig,  |message| exp = nil,  |asmreg| Return=nil, |asmreg|)
	opt NoRefCounts
	
	|| OrigTemps = (Orig >> 32)
	|| OrigDecls = (Orig << 32) >> 32
	|| Missing = ~(OrigTemps ||| OrigDecls)

	while .CloseOneVar(exp, Missing)
		0

	Missing = OrigDecls &~ .VDecls
	if !exp or !missing
		return return
	
	/*
		if value == nil {
			JB_Decr(value) // the decl is closed early
			exit
		}
		value.x++
		// then it is "missing" after the arg closes. So this will reopen it.
		// We assume that temps are never used in such a way and don't need reopening.
	*/
	
	.VDecls |= Missing	
	
	return return



function Assembler.ClearAllStructs (|message!| exp,  |bool|)
	for i in 32
		|| fat = .Register(i)
			.ClearStruct(exp, fat, i)


function Assembler.ClearStruct (|message?| exp,  |fatasm| fat,  |int| v,  |bool|)
	opt norefcounts
	if  exp  and  fat isa asm.allo						/// DEALLOCATE STRUCTS ///
		ASMType.AllocBearStruct(-1, exp.FlatLast, v.asm, fat.RegOnly(1)<<4)
	return true


function Assembler.CloseOneVar (|message?| exp,  |uint| Missing,  |bool|)
	opt norefcounts
	// we have a missing value. but is it missing from one, or the other? lets do it on that basis.
	|uint| Curr = .vdecls
	|uint| T = .vtemps
	|| Extra = Curr & Missing
	|| IsReal = true
	if !Extra
		Curr = T
		Extra = Curr & Missing #require
		IsReal = false

	|| v = extra.log2
	|| Result = Curr &~ (1<<v)
	.Regs.KnownMap &=~ (1<<v)
	if IsReal
		.vdecls = Result // easier to debug >:O 
	  else
		.vtemps = Result // ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥

	|| fat = .regs.Setters[v]
		if exp
			.SetRegister(v, nil, nil) // no reason to want to nop anything here.
		// Does code below suffer from unallocating something that is used later?
		return .ClearStruct(exp, .funcstart + fat, v)
	return true


function scdecl.CalculateASMType (|asmreg|)
	opt norefcounts
	if .pointercount or .iscarray
		// carrays must be allocated. So this reg will store a pointer to the carray.
		return datatypecode._voidptr|ASMReg|

	|| t = .type
	|| b = t.BaseType
	if b > scnodetype.DataType
		return datatypecode._voidptr|ASMReg|
	
	|| I = t.typeinfo
	return I|asmreg|


function SCFunction.ASMReturn (|scdecl|)
	opt norefcounts
	|| T = .returntype
	if t isnt ReturnedStruct
		return T


function SCFunction.ASMReturn (|ASMReg| Dest, |asmreg|)
	opt norefcounts
	dest.Âµtype = .ASMReturn.ASMRegType
	return dest


function asmreg.incr (|asmreg|)
	|| f = .fat
		f.Âµrefcount++
		return self
	target debug
		if .reg and self is Const  // sigh
	return self


function message.CallChainError (|string| name)
	opt norefcounts
	problem (self, name)
	|| sh = assembler.sh
	|| i = sh.inlinedepth|int|
	while --i >= 0
		|| st = sh.inlinestate[i]
		|| fn = st.fn
		|| src = fn.source
			problem (src, "\tInlined from here.")
