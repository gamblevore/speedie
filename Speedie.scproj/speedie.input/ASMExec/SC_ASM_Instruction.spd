

// why is this needed by exec?
// exec wants to be able to load stuff, so we need the ASM datatype?
// or just fake one. We just wanna call the VM really.
// perry, exec-vm, speedie
// how should they coordinate?
// perry displays stuff...
// exec will run the stuff
// but who or how does the debugging get done? Do we need speedie for this?
// its just a bunch of types and ways to print those types, right?
// exec can do that? We don't need speedie, for that?
// not even for debugging? Again... types and methods of printing them.
// that should do everything we need.
// So speedie is just for compilation, then. And reporting errors back to perry about compiles.
// So... what do I need the instruction for then?
// Well... I guess to display the current instruction so we can step through it ASM at a time?
// seems like something we'll need

// the other idea is just to run speedie as a lib.
// so... we won't need most of it?


selector Instruction // class instruction
	initafter (µform)
	
	|byte|			OpLength
	|byte|			aType
	|byte|			PCount
	|µForm|			Sizes
	|string|		FormName

	
	constants
		kTypeConst		= 2
		kTypeFunc		= 1

	instructionlist // magically extracts selector-items from "vm. box"

	
	render
		fs <~ .name
	
	function selector_init (|string| formName, |int| num=1)
		.oplength = num
		.formname = formname

	function ActualInit
		.sizes = µform.NeedForm(.FormName)$
		.PCount = .sizes.count
		instruction.store(self)


	syntax equals (|string| other, |bool| aware, |bool|)
		return .name.syntaxequals(other, aware)
	function IsFunc (|bool|)
		return .atype == kTypeFunc

	syntax access (|int| i, |µParam|)
		return .sizes.params[i]

	function IsSetConst (|bool|)
		return .atype == kTypeConst

	function Const 
		.atype = kTypeConst
		//.NoExpect // shouldnt have removed this?

	function opcode (|uint|)
		return .id

	module
		|dictionary of instruction|			TypeDict
		|instruction[256]|					TypeList
		|int|								TypeListSize

		syntax access (|message| m, |instruction|)
			opt norefcounts
			return TypeDict[m.name]			#expect (m, "Isn't a valid instruction.")


		function Store (|instruction| i)
			if .typelistsize++ != i.id
				debugat
			.TypeDict := dictionary.new
			.typelist[i.id] = i
			.typedict[i.name] = i


		function Init
			opt norefcounts
			for i in instruction.__first
				i.ActualInit

