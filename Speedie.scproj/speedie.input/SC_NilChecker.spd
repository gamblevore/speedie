

module NilChecker
	function SaveLives
		opt norefcounts
		using options.NilStrength
	
		|NilTracker| T
		for f in compiler.funclist
			T.Check(f)
		
		scfunction.currfunc = nil
		.SweepInits

	
	function SweepInits
		// || init = compiler.getfunc("init_")
		// what about "init_"?


function NilTracker.Check (|scfunction| f)
	debugat
	opt norefcounts
	require false
	require !f.IsMacro and !f.IsWrapper and f.isOK
	|| c = f.Lookup
		require c.name contains "NilTest"

	.Start(f)
	.RunNormal(f.SourceArg)
	.Finish(f)


function message.NilPropAccess (|scdecl|)
	opt norefcounts
	|| m = .DotMustBeProperty
	if m and m isnt onmodule
		return m


function message.NilDecl (|scdecl|)
	opt norefcounts
	|| obj = .obj
	if (obj isa scdecl)
		|| l = obj.IsLookupOnly
		if l isa scdecl
			return l
		return obj
	
	
function NilTracker.UseChildAsReal (|message| wrapper, |bool|)
	// a.b, *a, a[0], (a)()
	opt norefcounts
	|| ch = wrapper.first
		return .UseAsReal(ch, ch.NilDecl)


function NilTracker.Function (|message| msg)
	opt norefcounts
	|| fp = msg.first
	if fp.func == @bra
		require .UseChildAsReal(fp.first)						// (abc)()
	|| prms = fp.next
	|| fn = prms.obj|scfunction|
	|| ret = fn.ReturnType
		check (!ret.SuffersNil or ret.IsStated) (msg, "Unknown if this function returns nil.")

	|| p = prms.first
	for a in fn.args
		.VariableSet(a, p.nildecl, p, 1)
		if p.hasany
			.RunNormal(p)
		p++


function NilTracker.Return (|message| msg)
	opt norefcounts

	|| value = msg.first				#require
	|| vd = value.NilDecl
	if vd.suffersnil
		|| vn = vd.nilused
		|| rd = .fn.ReturnType
		|| r  = rd.NilDeclared
		if r is real  and vn is Nilish
			error (msg, "Nil returned, against function declaration!")
		rd.nilused |= vn // find the answer at the end


function NilTracker.IfWhileOne (|message| test, |message| root, |message|)
	opt norefcounts
	|| arg = test.first
	if arg == @arg
		.RunNormal(arg)
	  else
		.ProcessCond(arg, branchstate.always)
		arg++
		.RunNormal(arg)

	return arg.next
	

function NilTracker.IfOrWhile (|message| msg)
	opt norefcounts
	|| old = .enter
	|| test = msg
	while test
		test = .IfWhileOne(test, msg)
	.leave(old)


function NilTracker.If (|message| Tmp)
	opt norefcounts
	.IfOrWhile(Tmp)


function Message.RedundantBranch (|branchstate|)
	if StdErr.CanAddMore(errorseverity.problem)
		StdErr.NewProblem(self, "Redundant branch. Object's nilness is known.")
	return BranchState.Perhaps


function niltracker.UseAsReal (|message| err, |scdecl| d, |uint| PointerInferred=0,  |bool|)
	opt norefcounts
	if d.NilUsed isnt Nilish
		return true

	|| msg = .nilmsg(err, d, PointerInferred)
	expect  (!msg) (err, msg)
	d.NilDeclared = NilState.real
	d.nilused = NilState.Realish
	return true


function NilTracker.ProcessCondThg (|message| msg, |branchstate| Y, |branchstate|)
	opt norefcounts
	|| dest = NilState.Nilish + Y	
	|| dcl = msg.nildecl			#debug_require
	|| u = dcl.NilUsed
	
	if u == NilState.Either
		if (dcl is param) and (dcl.NilDeclared isnt stated)
			dcl.NilDeclared = NilState.optional
		return .SetNilness(msg, dcl, dest)

	if dcl.NilDeclared is Either
		return msg.RedundantBranch
	return BranchState.Never + (u == dest) // checking for nil-obj allocations


function NilTracker.ProcessCond (|message| m, |branchstate| Y, |branchstate|)
	opt norefcounts
	|| fn = m.func
	if fn == @thg
		return .ProcessCondThg(m, y)
	if fn == @bra or @type
		return .ProcessCond(m.first, Y)
	if fn == @rel
		return .ProcessCondRel(m, y)
	if fn == @func
		return .ProcessCondFunc(m, y)
	if fn == @brel
		return .ProcessCondBrel(m, y)
	.RunNormal(m)
	return branchstate.Perhaps


function NilTracker.ProcessCondPtr (|message| m, |branchstate| Y, |branchstate|)
	opt norefcounts
	|| PointedTo = m.first
	|| pd = PointedTo.nildecl
		.UseAsReal(PointedTo, pd)
		return .ProcessCond(PointedTo, y)


function NilTracker.ProcessCondBrel (|message| m, |branchstate| Y, |branchstate|)
	opt norefcounts
	|| b = *m.name
	if b == '!'
		return .ProcessCond(m.first, Y.not)
	if b == '*'
		return .ProcessCondPtr(m, Y)
	if b == '&'			// objects always have an address
		return Y
	debugat
	.RunNormal(m)
	return branchstate.Perhaps


function NilTracker.ProcessCondFunc (|message| m, |branchstate| Y, |branchstate|)
	opt norefcounts
	.Function(m)
	|| prms = m.last
	|| fn = prms.obj|SCFunction|
	if !fn.IsNilChecker
		return branchstate.Perhaps
	debugat // so what do we return if it is a nilchecker??
	

function NilTracker.ProcessCondRel (|message| m, |branchstate| Y, |branchstate|)
	opt norefcounts
	|| ll = m.first
	|| op = ll.next
	|| rr = op.next
	|| scop = op.obj|SCOperator|

	// let's say that actually... each cond tester tests things
	// so that is responsbile for calling runnormal or not.
	// so we shouldn't call .runnormal here	

	if scop.IsCompare
		|| LNil = (ll.obj as scdecl).IsNowNil
		|| RNil = (rr.obj as scdecl).IsNowNil
		if lnil or rnil
			expect (scop.IsNilTest) (op, "Can't use this operator on nil. Use != or ==.")
			if (lnil and rnil)
				return m.RedundantBranch
			if scop.HasEquals // if (a==nil or b==nil) return else a.a(b.b)
				y = y.not
			|| side = (rr, ll)(lnil)
			return .ProcessCond(side, Y)
		return BranchState.Perhaps
	
	
	if scop.IsAndOr
		if scop.IsAndOr == 3 // and
			// x = (a and b)
			if y == BranchState.Never
				y = BranchState.Perhaps
		  else
			// x = !(a or b)
			if y == BranchState.always
				y = BranchState.Perhaps
		
		.ProcessCond(ll, Y)
		.ProcessCond(rr, Y)
		return BranchState.Perhaps

		// what about the cond?
		// if (a and b)			// a yes,   b yes		... after a may, b may
		// if (!a and !b)		// a no,    b no    	... after a may, b may
		// if (!(a and b))		// a may,	b may   	... after a yes, b yes
		// if (!(!a and !b)		// a may,	b may   	... after a no,  b no
		// if (a or b)			// a may,	b may		... after a no,  b no		
		// if (!(a or b))		// a no,	b no		... after a may, b may
		// if (!(!a or !b))		// a may,	b may		... after a no,  b no 
		// if !msg or *msg
		// if (abc and m) or (*m == 1)

// its a bit ops by now. all others would have gone.
	if ll.hasany
		.RunNormal(ll)
	if rr.hasany
		.RunNormal(rr)
	return branchstate.Perhaps


function Niltracker.Decl (|message| declmsg)
	opt norefcounts
	|| exp = declmsg.last
	if exp == @rel
		exp = exp.last
		|| d = exp.AsDecl
		|| r = declmsg.AsDecl
		r.NilTake(d)	
	

function NilTracker.SetRel (|message| msg)
	opt norefcounts
	|| l = msg.first
	|| r = msg.last
	|| pd = r.nildecl
	.VariableSet(l.nildecl, pd, r, 0)
	if l.hasany
		.RunNormal(l)	
	if r.hasany
		.RunNormal(r)


function NilTracker.VariableSet (|scdecl| recv, |scdecl| pd, |message| errplace, |uint| IsParam) // setrel, relset
	opt norefcounts
	require recv.suffersnil

	|| PrmPointer = 0
	if recv.NilDeclared isnt nilish
		require .UseAsReal(errplace, pd, isparam>>1)
	  elseif (isparam) and (recv.SuffersNil)
		if !recv.IsStated and (pd.NilUsed is Nilish)
			error (errplace, "Unknown if this parameter accepts nil.")
		PrmPointer = recv.PointerCount		// if a: myfunc(&a), printline a.name		// nil-error! "a" can be nil.

	// |!&!&struct| abc = f
	if recv.PointerCount // tail call :O
		return .VariableSet(recv.internal, pd.internal, errplace, IsParam<<1)
	
	// we want this to act differently for params, but how? so what if its a pointer in a param?
	// well... basically... for f(&a)... 
	// for || x = &a... we just gonna ignore it and hope it works...
	// we don't have setting at this point anyhow?
	// i mean... we have "use a real"... but what about an optional being set from real... back to optional?


function NilTracker.RunNormal (|message| msg)
	opt norefcounts
	
	for s.fast in msg
		|| f = s.func
		if (f == @dot)
			|| Prop = s.NilPropAccess
				.UseChildAsReal(s)								// abc.var
		  elseif (f == @acc) 
			.UseChildAsReal(s)									// abc[0]
		  elseif (f == @brel) 
			if s != "*"
			.UseChildAsReal(s)									// *abc
		  elseif (f == @rel)
			if s.tmptype is kSetVar								// x = y
				.SetRel(s)
		  elseif (f == @func)
			.Function(s)
		  elseif (f == @tmp)
			|| type = S.TmpType
			if Type is kif
				.If(s)
			  elseif type is kwhile
				.IfOrWhile(s)
			  elseif type is kReturn
				.Return(s)
		  elseif (f == @decl)
			.Decl(s)
				
		  elseif !s.IsLast
			.RunNormal(s)
		  
		  elseif s.hasany
			return .RunNormal(s) // tail-call opt


function niltracker.nilmsg (|message| err, |scdecl| d, |uint| PointerInferred, |string|)
	if PointerInferred
		return "Nil Error: Pointed-to is not nil, but could become nil here."
	if d isnt param
		if err == @thg
			return `Nil Access: Needs "if" wrapping.`
		return "Nil Access here."
	if d.NilDeclared isnt Stated
		return "Nil Error: Don't declare with '?'... or test for nil."




/*
TODO:

* what about carrays of pointers? what comes first? when does the ptrcount get used?
* modifications of objects via func pointer param... during a cond

* do the work on args in the if-cond thing...
	* pass the info about BOTH the conditions... in the state "Y" thing... the applicator can decide what to do about "After" conditions...

* || x = (a and b), if x: a.a(b.b)
	* only the very next ifbranch only :) too many cases where x can be altered by all sorts of things...

* all containers contain nil.... so theres that
* cpp-wrappers and prototypes default to not nil unless stated.
* ternaries
* freeze bug
* msg.last/first etc will have to accept nil :O. The C++ compiler will opt it.



BOOLEAN LOGICS:
	refills and relsetters:
		if (!a) a = b(), a = &e
	
	multiple branches:
		if !a { if b {return 1} else {return 2} }
		a.b = 1
	
	return affecting future code:
		if (!msg)
			return
		msg.prop
	
	changes nothing:
		if (a or b)

	nil-checker funcs:
		can still be realish if returns false.


DONE?

rel-sets to internal pointers:

function calls:
	function gg (|object|)
		|| a = maybenil
		|| x = ff(a) // error: ff does not take nil.
		|| y = gg()  // error: unknown at this time if gg returns nil.

update the params:
	function abc (|message| o)
		o.position // o is now "!"

return values:
	if x
		return message()
	  else
		return nil // now this func returns optional values. 

using ptrs:
	if (*msg)

nilstrength:
	--nil=3

can access prop:
	if (msg)
		msg.prop

multiple tests:
	if (a and b)

redundant "m":
	if (m and m.length)
	if (!m or !m.length)

pointless:
	if nil == nil

fail:
	if msg >= nil, if msg <= nil

nil within branch:
	if msg == nil
*/


/*
* Init Vars Sweep?
	We need to go through the entire program, and give each item found, a "timecode". That
	is... it has an "earliest time" that it COULD occur.
perhaps just do it on a per-module basis... If a module makes no sense in terms of itself thats the programmers fault.
*/

/*
Issues:
What about the fact that a function's param nilness can rely on other funcs??
like:

	x = msg[0] // OK... so we don't rely on msg existing? but only cos it doesn't rely on self existing.
what if msg[n] is recursive and complicated? then how do we check if a decl... is nil or not?

The fact that we have ordered this... leaf first... helps. dependancies help... but that only reduces the problem
not eliminiates it. There will be cases that we can't eliminate.

* Make it nestable? That is... we actually can check functions?
	* this would only be needed for actual recursive functions... non-recursives would have a strict chain...
* what if two funcs with the same depth... and one is called before the other but the wrong one is called first?
	* then making it nestable helps!

* what about actually recursive funcs? I think for them... we let the user simply specify their nilness!! makes sense, right?
	* I think, just assume NOT NIL unless we can prove that it is tested. It is implicit and we can't be that smart.
*/



// DISTURBANCE CHECKER WILL HELP
// for global vars
	// global.x = obj
	// func()
	// global.x.func2 // allowed or not? func() might have altered global.x

