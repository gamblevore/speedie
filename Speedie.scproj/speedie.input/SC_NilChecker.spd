

module NilChecker
	function SaveLives
		opt norefcounts
		require StdErr.ok
		using options.NilStrength
			|NilTracker| T
			for f in compiler.funclist
				T.Check(f)
			
		scfunction.currfunc = nil
		.SweepInits
		StdErr.PrintErrors
		StdErr.Clear

	
	function SweepInits
		// || init = compiler.getfunc("init_")
		// what about "init_"?


function scfunction.canNil (|bool|)
	return !(.IsMacro and !.IsWrapper and .isOK)


function scfunction.LimitTests (|bool|)
	|| c = .Lookup #require
	require c.name contains "NilTest"

	require .SourceArg contains "nilcheck"


function NilTracker.Check (|scfunction| f)
	opt norefcounts
	require f.cannil and f.limittests
	return 
	.Start(f)
	.RunNormal(f.SourceArg)
	.Finish(f)


function message.NilPropAccess (|scdecl|)
	opt norefcounts
	|| m = .DotMustBeProperty
	if m and m isnt onmodule
		return m


function message.NilDecl (|scdecl|)
	opt norefcounts
	|| obj = .obj
	if (obj isa scdecl)
		|| l = obj.IsLookupOnly
		if l isa scdecl
			return l
		return obj
	
	
function NilTracker.UseChildAsReal (|message| wrapper, |bool|) // a.b, *a, a[0], (a)()
	opt norefcounts
	|| ch = wrapper.first
		return .FailIfNotReal(ch, ch.NilDecl)	
	

function NilTracker.Function (|message| msg, |branchstate| Y=0)
	opt norefcounts
	|| fp = msg.first
	|| prms = fp.next
	|| fn = prms.obj|scfunction|
	if msg.tmptype == ASMtmp.kTern
		debugat
		return .tern(prms)

	if (fp.func == @bra)
		require !.UseChildAsReal(fp.first)						// (abc)()
	
	|| ret = fn.ReturnType
		check (!ret.SuffersNil or ret.IsStated) (msg, "Unknown if this function returns nil.")

	|| p = prms.first
	for a in fn.args
		|| pd = p.NilDecl
		.VariableSet(a, pd, p, 1)
		if p.HasAny
			.RunNormal(p)
		p++


function NilTracker.Return (|message| msg)
	opt norefcounts

	|| value = msg.first				#require
	|| vd = value.NilDecl
	if vd.suffersnil
		|| vn = vd.nilused
		|| rd = .fn.ReturnType
		|| r  = rd.NilDeclared
		if r is real  and vn is Nilish
			error (msg, "Nil returned, against function declaration!")
		rd.nilused |= vn // find the answer at the end


function NilTracker.If (|message| msg, |bool|)
	opt norefcounts	
	|| BeginState = .DeclCount
	|| cond = msg.first
	|| arg1 = cond.next
	|| Else = arg1.next
	|| arg2 = else.Last

	.IfDepth++
	.ProcessCond(cond, BranchState.Always) // SetVars during conds actually should go into the parent branch... not undoable.
	.IfDepth++
	.RunNormal(arg1)
	
	if arg2												// IF X {y=y1} ELSE {y=y2}
		|| Arg1Only = .DeclCount
		.Restore(BeginState)							// (undo y=y1 but keep track of it)
		.IfDepth--
		.ProcessCond(cond, BranchState.Never)
		if arg2.IsFirst									// ELSE {y=y2}
			.IfDepth++
			.RunNormal(arg2)
		  else											// ELSEIF (Y) {y=y2}
			.IfDepth--
			.if(else)
		
		if arg1.Blocks
			0
		  elseif arg2.blocks							// (use arg1's state, <2% likelyhood)
			.Undo(BeginState)							// IF X {y=y1} ELSE {return}
		  else
			.DeclCount = Arg1Only						// (skip arg2, its already current)
			.merge(BeginState)							// (merges y=y1, y=y2)
		
	  elseif arg1.Blocks
		.Undo(BeginState)								// IF X {y=y1, return}
		.ProcessCond(cond, branchstate.never)

	  else
		.merge(BeginState)								// IF X {y=y1}

// 1 y: false
// if
// 2 x: True
// 3 y: true
// else
// 4 x: false
// 5 y: true



function NilTracker.Tern (|message| prm)
	opt norefcounts
	|| cond = prm.first
	|| A = cond.next
	|| B = A.next

	.ProcessCond(cond, branchstate.always)
	|| BeginState = .DeclCount
	.RunNormal(A)
	.Restore(BeginState)
	.ProcessCond(cond, branchstate.never)
	.RunNormal(B)
	.merge(BeginState)								// IF X {y=y1}

	|| decl = prm.NilDecl
	decl.NilUsed = a.NilDecl.nilused (|) B.NilDecl.nilused // something like that?
	// needs to propagate through bras and typescasts into a setrel


function Message.RedundantBranch (|bool| y)
	if StdErr.CanAddMore(errorseverity.problem)
		|| str = ("Redundant branch. Always true.", "Redundant branch. Always false.")(Y)
		StdErr.NewProblem(self, str)



function niltracker.FailIfNotReal (|message| err, |scdecl| d, |uint| PointerInferred=0,  |bool|)
	opt norefcounts
	if d.NilUsed isnt Nilish
		return true

	if !pointerinferred  and  d is param  and  d.NilDeclared is Stated
		d.NilDeclared = NilState.real
		d.nilused = NilState.Realish
		return true

	error (err, .nilmsg(err, d, PointerInferred) )


function NilTracker.ProcessCondThg (|message| msg, |branchstate| Y)
	opt norefcounts
	|| dest = NilState.Nilish + Y	
	|| dcl = msg.nildecl			#debug_require
	|| u = dcl.NilUsed
	
	if u == NilState.Either
		if (dcl is param) and (dcl.NilDeclared isnt stated)
			dcl.NilDeclared = NilState.optional
		return .TestedNilness(dcl, dest)

	if dcl.NilDeclared is Either
		return msg.RedundantBranch(y.syntaxcast)
//	return BranchState.Never + (u == dest) // checking for nil-obj allocations


function NilTracker.ProcessCond (|message| m, |branchstate| Y)
	opt norefcounts
	|| fn = m.func
	if fn == @thg
		return .ProcessCondThg(m, y)
	if fn == @bra or @type
		return .ProcessCond(m.first, Y)
	if fn == @rel
		return .ProcessCondRel(m, y)
	if fn == @func
		return .ProcessCondFunc(m, y)
	if fn == @brel
		return .ProcessCondBrel(m, y)
	.RunNormal(m)


function NilTracker.ProcessCondPtr (|message| m, |branchstate| Y)
	opt norefcounts
	|| PointedTo = m.first
	|| pd = PointedTo.nildecl
		.FailIfNotReal(PointedTo, pd)
		return .ProcessCond(PointedTo, y)


function NilTracker.ProcessCondBrel (|message| m, |branchstate| Y)
	opt norefcounts
	|| b = *m.name
	if b == '!'
		return .ProcessCond(m.first, Y.not)
	if b == '*'
		return .ProcessCondPtr(m, Y)
	if b == '&'			// objects always have an address
		return // Y
	debugat
	.RunNormal(m)


function NilTracker.ProcessCondFunc (|message| m, |branchstate| Y)
	opt norefcounts
	return .Function(m, Y)
	if !fn.IsNilChecker
		return branchstate.Perhaps
	debugat // so what do we return if it is a nilchecker??
	

function NilTracker.ProcessCondRel (|message| m, |branchstate| Y)
	opt norefcounts
	|| ll = m.first
	|| op = ll.next
	|| rr = op.next
	|| scop = op.obj|SCOperator|

	// let's say that actually... each cond tester tests things
	// so that is responsbile for calling runnormal or not.
	// so we shouldn't call .runnormal here	

	if scop.IsCompare
		|| LNil = (ll.obj as scdecl).IsNowNil
		|| RNil = (rr.obj as scdecl).IsNowNil
		if lnil or rnil
			expect (scop.IsNilTest) (op, "Can't use this operator on nil. Use != or ==.")
			if (lnil and rnil)
				return m.RedundantBranch(true)
			if scop.HasEquals // if (a==nil or b==nil) return else a.a(b.b)
				y = y.not
			|| side = (rr, ll)(lnil)
			return .ProcessCond(side, Y)
		return
	
	
	if scop.IsAndOr
		if scop.IsAndOr == 3 // x = (a and b)
			if y == BranchState.Never
				y = BranchState.Perhaps
		  else // x = !(a or b)
			if y == BranchState.always
				y = BranchState.Perhaps
		
		.ProcessCond(ll, Y)
		.ProcessCond(rr, Y)
		return

		// what about the cond?
		// if (a and b)			// a yes,   b yes		... after a may, b may
		// if (!a and !b)		// a no,    b no    	... after a may, b may
		// if (!(a and b))		// a may,	b may   	... after a yes, b yes
		// if (!(!a and !b)		// a may,	b may   	... after a no,  b no
		// if (a or b)			// a may,	b may		... after a no,  b no		
		// if (!(a or b))		// a no,	b no		... after a may, b may
		// if (!(!a or !b))		// a may,	b may		... after a no,  b no 
		// if !msg or *msg
		// if (abc and m) or (*m == 1)

// its a bit ops by now. all others would have gone.
	if ll.hasany
		.RunNormal(ll)
	if rr.hasany
		.RunNormal(rr)


function Niltracker.Decl (|message| declmsg)
	opt norefcounts
	|| exp = declmsg.last
	if exp == @rel
		exp = exp.last
		|| d = exp.AsDecl
		|| r = declmsg.AsDecl
		r.NilTake(d)	
	

function NilTracker.SetRel (|message| msg)
	opt norefcounts
	|| l = msg.first
	if l.hasany
		.RunNormal(l)	
	|| r = msg.last
	if r.hasany
		.RunNormal(r)
	.VariableSet(l.nildecl, r.nildecl, r, 0)


function NilTracker.VariableSet (|scdecl| recv, |scdecl| pd, |message| errplace, |uint| IsParam) // setrel, relset
	opt norefcounts
	require recv.suffersnil

	if recv.NilDeclared isnt nilish
		require .FailIfNotReal(errplace, pd, isparam>>1)
	  
	  elseif isparam										// a param that can accept nil
		if !recv.IsStated and (pd.NilUsed is Nilish)
			error (errplace, "Unknown if this parameter accepts nil.")
		if IsParam == 2
			.SetNilness(pd, recv.nilused)
			debugger 										// its too hard to imagine. just figure this out later
			// if (a and func(&a))
	  else
		.SetNilness(recv, pd.nilused)
		
			
	if recv.PointerCount == 1	// |!&!&struct| abc = f
	// what about pointers to pointers to something? // just give up? i think so...
		return .VariableSet(recv.internal, pd.internal, errplace, IsParam<<1)


function NilTracker.RunNormal (|message| msg, |bool|)
	opt norefcounts
	
	for s.fast in msg
		|| f = s.func
		if (f == @dot)
			|| Prop = s.NilPropAccess
				.UseChildAsReal(s)								// abc.var
		  elseif (f == @acc) 
			.UseChildAsReal(s)									// abc[0]
		  elseif (f == @brel) 
			if s != "*"
			.UseChildAsReal(s)									// *abc
		  elseif (f == @rel)
			if s.tmptype is kSetVar								// x = y
				.SetRel(s)
		  elseif (f == @func)
			.Function(s)
		  elseif (f == @tmp)
			|| type = S.TmpType
			if Type is kif
				.If(s)
			  elseif type is kReturn
				.Return(s)
		  elseif (f == @decl)
			.Decl(s)
				
		  elseif !s.IsLast
			.RunNormal(s)
		  
		  elseif s.hasany
			return .RunNormal(s) // tail-call opt
	return true


function niltracker.nilmsg (|message| err, |scdecl| d, |uint| PointerInferred, |string|)
	if PointerInferred
		return "Nil Error: Pointed-to can't be nil."
	if d isnt param
		if err == @thg
			return "Nil Access: Needs 'if' wrapping."
		return "Nil Access here."
	return "Nil Error: Don't declare with '?'... or test for nil."




/*
TODO:

* do the work on args in the if-cond thing...
* we need to undo cond-changes within a branch... but not pointer changes within branch
* so some changes need to be "remaining".... ooof. just set more bits I guess.

* || x = (a and b), if x: a.a(b.b)
	* only the very next ifbranch only :) too many cases where x can be altered by all sorts of things...



BOOLEAN LOGICS:
	nil-checker funcs:
		can still be realish if returns false.


DONE?

can't tell what happened:
	if (a or b) {nochangetoboth()} else {botharenil()}


refills and relsetters:
	if (!a) a = b(), a = &e

multiple branches:
	if !a { if b {return 1} else {return 2} }
	a.b = 1

return affecting future code:
	if (!msg)
		return
	msg.prop

ternaries:
	|| x = (a.b, nil)(a)

rel-sets to internal pointers:
	|| obj = nil
	|!&!object| x = &obj // error: Pointed-to can't be nil

function calls:
	function gg (|object|)
		|| a = maybenil
		|| x = ff(a) // error: ff does not take nil.
		|| y = gg()  // error: unknown at this time if gg returns nil.

update the params:
	function abc (|message| o)
		o.position // o is now "!"

return values:
	if x
		return message()
	  else
		return nil // now this func returns optional values. 

using ptrs:
	if (*msg)

nilstrength:
	--nil=3

can access prop:
	if (msg)
		msg.prop

multiple tests:
	if (a and b)

redundant "m":
	if (m and m.length)
	if (!m or !m.length)

pointless:
	if nil == nil

fail:
	if msg >= nil, if msg <= nil

nil within branch:
	if msg == nil
*/


/*
Init Vars Sweep?
	We need to go through the entire program, and give each item found, a "timecode". That
	is... it has an "earliest time" that it COULD occur.
perhaps just do it on a per-module basis... If a module makes no sense in terms of itself thats the programmers fault.

recursive funcs?
	I think for them... we let the user simply specify their nilness!! makes sense, right?
	I think, just assume NOT NIL unless we can prove that it is tested. It is implicit and we can't be that smart.
*/



// DISTURBANCE CHECKER WILL HELP
// for global vars
	// global.x = obj
	// func()
	// global.x.func2 // allowed or not? func() might have altered global.x

