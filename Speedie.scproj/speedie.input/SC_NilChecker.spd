

module NilChecker
	function SaveLives
		opt norefcounts
		using options.NilStrength
	
		|NilTracker| T
		for f in compiler.funclist
			T.Check(f)
		
		scfunction.currfunc = nil
		.SweepInits

	
	function SweepInits
		// || init = compiler.getfunc("init_")
		// what about "init_"?


function NilTracker.Check (|scfunction| f)
	debugat
	opt norefcounts
	require false
	require !f.IsMacro and !f.IsWrapper and f.isOK
	|| c = f.Lookup
		require c.name contains "NilTest"

	.Start(f)
	.RunNormal(f.SourceArg)
	.Finish(f)


function message.NilPropAccess (|scdecl|)
	opt norefcounts
	|| m = .DotMustBeProperty
	if m and m isnt onmodule
		return m


function message.NilDecl (|scdecl|)
	opt norefcounts
	|| obj = .obj
	if (obj isa scdecl)
		|| l = obj.IsLookupOnly
		if l isa scdecl
			return l
		return obj
	
	
function NilTracker.UseChildAsReal (|message| wrapper)
	// a.b, *a, a[0], (a)()
	opt norefcounts
	|| ch = wrapper.first
		.UseAsReal(ch, ch.NilDecl)


function NilTracker.CheckFunction (|message| msg)
	opt norefcounts
	|| fp = msg.first
	if fp.func == @bra
		.UseChildAsReal(fp.first)						// (abc)()
	|| prms = fp.next
	|| fn = prms.obj|scfunction|
	|| ret = fn.ReturnType
		check (!ret.SuffersNil or ret.IsStated) (msg, "Unknown if this function returns nil.")

	|| p = prms.first
	for a in fn.args
		if p.hasany
			.RunNormal(p)
		a.NilCheckForSet(p)
		p++


function SCDecl.NilCheckForSet (|message| p)
	opt norefcounts
	|| pnd = p.NilDecl

	// handles things like: func (|!&object!| abc)
	
	while pnd
		if (pnd.NilUsed is Nilish) and .SuffersNil		
			if !.IsStated
				error (p, "Unknown if this parameter accepts nil.")
			  elseif .NilDeclared isnt Nilish
				error (p, "Passing possible nil")
		self = self.Internal
		pnd = pnd.Internal
		

// what about containedness also??
// i think most (all?) containers contain nil.... so theres that

function NilTracker.Return (|message| msg)
	opt norefcounts

	|| value = msg.first				#require
	|| vd = value.NilDecl
	if vd.suffersnil
		|| vn = vd.nilused
		|| rd = .fn.ReturnType
		|| r  = rd.NilDeclared
		if r is real  and vn is Nilish
			error (msg, "Nil returned, despite function declaration!")
		rd.nilused |= vn // find the answer at the end


function NilTracker.IfWhileOne (|message| test, |message| root, |message|)
	opt norefcounts
	|| arg = test.first
	if arg == @arg
		.RunNormal(arg)
	  else
		|| Br = .ProcessCond(arg, branchstate.always)
		arg++
		.RunNormal(arg)

	return arg.next
	

function NilTracker.IfOrWhile (|message| msg)
	opt norefcounts
	|| old = .enter
	|| test = msg
	while test
		test = .IfWhileOne(test, msg)
	.leave(old)


function NilTracker.If (|message| Tmp)
	opt norefcounts
	.IfOrWhile(Tmp)


function Message.RedundantBranch (|branchstate|)
	if StdErr.CanAddMore(errorseverity.problem)
		StdErr.NewProblem(self, "nil check is constant (always true or false)")
	return BranchState.Perhaps


function niltracker.UseAsReal (|message| msg, |scdecl| d)
	opt norefcounts
	|| u = d.NilUsed
	if u is Nilish
		expect (d is param) (msg, msg.nilmsg)
		expect (d.NilDeclared isnt Stated) (msg, "NilObjectError: Don't declare with '?'... or test for nil.")
		d.NilDeclared = NilState.real
		d.nilused = NilState.Realish


function NilTracker.ProcessCondThg (|message| msg, |branchstate| Y, |branchstate|)
	opt norefcounts
	|| dest = NilState.Nilish + Y	
	|| dcl = msg.nildecl			#debug_require
	|| u = dcl.NilUsed
	// we need to have actually 3 states set.
	// one for this branch, one for the other branch...
	// and one for the after branch... in case one or other branch returns.
	// where do we store this info? id rather figure it out at this point in time...
	// but the if/else thingy needs to restore it?
	// seem slike the if/else needs to set it, then...
	
	if u == NilState.Either
		if (dcl is param) and (dcl.NilDeclared isnt stated)
			dcl.NilDeclared = NilState.optional
		return .SetNilness(msg, dcl, dest)

	if dcl.NilDeclared is Either
		return msg.RedundantBranch
	return BranchState.Never + (u == dest) // checking for nil-obj allocations


function NilTracker.ProcessCond (|message| m, |branchstate| Y, |branchstate|)
	opt norefcounts
	|| fn = m.func
	if fn == @thg
		return .ProcessCondThg(m, y)
	if fn == @bra or @type
		return .ProcessCond(m.first, Y)
	if fn == @rel
		return .ProcessCondRel(m, y)
	if fn == @func
		return .ProcessCondFunc(m, y)
	if fn == @brel
		return .ProcessCondBrel(m, y)
	.RunNormal(m)
	return branchstate.Perhaps


function NilTracker.ProcessCondPtr (|message| m, |branchstate| Y, |branchstate|)
	opt norefcounts
	|| PointedTo = m.first
	|| pd = PointedTo.nildecl
		.UseAsReal(PointedTo, pd)
		return .ProcessCond(PointedTo, y)


function NilTracker.ProcessCondBrel (|message| m, |branchstate| Y, |branchstate|)
	opt norefcounts
	|| b = *m.name
	if b == '!'
		return .ProcessCond(m.first, Y.not)
	if b == '*'
		return .ProcessCondPtr(m, Y)
	if b == '&'			// objects always have an address
		return Y
	debugat
	.RunNormal(m)
	return branchstate.Perhaps


function NilTracker.ProcessCondFunc (|message| m, |branchstate| Y, |branchstate|)
	opt norefcounts
	.CheckFunction(m)
	|| prms = m.last
	|| fn = prms.obj|SCFunction|
	if !fn.IsNilChecker
		return branchstate.Perhaps
	debugat // so what do we return if it is a nilchecker??
	

function NilTracker.ProcessCondRel (|message| m, |branchstate| Y, |branchstate|)
	opt norefcounts
	|| ll = m.first
	|| op = ll.next
	|| rr = op.next
	|| scop = op.obj|SCOperator|

	// let's say that actually... each cond tester tests things
	// so that is responsbile for calling runnormal or not.
	// so we shouldn't call .runnormal here	

	if scop.IsCompare
		|| LNil = (ll.obj as scdecl).IsNowNil
		|| RNil = (rr.obj as scdecl).IsNowNil
		if lnil or rnil
			expect (scop.IsNilTest) (op, "Can't use this operator on nil. Use != or ==.")
			if (lnil and rnil)
				return m.RedundantBranch
			if scop.HasEquals // if (a==nil or b==nil) return else a.a(b.b)
				y = y.not
			|| side = (rr, ll)(lnil)
			return .ProcessCond(side, Y)
		return BranchState.Perhaps
	
	
	if scop.IsAndOr
		if scop.IsAndOr == 3 // and
			// x = (a and b)
			if y == BranchState.Never
				y = BranchState.Perhaps
		  else
			// x = !(a or b)
			if y == BranchState.always
				y = BranchState.Perhaps
		
		.ProcessCond(ll, Y)
		.ProcessCond(rr, Y)
		return BranchState.Perhaps

		// what about the cond?
		// if (a and b)			// a yes,   b yes		... after a may, b may
		// if (!a and !b)		// a no,    b no    	... after a may, b may
		// if (!(a and b))		// a may,	b may   	... after a yes, b yes
		// if (!(!a and !b)		// a may,	b may   	... after a no,  b no
		// if (a or b)			// a may,	b may		... after a no,  b no		
		// if (!(a or b))		// a no,	b no		... after a may, b may
		// if (!(!a or !b))		// a may,	b may		... after a no,  b no 
		// if !msg or *msg
		// if (abc and m) or (*m == 1)

// its a bit ops by now. all others would have gone.
	if ll.hasany
		.RunNormal(ll)
	if rr.hasany
		.RunNormal(rr)
	return branchstate.Perhaps


function Niltracker.Decl (|message| declmsg)
	opt norefcounts
	|| exp = declmsg.last
	if exp == @rel
		exp = exp.last
		|| d = exp.AsDecl
		|| r = declmsg.AsDecl
		r.NilTake(d)	
	

function NilTracker.SetRel (|message| msg)
	opt norefcounts
	|| l = msg.first
	|| ld = l.nildecl
	|| r = msg.last
	|| rd = r.nildecl
	// |!&file!| abc = f	// real pointer to a real file
							// now, f must be real? sure... but the internal object must be nil too.
							
	if ld.NilDeclared isnt nilish
		.UseAsReal(r, rd)
	while
		ld = ld.Internal
		rd = rd.Internal
		loop ld and rd
		if ld.NilDeclared isnt Nilish  and  rd.nildeclared is nilish
			// The msg is not here anymore, so we can't upgrade. Just make an error
			error (l, "NilObjectError: Pointed-to is not nil, but could become nil here")
	.RunNormal(msg)			


function NilTracker.RunNormal (|message| msg)
	opt norefcounts
	
	for s.fast in msg
		|| f = s.func
		if (f == @dot)
			|| Prop = s.NilPropAccess
				.UseChildAsReal(s)								// abc.var
		  elseif (f == @acc) 
			.UseChildAsReal(s)									// abc[0]
		  elseif (f == @brel) 
			if s != "*"
			.UseChildAsReal(s)									// *abc
		  elseif (f == @rel)
			if s.tmptype is kSetVar								// x = y
				.SetRel(s)
		  elseif (f == @func)
			.CheckFunction(s)
		  elseif (f == @tmp)
			|| type = S.TmpType
			if Type is kif
				.If(s)
			  elseif type is kwhile
				.IfOrWhile(s)
			  elseif type is kReturn
				.Return(s)
		  elseif (f == @decl)
			.Decl(s)
				
		  elseif !s.IsLast
			.RunNormal(s)
		  
		  elseif s.hasany
			return .RunNormal(s) // tail-call opt


function message.nilmsg (|string|)
	if self == @thg
		return `NilObjectAccess: Needs "if" wrapping.`
	return "Possible NilObjectAccess"




/*
TODO:

* modifications of objects via func pointer param... during a cond

* do the work on args in the if-cond thing...
	* pass the info about BOTH the conditions... in the state "Y" thing... the applicator can decide what to do about "After" conditions...

* || x = (a and b), if x: a.a(b.b)
	* only the very next ifbranch only :) too many cases where x can be altered by all sorts of things...

* cpp-wrappers and prototypes default to not nil unless stated.
* ternaries
* freeze bug
* msg.last/first etc will have to accept nil :O. The C++ compiler will opt it.



BOOLEAN LOGICS:
	refills and relsetters:
		if (!a) a = b(), a = &e
	
	multiple branches:
		if !a { if b {return 1} else {return 2} }
		a.b = 1
	
	return affecting future code:
		if (!msg)
			return
		msg.prop
	
	changes nothing:
		if (a or b)

	nil-checker funcs:
		can still be realish if returns false.


DONE?

rel-sets to internal pointers:

function calls:
	function gg (|object|)
		|| a = maybenil
		|| x = ff(a) // error: ff does not take nil.
		|| y = gg()  // error: unknown at this time if gg returns nil.

update the params:
	function abc (|message| o)
		o.position // o is now "!"

return values:
	if x
		return message()
	  else
		return nil // now this func returns optional values. 

using ptrs:
	if (*msg)

nilstrength:
	--nil=3

can access prop:
	if (msg)
		msg.prop

multiple tests:
	if (a and b)

redundant "m":
	if (m and m.length)
	if (!m or !m.length)

pointless:
	if nil == nil

fail:
	if msg >= nil, if msg <= nil

nil within branch:
	if msg == nil
*/


/*
* Init Vars Sweep?
	We need to go through the entire program, and give each item found, a "timecode". That
	is... it has an "earliest time" that it COULD occur.
perhaps just do it on a per-module basis... If a module makes no sense in terms of itself thats the programmers fault.
*/

/*
Issues:
What about the fact that a function's param nilness can rely on other funcs??
like:

	x = msg[0] // OK... so we don't rely on msg existing? but only cos it doesn't rely on self existing.
what if msg[n] is recursive and complicated? then how do we check if a decl... is nil or not?

The fact that we have ordered this... leaf first... helps. dependancies help... but that only reduces the problem
not eliminiates it. There will be cases that we can't eliminate.

* Make it nestable? That is... we actually can check functions?
	* this would only be needed for actual recursive functions... non-recursives would have a strict chain...
* what if two funcs with the same depth... and one is called before the other but the wrong one is called first?
	* then making it nestable helps!

* what about actually recursive funcs? I think for them... we let the user simply specify their nilness!! makes sense, right?
	* I think, just assume NOT NIL unless we can prove that it is tested. It is implicit and we can't be that smart.
*/



// DISTURBANCE CHECKER WILL HELP
// for global vars
	// global.x = obj
	// func()
	// global.x.func2 // allowed or not? func() might have altered global.x

