
/*
	Maybe better to simply copy the ENTIRE object. At least as a "default" approach, for most classes.
	even object references. And the loader then loads a map of obj-references... to restore them.
	Makes saving really fast!!! and simple! Even the loader is kinda simple, we can just copy them back
	entirely, and then "Fixup" whatever positions... We can have maybe one...
	u32 bitfield for the object positions, that need fixups?
*/


module SC_Saver {

	function Message.CheckSuperDotSave (|string|name, |bool| ShouldBe=true)
		|| Match = ((self isdot name) and (.first isthing "super")) 
		warn (match == ShouldBe) (self, "First statement must be call to super.$name")
	

	function SCFunction.ValidateSaver (|string| name)
		using .source!
			.ValidateSaverSub(name)
		
	
	function SCFunction.ValidateSaverSub (|string| name)
		opt norefcounts
		// So... now? Let's look at a real saver...
		// first, let's check if we NEED to call the super.

		|| Cls = .cls #expect
		require (cls != typesaveable)
		
		|| First = .SourceArg.first
		warn First (.source, "This func needs some code.")
		for (line in .SourceArg)
			if (cls.super != TypeSaveable)
				line.CheckSuperDotSave(name, first == line)	// need a call to the saver first...
			require stderr.ok
			// To do: Add order checker to compare code in saver/loader...
	

	function SCFunction.FillInSaver (|String| name) {
		require self is AutoGeneratedSaver
		|| cls		= .cls!
		|| IsSave	= (name contains "Save")
		|| fs		= FastString.new
		
		.BlindCasts = 0
		for (item in cls.properties) {
			|| type = item.TryUseSaveable(IsSave, cls)
			if (!type) {continue}
			
			fs <~ "\n\t"
			|| Count = item.c_Array
			|| T = item.type.TypeInfo
			|| AppendAsData = (T.ByteShift and T.isfloat)  // not sure what this is meant to do....
			if (!AppendAsData and Count)
				fs <~ "for (i in $Count) {\n"
			if (AppendAsData)
				type = "raw" // Ideally the entire thing should be appended as ONE data thing, and then just fix up the object refs...
							// would make debugging harder though. floats are already hard so... whats the difference?
				Count ?= 1   // makes sense.
			
			if (IsSave)
				// .SnakeGraphics.SaveWrite(Saver)
				// .count|int|.Savewrite(saver)
				// saver.appendint(.count)						 // Actually less good than above 
				if (type == "struct")
					fs <~ '.'
					fs <~ Item.Name
					fs <~ ".SaveWrite(saver)"
					if (Count)
						fs <~ "[i]"
				  else
					fs <~ "saver.Append"
					fs <~ type
					fs <~ '('
					if (AppendAsData)
						fs <~ "(&"
					fs <~  '.'
					fs <~ Item.Name
					if (AppendAsData)
						fs <~ ")|&byte|, "
						fs <~ T.ByteCount * Count
					  elseif (Count)
						fs <~ "[i]"
					fs <~ ')'


			  elseif (AppendAsData)  // load raw data.
				fs <~ "loader.LoadRaw((&."
				fs <~ item.name
				fs <~ ")|&byte|, "
				fs <~ T.ByteCount * Count
				fs <~ ")\n"
		
			  else
				// .count[i] = loader.int|u16|				  // fine
				// .snakegraphics[i].loadproperties(saver)	  // fine
				fs <~ '.'
				fs <~ item.Name
				if (Count)
					fs <~ "[i]"
				if (type == "struct")
					fs <~ ".LoadProperties(loader)"			   // so much cleaner...
				  else
					fs <~ " = "
					fs <~ "loader."
					fs <~ type
					|| it = item.type
					if (it.NumericCount <= 1) and (type!=.name)
						fs <~ '|'
						fs <~ it.name // probably OK? won't get here if it's a pointer anyhow...
						fs <~ '|'
				
			if (!AppendAsData and Count)
				fs <~ "\n}\n"
		}

		// put it in the code.
		|| Using = .source!.syntaxusing
		|| SrcStr = fs.getresult
		|| Msg = SrcStr.parse
		|| dest = .sourcearg!
		for (line in Msg)
			dest <~ line
	}
	

	function SCDecl.IsSaveable (|string|)
		require !.PointerCount
		return .type.SaveAs


/*
	it's actually easier, to specify it though.
	"SavingCanSkip" works
*/

	function SCDecl.TryUseSaveable (|bool|IsSave, |SCClass|cls, |string|)
		|| type = .issaveable
		if (!Type or type == "fail")
			ifn options.IgnoreCantSaveErrors
				expect IsSave (.source, "Can’t save ${.name} (${.type.name})")
			return type
		require (type != "nil")
		
		
		if (.type is SavingCanSkip)
			|| Con = .contains // So, if we contain something, that has "saveas nil" // Then... don't save it.
				require Con.TryUseSaveable(true, cls)
		return type


	// SAVEAS TYPES:
	// saveas nil:	 "it's fine to not save this"
	// saveas canskip: "usually save this, unless the thing we contain has saveas nil"
	// saveas fail:	"we don't know how to save this"
	// saveas struct:  "generate struct saver"

	function SCClass.LoadSaver
		while
			|| Msg = .SourceArg.find( @Tmp, "saveas" )#loop
			|| S = msg[@thg]$.name.lowercase
			if (S == "nil" or "fail" or "struct")
				.saveas = S // already fine.
			  elseif (S == "canskip")
				is SavingCanSkip
			  else
				.saveas = S
				require compiler[msg]		  // check it exists
			msg.remove

		.SaveAs ?= .LoadSaverSub
	
	
	function SCClass.LoadSaverSub (|string|)
		opt norefcounts
		if (self == TypeBool)
			return "bool"
		  elseif .NumericCount == 1
			if .isa(typefloat)
				return "float"
			  elseif .isa(typefloat64)
				return "f64"
			  else
				return "int"
		  elseif (.NumericCount)
			|| d = .TypeInfo
			if d.isfloat
				if d.itemBitCount == 32
					return "float"
			  else
				if (d.itemBitCount == 32)
					return "int"
			return "" // fail
		  elseif .isObject
			if self == typeString
				return "string"
			  elseif (self == TypeSaveable)
				return "object"
		|| s = .Super
			return s.saveas // Makes sense?
	
	
	function SCClass.StartupSaver (|String| Name)
		|| dest		= FastString.new
		|| IsStruct = (.saveas == "struct")
		|| IsSave	= (name contains "Save")

		|| Using = .source!.syntaxusing
		if (IsStruct)
			dest <~ "function "
		  else
			dest <~ "behaviour "
		
		Dest <~ name
		if (IsStruct)
			if (IsSave)
				dest <~ " (|&ObjectSaver| Saver)"
			  else
				dest <~ " (|&ObjectLoader| Loader)"
		Dest <~ " {\n"
		
		if (IsStruct)
			dest <~ "visible\n"
			
		  elseif (.super != typesaveable) // call it...
			dest <~ "\tsuper."
			dest <~ name
			dest <~ '('
			if (IsSave)
				dest <~ "saver"
			  else
				dest <~ "loader"
			dest <~ ')'
		
		dest <~ "\n}"
		
		|| str = dest.getresult
		|| src = str.parse
		|| fn = .CollectSub(src)
		if (fn isa SCFunction)
			(fn is AutoGeneratedSaver)
			is AutoGeneratedSavers
	
	
	function SCClass.DoSaver (|String| name, |int| stage, |scfunction|)
		require !(.isa(typestring))
		|| Fn = self[name]
		// so... what do we want to do? well... let's validate first...
		if (!stage and !fn)
			.StartupSaver(name)

		  elseif (fn isa scfunction)
			if (Stage == 1)
				fn.FillInSaver(name)
			if (Stage == 2)
				fn.ValidateSaver(name)
			return fn
		  elseif (Stage == 2)
			error (.source, "No saving behaviour $name was found for this saveable class.")
	
	
	function Compiler.DoSavers (|int| Stage)
		opt norefcounts
		for c in .classlist
			if c.IsSaveableObject or c.issaveablestruct
				|| First = c.DoSaver("SaveWrite", stage)
				|| Second = c.DoSaver("LoadProperties", stage)
				if First|bool| != Second|bool|
					First ?= Second
					error (first!.source, "Can’t make one save/load function but not the other. Either make both or neither.")
	
	
	function SCClass.IsSaveableObject (|bool|)
		require .IsObject 
		require !.isrole
		|| S = .SaveAs
		return S and (S != "nil")

	
	function SCClass.IsSaveableStruct (|bool|)
		require .IsStruct 
		return (.SaveAs == "struct")

	
	function BugWorkAround
		Visible // make sure SaverLoadClass is generated... 
		|SaverLoadClass| whatever
	
	
	function TestSaver
		require StdErr.ok
		|| R = array.new
		|| n = 5
		for i in n
			|| s = SavingTest.new(i)
			if !i
				s.name = ""
			R <~ s
			R <~ s
		R <~ "hello"
		
		|| path = TransCompiler.tmpbase("SavingTest.txt")
		|| F = path.file
		R.saveto(F)
		
		|| R2 = F.parse.RestoreLoad
		if R2 isa Array
			R.pop
			|| last = r2.pop
			expect last and (last isa string) and (last|string| == "hello")

			expect R2.length == R.length
			for i in n
				expect savingtest.IsEqual(R[i], R2[i])
			// printline "SaveTests Complete!"
		  else
			error "SaveTest failed."

	linkage
		cpp_part Sav
}



function SCClass.RenderSaveableSub (|faststring| fs, |bool|)
//	require .AutoGeneratedSavers or (self == typesaveable)
	|| s = .super
		require s.RenderSaveableSub(fs) or true
	for (p in .properties)
		|| ST = p.issaveable
		if (st and st!="nil")
			if (st == "struct")
				st = p.type.name
			fs <~ '|'
			fs <~ st
			fs <~ '|'
			fs <~ ' '
			fs <~ p.name
			fs <~ ','
			fs <~ ' '
	return true


function SCClass.RenderSaveable (|faststring| fs)
	fs <~ '"'
	.rendersaveablesub(fs)
	fs.remove(' ')
	fs.remove(',')
	fs <~ '"'



class SavingTest (saveable)
	|string|	Name
	|int|	   Value
	|int[1]|	ABC

	function Constructor  (|int|n)
		.name = "fred" + n
		.value = 1000 + n

	module
		function IsEqual (|object| A, |object| B, |bool|)
			ifn A and B
				return (B==A)
			if (A isa SavingTest)
				if (b isa savingtest)
					return (A.value == B.value) and (A.name == B.name)
	
	// write/load are auto-generated... and collect doesn't need over-riding :)


