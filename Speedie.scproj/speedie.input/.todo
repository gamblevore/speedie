

bugs:
	* unify numeric types a lot. Many functions want to work on uint, int, etc... and one func is good enough for all!
		* datatype byte: inherit int // anything you can do on an int... can be done on a byte!
	* vector constants
	* &uint... allow &int in c++ gen
	* passing .hfloatvar to  func(float) causes reporting error
	* render float.fn {code} // won't compile
	*	status(.CurrMousePixelColor.render) // tmp struct.
	* The "function case affects visibility" (from GoLang) thing needs deletion.
	* refcounter passing properties as function param, SHOULD NOT assume it won't be cleared... not without disturbance checker


additions:
	* class descriptions!
	* add \123 numeric type (mostly for jbin). use a float/int format, that is signed. 2 exponent bits per byte.
		* first byte (if float) can also store the sign of the exponent.
		* could be an interesting type to have generally... like perhaps as a string subclass?
	* refcount optimiser
	* â€“container @ques ability... for macros. This returns the syntax that contained us. Useful for (all~files).delete
	* unify macros? or just modernise. Why pass an array? why not a message~list? Arrays suck. list sexy.
	* nicer lookups: fn x (|int| n), .x(max) --> .x(int.max) // assuming max doesn't exist locally.
   * just set a global var... somewhere, and do set .obj or whatever it is that we lookup from in lookupsub, to that var if we can't find anything... it should happen in priority to globals, though.
	* do we need lowercase in lookupsub??? all dots/funcs got lowered in parseclean?
		* perhaps parseclean should use an ID system...
	*  msg <~ {
		dot "hi"
		thg "ok"
		prm
			thg "yep" }    -->    ok.hi(yep)
	* new destructor! bitfield 64 for objs! no super! works for most!
		// could be done better with ast-spawner?
	* (node, err) = .text.parse --> |error| err, || node = .text.parse(err) // noice
	* any object can be created with an virtual-function override table, just store before the refcount?
		* if refcounts come in multiple of 2 (or even 4), we could store if we have a override table... per object
	* || x = .SomeCArray // should just get the address... :)
	* months.scproj demo needs better compiler support, including .render not being needed.

	* auto foo() { // multiple return?
		struct retVals {        // Declare a local structure 
			int i1, i2;
			string str;
		};
		return retVals {10, 20, "Hi"}; // Return the local structure
	}
	

class-changes
	* replace dictionary with fixeddict
		* doesnt need datatype wrapper! We could use a dict of ints / pointers...
* Get galaxxies compiling
* GameFloodFill being generated despite not being used.
	GameFloodFill_Behaviour GameFloodFill_FuncTable_ = InitTableGameFloodFill_();
	JBClassPlace4(GameFloodFill, JB_AsClass(FastAppender), GameFloodFill_FuncTable_);
	void Game_Flood_Destructor(GameFloodFill* self) {
		Game_Flood_PopAllOff(self); // bug here
	}
I guess it's because it's a saveable? makes sense, sorta. We can just make it not saveable...
*	|FastString| StdOutFS // create .disposeall_ func. just search for ".initvarsarg"
* Can't save GameMaterial... but we can save cell? neither are subclass of saveable.

* Loop bug with moveset iterator as nested loop? NearestEmptyCell... fails if we remove "|| OurLoop = Dirs" cos dirs gets altered when it shouldn't.

* CollectDecls needs to be split up and... able to only process one at a time.
	for m in msgs 
		.CollectOneDecl(m)

* Saving... should work as ONE stream. Maybe 1 or 2 phases. (Collects objects + write objects, but don't separate into classes.). Allows tighter compression, simpler-saving-code, etc. Makes it easier to work into an archiving system even!!! Faster saving too, just copy entire object. Needs a "SaveProperty true/false" temporal... Just use save-marking to stop saving objects twice. Need one array to clear the save-marks. dicts can use a special value to mark "end"
    * Actually... speed isn't the issue. SIMPLICITY is. more than fast enough.
        * Allow a tree, like JSON? Repeated objs become a ref second time around.
            * Debuggable...
* Make all objects saveable? Why would some not be? Simpler than marking them as saveable.
	* If a class has specific stuff that can't be saved... we can silently mark it as non-saveable... unless already marked as saveable... or we try to save it, then we create an error.
* burst-mode allocation, for parsing basically, seeing as we spend 80% of our time during parse in allocators!

