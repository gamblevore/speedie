

bugs:
	* unify numeric types a lot. Many functions want to work on uint, int, etc... and one func is good enough for all!
	* recursion blocker. We block any func from being recursive unless explicitly stated it could be. (can mark entire file as recursive though... like for my parser)
	* don't use "syntax append", simply "function append". Same with "call". I mean *x --> x.first
	* sdleventtype.mousedown() // compiles???
		* cant do sdlapp.event is mousedown! is it cos its a struct? it shoudl work on modules and struct
	* Function finding fails with dictionary subclasses? DictSub["abc"]
	* collectdecls uppercase one letter at least... within funcs, unless 1 byte long
	* vector constants
	* || s = "".Address.IsLower // won't compile...
	* perryide_Behaviour 
		* Make not available from speedie, c-export only.
		* Perhaps a unicode start letter. or don't add to lookup table
	* &uint... allows &int
	* passing .hfloatvar to  func(float) causes reporting error
	* |string| s = __now__.render fails
	* render float.fn {code} // won't compile
	* v.operatormul(1.33) instead of v*1.33 :(
	* ?? is kinda buggy for a lot of things.
		x = a ?? x // sets x to x! should disallow? if a: x=a thats what we want.
	*	status(.CurrMousePixelColor.render) // tmp struct.
	* The "function case affects visibility" (from GoLang) thing needs deletion.
	* refcounter passing properties as function param, SHOULD NOT assume it won't be cleared... not without disturbance checker

additions:
	* add \123 numeric type (mostly for jbin). use a float/int format, that is signed. 2 exponent bits per byte.
		* first byte (if float) can also store the sign of the exponent.
		* could be an interesting type to have generally... like perhaps as a string subclass?
	* refcount optimiser
	* nil-checker could eliminate scope-escape... of local vars addresses. Its an error regardless.
	* CollectDecls needs to not return early!! or break it up into pieces
	* â€“container @ques ability... for macros. This returns the syntax that contained us. Useful for (all~files).delete
	* unify macros? or just modernise. Why pass an array? why not a message~list? Arrays suck. list sexy.
	* do we need lowercase in lookupsub??? all dots/funcs got lowered in parseclean?
		* perhaps parseclean should use an ID system...
	*  msg <~ {
		dot "hi"
		thg "ok"
		prm
			thg "yep" }    -->    ok.hi(yep)
	* new destructor! bitfield 64 for objs! no super! works for most!
		// could be done better with ast-spawner?
	* (node, err) = .text.parse --> |error| err, || node = .text.parse(err) // noice
	* any object can be created with an virtual-function override table, just store before the refcount?
		* if refcounts come in multiple of 2 (or even 4), we could store if we have a override table... per object

	* could unify all the tmp names into IDs during the lookup phase. We use a dict of the names anyhow right?
	* || x = .SomeCArray // should just get the address... :)
	
	* Errors in subprojects kinda suck with error-reporting
		* errors with jbin also suck
	* months.scproj demo needs better compiler support, including .render not being needed.

	* auto foo() { // multiple return?
		struct retVals {        // Declare a local structure 
			int i1, i2;
			string str;
		};
		return retVals {10, 20, "Hi"}; // Return the local structure
	}
	

class-changes
	* Make objectset from FixedDict?
	* replace dictionary with fixeddict
		* remove the datatype wrapper? it was only used for dicts+arrays anyhow...
			* We could use a dict of ints or carray for pointers...
* Get galaxxies compiling
	* Condtionally use glm in galaxxies.
	* (|xyz| a)	// Should be @decl					// Replace fTypeCast2 with fdecl...
* GameFloodFill being generated despite not being used.
	GameFloodFill_Behaviour GameFloodFill_FuncTable_ = InitTableGameFloodFill_();
	JBClassPlace4(GameFloodFill, JB_AsClass(FastAppender), GameFloodFill_FuncTable_);
	void Game_Flood_Destructor(GameFloodFill* self) {
		Game_Flood_PopAllOff(self); // bug here
	}
I guess it's because it's a saveable? makes sense, sorta. We can just make it not saveable...
* obj*bool = JB_ObjOrNot(obj,bool)
	* need special "returns self" type?

*	|FastString| StdOutFS // create .disposeall_ func. just search for ".initvarsarg"
* Can't save GameMaterial... but we can save cell? neither are subclass of saveable.

* Loop bug with moveset iterator as nested loop? NearestEmptyCell... fails if we remove "|| OurLoop = Dirs" cos dirs gets altered when it shouldn't.

* CollectDecls needs to be split up and... able to only process one at a time.
	for m in msgs 
		.CollectOneDecl(m)

* Saving... should work as ONE stream. Maybe 1 or 2 phases. (Collects objects + write objects, but don't separate into classes.). Allows tighter compression, simpler-saving-code, etc. Makes it easier to work into an archiving system even!!! Faster saving too, just copy entire object. Needs a "SaveProperty true/false" temporal... Just use save-marking to stop saving objects twice. Need one array to clear the save-marks. dicts can use a special value to mark "end"
    * Actually... speed isn't the issue. SIMPLICITY is. more than fast enough.
        * Allow a tree, like JSON? Repeated objs become a ref second time around.
            * Debuggable...
* Make all objects saveable? Why would some not be? Simpler than marking them as saveable.
	* If a class has specific stuff that can't be saved... we can silently mark it as non-saveable... unless already marked as saveable... or we try to save it, then we create an error.
* burst-mode allocation, for parsing basically, seeing as we spend 80% of our time during parse in allocators!

