
/*
	Jeebox internals. By Theodore H. Smith...
*/



prototype ExprResolver (|Message| Exp, |SCNode| name_space, |Message?| side=nil, |SCObject?|)

dispatch ExprFuncs (ExprResolver)
/* @decl is BAD!   dont add it*/
	@Rel  : (TypeOfRel)
	@BRel : (TypeOfBRel)
	@ARel : (TypeOfARel)
	@Adj  : (TypeOfAdj)
	@Func : (TypeOfFunc)
	@Acc  : (TypeOfAccess)
	@msg  : (TypeOfMsg)
	@sthg : (TypeOfSthg)
	@Dot  : (TypeOfDot)
	@Name : (TypeOfSyx)
	@list : (TypeOflist)
	@Arr  : (TypeOfArr)
	@Arg  : (TypeOfArgArr)
	@Char : (TypeOfChar)
	@sstr : (TypeOfSString)
	@Item : (TypeOfLast)
	@Bra  : (TypeOfBra)
	@Str  : (TypeOfStr)
	@Back : (TypeOfStr)
	@Num  : (TypeOfNum)
	@unit : (Typeofunit)
	@Thg  : (TypeOfThg)
	@Ques : (TypeOfQues)
	@SDot : (Typeofsdot)
	@Type : (typeoftype)
	@Emb  : (TypeOfNothing)
	@Sheb : (TypeOfNothing)
	63    : (TypeOfNothing)



function TypeOfSDot (ExprResolver)
	SCFunction.Tran_Sdt( exp )
	Return TypeOfDot( exp, name_space, side )


function TypeOfType (ExprResolver) // typeoftypecast, typeofcast
	|| exp0 = exp.first!.unbra
	|| Old = TypeOfExpr( exp0, name_space, side )									#require
	|| New = ExtractDecl( exp.last!, name_space, declmode.TypeCast )				#require
	// allow MOST typecasts, but NOT typecasts between struct instances...
	if Old.isntReallyCastable(exp0)  or  New.isntReallyCastable(exp0)
		error (exp, "Can’t cast between structs/carrays")
	  else
		if exp0.isint and new.TypeSuffers
			if exp0.iszero or Old.IsNil
				new = new.MakeNewNil
			  else   // || xx = 1234|&byte| // Its only used to force a crash, basically.
				new = new.MakeNewReal
		new.NoBlindCasts(old, exp, name_Space)
	return New


function TypeOfNothing (ExprResolver)
	return nil


function SCDecl.IsntReallyCastable (|message| side = nil, |bool|)
	require (.type.IsStruct or .IsCArray) and (!.pointercount)
	if !side
		return true
	return  side.Unwrap != @arg


function scdecl.NoBlindCasts (|scdecl| old, |message| exp, |SCNode| name_space)
	opt norefcounts
	|| fn = scfunction.CurrFunc 
	if fn and (fn isnt constructor) and fn.blindcasts
		if old.IsNormalObject and .IsNormalObject
			if !old.type.real_isa2( .type )
				stderr <~ error(exp, "Blindcasting error. Use 'isa' or 'as' to typecast.", fn.blindcasts)


function TypeOfReal (ExprResolver)
	opt	norefcounts
	return TypeOfExpr(exp.first, name_space)$.makereal


function TypeOfARel (ExprResolver)
	if exp == "!"
		return TypeOfReal(exp, name_space, side)
	if Exp == "..."
		return TypeOfDotDotDot(exp, name_Space)
	|| Brel = exp.niceparent == @arg
		exp.func = @brel
	return SCFunction.Tran_AfterRel(exp, name_space, side)// for now//!brel)


function TypeOfFunc (ExprResolver)
	opt norefcounts
	|| f = exp.first
	if f == @list
		return TypeOfTernary(exp, name_space, side)
	
	|| fn = TypeOfFuncSub(exp, name_space, side)			#expect (exp, "Can’t use this as a function.")
	if fn isa SCFunction
		|| obj = fn.ReturnType
		if !obj
			exp.obj = typevoid
		if fn Is Killer
			exp.LastInBlock(SCBlockage.Quit)
		return obj // voids are so annoying.
	return fn


function Message.CanGetAddress (|SCNode| name_space, |bool|)
	opt norefcounts
	|| curr = .unbra
	if (curr == @acc)
		|| f = curr.first
		|| T = TypeOfExpr(f, name_space)				#require
		return (T.isnumeric <= 1) #expect (curr, "Can't get address of vector element (c++ limitation).")

	|| T2 = TypeOfExpr(curr, name_space)				#require // might transform it
	expect (curr == @thg or @dot)		(curr, "Can't get the address of this.")
	expect (T2 isnt NumberConst)        (curr, "Can't get the address of a const.")
	
	if (curr == @thg) and t2.isregister
		|| f = .ParentForAddress
		t2.isregister
		expect (f == @prm or @dot)		(curr, "Can't store the address of register based variables.")
			
	return true


function Message.ParentForAddress (|syntax|)
	opt norefcounts
	|| gotaddr = 0
	|| p = .parent
	while p
		|| f = p.func
		if (f != @Bra and @Type)
			if (f == @brel and p == "&")
				gotaddr++
				require gotaddr <= 1
			  else
				return p.func
		p = p.parent


function DollaDolla (|message| exp, |SCNode| name_space, |SCObject|)
	opt norefcounts
	// $x --> (swearword(x))
	// $$$x --> (swearword(x))
	// !!$$!x -- (swearword(X,3))
	// $1 --> (swearword(1))
	// {$1} --> {app.say swearword(1)}
	|| strength = 0
	|| ch = exp
	while ch == @brel
		|| n = ch.name
		if n == "!" // ok
			strength++
		  elseif n != "$"
			exit
		ch.become @bra
		ch = ch.first!
	exp.become(@bra)
	using exp
	|| fnc = "swearword()"~parse
	|| prm = fnc.last
	prm <~ exp.first
	if strength > 0
		prm <~ strength
	if exp in @arg
		|| say = "app.say()"~parse
		say.last <~ fnc
		fnc = say
	exp <~ fnc
	return TypeOfExpr(exp, name_space)


function TranNegate (|message| f, |SCNode| name_space, |SCObject|)
// if this is @thg... do we really NEED to expand this to a bool?
	opt norefcounts
	f = F.ExpandToBool( name_space )$
	|| d = f.obj
	if (d isa scdecl)
		if d.IsConstOf(Falsebool)
			return truebool
		if d.IsConstOf(Truebool)
			return falsebool
	
	Return TypeBool!.TypeNormal // it's a bool anyhow
	

function TypeOfBRel (ExprResolver)
	opt norefcounts
	|| name = exp.name
	|| n = name[]
	|| F = exp.first									#require

	if (n == '$') or (n == '!'  and  f isbrel "$")
		return DollaDolla(exp, name_space)

	|| SubType = TypeOfExpr( F, name_space )			#require
	
	if n == '*'
		problem (exp, "Use [] instead")
		return SubType.Dereference(exp, name_space, false)
	
	if n == '-' and name == 1 // minus
		expect (subtype.IsNearlyNormalNumber or subtype.isbool) (exp, "Expected a number.") 
		Return subtype
		
	if n == '&'
		if Subtype.type.funcproto
			return TypeOfFuncPointer(F, name_space, side)
		F.CanGetAddress(name_Space)
		require F.CanGetAddress(name_Space)
		return Subtype.GetAddress
		
	if n == '!'
		return TranNegate(f, name_space)
		
	if n == '~'
		check (subtype.IsInteger) (exp, "Expected an integer.") 
		Return subtype
		
	SCFunction.Tran_AfterRel( exp, name_space, side )
	Return SubType


function TypeOfLast (ExprResolver)
	return TypeOfExpr( exp.Last, name_space )


function TypeOfBlock (ExprResolver)
	|| last = exp[@nil, -1]$
	ifn last istmp "rejoin"
		using last
			last = last.wrapwith(NewRejoin())
	
	|| p = exp.scarg( name_space )!
	exp.Parent!.statementexpr = p
	|| fn = p.owningfunc! // isnt this the same as scfunction.currfunc
	
	CollectDeclsFuncBodyUnsureHowToRemove( exp, p ) // hard to remove these. might take an hour or 2 just on removing this.
	
//	SCFunction.Tran_All( fn, exp, p ) // should be enough... not working for some odd reason.

	for ch in exp			// copied from tran_all... shouldn't be necessary... 
		if ch == @Arg
			SCFunction.Tran_All( fn, ch, ch.scArg( p )! )
		  else
			SCFunction.Tran_All( fn, ch, p )
	
	|| val = last.NeedFirst
	if val.expectlast
		return TypeOfExpr(val, p)


function TypeOfThg (ExprResolver)
	opt norefcounts
	|| R = name_space.LookUpvar( exp.name, exp, side )
	
	if R isa SCModule
		|| Cls = R.Cls								#expect (Exp, "Can’t refer to a module like that.")
		if Cls.IsModel
			return Cls.GetFlyingMemory(exp)
		if cls.isobject					//
			|| T = Cls.classtype
				exp.name = t.name			// right?
				return T
			error (exp)
		expect (false) (exp, "Expected an object here.")
	
	  elseif R isa SCDecl
		if side
			(r is setto)
		|| O = R.islookuponly
		if O isa message
			exp.SafeReplaceWith(o.copy(exp))
			
	return R
	


function TypeOfBra (ExprResolver)
//	opt norefcounts // needs to stay. typeofdot can destroy nodes???
	|| c0 = exp.first
	if (c0 == @arg)
		return typeofBlock(c0, name_space, side)
	  else
		return TypeOfExpr(c0, name_space, side)


function TypeOfStr (ExprResolver)
	opt norefcounts
	scfunction.String_Expand(exp, exp.MsgOwningFunc)
	Return TypeStringzero!.TypeReal


function TypeOfSString (ExprResolver)
	return TypeStringZero!.TypeReal


|dictionary of scdecl| CodePointTable
function TypeOfChar (ExprResolver)
	if exp.length == 1
		return TypeByte!.typenormal
	|| cp = exp.name.codepoint|ind| 		#expect (exp, "Invalid codepoint")
	
	|| d = CodePointTable init Dictionary()
	|| str = cp.Render
	|| place = d.MakePlace(str)
	|| char_decl = place[]
	if !char_decl
		char_decl = TypeCodePoint!.typenormal.CopyDecl
		place[] = char_decl
		(char_decl is const)			//	compiler.NewConst(char_decl) // no!
		char_decl.ExportPosition = cp	// nice!
	exp.Func = @num
	exp.name = str	
	exp.obj = char_decl
	return char_decl



|| CSHex			= "AFaf09__".charset
|| CSNum			= "09..".charset


function message.UnitMatch (|string| a, |string| b, |bool|)
	opt norefcounts
	|| unit = .name
	if unit == a: return true
	if unit == b
		error (self, "Unit should be " + a)


function TypeOfUnit (ExprResolver)	
	|message--| it = exp.first!
	if exp == "l"
		exp.become(@bra)
		it.func = @num
		return typeofnum(it, name_space, exp)

	|Float64| Mul = 0.0
	|scclass--| Type = TypeInt!
	|string--| unit = exp.name
	if unit == "KB" or "K"
		Mul = (1<<10)|Float64|
	  elseif unit == "MB" or "M"
		Mul = (1<<20)|Float64|
	  elseif unit == "GB" or "G"
		Mul = (1<<30)|Float64|
	  elseif unit == "TB" or "T"
		Mul = (1|int64|<<40|int64|)|Float64| // goddamn c++ complaining
	  elseif unit == "th"
		Mul = 0
	  else
		type = typedate!
		|Float64| s4 = 64.0*1024.0
		if unit == "s"
			mul = s4
		  elseif unit == "ms"
			mul = 64.0
		  elseif unit == "π"
			mul = π
			type = typefloat64!
		  elseif unit == "τ"
			mul = τ
			type = typefloat64!
		  elseif exp.UnitMatch("days", "day")
			mul = 86400.0 * s4
		  elseif exp.UnitMatch("weeks", "week")
			mul = 604800.0 * s4
		  elseif exp.UnitMatch("years", "year")
			mul = 31536000.0 * s4
		  elseif exp.UnitMatch("mins", "min")
			mul = 60.0 * s4
		  elseif exp.UnitMatch("hours", "hour")
			mul = 3600.0 * s4
		  else
			error (exp, "Unknown unit")
	
	|| val = it.float
	if !mul
		val = (1.0 / val)
		Type = TypeFloat!
	  else
		val *= mul
	
	|| str = ""
	|| D = type.typenormal.copydecl
	|| X = val|uint64|
	|| CanFloat = type.typeinfo.isfloat
	if !CanFloat// and !(type == typeint and mul != 0.0)
		CanFloat = it.name contains '.'
	if type == typedate
		str = val|int64|.render
		
	  elseif CanFloat
		str = val.renderfloat
		|Float64| big = 16.0*1024.0*1024.0
		if val >= big  or val < -big
			D.type = typefloat64!
			X = val.asint
		  else
			D.type = TypeFloat!
			X = val|float|.asint
		// So... then what should I do?
	  else
		str = val|int64|.render
		|Float64| big = (1|int64| << 31|int64|)|Float64|
		if val >= big  or val < -big
			D.type = TypeInt64!
		if mul == 1
			X = it.int
	
	d.NumberConst = x
	if it == str
		str = it.name

	exp.become(@num, str)
	exp.clear
	return D


function scdecl.NumberConst (assigns:|uint64| v)
	.ExportPosition = v
	is NumberConst


function TypeOfNum (ExprResolver)
	opt norefcounts
	|| p = compiler.numbers.makeplace(exp.name)
	|| y = p[]
		return y|scdecl|
	rz = TypeOfNumSub(exp, name_space, side)!
	if rz isa SCDecl
		p[] = rz
	  else
		debugger // hmmm


function TypeOfNumSub (ExprResolver)
	|| n = exp.name
	if (n contains ".")
		|| d = Typefloat!.typenormal.copydecl
		|| f8 = exp.float
		|uint64| V
		if (d.DeclSize == 4) and !side
			V = f8|float|.asint
		  else
			V = f8.asint
		d.numberconst = V
		Return D

	|| Val = exp.int
	|| d2 = typeint!.typenormal.copydecl
	if (((Val << 32) >> 32) != Val)  or  side
		d2.type = typeint64!
	d2.numberconst = val
	return d2
	


function Message.CollectionPlace (|Message|)
	|| msg = self
	while (msg)
		|| p = msg.parent
		if (msg == @arg)
			// possibly good?
			if !p: Return msg
			if (p isTmp "class" or "module"): Return msg
		msg = p


function scdecl.ExtractAmount (|Message| Prms, |SCNode| name_space, |scdecl|)
	rz = .extractamountsub(prms, name_space)
	check (rz) ( prms, "Expected something like: |Type[10]|" )


function scdecl.ExtractAmountSub (|Message| Prms, |SCNode| name_space, |scdecl|)
	|| num = prms.first
	if num == @unit
		typeofunit(Num, nil, nil)
	if num.expect(@num) and num.ExpectLast
		rz = .CopyDecl
		rz.IsCArray(Num.Int, self)
		rz.Default = @arg.msg


function ExtractDecl (|Message!| c, |SCNode?| name_space, |declmode| Purpose, |int| Depth=0, |SCDecl?|)
	// a bit recursive!
	|| f = c.func
	if (f == @Thg)		// usual case
		if c == "nil" // nice
			return typevoid
		return Compiler.FindClassType( c )
	
	depth++
	if (f == @Decl)
		Return ExtractDecl( c.first!, name_space, purpose, depth )
	
	if (f == @Emb)
		c.Expectempty
		return nil
	
	if (f == @Bra)
		return extractdecl(c.first!, name_space, purpose, depth)
		
	if (f == @sthg) and (c == "...")
		return name_space.RequireContained( c )
		
	if (f == @list) and !c.hasany
		|| p = c.UpToType    // abc|()--|
			return typeofexpr(p.first, name_space)				
			
	if (c == @Acc)		// |Byte[10]| TenBytes
		|| Prms = c.second
		if prms.HasAny
			|| R = ExtractDecl( c.first!, name_space, purpose, depth )			#require
			return R.ExtractAmount( Prms, name_space )
			
		f = @rel
		c.func = f
		|| fi = c.first
		c.clear
		c <~ (@thg, "memory")
		c <~ (@opp, "of")
		c <~ fi
	
	if (f == @func)
		|| R = ExtractDecl( c.first!, name_space, purpose, depth )				#require
		return R.RefineDecl(c.last)
	
	if (f == @Arel or @brel)
		|| R = ExtractDecl( c.first!, name_space, purpose, depth )				#require
		if C == "~"
			return R.MakeDataObject(name_space, purpose)
		if (C == "&")											// pointer
			return r.GetAddress(purpose)
		if (C == "?")
			return R.MakeNewOptional
		if (C == "!")
			if R.StatedReal and c isnt inserted
				problem (c, "Already assumed real. Only '?' needs to be specified.")
			return R.MakeNewReal
		if (C == "--")
			return R.MakeBorrowed(c.uptotype != nil)
		if (C.name)												// emptyname = compiler internal
			error (c)
		return r

	if (F == @name)												// use instead of below!
		c.func = @thg
		|| d = ExtractDecl(c, name_Space, purpose, depth)						#require
		(d is compilercreated)
		return d

	if (F == @arg)												// a bit ugly... |{\n\tfaststring\n}|
		|| d = ExtractDecl(c.first!, name_Space, purpose, depth)$
		(d is compilercreated)
		return d

	if (f == @dot)
		return Compiler.FindClassType( c )
		

	rz = SCDecl(TypeVoid_!)
	|| ErrCount = stderr.errorCount

	if (f == @Arr)
		|| ch = c.first
		if !ch													// |[]|
			Return TypeArray!.TypeNormal
		
		expect (ch != @Item) (c)
		|| dcl = ExtractDecl( ch, name_space, purpose, depth )
			rz.Contains = dcl.MakeContainedOptional
			rz.Type = TypeArray!
		
	  elseif (f == @Adj)
		problem (c, "Use 'of' instead.")
		rz.LoadContained(c.first!, c.last!, name_Space, purpose)		#require
		
	  elseif (f == @rel)
		|| op = c[@opp, 1]												#require
		op.expect(@opp, "of")
		|| contained = c[@nil, 2]										#require
		rz.loadContained(contained, c.first!, name_Space, purpose)		#require
		
	  elseif (ErrCount == StdErr.errorCount)
		error ( c ) // no spam
	

	rz.MakeContainedObject(c)	
	if (ErrCount != StdErr.errorCount)
		rz = nil



function SCDecl.MakeStatic (|Message| wrap, |SCNode| Name_Space, |declmode| Purpose, |bool|)
	|| R = ExtractDecl( wrap, name_space, purpose )
		R.CopyTypeInfoTo(self)
		is static
		return true


function SCDecl.LoadContained (|Message| Contained, |Message| wrap, |SCNode| Name_Space, |declmode| Purpose, |bool|)
	if contained == @thg and "static"
		return .MakeStatic(wrap, name_space, purpose )
	|| Cont = ExtractDecl( Contained, Name_Space, purpose )
		return .LoadContainedSub(cont, wrap, Name_Space, purpose)


function SCDecl.MakeDataObject (|SCNode| Name_Space, |declmode| Purpose, |scdecl|)
	|| wrapp = «thg "dataobject"»
	rz = SCDecl(.type)
	rz.LoadContainedSub(self, wrapp, name_space, purpose)

	
function SCDecl.LoadContainedSub (|SCDecl| Cont, |Message| wrap, |SCNode| Name_Space, |declmode| Purpose, |bool|)
	|| R = ExtractDecl( wrap, name_space, purpose )			#require
	R.Copytypeinfoto(self)
	.contains = cont.MakeContainedOptional
	if TypeWrapper!.typenormal.TypeMatch(R, ktypecastfalse).IsNormalMatch
		check (!Cont.isnormalobject)  ( wrap, "Datatype-wrappers can't contain this." )
	  else
		|| RCont = R.Type.Contained							#expect ( wrap, "Not a container class." )
		if (RCont.type != typeobject) and RCont.IsNormalObject
			RCont.ExpectMatch(cont, 0, nil, wrap)
	return true


function TypeOfExprModulesOK (|Message| Exp, |SCNode| name_space, |Message| side = nil, |SCObject|)
	// this function should be removed.
	// classes now have .classtype which we can use!
	if (Exp.obj)
		return exp.obj|SCObject|
	if (exp == @thg)
		exp.Obj = name_space.LookUpVar( exp.name, exp, side )
		return exp.Obj|SCObject|
	return TypeOfExprSub(exp, name_space, side)


function TypeOfExprSub (|Message| Exp, |SCNode| name_space, |Message?| side = nil, |SCObject|)
	opt norefcounts
	if exp == @Decl
		|| d = exp.last!.obj
		if d isa SCDecl
			Return d

	if name_space
		|| f = ExprFuncs[Exp.func|int|]					#expect ( exp )
		|| obj = (f)(Exp, name_space, side)
			exp.obj = obj
		return obj|SCObject|

	if !SpdProcess.parent
		error (Exp, "Failed to get type of this.")



function TypeOfExpr (|Message?| Exp, |SCNode| name_space, |Message?| side = nil, |SCDecl|)
	opt norefcounts
	if exp
		|| obj = exp.obj|SCObject| ?? TypeOfExprSub(Exp, name_Space, side)
		if obj isa SCDecl
			return obj


function Message.File (|SCFile|)
	opt norefcounts
	nil self
	for S.up in self
		|| r = S.memoryLayer.obj
		if r isa SCFile
			Return r
		require S != @arg

function Message.FileNum (|int|)
	opt norefcounts
	return .memoryLayer.num3



function scclass.IsMArray (|message| arr, |bool|)
	// || X = MyStruct[N]
	// allocates N of MyStruct
	
	if (!arr or arr.HasOneChild)
		return .IsDataTypeOrFP or .IsStruct



function message.ExpectMatch (|SCNode| name_space, |scclass| With, |bool|)
	opt norefcounts
	|| T = TypeOfExprNeeded( self, name_space )
		return .ExpectClass(T, With)


function LowlevelArrayTransform (|Message| exp, |SCClass| Cls, |SCDecl|)
	// Vector[N] --> memory.object(N, itemsize)

	|| ty = exp.first!
	|| prms = ty.next!
	if prms == @opp
		prms <~ prms.next
		prms.name = ""

	exp.become( @dot, "object" )
	ty.name  = "memory"

	prms.Func = @prm
	prms <~ cls.calculatesize
	
	|| MemWrapper = TypeOfExpr(exp, compiler.program)	#require
	MemWrapper = MemWrapper.copydecl // cos we gonna alter it.
	(memwrapper is newlycreated)
	memwrapper.contains = cls.TypeOptional
	
	return MemWrapper


function TypeOfVecAccess (|message| index, |scdecl| ty0, |int| w, |scdecl|)
	if index == @num // ok!
		expect (index.int inrange w) (index, "Vector access is too large.")
	if ty0.type.typeinfo.isfloat
		return typefloat!.NotConst
	return typeint!.NotConst


function Message.ExpectInt (|scdecl| type, |bool|)
	|| ty = type.Type.TypeInfo
	expect ty.ByteCount <= 4 (self, "Can't use 64-bit index upon pointer (32-bit max)")
	expect ty.IsInt (self, "Expected integer")
	return true


function scdecl.TypeOfAccess (|scdecl| access, |message| ch, |int|)
	opt norefcounts
	|| W = .isnumeric
	if W > 1
		return 1
	if .IsCArray
		return 2
	if .PointerCount
		if !access
			require !.Type.IsStruct
			return 2
		if (Access matches typeint!)
			ifn (ch == @bra and ch.first == @bra)
				return 2


function TypeOfAccess (ExprResolver)
	opt norefcounts
	|| ch = exp.first!
	|| Ty0 = TypeOfExprModulesOK( ch, name_space )
	|| arr = ch.next!
	|| Index = Arr.first

	if (ty0 isa scmodule)
		|| cls = ty0.Cls
		if cls and cls.IsMArray(arr) and index!.ExpectMatch(name_Space, typeint!)
			return LowlevelArrayTransform(exp, Cls)
	  elseif (Ty0 isa SCDecl) and !index.next
		|| Access = TypeOfExpr(index, name_space)
		|| oof = ty0.TypeOfAccess(access, ch)
			if !index
				using arr
				index = arr.msg(@num, "0")
				access = TypeOfExpr(index, name_space)
			
			if access and Index.ExpectInt(Access)
				if oof == 1
					return TypeOfVecAccess(index, ty0, ty0.isnumeric)
				  else
					return ty0.Dereference(exp, name_space, true)

	arr.Func = @prm
	exp.become(@dot, "SyntaxAccess")
	exp.range = arr.range 
	
	Return TypeOfDot( exp, name_space, side )


function TypeOfFuncPointer (|Message| Exp, |SCNode| name_space, |message| side, |SCObject|)
	|| ch = exp.unbra
	if ch == @dot
		rz = TypeOfDot( ch, name_space, side )
	  elseif (ch == @thg)
		rz = name_space.LookUpVar( ch.Name, ch, side )
	  else
		error (exp)
	ch.obj = rz


function MoveFutureStaticsIn (|Message| msg)
// module {|int|a=0}, module {|int|b=0} --> module {|int|a=0, |int|b=0}, module {}

	opt norefcounts
	for ch.forward in msg$.next
		if (ch istmp "module")
			ch.last(@arg).AppendAllInto( msg.Last )



function message.TypeOfArrItem (|message|)
	// x = [("",n)] // an array of "", for n items. 
	opt norefcounts
	if self == @list
		return .first
	if (self == @rel) and (.second isthing "for")
		return .first
	return self


function TypeOfSthg (ExprResolver)
	exp.MakeComment


function TypeOfMsg (ExprResolver)
	|| type = exp.first!
	require message.GetFunc(type)
	|| name = type.first
		TypeOfExpr( name, name_space )
	for ch.forward in type.next
		TypeOfExpr( ch, name_space )

	|| msg = compiler["message"]
		rz = msg.typenormal


function SpellOutMsg (|message| type, |message| Exp, |message| namemsg, |message|)
	using (exp)
	|| Result = «dot "msg"
		type
		«prm, NameMsg »
	»
	Type.become(@thg, "Syx" + Type.name)
	
	exp.func = @bra
	exp.first = Result
	return result


function Tran_Msg (|SCFunction| fn,  |message| Exp,  |SCNode!| name_space)
	|| Type		= exp.first!
	|| NameMsg	= Type.first!
	if exp LessOrEqual 1
		|| Mini	= SpellOutMsg(type, exp, namemsg)
		TypeOfExpr( Mini, name_space )
		return

	|| itm		= type.next
	|| P		= exp.parent
	|| Place	= exp.IntoVariable(name_space)
	if place.arg
		name_space = place.arg.SCArg(name_space) 
		if name_space
			|| Result = SpellOutMsg(type, exp, namemsg)
		
			while (itm)
				|| NextItm = itm.next
				using (itm)
				|| Line = «dot "SyntaxAppend"
					«thg place.name »
					«prm, itm »
				»
				place <~ Line
				TypeOfExpr( Line, name_space )
				scfunction.Tran_all(fn, line, name_space)
				itm = nextitm
			
			TypeOfExpr( Result, name_space )


function Tran_MsgList (|scfunction| fn, |message| Exp, |SCNode| name_space)
	error (Exp, `Use «thg "name"» syntax instead!`)
	scfunction.disabledpoints++


function SameTypeSub (|message| first,  |message| second,  |SCNode| name_space,  |scdecl|)
	|| T1 = TypeOfExpr( first, name_space )
	|| T2 = TypeOfExpr( second, name_space )
	require t1 and t2
	
	if t1.isnil
		t2.TypeMatch(t1, ktypecasttrue, first)
		return t2
	if t2.isnil
		t1.TypeMatch(t2, ktypecasttrue, second)
		return t1
	|| Obj1 = t1.isnormalobject
	|| Obj2 = t2.isnormalobject 
	if Obj1 and Obj2
		0
	  elseif !Obj1 and !Obj2
		rz = t1.better_numeric(t2, first, second) // oof
	  elseif Obj1
		t2 = t2.newwrapper(t2)
	  else
		t1 = t1.newwrapper(t1)

	if !rz
		rz = t1.HighestMatch( t2, first )
		if !rz
			return t1
// make C++ happy
	if rz != t2
		rz.CreateSimpleTypeCast(second)  // can delete these two lines
	if rz != t1
		rz.CreateSimpleTypeCast(first)	 // if we ever dump c
	


function TypeOfTernary (ExprResolver)
	|| list		= exp.first
	|| params	= list.next
	expect  list.hasany and params.haschildcount(1)  (exp, "expected: (a,b)(cond)")
	
	
	|| first	= list.first!
	|| second	= first.next
		require second.expectlast
	  else
		second = exp.createnil
		first.next = second

	|| Test = params[@nil]$
	|| result = SameTypeSub(first, second, name_space)	
	if result and test.ExpandToBool( name_space )
		params <~ list.first
		list.become(@thg, "JB_Ternary")
		params.obj = compiler.TernaryFunc
		params <~ list.first
		exp.ASMType = ASMType.ktern
		return result


function ArrayInOrderCheck (|int| InOrder, |message| msg, |int|)
	if (Inorder >= 0 and msg == @num)
		if (msg.int == InOrder)
			return InOrder + 1 
	return -1


function TypeOfArr (ExprResolver)
	|int| IsDispatch = (exp ~= "dispatch")|int|
	|| InOrder = 0
	|| result = SCDecl(TypeVoid_!)
	result.nildeclared = nilstate.real
	exp.obj = result
		
	for (itm in exp)
		|| NewArrCls = TypeArray!
		
		if (itm == @Item)
			|| IdxType = TypeOfExpr( itm.first, name_space )
			if (IdxType matches TypeString!)
				NewArrCls = TypeDictionary!
			  elseif (IdxType matches TypeInt!)
				// remove this! arrays never are specified like [0:item, 1:item] // !!!
				// items should always be dictionaries unless a dispatch.
				if !IsDispatch
					InOrder = ArrayInOrderCheck(InOrder, itm.first)
					if (InOrder <= 0)
						NewArrCls = TypeDictionary!
			  elseif !(IdxType matches TypeSyntax)
				error ( exp, "Array index is wrong type." )
				itm = nil
			
			itm = itm.Last
		
		if itm
			|| Contained = TypeOfExpr( itm.TypeOfArrItem, name_space ) // find more errors
				itm = itm.Resync(exp)
				
				if (Contained.type.isobject)
					Contained = Contained.type.TypeNormal
				  elseif isdispatch
					IsDispatch++// 
				
				if (result.Contains)
					result.contains = Contained.HighestArrayContainMatch( result.contains, itm ) 
				  else
					result.Contains = Contained
				
				if (result.Type == TypeVoid_!)
					result.type = NewArrCls
				  else
					expect (result.Type == NewArrCls) ( exp, "Array indexes mismatch." )
	
	
	|| c = result.contains
		c = c.ForContained
		if IsDispatch and result.type != typedictionary! // dispatches use function pointers... 
			result.type = c.type						// so we might as well make a c-array
			result.contains = nil
			result.IsCArray(IsDispatch-1, c)
			exp.func = @arg
			tran_argarray(exp, name_space, result)
		  elseif  !c.type.isobject
			result.Contains = c.newwrapper(c)
		  else
			result.Contains = c.MakeContainedOptional

	
	if result.type == TypeVoid_
		result.Type = typearray!
	return result


function message.DeclAddNumbInt (|int64| num, |scnode| name_space)
	opt norefcounts
	|| Numb = .msg(@num, num.render)
	numb.obj = TypeOfNum(Numb, name_Space)


function TypeOfSwizzle (|message| Exp, |scdecl| Type, |SCNode| name_space, |message| side, |int| swiz, |scdecl|)
	// So... we are getting like: v.z --> v[2]	
	|| Count = swiz >> 16
	|| W = type.type.NumericCount
	expect (Count == 1 or side == nil)    (exp, "Can't swizzle that many yet.")
	expect (count <= 4)                   (exp, "Vectors max out at 4 items.")
	if w == 3 // vec3 is a secret vec4
		w = 4
	
	|| prms = exp.last!
	|| T = VecType(!type.IsInteger, count).notconst
	if (count == 1)
		swiz &= 7
		expect (swiz < W) (prms, "Vector access is too large.")
		exp.become(@acc)
		prms.func = @arr
		prms.DeclAddNumbInt(swiz, name_space)

	  else
		prms.remove

		|| oof = exp.first!
		|| tmp = oof.name
		if (oof == @thg)
			oof.remove
		  else
			|| what = oof.intovariable(name_space)
			oof = what.arg #require
			oof.parent!.obj = T
			name_space = oof.asarg
			exp.become(@bra)
			exp = oof.last.last!
			tmp = exp.name
			exp.obj = T
			
		exp.become(@list)

		for (i in count)
			|| field = (swiz >> (i*3)) & 7
			|message| item
			if field == 4
				item = «num "0" »
			  else
				expect (field < W) (exp, "Vector access is too large.")
				|| thg = «thg tmp » 
				item = «acc
					thg
					«arr
						«num field »
					»
				»
			typeofexpr(item, name_space)
			exp <~ item 
		
	return T
	
	// So... v[1, 2] --> (v[1], v[2])



function string.IsSwizzle (|int| Width, |int|)
	|| N      = .length
	|| Total  = 0
	|| i      = 0
	|| shift  = 0
	|| c      = 0
	|| dold   = 0
	require (N <= 8)
	
	|| HasLetter = false
	while (i < N)
		|| d  = self[i++].lowercase
		if (d != '_')
			HasLetter = true
			require (!c) or ((d >= 'w') == (dold >= 'w')) or (dold == '_')
			
		c = d
		dold = d
		if (c == 'r' or 'x')
			c = 0
		  elseif  c == 'g' or 'y'
			c = 1
		  elseif  c == 'b' or 'z'
			c = 2
		  elseif  c == 'a' or 'w'
			c = 3
		  elseif  c == '_'
			c = 4

		if i < n
			|int| c2 = self[i].lowercase
			if c2 == '1'
				i++
			  elseif c2 == '2'
				i++
				require (Width != 3)
				c += (Width>>1)
		require (c <= 4 and c >= 0)
		total  |= (c << (shift++ * 3))

	if HasLetter
		return total ||| (shift<<16)


function TypeOfSyx (ExprResolver)
	exp.func = @thg
	exp.name = "syx" + exp.name
	return typeofthg(exp, name_space, side)


function message.DotSpace (|SCNode| name_space, |SCObject|)
	opt norefcounts
	if self != @Thg
		// allow __modules__.abc.func
		// what about namespace.jeebox.func?
		return TypeOfExprModulesOK( self, name_space ) 
	// module.func, module.var
	rz = name_space.LookUpVar( .name, self, nil )
	.obj = rz


function TypeOfSwiz (|message| exp, |SCNode| name_space, |message| side, |scdecl| class_Space, |scdecl|)
	opt inline
	opt norefcounts
	|| W = Class_Space.type.NumericCount 
	if (W > 1) and !exp.last.hasany
		|| swz = exp.name.isSwizzle(W)
			return TypeOfSwizzle(exp, Class_Space, name_space, side, swz)   // 


function TypeOfDot (ExprResolver)
	require !(exp.Last!.obj) // it's a func that returns nothing. we already got it, don't get again.

	|| DotVar = exp.first!.DotSpace(name_space)|SCNode| #expect (exp, "This expression can’t be used here.") // DotVar is the type of the thing that the dot is on.


	|SCDecl| contains
	|| DotVarIsaDecl = (DotVar isa SCDecl) 
		|| swiz = TypeOfSwiz(exp, name_space, side, DotVar|scdecl|)
			return swiz
			
		contains = DotVar|scdecl|.Contains
		|scclass--| ty = DotVar|scdecl|.Type
		DotVar = ty
		
		contains := ty.Contained
	  else
		expect  (DotVar isa SCClass or scmodule)  ( exp, "Not a class or module." )
	
	|| o = DotVar.LookUpDot( exp.name, exp, name_Space, contains, side )		#require
	if (o isa SCModule)
		// for __modules__.String   // one day namespace.myclass ?
		|| f = exp.first
		if f == @thg
			exp.Func = @thg
			f.remove
			if f == "__classes__"
				|| cls = o.cls
					|| t = cls.classtype
						exp.name = t.name
						return t
		return o
	
	|| decl = o.BaseAsDecl
		if contains
			if (DotVar isa scclass) and !exp.IsSettablePlace
				decl = decl.ContainedReplace( Contains, true )
		if decl is task
			return decl
	  else
		decl = typevoid!
	
	|| fn = exp.last!.asfunc
		exp.obj = decl
		if exp != @func
			fn.DotFuncToNormalFunc( exp )
	
	return decl



function message.ExpFunc (|scfunction|)
	opt norefcounts
	|| it = .unbra.last
		|| fn = it.obj
		if fn isa scfunction
			return fn


function TypeOfExprNeeded ( |message| exp, |SCNode| name_space, |SCDecl| )
	opt norefcounts
	|| OldCount = stderr.errorcount
	|| result = TypeOfExpr(Exp, name_space)
	if result.Found
		return result
	if (oldcount == stderr.errorcount)
		error (exp, "This expression doesn't return anything.")
		|| it = exp.expfunc
			problem (it.source, kUsingStr)
			

function message.BecomeSetRel
	.func = @rel
	.asmtype = ASMType.kSetRel


function message.NiceIsFlagSyntax (|message| opch,  |message| RN,  |SCNode| name_space, |message| side, |scdecl|) {
	|| cls = typeofexpr(self, name_space) #require
	expect (cls.ismostlynormal) (self, "Can't use 'is' on this type.")

	|| ty = cls.type
	|| fn = ty.TheIsFunc			#expect (opch, "${ty.name} doesn‘t have 'syntax is' specified.")
	|| arg1 = fn.args[1]			#expect (fn.source, "This func needs a parameter!")
	|| LookupType = arg1.type			// OK so... we have the arg. it's a decl, with a type
	require rn.expect(@thg)
	
		// (a is b) --> (a is b) = true
		
	using (rn)

	// (a is b) = true		-->		a.syntaxis(s.b) = true
	// if a is b			-->		if a.syntaxis(s.b)
	// (a isnt b) = true	-->		a.syntaxis(s.b) = !true
	// if a isnt b			-->		if !a.syntaxis(s.b)
	
	|| exp = .parent!
	if !side
		|| bra = exp.parent
		if bra != @bra
			bra = exp
		if (bra in @arg)
			if bra == exp // a is b = c --> (a is b)=c
				bra = exp.WrapWith(@bra)

			bra.BecomeSetRel
			|| eq = bra.msg(@opp, "=")
			eq.obj = scoperator.assigns
			bra <~ (@thg, "true")
			side = bra.last
			
	
	exp.SpdFunc = @dot		// i don't like this... harder to keep in sync
	|| OpchIsnt = opch == "isnt"
		exp.name = "syntaxisnt"
	  else
		exp.name = "syntaxis"
	opch.become(@prm)
	opch.obj = nil		// needed
	rn.func = @dot

	while rn.hasany
		opch <~ rn.first
	rn  <~ (@thg, LookupType.name) 
	rn  <~ opch
	exp.msg(@prm) <~ rn
	
	// if a is b   --> if  a.is(B)
	// if a isnt b --> if !a.is(B)
	
	if OpchIsnt
		|| NOT = @brel + "!"
		exp.name = "syntaxis"
		if !side
			exp.next = not // replacewith
			not <~ exp
			exp = not
		  else
			side.next = not
			not <~ side
			side = not
			TypeOfExpr(side, name_space)
			
	return TypeOfExpr(exp, name_Space, side)
}




function CanOpCompare (|message| exp,  |scdecl| lc,  |scdecl| rc,  |scoperator| comp,  |bool| )
	opt norefcounts
	ifn exp in @arg
		|| eq = (Comp Is EqualOrNot)|bool|
		if LC.Type.CanCompare(RC, eq)
			return true


function DoOpCompare (|message| exp,  |scdecl| lc,  |scdecl| rc,  |scoperator| comp,  |SCNode| name_space, |scdecl|) {
	using (exp)
	|| dot = «dot
		exp.first
		«prm
			exp.last
			«thg comp.CaseAwareStr »
		»
	»
	exp.First = dot

	if (comp Is EqualOrNot)
		exp.Last.Remove
		dot.name = "SyntaxEquals"
		if (comp.CompOp == "!=")
			exp.become( @BRel, "!" )
			exp <~ dot
		  else
			exp.become(@bra) // don't break the AST...
	  else
		dot.name = "SyntaxCompare"
		exp.Last!.name = comp.compOp
		exp <~ (@num, comp.compparam)

	TypeOfExpr( dot, name_space )
	Return TypeBool!.TypeNormal
}


function scdecl.ConstInRangeSub (|int64| Value, |bool| WasHex, |bool|)
	|| T = .type.typeinfo
	|| S = t.ByteCount
	if S == 8
		return true
	if t.isint
		|| ign = t.issigned
		if S == 4
			if ign and !WasHex
				return (value >= int.min) and (value <= int.max)
			  else
				return (value >= -1) and (value <= 0xFFFFffff)
				
		  elseif S == 2
			if ign and !WasHex
				return value >= int16.min and value <= int16.max
			  else
				return (value >= -1) and (value <= 0xFFFF)
		  elseif S == 1
			if ign and !WasHex
				return (value >= int8.min) and (value <= int8.max)
			  else
				return (value >= -1) and (value <= 0xFF)
	return true


function scdecl.ConstInRange (|message| RN, |scdecl| rt, |bool| WasHex,  |bool|)
	opt norefcounts
	if RN == @num	
		if rn.isint 
			return .ConstInRangeSub(rn.int, washex)
	
	  elseif (rn == @thg) and (rt is NumberConst) and rt.isnormalnumber and rt.isinteger
		return .ConstInRangeSub(rt.exportposition, washex)

	// if RN == @num... check the type of self big enough
	// if RN == @thg and is a const... check the type of self big enough
	// if num == -1 then... allow into unsigned... otherwise no negative consts.
	return true


function SCDecl.AssignabilityCheck (|message?| ln, |message!| RN, |scdecl| rc, |bool| WasHex=false,  |bool|)
	opt norefcounts
	nil checker
	require self and rc
	
	if ln
		expect ((LN.IsAssignable) and (self isnt const)) (LN, "Not assignable.")

	if rc.isnil
		return true
	if  .IsCArray  or  rc.IsCArray
		expect  (.c_array == rc.c_Array) (rn, "Sizes don't match")
		if rn in @sheb
			return true						// ignore it:  x = {a,b,c}
		error (rn, "Not assignable.")

	if rc is const
		return (.ConstInRange(RN, rc, washex))		#expect (RN, "Loses numeric info [1]") 
	return true


function message.AndOrExpansionTest (|int|)
	opt norefcounts

	|| ln = .first
	if self == @bra
		return ln.AndOrExpansionTest
	require self == @rel

	|| op = ln.next
	require op != "="

	|| rn = op.next$
	|| ls = ln.AndOrExpansionTest
	|| rs = rn.AndOrExpansionTest
	|| bs = ls ||| rs
	|| orand = 1
	if (op == "or"  or  op == "and")
		return orand ||| bs
	if (ls == 2 or ls == 0) and (rs == orand) // ls should be 0? not 2?
		.BunchlessFix
		return -1

	// x InRange and y or z					// R == boolops
	// x InRange and (y==0) or z==1			// go into
	// x InRange w and y or (z+z)			
	return 2 + bs


function TypeOfRel (ExprResolver)
	|| LN = exp.first!
	|| opch = ln.Next!
	|| Comp = SCOperator.Lookup( opch )
	|| RN = opch.Next #expect	(exp, "Missing right hand side")
	if opch == "is" or "isnt"
		return LN.NiceIsFlagSyntax(opch, RN, name_space, side)
	
	side = nil
	|| P = exp.niceParent
	|| ParentFunc = P.func
	|| ShouldBeSet = (ParentFunc == @Arg or @Decl) 
	if (comp != "=")
		if (ShouldBeSet)
			error (opch, "Can't use this operator here.")
	  elseif (ShouldBeSet)
		side = rn
		exp.ASMType = ASMType.kSetRel // for the ASM
	  else
		error (opch, "Did you mean '=='?")

	
	|SCDecl| RC
	|SCDecl| LC
	
	if (side)
		RC = TypeOfExprNeeded( RN, name_space ) #require 
		LC = TypeOfExpr( LN, name_space, side )
		if (exp == @rel) and (ln == exp.last)		// oop. it just changed.
			return TypeOfRel(Exp, name_space, side) // lol.
	  else 
		LC = TypeOfExpr( LN, name_space )
		RC = TypeOfExprNeeded( RN, name_space ) #require 

	require (exp == @rel) // has exp changed?
	expect  (LC)  (LN, "Can’t find the type of this.")
	
	if (side)
		// check for dumb stuff like "func() = nil" or "abc|bool| = false"
		require LC.AssignabilityCheck(LN, RN, rc)
	
	opch.obj = comp // shouldn't this be higher even?
	
	if (comp.kind & opmode.andor) // either
		return Or_And_Expansion( LC, RC, exp, name_Space ) // expects both sides to be booleans, right?


	|| Custom = 0
	if (RC != TypeNil)
		|| IPM = IsPointerMath(LC, RC, comp, exp)
			return ipm.CheckMath(exp)
	
	Custom = UseCustomOperators(LC, RC, comp, exp) 
	if Custom == CustomOps.needed
		if (!comp.IsCompset)
			return CustomFuncOp( exp, comp, name_space, RN )
		 if (RC == TypeNil)
			0 //
		  elseif (comp is caseaware) or CanOpCompare(exp, lc, rc, comp)
			return DoOpCompare(exp, lc, rc, comp, name_space)
	  elseif (comp is Bit)
		require RC.IntsOnly(RN) and LC.IntsOnly(LN)
	
	if !side and (custom & CustomOps.TypeCastFromBool) 
		lc = typeint!.typenormal
		rc = lc	

	if Custom > CustomOps.needed
		return ((LC, RC)(Custom == CustomOps.OnlyLeftIsVector)).NotLocal	// return bigger

	if lc is IntendedAsReturn
		ln = ln.MakeAccess0
		lc = lc.internal!
		ln.obj = lc // put inside MakeAccess0?
		// rz --> rz[]
	
	if LC.ExpectRelMatch( RC, RN, side, exp ) // RN/LN have changed... and their types too!
		ln = exp.first! //
		rn = exp.last!
		rc = rn.fastdecl
		lc = ln.fastdecl
	
	
	if !side and (comp Is Compare)
		Return TypeBool!.typenormal


	if custom & customops.RecheckType
		lc = exp.obj|scdecl|!
	// we can't do 1 << (a,b,c) ?

	  else
		if custom & (CustomOps.TypeCastToBetter|||customops.TypeCastToSmaller) 
			|| pc = lc.better_numeric(rc, comp.Kind, ln, rn)
			if  pc is const  and  lc isnt const // sigh... we got rc instead of lc
				lc = pc.type.typenormal
			  else
				lc = pc

		if lc is const
			if (rc is const) and (comp is mathlike)
				lc = lc.copydecl
				(lc is const)
				(lc is UnknownConst)
			  else
				lc = lc.type.typenormal
	
	Return LC.NotLocal
	// s =  "abc"   ->   s.eq("abc", false)
	// s ~= "abc"   ->   s.eq("abc", true )


function VecType (|bool| isfloat, |int| count, |SCClass|) {
	if (isfloat)
		if (count==2): return typevec2!
		if (count==3): return typevec3!
		if (count==4): return typevec4!
		return typefloat!

	if (count==2): return typeivec2!
	if (count==3): return typeivec3!
	if (count==4): return typeivec4!
	return typeint!
}



function scclass.NotConst (|scdecl|)
// da egg didnt make it... :(
	opt norefcounts
	require self
	
	|| d = ._NotConst
		return d
	d = .typenormal
	if (d is NumberConst)
		D = D.copydecl		// erase IsConst, like collectdecls does...
		(D Isnt NumberConst)
	._NotConst = d			// a space of new eggs!!!
	return D


function datatypecode.FloatIntMerge (|int| old, |message| s, |int|)
	if (.isfloat)
		old |= 2
	  elseif (.isint)
		old |= 1
	expect (old != 3) (s, "int or float vector?")
	return old


function string.IsZero (|bool|)
	for c in self
		require  (c == '.' or '0')
	return true

function string.Isnull (|bool|)
	for c in self
		require c == '\0'
	return true


function message.IsZero (|bool|)
	return  (self == @num)  and  (.name.iszero)


function message.WrapFloatOrInt (|datatypecode| T, |int| N, |scdecl| D)
	require T isnt float and int
	|| V = VecType(T.isfloat, N)
	ifn d exact_isa v
		using (self)
		|| W = @type.msg
		|| thg = w.msg(@thg, V.name)
		thg.obj = V.typenormal
		w.obj = V.typenormal
		.wrapwith(w)


function TypeOfList (ExprResolver)
	|| FoundType = 0
	|| AllowType = 0
	|| Count = 0
	|| HasBig = false
	|| Numeric = true
	
	for (s in exp)
		|| typ = typeofexpr(s, name_space) #require
		|| N = typ.IsNumeric
		if !n
			numeric = false
		  elseif numeric
			if (N > 1)
				HasBig = true

			if (typ.mustbe(SCDecl, s))
				|| T = typ.type.typeinfo
				if s.IsZero
					AllowType = T.floatintmerge(AllowType, s)
				  else
					FoundType = T.floatintmerge(FoundType, s) 
					S.WrapFloatOrInt(T, N, typ)

			count += N
			expect (count <= 4) (exp, "Over 4 items in vector.")


	expect Numeric      (exp, "Expected numbers in this vector.")
	expect (count >= 2) (exp, "Under 2 items in vector.")

	FoundType := Allowtype
	|| IsFloat = (Foundtype == 2)
	|| cns = VecType(IsFloat, count).NotConst
	if !HasBig
		exp.obj = cns
		return cns

	using (exp)
	|| name = ("vecmix", "ivecmix")(isfloat)
	|| list = «prm »
	exp.AppendAllInto(list)
	exp <~ (@thg, name)
	exp <~ list
	exp.func = @func
	return TypeOfExpr(exp, name_space)


function ClassOfObjForC (|Message| curr, |SCClass|)
	opt norefcounts
	if curr == @Func
		|| fnc = curr.MsgFunc
			|| rt = fnc.ReturnType
				Return rt.Type
		return nil
	
	|| obj = curr.obj
	if obj isa SCDecl:		return obj.Type
	if obj isa SCClass:		return obj
	
	if obj isa SCModule
		if obj.Cls: Return TypeJBClass


function DeclOfObjForC (|Message| curr, |SCDecl|)
	opt norefcounts
	if curr == @Func
		|| fnc = curr.MsgFunc
		if fnc: Return fnc.ReturnType
	
	|| obj = curr.obj
	if obj isa SCDecl:		return obj
	if obj isa SCClass:		return obj.TypeNormal
	if obj isa SCFunction:	return obj.ReturnType
	
	if obj isa SCModule
		|| cls = obj.Cls
			return cls.ClassType


function errorreceiver.TooMany (|bool|)
	return .errorCount >= 50


function message.PrepareAST (|string| path="")
	opt NoRefCounts
	|| After = .FlatAfter
	|| msg = self 
	while msg != After
		if (msg == @tmp) and (msg == "functiontable" or "dispatch")
			SCFunction.Tran_FuncTable( msg )
		msg = msg.flatnext


function Message.FixErl 
	// just do a syntactic expand...
	|| ch = .first!
	|| opp = ch.Next!
	|| last = opp.Next
	|| name = opp.Name
	
	if (name == ":=") and (.niceparent != @arg)
		.BecomeMacro(Macros.InitExpand, [ch, .last!])
	  else
		using opp
		
		while self in @bra
			.parent!.ReplaceWith( self )
		
		|| IsBitOr = (name == ":=") 
		.Func = @rel
		opp.Name = "="

		ch = ch.copy
		if IsBitOr
			|| new_if = @tmp+"if"
			new_if <~ ch.wrapwith(@brel, "!")
			.Prev = new_if
			new_if.msg(@arg) <~ self

		  else								// a += 1 --> a = a + 1
			if last == @rel
				last = last.WrapWith(@bra)
			|| rel = @rel.msg
			opp.Next = rel
			rel <~ ch
			rel.msg(@opp, name)
			rel <~ last


function AddToStaticSection (|Message| arg, |Message| ToAdd)
	opt norefcounts
	|| Static = arg.find(@tmp, "module")
		arg = static.Last
		expect ( arg == @arg ) ( static, "Missing argument." )
	  else
		static = «tmp "module"»
		arg <~ static 
		arg = static.msg(@arg)

	arg <~ ToAdd


function Message.Resync (|Message| parent, |Message|)
	opt norefcounts
	rz = self
	While rz and (rz.parent != parent)
		rz = rz.parent


function TypeOfSyntaxCall (|Message| exp, |SCNode| name_space, |Message| side, |scdecl|)
	exp.become( @dot, "SyntaxCall" )
	return typeofexpr(exp, name_space, side)


function TypeOfFuncSub (|Message| exp, |SCNode| name_space, |Message| side, |SCObject|)
	|| fn = exp.MsgFunc
		return fn
	|| ch = exp.first
	|| params = ch.next

	|scdecl| thgdecl 
	if ch == @Thg
		thgdecl = name_space.LookUpFunc( ch.name, exp )|scdecl|
		ifn thgdecl isa scdecl
			return thgdecl
	  else
		ThgDecl = TypeOfExpr( ch, name_space )		   #require
	
	fn = ThgDecl.Type.FuncProto
	if !fn
		fn = exp.prmfunc
		if fn
			return fn
		return TypeOfSyntaxCall(exp, name_space, side)
	
	|| PList = SCParamArray.new(exp)				// these 3 lines should be 2 lines...
	require PList.PreReadTypes(name_space, params, side)
	|| fn2 = fn.ArgsMatch( nil, name_space, PList )
		if !fn2.ReturnType
			exp.Obj = typevoid // save it being looked up over and over...
	  else
		fn.ArgsMatch( nil, name_space, PList, kTypeCastDescribeErrors )
		
	return fn2


function NewDeclNum (|SCDecl?| D, |int64| N, |string| VarName="", |bool| Shifts=false, |Message!|)
	opt norefcounts
	if !D
		d = scdecl.new(typeint!)
	rz = n.MsgForConst(Shifts)
	rz.obj = d
	if  n < int.min  or  n > int.max
		d.type = typeint64!
	d.name = varname
	d.numberconst = n
	if varname								// SetVarName later?
		D.Default = rz
	
	

function SCFunction.DotFuncToNormalFunc (|Message| dot)
	// a.b( c )
	// b(a, c)
	dot.become(@Func)

	|| first = dot.First!
	|| L = dot.Last!
	L.obj = self
	L.Func = @prm
	if first.obj isa SCModule
		first.Remove
	  else
		L.First = first

	using (dot)
		dot.First = «thg .ExportName »
	if self Is Killer
		dot.LastInBlock(SCBlockage.Quit)


function SCDecl.ProcessAs (|Message!| msg, |SCDecl|)
	|| P = msg.parent!.unbra
	if (P isBrel "&")					 // :)
		return self
	|| T = .type.processas!.TypeNormal
	T.CreateSimpleTypeCast(msg)
	|| L = msg.last
		L.obj = self					 // fix bug?
	  else
		error msg 
	return T


function Message.FindDestructor (|Message|)
	opt norefcounts
	for c in self
		if c == @Func // i guess its a dot?
			|| cl = c.Last
				if cl.asfunc is Destructor
					Return c


function TypeOfArgArr (ExprResolver)
	|scdecl| result
	|| Count = 0
	for itm in exp
		if itm == @tmp
			itm.func = @thg
		|| Contained = TypeOfExpr( itm, name_space )
			check (Contained.type.isdatatypeOrFP or contained.PointerCount) (itm, "Must be a datatype.")
			if (result)
				|| oof = contained.HighestArrayContainMatch( result.type.TypeNormal, itm )
				result.type = oof.type
			  else
				result = SCDecl(contained.type)
			Count++
	
	exp.obj = result						#expect (exp, "Can't get the type of this.")
	result = result.getcarray(Count)
	Tran_ArgArray(exp, name_space, result)
	return result


function Tran_ArgArray (|Message| Exp, |SCNode| name_space, |scdecl| decl)
	visible
	// needs cleaning up. we are getting this called a few times!
	|| thg = exp.IsSetIntoVar	
	if (!thg)
		// shouldn't come here anyhow. set a breakpoint to fix this!
		check (exp in @sheb) (exp)
		return nil 

	|| rel = exp.NiceParent
	rel.expect(@rel)
	|| Place = rel.ParentPoint!
	|| d = thg.asdecl
		d.default = nil

	rel.func = @sheb			// comment
	rel.ASMType = ASMType.kIgnore
	if place == rel
		rel.next = thg
		Place = thg
	  else
		rel.replacewith(Thg)
		place.next = rel
		exp.func = @str

	using (exp)
	|ArgArrayCounter| Counter
	for itm in exp
		|| rel2 = Counter.do(thg.name, itm, name_space)
		place.Next = rel2
		place = rel2

	counter.check(exp)
	if counter.isitem
		|| c = counter.max+1
		check (c < 16K) (exp, "Too many items in C-array.")
		decl.C_Array = c


