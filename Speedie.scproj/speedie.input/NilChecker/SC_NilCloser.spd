


//
// I think this idea doesn't work.
// the refcounter still creates more vars. And yet... it happens after this
// FUUUCCKKKK. I guess I really am overworked. I can't see the obvious!
// I'd need to move the entire refcounter over to this, for it to work
// Theres no way I can continue like this as a human if I can't see the obvious.
// I used to see the obvious alll the timeeeeee....
// I had normal instincts. And super ones too. Now I got less... than normal.
// 

target argh {
function Message.MarkVarClosed (|message| Closer, |scdecl| D)
	opt norefcounts
	|| T = .asmtype
	if t is kif or kwhile
/		0 // what to do? In fact the entire issue seems useless. delete the entire code?
	|| next = .next
	require next and next.ASMType != ASMType.kreturn
		
/	|| m = Message(@xml, d.name)
	m.asmtype = ASMType.kIgnore
	
	if d.IsNormalObject
		m.asmtype = 0
		m.func = @func
		m.name = ""
		m.msg(@thg, "JB_Decr")
		|| p = m.msg(@prm)
		p.obj = Compiler.RefDecr
		p.msg(@thg, d.name).obj = d
/		d = TypeVoid
	
	m.obj = d
	if closer!=@arg
/		closer.prev = m
	  else
/		closer <~ m



extend_module ArchonPurger
	function UndeclareOne (|message| Closer, |int| from)
		opt norefcounts
		|| D = t.decls[from]!
		(d is Grabbed)
		if D is NeedsClose
			|| msg = t.closers[from]
				msg.MarkVarClosed(closer, D)
	
	function UpdateFoundPlace (|message!| argument, |int| from)
		opt norefcounts
		|| y = t
		|| FoundCloser = y.Closers[from]
			|| p = FoundCloser.parent
			if p == argument
				y.closers[from] = p.UpToArg
		
	function CloseVars (|message!| Closer, |int| VarDepth=0)
		disabled "I guess this was a bad idea"
		|| From = .value.DepthOfVars
		while From > VarDepth
			.UndeclareOne(closer, from)
			from--
		
	
	function MergeVars (|message!| argument, |Nilrecord| FinalVars, |int| OrigDepth)
		disabled "grossss"
		|| From = FinalVars.DepthOfVars
		while From > OrigDepth
			.UndeclareOne(argument, from)
			t.closers[from] = nil
			from--
	
		if 0//argdepth > 1
			while OrigDepth > 0
				.UpdateFoundPlace(argument, OrigDepth--)
		
}
