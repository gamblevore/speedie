

function Message.MarkVarClosed (|scdecl| D)
	opt norefcounts
//	target debug {
	|| next = .next
	require next and next.ASMType != ASMType.kreturn
	
	|| m = Message(@xml, d.name)
	m.asmtype = ASMType.kIgnore
	if d.IsNormalObject
		m.asmtype = 0
/		m.func = @func
		m.name = ""
/		m.msg(@thg, "JB_Decr")
		|| p = m.msg(@prm)
		p.obj = Compiler.RefDecr
		p.msg(@thg, d.name).obj = d
		d = TypeVoid
	
	m.obj = d
	.next = m
//	}



extend_module ArchonPurger
	function UndeclareOne (|int| from)
		opt norefcounts
		target debug {
		|| D = t.decls[from]!
		target debug2
			if !D
		
		(d is Grabbed)
		if D is NeedsClose
			|| msg = t.closers[from]
				msg.MarkVarClosed(D)
		}
	
	
	function UpdateFoundPlace (|int| from)
		opt norefcounts
		target debug {
		|| decl = t.decls[from]
		|| FoundCloser = t.Closers[from]
			|| p = FoundCloser.parent!
			|| FoundCloserDepth = p.indent
			if FoundCloserDepth < argdepth
				debugat
				"less" 
			  elseif FoundCloserDepth == argdepth
				debugat
				"equal"
			  else
				debugat
				"more"
			
//			if d <= 
//			if p.indent >= argdepth
			t.closers[from] = p.UpToArg
		}

		
		
	function CloseVars (|int| VarDepth=0)
		target debug {
		|| From = .value.DepthOfVars
		while From > VarDepth
			.UndeclareOne(from)
			from--
		}

		// now.. how to do this?
		// lets say we are returning... we just wanna close it, right?
		// what about up-going? no. the arg does that!
		// this should work for return
		// what about exit/continue?
		// seems the same?
		// OK... so in theory... this should all work now!
	
	
	function MergeVars (|Nilrecord| FinalVars, |int| OrigDepth)
		target debug {
		|| From = FinalVars.DepthOfVars
		while From > OrigDepth
			.UndeclareOne(from)
			t.closers[from] = nil
			from--

		while OrigDepth > 0
			.UpdateFoundPlace(OrigDepth--)
		}
