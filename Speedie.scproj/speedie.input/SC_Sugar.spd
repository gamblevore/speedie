
/*
	Jeebox internals. By Theodore H. Smith...
*/


    // wouldn't it be better as app properties? or jsut arg properties?
    // args.f, args.s, args.n? like a module? to be accessable anywhere?
    // also needs arrays to be useful... and existingfiles.

function TypeOfDotDotDot (ExprResolver)
	using (exp)
		exp.become(@bra)
		|| P = exp.parent
		|| c = exp
		while p != @prm and @arr
			expect (p and p!=@arg) (exp, "Should be in a list.")
			c = p
			p = p.parent
		
		c.next = «dot "max", «thg "int"», «emb »»
	return TypeOfExpr(exp.first, name_space)




function message.QMarkRel (|message|)
	opt norefcounts
	|| x = self
	while
		|| p = x.parent
		if (p == @rel) and x.isfirst and (p.second == "=")
			expect !(p in @decl) (self)
			return p
		x = p
		require x == @dot
		

	
function message.Tran_QMark
	|| thedot		= .first$
	|| IsNormal		= (thedot == @dot or @sdot or @func) 
	expect (isnormal) (thedot, "Question-mark not one of:  a.b?,  (a)(b)?,  a.b? = c")
	if thedot == @sdot
		scfunction.Tran_Sdt(thedot)
	|| inside = thedot.first
	if thedot == @func
		require inside.expect(@bra)
		inside = inside.first
	
	using (self)
	|| rel = .QMarkRel						// a().b? = c   -->   {|| t = a(),  if t: t.b = c}
		if rel contains "B2"
		.prev = thedot
		rel.next = self
		.become(@arg)
		inside.replaceWith(@thg.msg("_t"))
		|| decl = MakeDecl("",  "_t", inside) 
		self <~ decl
		decl.msg(@arg) <~ rel
		return

	|| tern = self
	if self in @arg					//  {if a: a.b}   OR   {|| t = a(), if t: t.b}
		.become(@arg)
		is style2
	  elseif (inside == @thg)		// (a.b, nil)(a))
		.func = @func
	  else							// ({ || t = a(), (t.b, nil)(t) })
		.func = @bra
		tern = .msg(@arg)
		(tern is style2)
		tern = tern.msg(@func)
	
	|| Cond = @thg + inside.name
	if self in @arg
		tern = .msg(@tmp, "if")
		tern <~ cond
		// add |()--| to thedot?
		// is there an easier way? Just add... like a bit somewhere to the msg?
		// maybe not?
		// what if we do something like type with a name?
		tern.msg(@arg) <~ thedot
	  else
		|| options = tern.msg(@list)
		tern.msg(@prm) <~ cond
		options <~ thedot
		options.msg(@thg, "nil")	// TypeOfTern could "just give the default"!
									// So I don't even need to enter "nil"! Just delete it!
	if (inside != @thg)
		cond.name = "_t"
		inside.replaceWith(@thg.msg("_t"))
		tern.prev = MakeDecl("",  "_t", inside)
	

function message.MainOneArg (|message| arg, |int64| i, |faststring| usage)
	opt norefcounts
	|| type = self[@thg]					#require
	|| name = type.next						#require
	|message| value
	|| mac = macros.MainArg1
	if name == @rel
		name = name[@thg]					#require
		|| opp = name.next(@opp, "=")		#require
		value = opp.next(@Nil)				#require
		mac = macros.MainArg2
	  else
		require name.Expect(@thg)
	arg.MainOneArgSub(mac, name, type, i.msg, value)
	
	usage <~ "${name.name}"
	ifn type ~= "string"
		usage <~ "(${type.name}) "


function message.MainOneArgSub (|macro| mac, |message| name, |message| type, |message| i, |message| value)
	|| args = [name, type, i]
	if value
		args <~ value
	self <~ (mac)(args)
	
	
/*
main (|file| f, |string| s, |int| n = 0)
	-->
main
    |file|   f = file.MainArg(0)
    |string| s = string.MainArg(1)
    |int|    n = (int.MainArg(2), 0)(__ArgCount > 2)
*/
	
	
function message.MainArgs (|message| arg)
	opt norefcounts
	arg <~ "|| __ArgCount = app.args.length".parse
	|| i = 0
	|| usage = faststring()
	for ch in self
		if ch.expect(@decl)
			ch.MainOneArg(arg, i++, usage)
	arg.first = ("app.usage = <(`$usage`)>").parse



