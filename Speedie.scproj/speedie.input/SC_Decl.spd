
/*
	Jeebox internals. By Theodore H. Smith...
*/

// scdecl isn't quite made the way I wanted it
// i would require a rework of everything...
// this will do for now

constants
	// order of badness?
	// don't go to 1024 << 22 ! even 512 risks negative ints.
	kNeedsAddressOfButAlsoNeedsSuperMatch  = 64 << 22
	kNeedsAddressOf     = 32 << 22
	kNeedsTypeCast		= 16 << 22
	kNeeds				= kNeedsTypeCast (|) kNeedsAddressOf (|) kNeedsAddressOfButAlsoNeedsSuperMatch 

	kUseDefaultParams   = 8 << 22
	kLossyCastedMatch	= 7 << 22
	kCastedMatch		= 6 << 22
	kVoidPtrMatch		= 5 << 22
	kSuperClassMatch	= 4 << 22
	kAddressOfMatch     = 3 << 22
	kNumericMatch		= 2 << 22
	kSimpleMatch		= 1 << 22// want to move all these up.
	kNoMatch			= 0
	
	// nevermind it... for now!
	// using 8... conflicts with kTypeCastBothWays ? despite that its used as 
	// a "amount of typecasting needed", and these are "the type-casting result".

	kStrSharedParams	= 10
	kStrOwned			= 20
	kStrShared			= 0
	
	kSaveProperty		= 1 // for when we want to save the property, but not go into the object to add it to save-list
	kSavePropertyAndGoIn= 2 // for most of them?  
	kDontSaveProperty	= 0 // sets the variable to zero on load.


	kTypeCastMost = 1
	kTypeCastNumbers = 2
	kTypeCastIgnoreContained = 4
	kTypeCastBothWays = 8
	kTypeCastTrue = kTypeCastMost (|) kTypeCastNumbers   // to replace whatever we used to do when we passed "true"
	kNoBoolTypeCast = 16
	kTypeCastAssigns = 32
	kTypeCastWantSuperDistance = 64
	kActualTypecasts = ~(kTypeCastWantSuperDistance (|) kNoBoolTypeCast)  
	kTypeCastFalse = 0



datatype SCDeclInfo (uint)
	flags
		|SCDeclInfo|
		Borrowed
		StayBorrowed
		Const
		Static
		UpgradeableContained
		NewlyCreated
		AutoCast
		TypeImprove
		UsedByCode
		API
		Hidden // unused... remove
		CompilerCreated
		Disabled
		Param // isparam
		GameFlyingMem
		Property
		Atomic
		OnModule
		SetTo // a var sets it... like: rz = obj
		
		
	function Set (|SCDeclInfo| d, |bool| b, |SCDeclInfo|)
		if b
			return self (|) d
		return self &~ d
		
	

class SCDecl (SCObject) {
	linkage
		cpp_part			Decl

	|int|				C_Array
	
	|SCFunction--|		Setter		// todo: replace the .stringdata/hider thing with this.
	|Object|			IsLookupOnly
	|string|			StringData
	|SCDecl|			Internal	// 4 special objects. Aren't they exclusive? Write some code to see if they are.
	
	//|SCDecl|			NextContains // for multiple contains
	|SCDecl|			Contains
	|Message|			Default
	|SCClass|			Type
	|SCDeclInfo|		Info
	|AsmReg|			DRegister
	|Byte|				PointerCount
	|Byte|				AllocSource
	|NilState|			NilDeclared
	|NilState|			NilUsed

	
	constructor (|scclass| type=nil)
		.type = type
		.NilDeclared = NilState.Either
		.NilUsed = NilState.Either
		//if .objectid == 39907580

		
	function Project (|scimport|)
		// scfunction and scclass should use this too!
		// iterator too... even. Then everything knows where it comes from
		opt norefcounts
		|| m = .MemoryLayer
		|| obj = m.obj
		if obj isa scimport
			return obj
		
	syntax append (|SCDeclInfo| d)
		.info |= d

	function IsBorrowed (assigns:|bool|)
		.info = .info.set(SCDeclInfo.Borrowed, Value)
	function IsConst (assigns:|bool|)
		.info = .info.set(SCDeclInfo.Const, Value)
	function IsStatic (assigns:|bool|)
		.info = .info.set(SCDeclInfo.Static, Value)
	function IsNewlyCreated (assigns:|bool|)
		.info = .info.set(SCDeclInfo.NewlyCreated, Value)
	function IsTypeImprove (assigns:|bool|)
		.info = .info.set(SCDeclInfo.TypeImprove, Value)
	function IsAPI (assigns:|bool|)
		.info = .info.set(SCDeclInfo.api, Value)


	syntax is (|SCDeclInfo| d, |bool|)
		if self
			return .info & d
	syntax isnt (|SCDeclInfo| d, |bool|)
		return !.syntaxis(d)
	syntax is (|SCDeclInfo| d, assigns:|bool|)
		.info = .info.set(d, Value)


	function isnil (|bool|)
		return self == typenil


	function RegType (|datatypecode|)
		require self
		|| T = .type.typeinfo 
		if T.isint
			return datatypecode.int64
		if t.bytesize == 4
			return datatypecode.float
		return datatypecode.double

	
	function Copy (|bool| ForNewVariable = false, |SCDecl|)
		|| dcl = SCDecl.new
		
		.CopyTypeInfoTo( dcl )
		dcl.IsConst  = self Is Const

		// why not copy the whole info?
		(dcl is api) = self is api
		(dcl is stayborrowed) = self is stayborrowed
		
		dcl.isstatic = self is static
		(dcl Is Borrowed) = !ForNewVariable and (self Is Borrowed)
		dcl.Name     = .Name
		dcl.Default  = .Default
		dcl.Strength = .Strength
		Return dcl

	
	function better_numeric (|scdecl| o, |scdecl|)
		opt norefcounts
										// int+float-->float
										// int+double-->double
		|| S =  .type.typeinfo
		|| T = o.type.typeinfo 
		if (s &~ datatypecode.sign) == (t &~ datatypecode.sign)
			return self
		|| cls = s.better_numeric_sub(t)
		if cls.typeinfo == s
			return self // in case of: || x = (date(), 0)(test)
		if cls.typeinfo == t
			return o
		return cls.typenormal


	function SCDecl.isfloat (|bool|)
		return .type.typeinfo.isfloat


	function datatypecode.better_numeric_sub (|datatypecode| t, |SCClass|)
		|| bits	= .ItemBitCount max t.ItemBitCount
		// what about a float + an int? f64 right?
		if .isfloat or t.isfloat
			// in here?
			if bits > 32
				return typef64
			if bits > 16
				return typefloat
			return typehfloat
		
		|| Signed = .issigned or t.issigned
		if bits > 32
			return (typeint64, typeuint64)(signed)
		if bits > 16
			return (typeint, typeuint)(signed)
		if bits > 8
			return (typeint16, typeuint16)(signed)
		return typebyte


	function PointeryMatch (|scdecl| O, |bool|)
		require (o.PointerCount == .PointerCount)
		require (o.C_array|bool| == .C_array|bool|)
		return true


	function PointeryMatchSub (|SCDecl| O, |int| TypeCast, |uint|)
		opt norefcounts
		|| OType = O.Type
		|| t = .type
		|| tica = t.IsRole
		if tica == otype.IsRole
			//
		  elseif tica
			while t.IsRole
				t = t.super
		  else
			while otype.IsRole
				otype = otype.super
		
		|| dist = 0
		for (CurrSuper.Upwards in OType)
			if (t == CurrSuper)
				// OK... so what about the distance?
				if (o.AllocSource or .ContainsMatch(o, TypeCast))
					if !dist
						Return kSimpleMatch
					if typecast & ktypecastwantsuperdistance
						return kSuperClassMatch (|) dist 
					return kSuperClassMatch
			dist++

	
	function CopyTypeInfoTo (|SCDecl| Dcl)
		dcl.Type		= .Type
		dcl.PointerCount= .PointerCount
		dcl.Contains	= .Contains
		|| cpyflags		= scdeclinfo.UpgradeableContained + scdeclinfo.compilercreated + scdeclinfo.autocast
		// why not copy all flags?
		// or split them into two properties?
		dcl.info &= ~cpyflags
		dcl.Info |= .info & cpyflags
		dcl.internal	= .Internal
		dcl.C_array		= .C_array
		dcl.NilDeclared = .NilDeclared
		dcl.NilUsed		= .NilUsed


	function TypeContained (assigns:|scclass|)
		.type = Value
		.contains := Value.contained
			
		
	function MakePointer (|SCDecl|)
		if .PointerCount
			return self
		return .GetAddress


// what if we do:
// x = obj()
// p = &x
// *p = nil
// now what? does the compiler know that x is now nil?
// that would be a very involved situation. pointers can escape all over
// better to assume that x is now optional... unless the pointer itself is not optional.
// of course... the declaredness can be transfered... so we can't set it to nil
	function GetAddress (|SCDecl|)
		rz = SCDecl.new
		.CopyTypeInfoTo(rz)
		rz.internal = self
		
		rz.PointerCount++
		rz.NilDeclared = NilState.either	// in case we later set it to nil.
		rz.NilUsed = NilState.real			// always exists
		check (rz.pointercount < 8) (.source, "Too much abstraction")
	
	
	function Dereference (|message| f,  |bool| IsAccess,  |scdecl|)
		opt norefcounts
		if (.C_Array)
			if IsAccess
				|| c = .Copy // should keep borrowedness...
				c.C_Array = 0
				return c				// OK... so what if we try to do *Carray. We want to get an error
		if .PointerCount > 0
			//|| actualtype = .Internal
			//	return actualtype
			//debugger 
			|| c = .Copy // should keep borrowedness...
			c.PointerCount--
			return c
		error (F, "Can't dereference this.")


	render
		.WriteDeclFull.Render(fs)
		
	function SyntaxExpect
		disabled  
		print self

	
	function AutoCompleteName (|string|)
		|| n = .realname
		|| fs = faststring()
		fs <~ n
		fs <~ (' ', (32-n.length) max 1)
		fs <~ '|'
		fs <~ .WriteType
		fs <~ '|'
		return fs
		

	function WriteDeclFull (|String| DeclName = "", |bool| minimal = false, |Message|)
		DeclName := .Name
		expect DeclName or !.default
		
		if DeclName
			return .WriteDeclSub(DeclName, minimal)
		return «decl, .WriteType(minimal) »
	

	function RenderTypeAndName (|bool|minimal,|string|)
		return .WriteDeclTypeAndName("", minimal).render
	
	
	function WriteDeclTypeAndName (|String| Name, |bool| minimal, |Message|)
		name := .Name
		return « decl,  .WriteType(minimal),  «Thg name » »
	
	
	function WriteDeclSub (|String| Name, |bool|minimal, |Message|)
		|| dcl = «decl, .WriteType(minimal) »
		|| def = .Default ?? .Type.defawlt
		if !def or .pointercount
			def = «thg "nil"»
		  else
			def = def.copy

		if (.Contains)
			def = «type ":)"
				def
				«adj // seems OK :P
					«Thg .Contains.Type.Name »
					«Thg .Type.Name »
				»
			»
		
		dcl <~ «rel
			«Thg name »
			«opp "="»
			def
		»
	
		Return dcl
	

	function IsNormalStruct (|bool|)
		return .Type.IsStruct and !.PointerCount and !.C_Array


	function IsSwappable (|bool|)
		require !.C_Array
		if .pointercount
			return true
		return !.Type.IsStruct


	function IsInteger (|bool|)
		return .IsDataType and .type.TypeInfo.isint


	function IsDataType (|bool|)
		return .Type.Isdatatype and !.PointerCount and !.C_Array

	function IsProto (|bool|)
		return .Type.FuncProto


	function IsNormalObject (|bool|)
		return (!.PointerCount) and (!.IsNil) and (.Type.IsObject) and (!.C_Array)


	function IsNormalNumber (|bool|)
		return (!.C_Array) and (!.PointerCount) and (.Type.NumericCount == 1) 
	
	
	function IsNormalBool (|bool|)
		return (!.C_Array) and (!.PointerCount) and (.Type == typebool) 


	function IsNumeric (|int|)
		opt norefcounts
		if (!.C_Array) and (!.PointerCount)
			return .Type.NumericCount


	function TypeInfo (|DataTypeCode|)
		opt norefcounts
		if (!.C_Array) and (!.PointerCount)
			return .Type.typeinfo


	function MiniMatch (|SCDecl| O, |int| TypeCast = 0, |bool|)
		Return .Match( o, TypeCast, nil )

	
	function SCObject.ShouldUnWrap (|bool|)
		if (self isa SCDecl)
			return (self isnt NewlyCreated) and (self is AutoCast)

	
	function CanWrap (|bool|)
		if (.pointercount or .type.funcproto)
			return true

		require !.IsNormalStruct
		require !.C_Array
		require .type.TypeInfo!=DataTypeCode.UnusedType
		return true


	function MakeContainedObject
		if (.contains)
			.contains = .contains.MakeAsObject(self, .source)


	function NewWrapperSub (|scdecl| CastTo, |scdecl|)
		rz.Internal = CastTo
		rz.info |= scdeclinfo.AutoCast
		rz.contains = castto
		rz.Type = typewrapper

	
	function NewWrapper (|scdecl| CastTo, |scdecl|)
		ifn castto and castto.isnormal
			return .NewWrapperSub(castto)

		|| it = .type.DataTypeWrapper
			return it
		rz = .NewWrapperSub(castto)
		.type.DataTypeWrapper = rz 
	
	
	function MakeAsObject (|SCDecl| Container, |Message| ErrPlace, |scdecl|)
		|| NormalContained = container.type.contained#require
		if (.IsNormalObject)
			check (NormalContained.isnormalobject) (errplace, "This doesn't contain objects.")
			return self

		  elseif !NormalContained.isnormalobject
			return self // yeah not very precise, but good enough for now!
		
		
		check .CanWrap (ErrPlace, "Can't store this type as an object (in this version of speedie).")
		return .NewWrapper(self)
	
	
	function SCClass.GoUpTo (|int|d, |SCClass|)
		|| s = self
		while (s and s.depth > d)
			s = s.super
		return s
	

	function HighestArrayContainMatch (|SCDecl| Other, |Message| exp, |SCDecl|)
		rz = .highestmatch(other, exp)
		rz := self
		
	function HighestMatch (|SCDecl| Other, |Message| exp, |SCDecl|)
		opt norefcounts
		require Other
		|| M = .type
		|| o = other.type

		require !(o == m)

		if (o.depth > m.depth)
			o = o.GoUpTo(m.depth)
		  elseif (o.depth < m.depth)
			m = m.GoUpTo(o.depth)

		while (o != m) and (o.super)
			o = o.super
			m = m.super
		return o.typenormal


	function Message.ExpectClass (|SCDecl| slf, |SCClass| Cls, |bool|)
		return slf.expectmatch(cls.typenormal, 0, self, self) 
	

	function ExpectMatch (|SCDecl| O, |int| TypeCast, |Message| exp, |Message| ErrNode = nil, |Message|)
		|| Matched = .Match(O, TypeCast, exp)
		if (Matched == kCastedMatch or kLossyCastedMatch)
			return exp.CastedParent

		  elseif (Matched == kNoMatch)
			ErrNode := exp
			error ( ErrNode, "Type mismatch, expected '${.RenderTypeName}' but found '${o.RenderTypeName}'." )
			.Match(O, TypeCast, exp)

		return exp


	function SCClass.MatchType (|SCDecl|Other, |message| exp, |bool|)
		return .typenormal.ExpectMatch(other, ktypecastfalse, exp, exp)


	operator isobj (|SCClass| type, |bool|)
		return self and (.type == type) and (.isnormalobject)


	function isptr (|scclass|type, |bool|)
		return self and (.type == type) and .pointercount == 1

		
	operator isa_not_stupid (|SCClass| O, |bool|)
		if o and self
			return O.TypeNormal.matchC(self)
		// same as operator isa but not backwards :(

	
	operator isa (|SCDecl| O, |bool|)
		cpp_part IsaDecl
		// should disable/deprecate this
		return .matchC(O)


	operator isa (|string| s, |bool|)
		cpp_Part IsaStr
		if self
			return .isnormal and .type.name ~= s
	

	operator isa (|SCClass| O, |bool|)
		if o and self
			return self isa O.TypeNormal
	
	
	function isuintlike (|bool|)
		|| t = .type.typeinfo
		require .isnormal and .isdatatype and t.isint
		return !t.IsSigned

	
	function MakeSignedIfPossible (|SCDecl|)
		if .type.signed
			return .type.Signed
		return self
		
	
	function MatchC (|SCDecl| O, |bool|)
		Return .Match( o, kTypeCastTrue, nil )


	function ClassActReplace (|scclass| cls, |scdecl|)
		if .matchc(cls.typenormal)
			return cls.typenormal
		return self

		
	function ContainedReplace (|scclass| DotCls, |SCDecl| contains, |bool| NeedsName,  |SCDecl|)
		opt NoRefCounts
		// handles   " ...  --> string "     (.iscontained)
		//    or     "[...] -->[string]"     (.contains.iscontained)

		if (self Is UpgradeableContained) and Contains
			if  !needsname and .SameForReplace(contains)
				return contains
			|| C = contains.copy				#require
			(C is borrowed) = self is borrowed
			C.PointerCount = .PointerCount
			//C.internal = .internal // seems bugged.
			//if self is autocast or contains is autocast
				//error (.source, "Compiler assumption fail")
			C.C_array = .C_array
			if NeedsName
				c.name = .name
				(C is UpgradeableContained) = (C.type != .type)
			Return C // unless??

		|| goddamn = .contains
			if (goddamn Is UpgradeableContained) and (goddamn != contains)
				|| result = .Copy
				result.Contains = contains
				Return result
		
		Return self
	

	function SameForReplace (|SCDecl| c, |bool|)
		require (c is borrowed) == (self is borrowed) 
		require c.PointerCount == .PointerCount 
		require c.C_array      == .C_array
		return true 


	function IsNormal (|bool|)
		debugger .Type
		return (!.PointerCount) and (!.IsNil) and !.C_Array


	function AlreadyContains (|bool|)
		opt norefcounts
		|| ty = .type.contained
			return .contains.MiniMatch(ty)
		
		
	function WriteType (|bool|minimal = false, |Message|)
		opt norefcounts
		|| simple = .WriteSimpleType
		if !.Contains or (minimal and .AlreadyContains)
			return simple
		
		return «rel
			simple
			«opp "of"»
			«thg .Contains.Type.Name »
		»
		

	function WriteSimpleType (|Message|)
		require self

		|| name = (.type.Name, "(nil!)")(.type)
		rz = «Thg name »
		for (.pointercount|int|)
			rz = «Brel "&", rz »

		if (.c_Array)
			rz = «acc 
				rz
				«arr
					«num .c_array »
				»
			»
		
		if self is borrowed
			rz = «arel "--", rz »
		if !.IsDataType and .NilDeclared is Stated
			if .NilDeclared is Optional
				rz = «arel "?", rz »
			  else
				rz = «arel "!", rz »
	
	
	function CreateSimpleTypeCast (|Message| exp, |Message|)
		|| Curr = exp
		While (curr == @bra)
			Curr.obj = self
			curr = curr.first

		rz = @type.msg(":)")
		// (s) --> (s|bool|)

		exp.ReplaceWith( rz )
		rz <~ exp
		rz <~ .WriteType
		rz.obj = self

	function RenderType (|string|)
		return .WriteType.render

	function CantBeNilInCpp (|bool|)
		require !.pointercount
		return (.C_array) or (.type.IsStruct) or (.isnumeric > 1) 


	function CreateStructNil (|message| errs, |Message|)
		using (errs)
		|| Arg = «arg »
		Arg.obj = self
		if (.C_Array)
			return Arg
		
		rz = «type ":)"
			Arg
			.WriteType
		»
		rz.obj = self
	

	function message.createnil (|message|)
		using (self)
		rz = «Thg "nil"»
		rz.Obj = TypeNil


	function CreateDefault (|message| errs, |bool|isfunc=true, |Message|)
		if (.CantBeNilInCpp) // in case we are storing objects... need to have non-corrupt data.
			if isfunc
				return .CreateStructNil(errs)
			return nil

		if (.PointerCount)
			if isfunc
				return errs.createnil
			return nil

		return .Type.defawlt.copy(errs)


	function CanUseDefault (|bool|)
		if .IsNil
			debugger
			return false

		debugger .type
		if (.Type.IsStruct and !.PointerCount)
			return (.IsNormalStruct)
		return true


	function IsReffable (|bool| SetOnly, |bool|)
		require (!.PointerCount)
		require (.Type)
		require (.Type.IsObject)
		require (!.Strength)
		require (!(SetOnly and (self Is Borrowed)))

		Return true


	function HasStruct (|bool|)
		opt norefcounts
		require (!.PointerCount)
		|| T = .type
		debug_require (T)
		return T.isstruct
	
	
	function HasStructDestructor (|SCFunction|)
		if .HasStruct
			return .type.destructorfunc


	function ReallyContains (|scdecl|)
		opt norefcounts
		|| c = .contains ?? .type.contained
		if c and c.type != self.type
			return c
	
	function ContainsMatch (|SCDecl| o, |int| TypeCast, |bool|)
		opt norefcounts
		if (TypeCast & kTypeCastIgnoreContained)
			return true // for now

		|| oc = o.reallycontains
		|| sc =  .reallycontains
		if (oc == sc) or !(sc and oc)
			Return true
		
		// OK so what cases do we have?
		// array of nil				vs array of object 
		// fixeddict of nil			vs fixeddict of string
		// we can allow "of nil" to match any... i guess?
		// the thing is... how to reject matches?
		// like array of nil being passed into param of array of message?
		
		
		if !o.contains
			return true
		Return sc.Match( oc, 0 ).IsNormalMatch


	function MakeBorrowed (|bool| StayBorrowed=false, |SCDecl|)
		if self Is Borrowed
			Return self
		
		rz = .Copy				// only used in extractdecl. Avoids modifying original.
		(rz Is Borrowed)
		if stayborrowed
			(rz is StayBorrowed)


	function MakeOptional (|SCDecl|)
		// this is declared optional...
		// the default type state is "either"... which is almost the same just undeclared
		return .MakeNil(nilstate.optional, .type.TypeOptional)
	
	
	function MakeReal (|SCDecl|)
		return .MakeNil(nilstate.real,  .type.TypeVeryExists)
	

	function MakeNil (|nilstate| type, |scdecl| Default, |scdecl|)
		opt norefcounts
		if .nildeclared == type
			Return self
		
		if (Default and self == .type.typenormal)
			return Default
		
		rz = .Copy
		rz.NilDeclared = type
		rz.nilused = Type &~ NilState.Stated


	function NilConstructor (|nilstate| type,  |scdecl|) 
		if !Type
			return self
		rz = .copy
		rz.NilDeclared = type
		rz.nilused = Type &~ NilState.Stated

		
	function RefineDecl (|message| list, |SCDecl|)
		rz = .Copy
		for p in list
			if (p isthing "tag")
				(rz is borrowed) = options.ProjectIsLibrary
			  elseif (p isthing "api")
				rz.isapi = true
			  else
				error p


	function Message.WrapExpr (|scdecl| src, |int|)
		if !self
			Return kNeedsTypeCast

		|| W = «dot "new"
			«thg "datatypewrapper"»
			«emb »
		»
		if src.isfloat
			w.name = "newfloat" // sigh
		.ReplaceWith(W)
		W.last <~ self
		TypeOfExpr(W, compiler.program)
		|| D = .AsDecl
			w.obj = D.NewWrapper(D)
		  else
			debugger
		
		return kCastedmatch
	
	
	function UnWrapDataType (|message| exp, |scbase| name_space, |scdecl|)
		rz = .Internal #expect
		|| ExpReplacement = exp.func.msg(exp.name)
		ExpReplacement.obj = exp.obj
		for s in exp
			ExpReplacement <~ s 
		
		exp.func = @type
		exp <~ «dot "Value"
			ExpReplacement
			«prm »
		»
		exp <~ «thg rz.type.name »
	
	
	function Message.CastToBool (|SCBase|name_space=nil, |int|)
		return .castToType("bool", TypeBool, name_space, kLossycastedmatch)

	function Message.CastToInt (|SCBase|name_space=nil, |int|)
		return .CastToType("int", TypeInt, name_space)

	function Message.CastToVoidPtr (|SCBase|name_space=nil, |int|)
		return .CastToType("_voidptr", compiler.._voidptr, name_space)

	function Message.CastTo (|string|type, |SCBase|name_space=nil, |int|)
		return .CastToType(type, compiler[type], name_space)

	function Message.CastToClass (|scclass|type, |SCBase|name_space=nil, |int|)
		return .CastToType(type.name, type, name_space)


	function Message.CastToType (|string| TypeName, |SCClass| type, |SCBase| name_space, |int| loss = kCastedMatch, |int|)
		if (!self)
			// its not "loss" here? or else we get kcastedmatch on things that
			// aren't casted.
			Return kNeedsTypeCast (|) loss


		if (name_Space)
			TypeOfExpr(self, name_space)
		  elseif (.obj)
			|| FoundType = TypeOfExprMaybeNil(self, name_Space)
			if FoundType and FoundType.type.isstruct
				expect FoundType.PointerCount (self, "Can't typecast a struct!")


		|| cst = «type ":)" »
		.ReplaceWith( cst )
		cst <~ self
		cst <~ «thg typeName »
		
		cst.obj = Type.TypeNormal	 // hmmm.... why not do it anyhow?
		Return loss	

	
	function Message.GetAddressOf (|SCDecl| Type, |bool| WasCArray = false, |int|)
		if !self
			Return kNeedsAddressOf
		
		|| Addr = «brel "&"»
		.ReplaceWith( Addr )

		|| inside = self
		if WasCArray
			inside = «acc 
				self
				«arr 
					«num "0"»
				»
			»
		
		Addr <~ inside
		Addr.obj = Type
		Return kAddressOfMatch
	
	
	function Message.GetAddressOf2
		|| sigh = .func + .name
		sigh.takeallfrom(self)
		.name = "&"
		.func = @brel
		self <~ sigh

//JB_Str_ContainsString
	function ExpectMatchRel (|SCDecl| O,  |Message| exp,  |Message| side,  |Message| ErrNode = nil)
		opt norefcounts
		// Just like ExpectMatch, except also does strength transformations...
		// and always does type-casting. and returns nothing.
		
		|| Cast = kTypeCastTrue
		if !side
			Cast |= kTypeCastBothWays
		
		.ExpectMatch( O, Cast, exp, ErrNode )
		require (exp and (.Strength > o.Strength) and exp.IsSetIntoPlace)
		|| fn = exp.MsgOwningFunc
		if .Type.SelfStrong != self
			fn.RefSmooth( self )
			return
		
		if fn isa kisconstructor or kIsDestructor
			expect false (exp, "You can’t modify 'self' in a constructor or destructor.")

		if .IsNormalObject
			fn.RefSmooth( fn.DeclSelfExtract(self) )
	
	
	function SCFunction.DeclSelfExtract (|scdecl| decl, |scdecl|)
		opt norefcounts
		
		rz = decl.copy
		if .args[0] == decl
			.args[0] = rz

		|| arg = .SourceArg.obj
		if arg isa scarg
			arg.access["self"] = decl
		
		for s.flat in .source
			|| obj = s.obj
			if obj == decl
				s.obj = rz
					

	function WriteNilRel (|Message|)
		return NewRel( .Name, "=", "nil" )

	
	function WriteNilDecl (|Message|)
		opt norefcounts
		|| dcl = «decl
			.WriteType
			.WriteNilRel
		»
		dcl.obj = self
		dcl.Last.obj = self
		dcl.Last.First.Obj = self
		Return dcl


	function WriteTypeCast (|Message| msg, |Message|)
		|| TheType = «type ":)"
			msg
			.WriteType
		»

		TheType.Obj = self // Does InitRootDecl actually want this?
		return TheType


	render RenderTypeName 
		if !self or !.type
			fs <~ "(nil!)"
		  else 
			if (.IsNil) 
				fs <~ "nil"
			  else 
				fs <~ ( '&', .PointerCount )
				fs <~ .Type.Name
			
			if (.c_array) 
				fs <~ '['
				fs <~ .c_Array|int|
				fs <~ ']'
			
			if .contains and !.contains.minimatch(.type.contained, 0) 
				fs <~ " of "
				fs <~ .contains.type.name

}


function IsPointerMath (|SCDecl|L, |SCDecl|R, |SCOperator| opp, |Message|exp, |SCDecl|)
	require (opp.name == "+" or "-")
	if (L.PointerCount) and (R.IsNumeric == 1)
		return L
	if (R.PointerCount) and (L.IsNumeric == 1)
		return R
	if (R.PointerCount) and (L.PointerCount) and (opp.name == "-")
		L.ExpectMatch(R, 0, exp)
		return TypeInt.TypeNormal


function Message.RenderType (|string|)
	debug_require self
	|| D = .obj
	if (D isa SCDecl)
		return D.WriteSimpleType.Render
	if (D isa scmodule)
		return d.name
	return .Render


function scdecl.TypeIsReached (|bool|)
	return (.type.CurrReacher)


function scdecl.ByteSize (|int|)
	opt norefcounts
	if .PointerCount
		return platform.PointerBytes
	|| n = .type.CalculateSize
	if .C_Array
		n *= .C_Array
	return N



