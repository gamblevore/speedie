
/*
	Jeebox internals. By Theodore H. Smith...
*/


class SCFile (file)
	|string|		ExportName
	|SCImport|		Proj
	|string|		FData
	|Message|		LiveAST
	|Message|		OrigAST
	|date|			OrigDate
	|uint16|		filenum
	|bool|			IsInternal


	constructor (|File| f)
		super.constructor((f.path, "")(f != nil))
		flow off
		.isinternal = f == nil
		.liveast = .start_ast
		Compiler.stTotalFileCount += .isinternal
		(SCImport.Recent max= f.modified) 
		
	function start_ast (|message|)
		if .IsInternal
			return message.newwithlayer((Message).createLayer(self), @arg, "")

	function Use
		require .LiveAst // if parse fails...
		.LiveAST.memoryLayer.Use


	function Decls (|SCBase| p)
		.Use
		.Proj.use // should be inside use?
		CollectDecls( .LiveAST, p, p, 1 )
		// not sure why CollectDecls(1) is being called in 3 places?
		// 2 should be enough. one for modules and one for files...


	function scmodule.InitDecls // same as scfile.decls just different
		|| a = .initvarsarg[0]
		if a.hasany
			.Project.use
			CollectDecls( a, self, self, 1 )


	function GetMsg (|int| pos, |bool| needname, |message|)
		opt norefcounts
		for f.flat in .orig
			if !needname or f.name
				if f.range contains pos
					return f


	function SavedData (|string|)
		if .origdate < .modified
			.fData = .ReadAll.decompress // why not.
		return .fdata

			
	function Orig (|message|)
		if !.OrigAST or .OrigDate < .Modified
			.OrigDate = .Modified
			.OrigAST = .ASTSub
		return .OrigAST


	function AST (|Message|)
		opt norefcounts
		return .liveast init .ASTSub$


	function DetectInsecureWords
		opt norefcounts
		require options.perry
		|| words = compiler.InsecureWords$
		|| where = (0,0)
		|| found = words.Find(.fdata, where)
			|| place = @thg + ""
			place.range = where
			stderr.newerror(place, "Insecure word found", .path)
		
		
	function ASTSub (|Message|)
		if .IsInternal
		FlowControl.input(.file, "AST")
			
		(Message).createLayer(self).use
		|| str = .ReadSafely.decompress
			.fData = str
			.origdate = .modified
			StdErr.source = .path
			parser.DotInsertallow = true	// more consistant with IDE
			
			parser.UsingTag = .filenum
			rz = .fData.ParseClean			// OK so now what?
			.DetectInsecureWords
			
			parser.usingtag = 0
			parser.DotInsertallow = false
			StdErr.source = nil
		(Message).restore
		

function message.DetectBadPosition
	opt norefcounts
	for msg.flat in self
		if (msg != self) and !msg.position
			printline msg.filelocation
			debugat


function app.CodeSign (|file|)
	|| sign = app.prefs[codesign_native] // code
		|| me = app.apppath.file
		me.codesign(sign.value)
		return me

	StdErr.newproblem( nil, "No code-signature found. (`speedie --codesign=\"details\" to save signature). Unable to sign self." )


function file.CodeSign (|string| sign, |errorint|)
	target osx
		if !platform.osx
			return -1
		using ErrorSeverity.Warning
		|[string]| args = []
		args <~ "--deep"
		args <~ "--force"
		if options.PrintCompileString
			args <~ "--verbose"
		args <~ "-s"
		args <~ sign.cstr
		args <~ self.cstr

		rz = "/usr/bin/codesign".DebugExecute(args) // creates unnecesssary errors

		args = []
		args <~ "--verify"
		if options.PrintCompileString
			args <~ "--verbose"
		args <~ self
		if rz
			rz = "/usr/bin/codesign".DebugExecute(args)
		if rz
			args[0] = "-a"
			rz = "/usr/sbin/spctl".DebugExecute(args)


function string.DebugExecute (|[string]| Args=nil, |faststring|Out=nil, |faststring| Errs=nil, |ErrorInt|)
	if file.DebugExecute // shouldnt be default!
		print self
		print " "
		printline args.Render
	return .Execute(args, out, errs, false)
	

function compiler.LoadPNG (|&byte| data, |int| len, |&int| x, |&int| y, |&int| comp, |int| req_comp, |&byte|)
	cpp_wrapper JB_Img__LoadPNG


function compiler.WriteQOI (|&byte| data, |int| w, |int| h, |&int| len, |&byte|)
	cpp_wrapper JB_Img__WriteQOI


function compiler.ConvertPNGToQBOI (|string| p, |string|)
	rz = string.error
	|| x	= 0
	|| y	= 0
	|| comp	= 0
	|| img = .loadpng( p.addr, p.length, &x, &y, &comp, 4 )
		|| n = 0
		|| qoi = .writeqoi(img, x, y, n)
			rz = string.Own(qoi, n).compress(mzlab.Fast)
	memory.free(img)

