

/*
	* refcounter passing properties as function param, SHOULD NOT assume it won't be cleared... not without disturbance checker
	* can fold the refcount optimiser into the nilchecker... mostly in .function and .variableset
	* can just store each class disturbance as one bit? just use 128 bits per... function?
		* if list is disturbed, everything is disturbed... because list could be a message, and message could have an obj... which could be anything.
	* look into how things like "Disowner checking" would work within the nil-checker.

* Approach: Do bit by bit
	* get property but only did math
	* mark a few string funcs as not-modifier/disowner/capturer
	* mark entire class
	* fast capture of disowned things. like: r1 <~ r2.pop
*/	


// unfinished
class CppRefs
	|uint16|			DisturbParams
	|bool|				Owned
	|[string]?|			Disturbs		// cant be a class cos this is called BEFORE the classes are inited.
										// awkward.
	
	constructor (|message| s=nil)
		if s
			.read(s)


	function SetDefaultRefStatus
		.Owned			= false
		.Disturbs		= array.new
		.disturbparams	= -1
		.disturbsget	<~ "object"


	function DisturbsGet (|[string]|)
		|| ds = .disturbs
			return ds
		rz = array()
		.Disturbs = ds
		
	function AddOne (|message| C)
		opt norefcounts
		if (C ~= "nil") // typeofnil
			// 
		  elseif (C ~= "self") // dcl is self
			.DisturbParams |= 1
		  elseif (C == @num)
			.DisturbParams |= (C.int << 1)
		  else
			.Disturbsget <~ C.name
	

	function Read (|message| node)
/*
	cpp_refs {
		Disowns			true
		Disturbs		nil
		ParamSafe		true
	}
*/
		.SetDefaultRefStatus
		|| arg = node[@arg] #require
		arg.expectlast
		
		for c in arg
			c.expect(@tmp)
			expect (c=="disturbs" or c=="disowns") (c, "Should be 'disturbs' or 'disowns'")
			|| ch = c.first
			if (ch == @bra): ch.func = @prm
			expect (ch == @thg or @prm or @num) (ch)
			ch.expectlast

		require stderr.ok

		
		|| Disown = arg.find(@tmp, "returnsdisowned")[0]
			.Owned = !disown.TrueOrFalse

		|| Stuff = arg.find(@tmp, "disturbs")[0]
			.Disturbs.clear
			.DisturbParams = 0
			if (Stuff != @list)
				.addone(stuff)
			  else
				for c in Stuff
					.addone(C)
	
	module
		function Linkage (collectfunc)
			return name_space.ProcessLinkage(node[@arg], ClassLinkageTable)		
		function ReadIntoCppRefs (CollectFunc)
			name_space.SpaceModule$.DefaultRefs.Read(node)
			return compiler.program



dispatch CppRefTable (TranFunc)
	disowns				{} //(SCFunction.NewCppWrapper)
	disturbs			{} //(SCNode.LoadCppPart)
	paramsafe			scfunction.tran_cpprefs



extend_module SCFunction	
	function Tran_CppRefs (TranFunc)
		expect (fn) (node, "Only use this on functions")
		fn.refs = cpprefs.new(node)
		node.remove


dispatch FuncLinkageTable (TranFunc)
	cpp_wrapper			{}
	cpp_part			{
		SCNode.LoadCppPart(node, name_space, node)
	}
	cpp_refs			scfunction.tran_cpprefs
	visible				{} // (SCFunction.Tran_Visible)
	ignore				{}
	inline				{}


dispatch ClassLinkageTable (TranFunc)
	// these items with {} are processed elsewhere...
	// it would have been better to process them all here. but I wrote this after
	// So the older code still needs removing and using this instead.
	cpp_wrapper			{}
	cpp_part			{SCNode.LoadCppPart(node, name_space, node)}
	cpp_refs			scfunction.tran_cpprefs
	cpp_class			{}
	visible				{} // (SCFunction.Tran_Visible)
	ignore				{}
	noearlyfree			{}
//	dontdestructlocally {}
	wrapper				{} //if name_space.mustbe(scclass) : name_space.IsWrapper = true}
	datatype
		if name_space.mustbe(SCClass, node)
			expect (name_space.isstruct) (node, "Expected this for a struct")
			|| value = node[@thg]
				value.expectlast

	numeric
		if name_space.mustbe(SCClass, node)
			expect (name_space.isdatatypeOnly) (node, "Expected this for a datatype")
			if node[@thg] == "false"
				name_space.typeinfo = datatypecode.unusedtype
				name_space.IsNotNumeric = true


function SCNode.ProcessLinkage (|message| node, |dictionary of tranfunc| Table, |SCNode|)
	opt norefcounts
	|| fn = .owningfunc
	for ch in node
		require ch.expect(@tmp)
		|| linker = Table[ch.name] #expect (ch)
		(*linker)(fn, ch, self)

	return compiler.program

