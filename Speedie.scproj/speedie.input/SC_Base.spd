
/*
	Jeebox internals. By Theodore H. Smith...
*/



prototype CollectFunc (|Message| node, |SCNode| name_space, |Message?| ErrPlace, |SCNode?|)


class SCNode (SCNamed) {
linkage
	cpp_part		Base

|Dictionary? of SCObject|			Access
|SCNode--?|							Parent
|SCNode--?|							MyReacher
|SCImport--?|						Project


function IsSTDLib (|bool|) // .islib, .isprojlib, .isproject, .isntproject, .isntlib
	opt norefcounts
	return .Project.IsSTDLib?


function Collect (|Message| AST, |bool| Visible, |message| dest=nil)
	.Source := AST // not good! Considering that one "project" module covers multiple files!
	|| r = ast.listall
	for c in r
		.CollectOne( C, Visible )

	require dest // sigh
	for c in r
		if c.parent == ast
			dest <~ c
	  


function FuncSrc (|Message|)
	return .Owningfunc$.Source


function CollectSub (|Message| c, |SCNode|)
	|| T = ClsCollectTable
	if self == compiler.program  or  self isa scmodule
		T = RootCollectTable
	
	if c != @tmp
		if self isa scclass
			c.expect(@decl)
		return nil
	
	|| FnObj = T[c.name]									#expect c
	|| base = (*FnObj)( c, self, c )						#require
	if (base != Compiler.program) // OK
		.TryAdd( c, base, base.Name )
	
	Return base


syntax access (|string| s, |SCObject|)
	opt norefcounts
	|| a = .Access
		return a.ValueLower(s)



function FindModuleMsg (|Message| where, |SCNodeFindMode| Mode=0, |SCModule?|)
	//debugat 3402
	opt norefcounts
	real self
	
	|| fn = where.func
	if fn == @dot
		|| f = where.first!
		f.next.expect(@emb)
		self = .FindModuleMsg(f, Mode) #require
	  else
		expect (fn == @thg or @name) (where)
	return .findmodule(where.name, where, Mode)


function scnode.FindClassMsg (|Message| where, |SCNodeFindMode| Mode=scnodefindmode.WantAType,  |SCClass|)
	opt norefcounts
	|| mod = .FindModuleMsg(where, Mode)
		|| C = mod.cls
			return C
		if mode isnt noerrors
			error (where, "Expected a class but found module.")


function FindClass (|String| name, |Message| where=nil, |SCNodeFindMode| Mode=0,  |SCClass|)
	opt norefcounts
	|| Mod = .FindModule(name, where, Mode)
		if mod.cls
			return mod.cls
		if Mode isnt noerrors
			error (where, "Expected a class but found module.")


function FindModuleParent (|SCNodeFindMode| Mode, |SCnode|)
	opt norefcounts
	if mode is wantatype // allow going up superclasses instead.
		|| cls = self|scmodule|.cls
			|| p = cls.parent|scclass|
				return p.modul
	return .parent


function FindModule (|String| name, |Message| where, |SCNodeFindMode| Mode=0, |SCModule|)
	opt norefcounts

	|| Upon = self
	while upon
		if name ~= upon.name
			if upon isa scmodule
				return upon

		|| Obj = upon[ name ]
		if Obj isa SCModule
			return Obj
		if mode is dontgoup
			exit
		upon = upon.FindModuleParent(mode)
		
	if where and (Mode isnt noerrors)
		error (where, "Can’t find module: " + name)


function UpCheck (|string| name, |bool| LookUp=true, |SCObject|) {
	opt norefcounts
	if LookUp and (self isa SCClass)
		for (c.upwards in self)
			|| it = c[name] 
				return it
		
	ifn (self isa scarg)
		return self[name]
	
	|| curr = self					// avoid bugs like || a = 1, {|| a = 1}
	while (curr isa SCArg)			// So... check upwards...
		|| found = curr[name] 
			return found
		require lookup
		curr = curr.parent|scarg|
}



// OK so.. i guess functions can hide stuff below it, right?
// so upcheck shouldn't work, if we are on a function, right?

function TryAdd (|Message?| ErrPlace, |SCObject?| IncObj, |String| name)
	real self
	require IncObj
	expect (name.length inrange 64) ( ErrPlace, "Name should be 1-64 bytes long." )
	if (self isa scclass)
		|| scls = incobj.class
		if (scls == scclass or scmodule)
			self = self.modul|scclass|
	.access := Dictionary.new
	.tryaddsub(errplace, incobj, name.Lowercase)

	
function TryAddSub (|Message| ErrPlace, |SCObject| IncObj, |String| name)
	opt norefcounts
	|| Old = .Upcheck( name, !(IncObj isa SCFunction) )
	if (!Old)
		.access![ name ] = IncObj
		return
	
	require (Old != IncObj) // possible?
	
	if (Old isa SCFunction)
		if (IncObj isa SCFunction)		// link
			if (old.cls == IncObj.cls) or incobj.IsConstructorOnModule(old)
				old.Last.NextFunc = IncObj
				Return
		  elseif incobj isa scdecl
			if old.HidesProperties
				expect (!IncObj.hiderfunc) (errplace, "Multiple property-hiders found.")
				incobj.hiderfunc = old
				.access![ name ] = IncObj
				return

	if name == "self"
		error ( ErrPlace, "Can't use 'self' here." )
	  else
		error ( ErrPlace, kNameConf )
		if old isa SCObject
			error (old.AnySource, kNameConf)
		  else
			error (old.render, kNameConf)


function scfunction.IsConstructorOnModule (|scfunction| old, |bool|)
	opt norefcounts
	if self is constructor
		|| p = old.parent
		return p == .cls!.modul

constructor
	cpp_part Constructor0
	.Project = scimport.curr
	.IsVisible = CurrVisibility	// don't do anything?


constructor (|string| Name, |bool| Dummy)
	cpp_part ConstructorStr
	.name = name


constructor (|Message?| node)
	cpp_part ConstructorMsg
	.source = node
	.IsVisible = CurrVisibility
	.Project = scimport.curr // why not?


function Use
	|| s = .source
		s.memoryLayer.Use
	.Project.use



function SubProjName (|string|)
	return Compiler.Program.ExportName


function SCFunction.NameOfClassAllocator (|string| s, |string| CppPart, |string|)
	rz = Cpppart
	if rz
		rz = "_" + rz
	  else
		rz = "_New"
	
	if s contains "Constructor"
		rz = s.ReplaceAll( "Constructor", rz, true )
	  else
		rz = s + Rz


function SCFunction.UseExportNameConstructor (|string| CppPart, |string| CppWrapper, |bool|)
	// REMOVE THIS
	// return true
	require !CppWrapper and (self is constructor)  
	|| fn = .CounterPart
	if fn isa scfunction
		if !fn.ExportName
			fn.LoadExportName

		|| s = .NameOfClassAllocator(fn.ExportName, CppPart)
		.SetExportName( s, fn|SCNode| is ExplicitExport )
		Return true


function SCFunction.UseExportWrapper (|string| CppWrapper, |bool|)
	require CppWrapper
	.IsWrapper = 1
	.SetExportName( CppWrapper, true )
	return true



function SCFunction.UseCppName (|string| CppName, |bool|)
	require CppName
	.SetExportName( CppName, true )
	return true



function LinkagePlace (|message|)
	|| Place = .SourceArg
	|| Link = Place.find(@tmp, "linkage")
	return Link[@arg] ?? Place


function message.Cpp_Wrapper (|string|)
	opt norefcounts
	if self
		if self == @bra
			return .firstname
		return .name


function SCFunction.ExportNameBuilder (|string|CppPart="", |string| )
	if !CppPart
		CppPart = .Name
		if .IsAssigns and !(cpppart endswith "Hider")
			CppPart += "Set"

	|| SubSection = ""
	|| AfterSub = ""
	|| c = .cls
		SubSection = c.Modul.CppPath
		AfterSub = "_"
		if (self is constructor) and !(CppPart contains "Constructor")
			cppPart = "Constructor" + CppPart
	  else
		|| L = .parent
		if (L isa SCModule)
			if L.CppPart
				SubSection = L.CppPath
				AfterSub = "__"

	|| P = .project // never nil but whatever
		|| wanted = p.mod.exportname
		if wanted != subsection
			rz = (wanted + "_")
	rz += (Subsection + AfterSub + CppPart)


function scmodule.CppPath (|string|)
	|| f = .cpppart
	while
		|| p = .parent
		if (p isa scmodule)
			if !p.isimport
				self = p
				f = p.cpppart + "_" + f
				continue
		exit
	return f
	
	// So... whats the path
	

function FindCppWrapper (|message| place, |bool|isclass, |message|)
	if self isa SCFunction
		|| pl = .FindCppWrapperFunc(place)
			return place.FindAndRemove2(pl, true, false)
	return place.FindAndRemoveSub( "cpp_wrapper", true, IsClass )


function Message.FindAndRemove2 (|message| place,  |bool| NothingOK,  |bool| IsClass,  |Message|)
//	opt norefcounts
	place.remove
	|| ch = place.first
	if NothingOK and !ch
		place.name = ""
		return place
	if ch == @thg or @bra
		if isclass
			expect (.parent istmp "linkage")   (ch, "Put this inside a 'Linkage' tag.")
		Return ch
	place[@thg]


function Message.FindAndRemoveSub (|String| name,  |bool| NothingOK,  |bool| IsClass,  |Message|)
	|| place = .find( @Tmp, name )
		return .FindAndRemove2(place, NothingOK, isclass)
	

function scfunction.FindCppWrapperFunc (|message| place, |message|)
	opt NoRefCounts
	for cpp in place
		if (cpp.name starts "cpp_") and .FoundOneCpp(cpp.name)
			return cpp


function scfunction.FoundOneCpp (|string| n, |bool|)
	if n == "cpp_nothing"
		.noautocomplete = 1
		.IsCppInBuilt = 2
		return true
	if n == "cpp_inbuilt"
		.noautocomplete = 1
		.IsCppInBuilt = 1
		return true
	if n == "cpp_libwrapper"
		.noautocomplete = 1
		.IsExternalLib = true
		return true


function LoadExportName 
	// Project_Class_Func
	// Project_Module__Func	
	require !.ExportName
	
	|| place	= .LinkagePlace
	|| IsClass	= (self isa SCClass)
	// probably should use a dispatch table
	// we want to check so many things, wrapper, name, part, inbuilt, library...
	|| CW		= .FindCppWrapper(place, isclass)
	|| CppName	= place.FindAndRemove( "cpp_name",	false,  IsClass )
	|| CppPart	= place.FindAndRemove( "cpp_part",	false,  IsClass )


	if self isa SCFunction
		.IsCppInBuilt := (cw == @bra)|int|
		|| CppWrapper = cw.cpp_Wrapper
			.MakeParamsReal
		require !.UseExportNameConstructor(CppPart, CppWrapper) and !.UseExportWrapper(CppWrapper) and !.UseCppName(CppName) and !.isdisabled

///  ///  ///  ///  ///	 ///  ///  ///	 ///  ///  ///	 ///  ///  ///
		cppname = .exportnamebuilder(cpppart)
		.IsWrapper = cw
	  else
		CppPart := .Name
		CppName := CppPart

		if self isa SCModule
			.CppPart = CppPart

		  elseif self isa scclass
			.Modul.CppPart = CppPart
			|| e = place.FindAndRemove( "cpp_class", false, true )
				.CppClass = e.unicodesafename
			.Modul.SetExportName( CppPart + "_", false ) // remove this? just try... once everything is working.

	.SetExportName( CppName, false )



function TryAddBase (|Message| c, |SCNode| neu) 
	.TryAdd( c, neu, neu.Name )


function LookUpFunc (|String| name, |Message| exp, |Message| ParamsHere, |scfunction|)
	return .LookUpSub( name, exp, ParamsHere, self, nil, nil, kPurposeFunc )|scfunction|



//function MyProj (|SCNode|)
//	return Compiler.Program!.ProjectFix


function ProjectFix (|SCNode|)
	opt norefcounts
	if (self == compiler.program)
		|| c = scimport.curr
			return c.Mod
	return self


function LookUpSub (|String| OrigName, |Message?| Exp, |Message?| ParamsHere, |SCNode| Arg_Space, |SCDecl?| contains, |Message?| side, |int| Purpose, |SCObject|)
// nil "exp" means "Not considered an error if not found", because we need exp to report errors!
// could be cleaned up so that exp is NEVER nil... "AddMain", "InitRootDecl", lookupvar etc would need altering...
	
	|| ParamsArray	= SCParamArray.new(exp)
	|| Curr			= ParamsArray.DetectDotSuper(self, arg_space)
	ParamsArray.PreReadTypes(Arg_Space, ParamsHere, side)
	|| CanFunction	= (ParamsHere) and  (!ParamsArray.IsAddress)
	|| ConstructorAsNew = (purpose == kPurposeDot) and (origname ~= "new") and (self isa scmodule)
	|SCFunction| Missing
	|SCFunction| f
	|scclass| owning_cls
	if scfunction.currfunc
		owning_cls = scfunction.currfunc!.cls
	
	for (b.ListLookup in Curr)
		|| o = b[ origname ]
		if (!o)
			continue
		if (ParamsArray.IsDot)  and  (ParamsArray.IsModule)  and  (b == compiler.program)
			exit								// Stop SCFunction.Byte looking up Main.Byte...
		
		if o isa SCDecl
			if o.Hiderfunc.Hidermatch(paramsarray.isassigns) and (owning_cls != curr)
				o = o.hiderfunc|scdecl|
			  else
				if o.Type.FuncProto
					expect ((ParamsArray.IsDot or !ParamsHere) and (!ParamsArray))  ( exp, "Wrap this in a bracket, before calling it as a function." )
					Return o

				if (!side and paramsarray.isdot and o.type.processas)
					debug_require exp
					return o.ProcessAs(exp)

		
		paramsarray.ConstructorAsNew = ConstructorAsNew
		if (paramshere and paramshere.func == @prm) and (o isa scmodule)
			o = o.GetTheNewer|scmodule|
			paramsarray.ConstructorAsNew = true
		
		
		if CanFunction and (o isa SCFunction)
			f = o								// store for later return? not needed?
			o = f.ArgsMatch( contains, arg_space, ParamsArray )
			if !o
				0
			  elseif o.ismacro
				if o.ismacro
					Missing = o
				o = nil
			  else
				if o.isdisabled
					error (exp,     o.description)
					error (o.source, "Disabled here.")

				if Paramshere
					ParamsHere.obj = o // multiple return :3
				if paramsarray.ConstructorAsNew and o is constructor
					ParamsHere.first = paramshere.CreateNil
				Return o
		
		if o
			paramsarray.found = true
			if !ParamsArray
				if (purpose == kPurposeDot) and !paramsarray.isaddress and (o isa scdecl) 
					Return o
				///////
				
				ifn o isa SCFunction
					Return o 			// canfunction is false
				ifn exp in @dot			// x = a.b is still a function call
					|| err = "Function must have a prototype."		// what about the side thing?
					if side and !paramsarray.MacroSize
						err = "Not assignable"
					check (o|scfunction|.ProtoDecl) (exp, err)
					Return o|scfunction|.ProtoDecl

	if missing	// the missing stuff should ENTIRELY go within argsmatch? cos its called in two places.
		return Missing.MacroFix( contains, arg_space, paramsarray )

	require (exp)
	
	if f
		if f.isdisabled
			error (exp, f.description)
		  elseif !paramsarray.MadeError
			f.ArgsMatch( contains, arg_space, ParamsArray, kTypeCastDescribeErrors )
		if ParamsHere
			ParamsHere.obj = f // for auto-complete
		Return f

	|| ErrMsg = "" // can't find "" on something "".
	if (paramsarray.found)
		ErrMsg = "Unexpected params on variable."
	  elseif (!ParamsHere)
		ErrMsg = "Can’t find object “${OrigName}”."
	  elseif (ParamsArray.IsDot)
		ErrMsg = "Can’t find “${OrigName}” on ${ParamsArray.RenderKind} “${ParamsArray.ModuleName}”."
		if self isa SCModule
			|| cls = .cls
				|| found = cls.UpCheck(origname)
					ErrMsg += " (But it does exist on the class.)"
	  else
		ErrMsg = "Can’t find function “${OrigName}”."
	error ( exp, ErrMsg )



constants (
	kPurposeAddress
	kPurposeFunc
	kPurposeDot
	kPurposeVar
	kPurposeVarDecl
	kPurposeHider=0x10000
)

flags (
	NoErrors = 1
	DontGoUp = 2
)


function LookUpDot (|String| name, |Message| exp, |SCNode| arg_space, |SCDecl| contains, |Message| side, |Object|)
	opt norefcounts
	return .LookUpSub( name, exp, exp.Last, arg_space, contains, side, kPurposeDot )


function LookUpVar (|String| name, |Message| exp, |message| side, |SCObject|)
	opt norefcounts
	if name ~= "super"
		name = "self"
	
	rz = .LookUpSub( name, exp, nil, self, nil, side, kPurposeVar )
	if rz isa scdecl
		(rz is UsedByCode)



function LookUpVarRootDecl (|String| name, |Message| exp, |SCObject|)
// misdesigned... but so is initrootdecl :(
	return .LookUpSub( name, exp, nil, self, nil, nil, kPurposeVarDecl ) 


function LookUpVarDecl (|String| name, |SCDecl|)
	|| result = .LookUpSub( name, nil, nil, self, nil, nil, kPurposeVarDecl )
	if result isa SCDecl
		Return result


function ImportFile (|SCFile| file)
	|| AST = file.AST								#require
	CurrVisibility = false
	file.Use
	compiler.program.Collect( ast, false )


function RequireContained (|Message| exp, |SCDecl|)
	|SCClass| cls
	
	if (self isa SCFunction)
		cls = .Cls
		if !cls
			|| p = .parent as SCModule
				cls = p.Cls
		
	  elseif (self isa SCClass)
		cls = self
		
	  elseif (self isa SCModule)
		cls = .Cls
		
	  elseif (self isa SCArg)
		|| f = .ParentFunc
			cls = f.Cls
	
	expect (cls and cls.Contained)   (exp, "Can’t use '...' here, no contained type found.")

	return cls.Contained


function SourceArg (|Message|)
	opt norefcounts
	|| p = .Source #require
	if p == @Arg
		Return p
	return p.find( @Arg )


function scfunction.SourceArg (|message|)
	opt norefcounts
	|| arg = .Source.last
	if arg == @arg
		return arg


function scfunction.ParamUniquer (|string| s, |string|)
	|| fs = faststring.new
	fs <~ s
	fs <~ "With"
	
	|| first = 0+(.cls!=nil)
	|| last = .args.length - 1
	if (last < first)
		fs <~ '0'
	  else
		for (i in first to last)
			|| a = .args[i]
				fs <~ a.type.modul.CppPart.Titlecase
	
	return fs


function UniquifyExport (|String| s, |string|)
	if (self isa scfunction)
		|| s2 = .ParamUniquer(s)
		if !compiler.exportnames[s2]
			return s2
	
	|| u = SCGlobals.UniqueNum++
	|| s3 = s + u.render
	if !compiler.exportnames[s3]
		return s3


function RehomeExport (|bool|)
	check (!.IsSTDLib) (self, "Can't rehome a std lib function. Use cpp_part to give a unique name.")
	|| newhome = .UniquifyExport(.exportname)			#require
	compiler.exportnames[.exportname] = nil
	compiler.exportnames[newhome] = self
	.exportname = newhome
	return true

			

function TestExportName (|String| s, |bool| Explicit, |string|) {
	|| o = Compiler.ExportNames[ s ]
	if !o : return s
	
	if !Explicit
		if (o isnt ExplicitExport)
			o.RehomeExport
		|| it = .UniquifyExport(s)
			return it
		
	  elseif o isnt ExplicitExport
		if o.RehomeExport: return s
	
	|| Err = "Export-name conflict: " + s
	error ( o.Source, Err )
	error (  .Source, Err )
}


function SetExportName (|String| s, |bool| Explicit)
	if self isa scfunction
		require !.ismacro

	s = s.UnicodeSafeName
	ifn (self isa SCModule) or (self isa SCClass)		// modules aren't really accessable like that.
		s = .TestExportName(s, explicit)				#require
		Compiler.ExportNames[ s ] = self

	(self is ExplicitExport) = Explicit
	.ExportName = s





function SCFunction.NeedsExport (|bool|)
	Return  (.MyReacher) or .isapi


function NeedsExport (|bool|)
	Return  (.MyReacher)


function message.InsideFunc (|SCFunction|) //owningfunc, infunc
	opt norefcounts
	for ch.up in self
		if ch == @tmp
			|| fn = ch.AsFunc
				return fn


function OwningFunc (|SCFunction|)
	if self isa SCFunction:	Return self
	if self isa scarg:		Return .ParentFunc


function CollectOne (|Message| c, |bool| Visible)
	if c IsTmp "visible"
		.LoadVisibility( c )
		c.remove
		Return
	
	|| Old = CurrVisibility 
	CurrVisibility = Visible
	if !.CollectSub( C ) and (self isa SCModule)
		.MoveToInitFunc( C ) // move unrecognised items...

	CurrVisibility = old // restore


function CollectString (|string| s, |message|)
	rz = s.ParseClean
	.Collect( rz, false )


function CreateNameDict (|Message| FuncName, |[message]| NameList) {
	expect (FuncName == @thg) ( FuncName, "Need a name." )
	
	|| AllSameType = ""
	for n in namelist
		|| Type = TypeofExpr(n, self) #require
		expect Type.IsNormal (n, "This can't be a constant.")
		
		|| NewType = type.type.name
		if (AllSameType == NewType or "")
			AllSameType = NewType
		  else
			AllSameType = "object"
	
	AllSameType := "object"

	|| Name = FuncName.Name
	|| fs = FastString.new

	fs <~ "
function $name (|dictionary of $AllSameType|)
	visible false
	|| _T = ${name}_Dict 
	if _T
		return _T
	_T = dictionary.new
	${name}_Dict = _T
"

	for s in NameList
		fs <~ `	_T.Set("`
		fs <~ s.name.Lowercase
		fs <~ `", `
		fs <~ s
		fs <~ ")\n"
		
	fs <~ "
	return _T
"

	|| FuncSrc = fs.GetResult
	|| msg = FuncSrc.ParseClean[0]
	.CollectSub( msg #expect )

	|| DclSrc = "|dictionary of $AllSameType| ${Name}_Dict = nil"
	|| DclMsg = DclSrc.ParseClean
		DclMsg.CollectFromBody(self)
}


function Message.ConstantExpandSub (|Message|)
	using (self)
	for item in self
		if rz
			rz = NewRel( rz, item.copy, "|||" )
		  else
			rz = item.copy


function ConstantExpand (|Message| ch)
	|| L = ch.first
	|| op = L.Next
	|| R = op.Next
	
	expect ((op == "=") and (L ==@thg))  ( op, "Expected 'd=(a,b,c...)' ." )
	
	|| Rel = «rel
		L
		«opp "="»
		R.ConstantExpandSub
	»

	ch.Next = rel
	R.MoveAllAfter(ch)
	ch.remove


function FindVis (|Message| c, |bool|)
	opt norefcounts
	if !c
		return true
	if c == @thg
		return c.TrueOrFalse
	if c == @adj
		|| first = c[@thg]
		first.expect(@thg, "class")
		|| name  = c[@thg, 1].name
		|| cls   = compiler[name]
		return cls and !cls.banned
	error c


function LoadVisibility (|Message| p)
	CurrVisibility = .FindVis(p.first) //   visible false,   visibile true,   visible
	.IsVisible = CurrVisibility
	SC_MakeComment( p )


//function ModuleType (|string|)
//	if self isa SCModule
//		return "module"
//	return "class"


function AutoCompleteKind (|string|)
	if self isa SCModule
		return "module"
	if self isa scclass
		if .FuncProto
			return "function prototype"
		if .IsDataTypeOnly
			return "datatype"
		if .IsStruct
			return "struct"
		if .IsObject
			return "class"
	return "unknown"


iterator ListLookup
	|| Curr = self
	while (Curr)
		yield Curr
		Curr = Curr.parent



module {
	|bool|			CurrVisibility
	|bool|			ConstantsLoadingOverride

	function LoadCppPart (CollectFunc)
		require (name_space isa scclass) or (name_space isa scmodule)
		
		if (name_space == compiler.program) // it's at root!
			|| file = node.scfile
				file.exportname = node[@thg]$.name
			node.remove
		
		return compiler.program
}

}



function DontRemove (CollectFunc)
	return Compiler.Program // OK



dispatch RootCollectTable (CollectFunc)
	+"love"					SCGame3D.Love
	+"function"				SCFunction.NewFunc
	+"extend_function"		SCFunction.NewFunc // user shouldn't write these
	+"api"					SCFunction.NewFunc
	+"cpp_libwrapper"		SCFunction.NewCppWrapper
	+"cpp_wrapper"			SCFunction.NewCppWrapper
	+"cpp_inbuilt"			SCFunction.NewCppWrapper
	+"cpp_nothing"			SCFunction.NewCppWrapper
	+"helper"				SCFunction.NewHelper
	+"macro"				SCFunction.NewMacro
	+"insertion"			SCThe.NewInsertion
	+"conf"					compiler.WrongConf
	+"crash"				{app.crash(node.firstname)}
	+"module"				SCModule.NeuModule
	+"static"				{error (node, "static is called 'module' in speedie.")}
	+"selector"				SCSelector.neu
	+"class"				SCClass.neuClass
	+"task"					sctasks.NewTask
	+"role"					SCClass.neuRole
	+"export_api"			SC_API.NewExportAPI
	+"model"				SCGame3D.NeuModel
	+"prototype"			SCFunction.NewProtoType
	+"render"				SCFunction.NewRender
	+"import"				(DontRemove)
	+"compile_linking"		Linkage.Collect
	+"shell_args"			InbuiltShellArgs.collect
	+"syntax"				SCClass.LoadSyntax
	+"linkage"				CppRefs.Linkage
	+"struct"				SCClass.newstruct
	+"datatype"				SCClass.DataType
	+"extend"				SCClass.StoreExtend
	+"extend_module"		SCClass.StoreExtendModule
	+"extends"				{ error (node, "I think you mean 'extend'"), return compiler.program }
	+"main"					SCFunction.NeuMain
	+"library"				SCFunction.NeuLibrary
	+"ignore"				(DontRemove)
	+"cpp_part"				(SCNode.LoadCppPart)
	+"constants"			(SCModule.ConstantCollector)
	+"flags"				(SCModule.ConstantCollector)
	



dispatch ClsCollectTable (CollectFunc)
	+"constructor"			SCFunction.NewConstructor		// ??
	+"destructor"			SCFunction.NewDestructor		// ??
	+"render"				SCFunction.NewRender			// ??
	+"function"				SCFunction.NewFunc
	+"extend_function"		SCFunction.NewFunc // user shouldn't write these
	+"setter"				SCFunction.NewHider
	+"api"					SCFunction.NewFunc
	+"macro"				SCFunction.NewMacro
	+"helper"				SCFunction.NewHelper
	+"behaviour"			SCBehaviour.NewActual
	+"actual"				SCBehaviour.NewActual
	+"virtual"				SCBehaviour.NewVirtual
	+"iterator"				SCIterator.NeuIter
	+"syx"					SCFunction.NeuSyx			   // jeebox specific
	+"cpp_wrapper"			SCFunction.NewCppWrapper
	+"cpp_libwrapper"		SCFunction.NewCppWrapper
	+"prototype"			SCFunction.NewProtoType
	+"syntax"				SCClass.LoadSyntax
	+"operator"				SCClass.LoadSyntax
	+"processas"			SCClass.ProcessAs
	+"cpp_refs"				cpprefs.ReadIntoCppRefs
	+"linkage"				CppRefs.Linkage
	+"pragma"				{ error (node) }

	+"class"				SCClass.NewInnerClass
	+"role"					SCClass.NewInnerClass
	+"task"					sctasks.NewTask

	+"initafter"			(SCModule.DoInitAfter)
	+"ignore"				(DontRemove)
	+"saveas"				(DontRemove)
	+"cpp_part"				(DontRemove)
	+"cpp_class"			(DontRemove)
	+"cpp_name"				(DontRemove)
	+"contains"				(DontRemove)
	+"default"				(SCClass.GetDefault)
	+"false"				(SCClass.GetFalse)
	+"size"					(SCClass.SetSize)
	+"module"				(DontRemove)
	+"constants"			(SCModule.ConstantCollector)
	+"flags"				(SCModule.ConstantCollector)



datatype SCNodeInfo (int)
	constants
		ExplicitExport
		Visible


datatype SCNodeFindMode (int)
	flags
		|SCNodeFindMode|
		NoErrors = 1
		DontGoUp = 2
		WantAType = 4
	syntax is (|SCNodeFindMode| m, |bool|)
		return self & m
