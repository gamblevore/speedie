
/*	
Notes:
					
	|Byte|					Indent				// speedie uses for nil+disturbance checker
	|MsgUIFlags|			Flags				// speedie uses for "inserted/breakpoint" only.
	|uint16|				Tag					// speedie uses this for ASM like "return/if/while/etc"
	
*/


/*
Issues:
What about the fact that a function's param nilness can rely on other funcs??
like:

	x = msg[0] // OK... so we don't rely on msg existing? but only cos it doesn't rely on self existing.
what if msg[n] is recursive and complicated? then how do we check if a decl... is nil or not?

The fact that we have ordered this... leaf first... helps. dependancies help... but that only reduces the problem
not eliminiates it. There will be cases that we can't eliminate.

* Make it nestable? That is... we actually can check functions?
	* this would only be needed for actual recursive functions... non-recursives would have a strict chain...
* what if two funcs with the same depth... and one is called before the other but the wrong one is called first?
	* then making it nestable helps!

* what about actually recursive funcs? I think for them... we let the user simply specify their nilness!! makes sense, right?
	* I think, just assume NOT NIL unless we can prove that it is tested. It is implicit and we can't be that smart.
*/




function SCFunction.CanNilCheck (|bool|)
	return  false
	require !.IsMacro and !.IsWrapper and .isOK
	|| c = .Lookup
		return c.name contains "NilTest"



function NilTracker.Check (|scfunction| f)
	debugat
	opt norefcounts
	.Start(f)
	.RunAll(f.SourceArg)
	.Tighten(f)					// then we alter the function's nilness
	.Restore


module VoidSweeper
	function SuperUberChecker
		opt norefcounts
		using options.NilStrength
	
		|NilTracker| T
		for f in compiler.funclist
			if f.CanNilCheck
				T.Check(f)
		
		scfunction.currfunc = nil
		.Sweep

	
	function Sweep
		// || init = compiler.getfunc("init_")
		// what about "init_"?

	
function message.NilPropAccess (|scdecl|)
	opt norefcounts
	|| m = .DotMustBeProperty
	if m and m isnt onmodule
		return m


function NilTracker.ChildMustExist (|message| wrapper)
	// a.b, *a, a[0], (a)()
	opt norefcounts
	|| msg = wrapper.first
	|| ObjDecl = msg.NeedDecl			#debug_require
	
	|| u = ObjDecl.NilUsed
	require u is nil
	expect (u is realish) (msg, nilerr)

	if  ObjDecl is param  and  ObjDecl.nildeclared isnt stated // fn name: msg.prop
		// what about self-param?
		// what about lookup via "isa class"
		ObjDecl.NilDeclared = NilState.Real

	ObjDecl.NilUsed = NilState.Realish


function NilTracker.IfWhile (|message| msg, |message|)
	// must re-add decls to the tracker...
	opt norefcounts
	expect !.if
	.if = msg
	.ProcessCond(msg.first, true)
	return msg.Second


function SCDecl.MustBeReal (|message| m, |scdecl|)
	.Nilused &= ~NilState.nil
	expect (.nilused is realish) (m, "Possible NilObject here")
	return self


function Message.RedundantBranch (|bool| Value, |branchstate|)
	if Value
		return .RedundantTrue
	return .RedundantFalse


function Message.RedundantTrue (|branchstate|)
	if StdErr.CanAddMore(errorseverity.problem)
		StdErr.NewProblem(self, "nil check is always true")
	return BranchState.Always


function Message.RedundantFalse (|branchstate|)
	if StdErr.CanAddMore(errorseverity.problem)
		StdErr.NewProblem(self, "nil check is always false")
	return BranchState.Never


function niltracker.IfIsReal (|message| m, |branchstate|)
	opt norefcounts
	|| d = m.NeedDecl
		if d.nilused isnt nil
			return m.RedundantTrue
		self <~ d
		d.Nilused &= ~NilState.nil
		if d.nilused isnt real
			return m.RedundantFalse
	return branchstate.Perhaps


function message.MustBeReal (|scdecl|)
	opt norefcounts
	|| d = .NeedDecl
		return d.MustBeReal(self)


function SCDecl.IsNowNil (|bool|)
	return (self == TypeNil) or (.nilused isnt real)


function NilTracker.ProcessCondThg (|message| m, |bool| Y, |branchstate|)
	opt norefcounts
	|| dest = NilState.nil + Y	
	|| d = m.NeedDecl			#debug_require
	|| u = d.nilused			#require
	if u == dest
		return m.RedundantTrue

	self <~ (m, d)
	d.Nilused = dest
	if u == NilState.Either // typical state
		return BranchState.Perhaps

	if d.NilDeclared is either
		return m.RedundantFalse

	return branchstate.Never


function NilTracker.ProcessCond (|message| m, |bool| Y, |branchstate|)
	opt norefcounts
	|| fn = m.func
	if fn == @thg
		return .ProcessCondThg(m, y)
	if fn == @bra or @type
		return .ProcessCond(m.first, Y)
	if fn == @rel
		return .ProcessCondRel(m, y)
	if fn == @func
		return .ProcessCondFunc(m,y)
	if fn == @brel
		return .ProcessCondBrel(m, y)
	debugat
	.RunAll(m)
	return branchstate.Perhaps


function NilTracker.ProcessCondPtr (|message| m, |bool| Y, |branchstate|)
	opt norefcounts
	|| d = m.NeedDecl #require
	require d.MustBeReal(m)
	.RunAll(m)							// if (*msg)
	return d.Nildeclared.Always(Y)


function NilTracker.ProcessCondBrel (|message| m, |bool| Y, |branchstate|)
	opt norefcounts
	if (m == "!")
		return .ProcessCond(m.first, !Y)
	if m == "*"
		return .ProcessCondPtr(m, Y)
	if m == "&"			// objects always have an address
		return NilState.Real.Always(Y)
	debugat
	.RunAll(m)
	return branchstate.Perhaps


function NilTracker.ProcessCondFunc (|message| m, |bool| Y, |branchstate|)
	opt norefcounts
	|| prms = m.last
	|| fn = prms.obj|SCFunction|
	if !fn.IsNilChecker
		return branchstate.Perhaps
	|| p1 = prms.first
	if p1 == @thg
		return .ProcessCondThg(m, y)
	
		
	// now what?

function NilTracker.ProcessCondRelSimple (|message| m, |bool| Y, |message|)
	
	

function NilTracker.ProcessCondRel (|message| m, |bool| Y, |branchstate|)
	opt norefcounts
	|| ll = m.first
	|| op = ll.next
	|| rr = op.next$
	|| scop = op.obj|SCOperator|				#debug_require
	if scop.IsCompare
		|| LNil = (ll.obj as scdecl).IsNowNil
		|| RNil = (rr.obj as scdecl).IsNowNil
		if lnil or rnil
			expect (scop.IsNilTest) (op, "Can't use this operator on nil. Use != or ==.")
			if (lnil and rnil)
				return m.RedundantBranch(scop.hasequals)
			if lnil
				return .ProcessCond(rr, Y != scop.hasequals)
			  else
				return .ProcessCond(ll, Y != scop.hasequals)
		return BranchState.Perhaps
	
	if scop.IsAndOr
		if scop == "and"
			return .ProcessCond(ll, Y) & .ProcessCond(rr, Y)
	
		if scop == "or"
			|| where = .Count
			|| SimpleLeft = .ProcessCond(ll, y)
			|| SimpleRight = .ProcessCondRelSimple(rr, y)
			if .Count > where
		// this will require .count to go up... so basically condthg will add it
		// but what removes it? we have to... right?
		
		// what about the cond?
		// if (a and b)			// a yes,   b yes		... after a may, b may
		// if (!a and !b)		// a no,    b no    	... after a may, b may
		// if (!(a and b))		// a may,	b may   	... after a yes, b yes
		// if (!(!a and !b)		// a may,	b may   	... after a no,  b no
		// if (a or b)			// a may,	b may		... after a no,  b no		
		// if (!(a or b))		// a no,	b no		... after a may, b may
		// if (!(!a or !b))		// a may,	b may		... after a no,  b no 
		
		
		// if !msg or *msg
		// if (abc and m) or (*m == 1)
		
	return branchstate.Perhaps


function NilTracker.RunAll (|message| s)
	opt norefcounts
	|| End = s.FlatAfter
	while 
		|| ch = s.first
			s = .Enter(ch)
			continue
		while
			|| n = s.next
				s = .Enter(n)
				exit
			.Leave(s)	
			s = s.parent
			require s != nil and end



function NilTracker.EnterArg  (|message| s)
	



function NilTracker.Enter  (|message| s, |message|)
	|| f = s.func
	// now... what have we entered? and where from?
	if (f == @tmp)
		if (s == "if" or "while") // what about elseif/else?
			.IfWhile(s)
	  elseif (f == @arg)
		.EnterArg(s)
	  elseif (f == @dot)
		|| Prop = s.NilPropAccess
			.ChildMustExist(s)								// abc.var
	  elseif (f == @acc) 
		.ChildMustExist(s)									// abc[0]
	  elseif (f == @brel) 
		if s == "*"
			.ChildMustExist(s)								// *abc
	  elseif (f == @func and s.first == @bra)
		.ChildMustExist(s.first)							//  (abc)()
	return s
	
	

function NilTracker.LeaveIf (|message| s)
	.If = nil


function NilTracker.Leave (|message| s)
	opt norefcounts
	if s == .if
		.LeaveIf(s)
		

	


/*
TODO:

* require returns nil for strings. we need some way to return "" for strings but nil for arrays... so cant just use the default value.
* using ptrs...
* Strength is settable in the project if its an error or problem
* return values
* freeze bug
* .if is needed?
* pop the msgs out.
* fn abc (|object| x)
	x = haha()

x is nil or not? haha? its literally been replaced so the original decl is unused.
	unused decls default to optional

* typecasts... what sort of nil checking do we do? do we check the original var?
	fn abc (|object| x, |object| y)
		x = x |int| |obj|
		y = haha() |int| |obj|

* set the .obj to an arg or the func itself... for continue/exit/return/rejoin in transform
	* also make app.quit into a blocker!! for refcounting and nilchecking

* ternaries
	* make ternies into (if/else) expressions!!
	|| x = ({|int| abc, if (Len != 4) {abc = 1} else {abc = 2}, rejoin abc})
	* also if/elses can return values... and then we don't need special ternary handling

BOOLEAN LOGICS:
	refills and relsetters:
		if (!a) a = b(), a = &e
	
	multiple branches:
		if !a { if b {return 1} else {return 2} }
		a.b = 1
	
	return affecting future code:
		if (!msg)
			return
		msg.prop
	
	changes nothing:
		if (a or b)


DONE?
can access prop:
	if (msg)
		msg.prop

multiple tests:
	if (a and b)

redundant "m":
	if (m and m.length)
	if (!m or !m.length)

pointless:
	if nil == nil

fail:
	if msg >= nil, if msg <= nil

nil within branch:
	if msg == nil
*/


/*
	|&int| p1 = 0
	|&int| p2 = &i
	if (p1)
	if (*p1)
	// can we say that the thing p2 points tooo... must exist? can we? how?
	// seems theres 4 possible versions...
	|&int| p2 = &i
	|&int!| p2 = &i
	|!&int!| p2 = &i
	|!&int| p2 = &i
*/


/*
* Init Vars Sweep: 
	We need to go through the entire program, and give each item found, a "timecode". That
	is... it has an "earliest time" that it COULD occur.
	So for branches, thats easy, both sides get the same time. We can do some simple logic like:
	
	function abc
		if !inited
			inited = true
			var1 = .CreateVar
			var2 = .CreateVar
		var1.explode
		var2.die
	
	If its only set in one place... that can help.
	
	So var1.explode actually has a "higher time" than var1 = .createvar. So its OK.
	
	Like this... we can make it work!
	
	POSSIBLY we could allow reordering.
	
	while loops are easier, unless they might not fire at all.
	
	function pointers... are a bit trickier?
	
	if (random[])
		a lot of code
		(.func)()
	  else
		small code
		(.func)()

	we have to check the time twice? But thats true of function calls in general???
	We could do it differently... "at each second in time..." there can be an array (or list whatever) of possible code we could be executing. The problem with that, is that it would explode exponentially :)
	
	Perhaps not? if we exclude times that not newer?
	
	PROBABLY MAKE SOMETHING SIMPELR THAN THIS
*/
