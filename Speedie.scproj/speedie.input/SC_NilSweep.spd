
/*	
Todo:
	* Collectdecls: Pointers still need separate treatment... and getting the address/dereffing might be different too?
					
	* Strength:
		Strength is settable in the project if its an error or problem
		For now it defaults to problem, but this is ALWAYS an error: nil|msg|.pos=0

	* ternaries

	|Byte|					Indent				// speedie does not use
	|MsgUIFlags|			Flags				// speedie uses for "inserted/breakpoint" only.
	|uint16|				Tag					// speedie uses this for ASM like "return/if/while/etc"
	
	* merge "disturbance checker" with nil checker?
*/




function SCFunction.NeedsNilCheck (|bool|)
	require !.IsMacro and !.IsWrapper
	|| c = .Lookup
		return c.name contains "NilTest"



function SCfunction.UltimateNilChecker (|&NilTracker| T)
	debugat
	opt norefcounts
	scfunction.currfunc = self		// Decls start unknown... unless specified or datatypes
	T.Start(self)
	t.RunAll(.sourcearg)
	T.Tighten(self)					// then we alter the function's nilness
	T.Restore


module VoidSweeper
	function SuperUberChecker
		opt norefcounts
		using options.NilStrength
	
		|NilTracker| T
		for f in compiler.funclist
			if f.NeedsNilCheck
				f.UltimateNilChecker(T)
		
		scfunction.currfunc = nil
		.Sweep

	
	function Sweep
		// || init = compiler.getfunc("init_")
		// what about "init_"?

/*
Issues:
What about the fact that a function's nilness can rely on other funcs??
like:

	x = msg[0] // OK... so we don't rely on msg existing? but only cos it doesn't rely on self existing.
what if msg[n] is recursive and complicated? then how do we check if a decl... is nil or not?

The fact that we have ordered this... leaf first... helps. dependancies help... but that only reduces the problem
not eliminiates it. There will be cases that we can't eliminate.

* Make it nestable? That is... we actually can check functions?
	* this would only be needed for actual recursive functions... non-recursives would have a strict chain...
* what if two funcs with the same depth... and one is called before the other but the wrong one is called first?
	* then making it nestable helps!

* what about actually recursive funcs? I think for them... we let the user simply specify their nilness!! makes sense, right?
	* I think, just assume NOT NIL unless we can prove that it is tested. It is implicit and we can't be that smart.
*/
	
	
function message.NilPropAccess (|scdecl|)
	opt norefcounts
	|| m = .DotMustBeProperty
	if m and m isnt onmodule
		return m


function NilTracker.Property (|message| msg)
	pragma inline, opt norefcounts
	|| Prop = msg.NilPropAccess$
	|| ObjDecl = TypeOfExpr(msg.first, nil) #debug_require

	// if (msg): msg.prop
	if obj.nilused isnt nil
		return 
	expect (ObjDecl.NilUsed isnt nil) (msg, "Possible NilObject access.")
	ObjDecl.NilUsed &= ~NilState.Optional


function NilTracker.Access (|message| msg)
	pragma inline


function NilTracker.FP (|message| msg)
	// FP calls and behaviours should all assume NOT NIL unless specified...
	pragma inline


// OK... so we have an if test... now the thing is... we are being called from within
// a special flattened searcher. So... after this returns... we'll get to the condition...
// so should we process the condition NOW or later? We can do it later if we say "we are in an if"?
// we could also preprocess it... then return where we will be next.

// Im gonna need an absolute simple first case that I can catch a problem.
// its the only way.


function NilTracker.IfWhile (|message| msg)
	// must re-add decls to the tracker...
	opt norefcounts
	expect !.if
	.if = msg
	|| tmp = msg

	
	while tmp
		|| cond = tmp.first			#loop
		//.allnodes(cond)

		|| arg = cond.next			#loop
		|| depth = .EnterIf(cond)
		//.arg(arg)


function NilTracker.EnterIf (|message| m, |int|)
	opt norefcounts
	|| fn = m.func
	if fn == @thg
		|| d = m.obj as SCDecl			#require
	if fn == @rel
		|| f = m.first
		|| op = f.next
		|| l = op.next
		|| scop = op.obj as SCOperator
		if scop.IsAndOr
			if scop == "and"
				// tests add up
			
			if scop == "or"
				// throw away the results...
	
/*
refills:
	if (!a) a = b()

multiple branches:
	if !a { if b {return 1} else {return 2} }
	a.b = 1


can access prop:
	if (msg)
		msg.prop

return affecting future code:
	if (!msg)
		return
	msg.prop

nil within branch
	if msg == nil

fail:
	if msg >= nil, if msg <= nil

multiple tests:
	if (a and b)

changes nothing:
	if (a or b)


*/

function NilTracker.RunAll (|message| s)
	opt norefcounts
	while
		|| ch = s.first
			s = .Enter(ch)
			continue
		while
			|| n = s.next
				s = .Enter(n)
				exit
			.Leave(s)	
			s = s.parent
			require s 



function NilTracker.EnterArg  (|message| s)



function NilTracker.Enter  (|message| s, |message|)
	|| f = s.func
	// now... what have we entered? and where from?
	if (f == @tmp)
		if (s == "if" or "while") // what about elseif/else?
			.IfWhile(s)
	  elseif (f == @arg)
		.EnterArg(s)
	  elseif (f == @dot)
		.Property(s)									// abc.var
	  elseif (f == @acc) 
		.Access(s)										// abc[0]
	  elseif (f == @brel) 
		if s == "*"
			.Access(s)									// *abc
	  elseif (f == @func and s.first == @bra)
		.FP(s)											//  (abc)()
	return s
	
	
function NilTracker.LeaveIf (|message| s)

function NilTracker.Leave (|message| s)
	opt norefcounts
	if s == .if
		.LeaveIf(s)
		

	



/*
* Init Vars Sweep: 
	We need to go through the entire program, and give each item found, a "timecode". That
	is... it has an "earliest time" that it COULD occur.
	So for branches, thats easy, both sides get the same time. We can do some simple logic like:
	
	function abc
		if !inited
			inited = true
			var1 = .CreateVar
			var2 = .CreateVar
		var1.explode
		var2.die
	
	If its only set in one place... that can help.
	
	So var1.explode actually has a "higher time" than var1 = .createvar. So its OK.
	
	Like this... we can make it work!
	
	POSSIBLY we could allow reordering.
	
	while loops are easier, unless they might not fire at all.
	
	function pointers... are a bit trickier?
	
	if (random[])
		a lot of code
		(.func)()
	  else
		small code
		(.func)()

	we have to check the time twice? But thats true of function calls in general???
	We could do it differently... "at each second in time..." there can be an array (or list whatever) of possible code we could be executing. The problem with that, is that it would explode exponentially :)
	
	Perhaps not? if we exclude times that not newer?
	
	PROBABLY MAKE SOMETHING SIMPELR THAN THIS
*/
