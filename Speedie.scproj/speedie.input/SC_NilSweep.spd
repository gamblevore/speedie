
/*	
Todo:
	* Collectdecls: Pointers still need separate treatment... and getting the address/dereffing might be different too?
					
	* Strength:
		Setting to a definite nil is ALWAYS an error... like: nil|msg|.pos=0
		Strength is settable in the project if its an error or problem
		For now it defaults to problem
	* ternaries

	|Byte|					Indent				// speedie does not use
	|MsgUIFlags|			Flags				// speedie uses for "inserted" only!
	|uint16|				RangeLength			// Speedie uses for debugging
	|uint16|				Tag					// speedie uses this for ASM like "return/if/while/etc"
	
	
	* thoughts on merging nil+ref
		* bad... many issues. 
		* We won't be able to make use of ALL the info as we won't have ALL of it at the time. Some we will... but whats the point?
		* giant rework
		* much more complex... merging multiple systems.
	
	* We could merge the "disturbance checker" with the nil checker anyhow...
*/




function SCFunction.NeedsNilCheck (|bool|)
	require !.IsMacro and !.IsWrapper
	if .BlindCasts < 123
		return true
	debugat


function SCfunction.NilCheck (|&NilTracker| T)
	scfunction.currfunc = self
	// Decls start unknown... unless specified or datatypes
	T.Start(self)
	.sourcearg.NilCheckArg(T)		// this will specify everything
	T.Tighten(self)					// then we alter the function's nilness
	T.Restore // nice!
	
	.BlindCasts = 123


module NilSweep
	function CheckAll
		opt norefcounts
		using options.NilStrength
	
		|NilTracker| T
		for f in compiler.funclist
			if f.NeedsNilCheck
				f.NilCheck(T)
		
		scfunction.currfunc = nil
		.Sweep

	
	function Sweep
		|| main = compiler.getmainfunc(nil)
		// what about "init_"?
	


/*
Issues:
	"if/while" must re-add decls to the tracker...
if/while blocks need to keep a stack of multiple variables
	if a and b and c
		a.a(b.b(c.c))


shared decls need unshare... after func is finished

What about the fact that a function's nilness can rely on other funcs??
like:

	x = msg[0] // OK... so we don't rely on msg existing? but only cos it doesn't rely on self existing.
what if msg[n] is recursive and complicated? then how do we check if a decl... is nil or not?

The fact that we have ordered this... leaf first... helps. dependancies help... but that only reduces the problem
not eliminiates it. There will be cases that we can't eliminate.

* Make it nestable? That is... we actually can check functions?
	* this would only be needed for actual recursive functions... non-recursives would have a strict chain...
* what if two funcs with the same depth... and one is called before the other but the wrong one is called first?
	* then making it nestable helps!

* what about actually recursive funcs? I think for them... we let the user simply specify their nilness!! makes sense, right?
	* I think, just assume NOT NIL unless we can prove that it is tested. It is implicit and we can't be that smart.
*/
	
	
function message.NilCheckProperty (|&NilTracker| tracker)
	pragma inline, opt norefcounts				// done?
	|| Prop = .DotMustBeProperty
	require prop and (prop isnt OnModule)
	|| f = .first
	|| ObjDecl = TypeOfExpr(f, nil) #debug_require

	expect (ObjDecl.NilUsed is real) (self, "Possible NilObject access.")
	ObjDecl.NilUsed &= ~NilState.Optional


function message.NilCheckAccess (|&NilTracker| T)
	pragma inline


function message.NilCheckFP (|&NilTracker| T)
	// FP calls and behaviours should all assume NOT NIL unless specified...
	pragma inline


function message.NilCheckIfWhile (|&NilTracker| T)
	opt norefcounts
	|| tmp = self
	
	while tmp
		|| cond = tmp.first			#loop
		cond.NilCheckFlat(T)

		|| arg = cond.next			#loop
		|| depth = T.EnterIf(cond)
		arg.NilCheckArg(T)
		T.LeaveIf(depth)
		if tmp == self
			tmp = arg.next
		  else
			tmp = tmp.next


function NilTracker.EnterIf (|message| m, |int|)
	opt norefcounts
	pragma inline
	// so... what do we do with this? how do we know what is happening?
	// I guess... we need to start with the and/ors
	// then find the individiaul items...

	// what about this?	
		// if (!a) a = b()
	
	// we need to build up a picture... of the nilness...
	// also we need to know if the arg returns!!!
	// what if it returns in multiple branches?
		// if !a { if b {return 1} else {return 2} }
		// a.b = 1
		// we'll need a more sophisticated nil-tracker
		// what is the time for?
		// just for... the init behaviour right?
		// its not needed for general funcs? I think we can remove it!

		// nil-sweep can be a secondary thing??? and its only for globals!
		// just remove it.
		// Also... an arg could leave multiple decls not nil! a test too!!
		// if (a and b): 
		// if (!(msg)) means I need to deal with brels and bras

	|| fn = m.func
	if fn == @thg
		|| d = m.obj as SCDecl			#require
	if fn == @rel
		|| f = m.first
		|| op = f.next
		|| l = op.next
		|| scop = op.obj as SCOperator
		if scop.IsAndOr
			if scop == "and"
				// tests add up
			
			if scop == "or"
				// throw away the results...
	
// the results also seem to depend on the arg!!	So we can't know what to do without knowing what the arg does!
// and how the cond is...
// it seems very complicated and I don't know where to start...
// maybe just start with a very simple case?
//if (msg) {
//	Can Use Msg
//}
//if (!msg) {
//	return
//}
// can use msg
//	if msg
//		// msg is now optional
//		if msg > nil, if msg != nil // same
//		// msg is now optional and NOT nil within this branch
//	
//	if msg == nil // msg is now optional... but nil within that branch
//	if msg >= nil, msg <= nil // what? just fail!
//	if !msg // msg is now nil!!
//	if !msg
//		return
//	NOW msg is not nil!!
//  
//	
	
	
function NilTracker.LeaveIf (|int| n)
	opt norefcounts
	pragma inline



function Message.NilCheckFlat (|&NilTracker| tracker)
	opt norefcounts
	for s.flat in self
		if s == @arg
			s.NilCheckArg(tracker)
			continue_with s.FlatAfter
		  else
			s.NilCheckMemory(tracker)


function Message.NilCheckMemory (|&NilTracker| tracker)
	opt norefcounts
	|| f = .func
	if f == @dot
		.NilCheckProperty(tracker)									// abc.var
	  elseif (f == @brel and self == "*") or f == @acc
		.NilCheckAccess(tracker)									// *abc / abc[0]
	  elseif (f == @func and .first == @bra)
		.NilCheckFP(tracker)										//  (abc)()



function Message.NilCheckArg (|&NilTracker| T)
	#! We have ASM if/while flags set! Just use them???
	opt norefcounts
	for s in self
		if s.func == @tmp and (s == "if" or "while")
			s.NilCheckIfWhile(T)
		  else
			s.NilCheckFlat(T)




/*
* Init Vars Sweep: 
	We need to go through the entire program, and give each item found, a "timecode". That
	is... it has an "earliest time" that it COULD occur.
	So for branches, thats easy, both sides get the same time. We can do some simple logic like:
	
	function abc
		if !inited
			inited = true
			var1 = .CreateVar
			var2 = .CreateVar
		var1.explode
		var2.die
	
	If its only set in one place... that can help.
	
	So var1.explode actually has a "higher time" than var1 = .createvar. So its OK.
	
	Like this... we can make it work!
	
	POSSIBLY we could allow reordering.
	
	while loops are easier, unless they might not fire at all.
	
	function pointers... are a bit trickier?
	
	if (random[])
		a lot of code
		(.func)()
	  else
		small code
		(.func)()

	we have to check the time twice? But thats true of function calls in general???
	We could do it differently... "at each second in time..." there can be an array (or list whatever) of possible code we could be executing. The problem with that, is that it would explode exponentially :)
	
	Perhaps not? if we exclude times that not newer?
	
	PROBABLY MAKE SOMETHING SIMPELR THAN THIS
*/
