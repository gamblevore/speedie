
/*	
Todo:
	* Collectdecls: Pointers still need separate treatment... and getting the address/dereffing might be different too?
					
	* Strength:
		Strength is settable in the project if its an error or problem
		For now it defaults to problem, but this is ALWAYS an error: nil|msg|.pos=0

	* ternaries

	|Byte|					Indent				// speedie uses for nil+disturbance checker
	|MsgUIFlags|			Flags				// speedie uses for "inserted/breakpoint" only.
	|uint16|				Tag					// speedie uses this for ASM like "return/if/while/etc"
	
	* merge "disturbance checker" with nil checker?
*/




function SCFunction.CanNilCheck (|bool|)
	require !.IsMacro and !.IsWrapper
	|| c = .Lookup
		return c.name contains "NilTest"



function SCfunction.UltimateNilChecker (|&NilTracker| T)
	debugat
	opt norefcounts
	T.Start(self)
	T.RunAll(.SourceArg)
	T.Tighten(self)					// then we alter the function's nilness
	T.Restore


module VoidSweeper
	function SuperUberChecker
		opt norefcounts
		using options.NilStrength
	
		|NilTracker| T
		for f in compiler.funclist
			if f.CanNilCheck
				f.UltimateNilChecker(T)
		
		scfunction.currfunc = nil
		.Sweep

	
	function Sweep
		// || init = compiler.getfunc("init_")
		// what about "init_"?

/*
Issues:
What about the fact that a function's nilness can rely on other funcs??
like:

	x = msg[0] // OK... so we don't rely on msg existing? but only cos it doesn't rely on self existing.
what if msg[n] is recursive and complicated? then how do we check if a decl... is nil or not?

The fact that we have ordered this... leaf first... helps. dependancies help... but that only reduces the problem
not eliminiates it. There will be cases that we can't eliminate.

* Make it nestable? That is... we actually can check functions?
	* this would only be needed for actual recursive functions... non-recursives would have a strict chain...
* what if two funcs with the same depth... and one is called before the other but the wrong one is called first?
	* then making it nestable helps!

* what about actually recursive funcs? I think for them... we let the user simply specify their nilness!! makes sense, right?
	* I think, just assume NOT NIL unless we can prove that it is tested. It is implicit and we can't be that smart.
*/
	
	
function message.NilPropAccess (|scdecl|)
	opt norefcounts
	|| m = .DotMustBeProperty
	if m and m isnt onmodule
		return m


function NilTracker.Property (|message| msg)
	pragma inline, opt norefcounts
	|| Prop = msg.NilPropAccess$
	|| ObjDecl = TypeOfExpr(msg.first, nil) #debug_require

	// if (msg): msg.prop
	if objdecl.nilused isnt nil
		return 
	
	// fn name: msg.prop
	ObjDecl.NilUsed &= ~NilState.nil
	expect (ObjDecl.NilUsed) (msg, "Possible NilObject access.")


function NilTracker.Access (|message| msg)
	pragma inline


function NilTracker.FP (|message| msg)
	// FP calls and behaviours should all assume NOT NIL unless specified...
	pragma inline


// OK... so we have an if test... now the thing is... we are being called from within
// a special flattened searcher. So... after this returns... we'll get to the condition...
// so should we process the condition NOW or later? We can do it later if we say "we are in an if"?
// we could also preprocess it... then return where we will be next.

// Im gonna need an absolute simple first case that I can catch a problem.
// its the only way.


function NilTracker.IfWhile (|message| msg, |message|)
	// must re-add decls to the tracker...
	opt norefcounts
	expect !.if
	.if = msg
	.ProcessCond(msg.first, true)
	return msg.Second


function SCDecl.MustBeReal (|message| m, |scdecl|)
	.Nilused &= ~NilState.nil
	expect (.nilused is realish) (m, "Possible NilObject here")
	return self


function Message.RedundantTrue (|branchstate|)
	if StdErr.CanAddMore(errorseverity.problem)
		StdErr.NewProblem(self, "nil check is always true")
	return BranchState.Always


function Message.RedundantFalse (|branchstate|)
	if StdErr.CanAddMore(errorseverity.problem)
		StdErr.NewProblem(self, "nil check is always false")
	return BranchState.Never


function niltracker.IfIsReal (|message| m, |branchstate|)
	opt norefcounts
	|| d = m.NeedDecl
		if d.nilused isnt nil
			return m.RedundantTrue
		self <~ d
		d.Nilused &= ~NilState.nil
		if d.nilused isnt real
			return m.RedundantFalse
	return branchstate.Perhaps

			

function message.MustBeReal (|scdecl|)
	opt norefcounts
	|| d = .NeedDecl
		return d.MustBeReal(self)


function NilTracker.ProcessCondThg (|message| m, |bool| Y, |branchstate|)
	opt norefcounts
	|| dest = NilState.nil + Y	
	|| d = m.NeedDecl			#debug_require
	|| u = d.nilused			#require
	if u == dest
		return m.RedundantTrue

	self <~ (m, d)
	d.Nilused = dest
	if u == NilState.Either // typical state
		return BranchState.Perhaps

	if d.NilDeclared is either
		return m.RedundantFalse

	return branchstate.Never

	

function NilTracker.ProcessCond (|message| m, |bool| Y, |branchstate|)
	opt norefcounts
	|| fn = m.func
	if fn == @thg
		return .ProcessCondThg(m, y)
	if fn == @bra or @type
		return .ProcessCond(m.first, Y)
	if fn == @rel
		return .ProcessCondRel(m, y)
	if fn == @func
		return .ProcessCondFunc(m,y)
	if fn == @brel
		return .ProcessCondBrel(m, y)
	debugat
	.RunAll(m)
	return branchstate.Perhaps


function NilTracker.ProcessCondPtr (|message| m, |bool| Y, |branchstate|)
	opt norefcounts
	|| d = m.NeedDecl #require
	require d.MustBeReal(m)
	.RunAll(m)							// if (*msg)
	return d.PtrNildeclared.Always(Y)




function NilTracker.ProcessCondBrel (|message| m, |bool| Y, |branchstate|)
	opt norefcounts
	if (m == "!")
		return .ProcessCond(m.first, !Y)
	if m == "*"
		return .ProcessCondPtr(m, Y)
	if m == "&"			// objects always have an address
		return NilState.Real.Always(Y)
	debugat
	.RunAll(m)
	return branchstate.Perhaps


/*
	|&int| p1 = 0
	|&int| p2 = &i
	if (p1)
	if (*p1)
	// can we say that the thing p2 points tooo... must exist? can we? how?
	// seems theres 4 possible versions...
	|&int| p2 = &i
	|&int!| p2 = &i
	|!&int!| p2 = &i
	|!&int| p2 = &i
*/


function NilTracker.ProcessCondFunc (|message| m, |bool| Y, |branchstate|)
	opt norefcounts
	|| prms = m.last
	|| fn = prms.obj|SCFunction|
	if !fn.IsNilChecker
		return branchstate.Perhaps
	|| p1 = prms.first
	if p1 == @thg
		return .ProcessCondThg(m, y)
	
		
	// now what?

function NilTracker.ProcessCondRelSimple (|message| m, |bool| Y, |message|)
	
	
function SCDecl.IsNowNil (|bool|)
	return (self == TypeNil) or (.nilused isnt real)


function NilTracker.ProcessCondRel (|message| m, |bool| Y, |branchstate|)
	opt norefcounts
	|| f = m.first
	|| op = f.next
	|| l = op.next
	|| scop = op.obj|SCOperator|				#debug_require
	if !scop.IsAndOr
		if scop.IsCompare
			|| ld = f.obj as scdecl
			|| rd = l.obj as scdecl
			|| LNil = ld.isnownil
			|| RNil = rd.isnownil
			if (lnil and rnil) : m.RedundantTrue
			
				
			// so... what are we comparing to? nil or something that is nil or exists
	  elseif scop == "and"
		return .ProcessCond(f, Y) & .ProcessCond(l, Y)
	
	  elseif scop == "or"
		|| where = .Count
		|| SimpleLeft = .ProcessCond(f, y)
		|| SimpleRight = .ProcessCondRelSimple(l, y)
		if .Count > where
		// this will require .count to go up... so basically condthg will add it
		// but what removes it? we have to... right?
		
		// what about the cond?
		// if (a and b)			// a yes,   b yes		... after a may, b may
		// if (!a and !b)		// a no,    b no    	... after a may, b may
		// if (!(a and b))		// a may,	b may   	... after a yes, b yes
		// if (!(!a and !b)		// a may,	b may   	... after a no,  b no
		// if (a or b)			// a may,	b may		... after a no,  b no		
		// if (!(a or b))		// a no,	b no		... after a may, b may
		// if (!(!a or !b))		// a may,	b may		... after a no,  b no 
		
		
		// if !msg or *msg
		// if (abc and m) or (*m == 1)
		
	return branchstate.Perhaps

	
	
/*
refills:
	if (!a) a = b()

multiple branches:
	if !a { if b {return 1} else {return 2} }
	a.b = 1

redundant "m":
	if (m and m.length)
	if (!m or !m.length)

can access prop:
	if (msg)
		msg.prop

return affecting future code:
	if (!msg)
		return
	msg.prop

nil within branch
	if msg == nil

fail:
	if msg >= nil, if msg <= nil

multiple tests:
	if (a and b)

changes nothing:
	if (a or b)
*/


function NilTracker.RunAll (|message| s)
	opt norefcounts
	|| End = s.FlatAfter
	while 
		|| ch = s.first
			s = .Enter(ch)
			continue
		while
			|| n = s.next
				s = .Enter(n)
				exit
			.Leave(s)	
			s = s.parent
			require s != nil and end



function NilTracker.EnterArg  (|message| s)



function NilTracker.Enter  (|message| s, |message|)
	|| f = s.func
	// now... what have we entered? and where from?
	if (f == @tmp)
		if (s == "if" or "while") // what about elseif/else?
			.IfWhile(s)
	  elseif (f == @arg)
		.EnterArg(s)
	  elseif (f == @dot)
		.Property(s)									// abc.var
	  elseif (f == @acc) 
		.Access(s)										// abc[0]
	  elseif (f == @brel) 
		if s == "*"
			.Access(s)									// *abc
	  elseif (f == @func and s.first == @bra)
		.FP(s)											//  (abc)()
	return s
	
	

function NilTracker.LeaveIf (|message| s)
	.If = nil


function NilTracker.Leave (|message| s)
	opt norefcounts
	if s == .if
		.LeaveIf(s)
		

	



/*
* Init Vars Sweep: 
	We need to go through the entire program, and give each item found, a "timecode". That
	is... it has an "earliest time" that it COULD occur.
	So for branches, thats easy, both sides get the same time. We can do some simple logic like:
	
	function abc
		if !inited
			inited = true
			var1 = .CreateVar
			var2 = .CreateVar
		var1.explode
		var2.die
	
	If its only set in one place... that can help.
	
	So var1.explode actually has a "higher time" than var1 = .createvar. So its OK.
	
	Like this... we can make it work!
	
	POSSIBLY we could allow reordering.
	
	while loops are easier, unless they might not fire at all.
	
	function pointers... are a bit trickier?
	
	if (random[])
		a lot of code
		(.func)()
	  else
		small code
		(.func)()

	we have to check the time twice? But thats true of function calls in general???
	We could do it differently... "at each second in time..." there can be an array (or list whatever) of possible code we could be executing. The problem with that, is that it would explode exponentially :)
	
	Perhaps not? if we exclude times that not newer?
	
	PROBABLY MAKE SOMETHING SIMPELR THAN THIS
*/
