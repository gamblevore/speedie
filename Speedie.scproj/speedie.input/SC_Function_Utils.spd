
/*
	Jeebox internals. By Theodore H. Smith...
*/




prototype fnPreReader (|scfunction| self, |message| msg, |bool|)

function scfunction.PreRead (|message| Arg)
	opt norefcounts
	for s in arg
		if s == @tmp
			|| fn = FuncPreReader[s.name]
				(fn.first)(self, s)
				s.remove


dispatch FuncPreReader (fnPreReader)
	+"disabled"
		opt norefcounts
		is disabled
		.description = "Called a disabled function."
		|| s = msg.first
			s.ExpectString
			.description = s.name
			
	+"todo"
		opt norefcounts
		msg[@nil].expectlast
		compiler.TodoList <~ msg
	
	
	+"pragma"
		opt norefcounts
		|| f = msg[@thg]
			f.expectlast
			if f ~= "inline"
				Is Inline
			  else
				error f
				
	+"numeric"
		opt norefcounts
		|| f = msg.first
			error f
		(self is numbercreator)
	
	
	+"opt"
		opt norefcounts
		|| f = msg[@thg]
		if f ~= "NoRefCounts"
			is NoRefCounts
		  elseif f ~= "min"
			|| Min = f.next(@num)
				.minopt = min.int
		  else
			error f
	
	
	+"nil"
		opt norefcounts
		|| f = msg[@thg]$
		if f ~= "self"
			.NilSelff(msg, nilstate.optional)
		  elseif f ~= "checker"
			.MakeNilChecker(msg)
		  elseif f ~= "safe"
			.MakeNilChecker(msg)
			is HidesProperties
			is inline
			.isvisible = true
			
		  else
			error f
	
	
	+"real"
		opt norefcounts
		|| f = msg[@thg]$
		if f ~= "self"
			.NilSelff(msg, nilstate.real)
		  else
			error f
	

	+"description"
		|| str = msg[@str]
			if (self Is Disabled)
				error (msg, "Already disabled")
			  else
				check !.description (msg, "Multiple descriptions.")
				.Description = str.name
	


function scfunction.MakeNilChecker (|message| msg)
	.NilSelff(msg, nilstate.optional)
	.IsNilChecker = 1
	

function SettingSelfProperty (|Message| Rel, |bool|)
	// .bla = X
	opt norefcounts
	|| Dot = SettingAProperty(rel)
		return (Dot.first IsThing "self")


function SettingAProperty (|Message| Rel, |Message|)
	// bla.bla = X
	opt norefcounts
	require (Rel.IssetRel)
	|| f = Rel.first
	if f and f.DotType
		return f


function SettingMemory (|Message| Rel, |bool|)
	// bla.bla = X
	opt norefcounts
	require Rel.IsSetRel
	|| f = Rel.first
		|| d = f.SetType
			return true


function scfunction.NilSelff (|message| where, |nilstate| v)
	expect (!.nilself) (where, "Already stated")
	.nilself = v


function string.UnicodeSafeName (|faststring| fs_in=nil, |string|)
	if .isascii
		if fs_in
			fs_in <~ self
		return self
	
	|| fs = faststring(fs_in)
	for s in self
		if C_Letters[s]
			fs <~ s
		  else
			fs <~ 'x'
			fs.appendhex(s)
	return fs.GetResult(fs_in)




datatype SCBlockage (int)
	flags
		Bits		= 0b111100000	// reserve 1 more bit
	
		Continue	= 0x0040
		Exit		= 0x0080
		Return		= 0x00C0
	
		Quit		= Return		// for now
	
	
	syntax is (|SCBlockage| b, |bool|)
		return self == b
	
	
	
function fdb (|[scfunction]| r)
	opt norefcounts
	cpp_name fdb
	visible
	for f in r
		printline f.Exportname
