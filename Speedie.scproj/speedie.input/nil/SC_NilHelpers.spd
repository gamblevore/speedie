

extend Message {

function RedundantTest (|bool| real, |nilcheckmode|)
	if StdErr.CanAddMore(errorseverity.problem)
		|| str = ("Redundant test on always-real object", "Redundant test on nil object")(real)
		StdErr.NewProblem(self, str)


function NilPropAccess (|bool|)
	opt norefcounts
	|| m = .DotMustBeProperty
	return m and m isnt onmodule


function NilDecl (|scdecl|)
	opt norefcounts
	|| obj = .obj
	if (obj isa scdecl)
		|| l = obj.IsLookupOnly
		if l isa scdecl
			return l
		return obj


function LastInBlock
	opt norefcounts
	.RemoveAfter

	|| arg = .parent
	arg.flags |= kEndsBlock
	.Flags |= kEndsBlock
	|| Test = arg.parent
	require Test istmp "else" // this is really cool!

	while test
		arg = test.prev // if.arg
		require arg.Blocks
		test = arg.parent
		test.flags |= kEndsBlock
		if test.TmpType is kif
			return test.LastInBlock // bubble up :O
}


function @scfunction.LoopExitter (Tranfunc)
	|| f = node.first
		error f
	check node.FindOwningLoop(fn.sourcearg) (node, "Must be within a loop.")
	node.LastInBlock


function scdecl.ParamUpgrade
	if (self is param) and (.NilDeclared isnt stated)
		.NilDeclared = NilState.optional


datatype NilCheckMode (uint)
	flags
		|NilCheckMode| 
		Positive
		Negative
		AllowRedundant
		Active = Positive + Negative

	
	syntax is (|NilCheckMode| other, |bool|)
		return self & other

	syntax isnt (|NilCheckMode| other, |bool|)
		return !(self & other)
	
	function Negate (|NilCheckmode|)
		rz  = (self & positive) << 1
		rz |= (self & negative) >> 1
		rz |= (self &~ active)  << 0

