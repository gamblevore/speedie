

// bugs:
	// * string.addr is real... no reason it should be.



function NilTracker.UseChildAsReal (|message| wrapper, |nilstate|) // a.b, *a, a[0], (a)()
	opt norefcounts
	|| ch = wrapper.first
		Jump(ch)
		|| d = ch.NilDecl
		FailIfNotReal(ch, d)
		return d.NilUsed


extend_module NilTracker {
	dispatch NilTable (NilTrackerFn)
		@thg:	Thing
		@bra:	Bracket
		@type:	Bracket // pretty much
		@func:	Function
		@tmp:   Statement
		@dot:	Property
		@acc:	Access
		@brel:	brel
		@rel:	Rel
		@decl:	Declaration
		@arg:	Argument
		@sstr:	JustReal
		@str:	JustReal
		@num:	JustReal
		@char:	JustReal
		63:     // for the size
	
	TrackerDummies()


function TrackerDummies
	for i in 64
		NilTable[i] := Dummy
					

function Dummy (NilTrackerFn)
	debugger


function Access (NilTrackerFn)
	opt norefcounts
	return T.UseChildAsReal(msg)						// abc[0]

	
function Rel (NilTrackerFn)
	opt norefcounts
	if msg.tmptype is kSetVar					// x = y
		return SetRel(msg, test)
	return ProcessCondRel(msg, test)


function Property (niltrackerfn)
	opt norefcounts

	|| ch = msg.first
	.Jump(ch, test)
	.FailIfNotReal(ch, ch.NilDecl)
	|| dcl = msg.nildecl			#debug_require
	return dcl.NilDeclared


function Statement (NilTrackerFn)
	opt norefcounts
	|| type = msg.TmpType
	if Type is kif
		return .If(msg)
	if type is kReturn
		return .Return(msg)
	if type is kWhile
		return .While(msg)
		
	
function Function (NilTrackerFn)
	opt norefcounts
	|| fp = msg.first
	|| prms = fp.next
	|| fn = prms.obj|scfunction|
	fn.nildebug

	if msg.tmptype == ASMtmp.kTern
		return tern(prms, test)

	if (fp.func == @bra)
		T.UseChildAsReal(fp.first)						// (abc)()

	|| p = prms.first
	for a in fn.args
		|| submode = nilcheckmode.nothing
		if p.isfirst and fn.IsNilChecker and (test is Positive)
			submode = NilCheckMode.PosRed
		.Jump(p, submode)
		.VariableSet(a, p.NilDecl, p, 1)
		if a.pointercount
		p++

	|| ret = fn.ReturnType				#require
	check (ret.NilStated or !ret.SuffersNil) (msg, "Unknown if this function returns nil.")
	return ret.NilDeclared


function Return (NilTrackerFn)
	opt norefcounts

	|| value = msg.first				#require
	|| vd = value.NilDecl
	if vd.suffersnil
		|| vn = vd.nilused
		|| rd = T.fn.ReturnType
		|| r  = rd.NilDeclared
		if r is real  and vn is Nilish
			error (msg, "Nil returned, against function declaration!")
		rd.nilused |= vn // find the answer at the end


function While (NilTrackerFn)
	opt norefcounts

	|| beginning = t.DeclCount
	.jump(msg.first, NilCheckMode.positive)
	.RunAll(msg.second)
	t.Merge(Beginning) // while seems very simple?


function If (NilTrackerFn)
	opt norefcounts
	|| Beginning = T.DeclCount
	|| cond = msg.first,  || arg1 = cond.next,  || Else = arg1.next,  || arg2 = else.last

	.jump(cond, NilCheckMode.positive)
	.RunAll(arg1)
	|| FirstHalf = T.DeclCount
													// IF X {y=y1} ELSE {y=y2}
	t.Restore(Beginning)							// (undo y=y1 but keep track of it)
	.jump(cond, NilCheckMode.negative)
	if arg2.isfirst									// ELSE {y=y2}
		.RunAll(arg2)
	  elseif arg2
		.if(else)
	
	if arg1.blocks
		if !arg2.Blocks
			t.Clear(Beginning, FirstHalf)
		  else
			t.undo(Beginning)						// clear for owners
		
	  elseif arg2.blocks
		t.Undo(FirstHalf)							// IF X {y=y1} ELSE {return}
		
	  else
		T.DeclCount = FirstHalf						// (skip arg2, its already current)
		t.Merge(Beginning)							// (merges y=y1, y=y2)


function Tern (Niltrackerfn)
	opt norefcounts
	|| C = msg.first
	|| A = C.next
	|| B = A.next

	debugat
	|| BeginState = T.DeclCount

	.jump(C, nilcheckmode.positive)
	rz = .Jump(A, test)
	t.Restore(BeginState)

	.jump(C, nilcheckmode.negative)
	rz |= .Jump(B, test)
	t.merge(BeginState)								// IF X {y=y1}

		
function Thing (NilTrackerFn)
	opt norefcounts
	|| dcl = msg.nildecl			#debug_require
	if test is Active
		if dcl.NilUsed is Either
			dcl.ParamUpgrade
			return T.TestedNilness(dcl, nilstate.realish)
	
		if dcl.NilDeclared is Either
			msg.RedundantTest(dcl.nilused is realish)
	return dcl.NilUsed


function Argument (Niltrackerfn)
	opt norefcounts
	ifn msg in @bra
	.RunAll(msg, test)

	
function Bracket (Niltrackerfn)
	opt norefcounts
	return .Jump(*msg, test)
	

function JustReal (Niltrackerfn)
	opt norefcounts
	return nilstate.realish


function ProcessCondRel (Niltrackerfn)
	opt norefcounts
	|| ll = msg.first
	|| op = ll.next
	|| rr = op.next
	|| scop = op.obj|SCOperator|

	if scop.IsCompare
		|| LNil = ll.IsNowNil
		|| RNil = rr.IsNowNil
		ifn lnil or rnil			// if (a > b)
			.jump(ll, test)
			.jump(rr, test)
			return NilState.Real
		
		if (lnil and rnil)
			return ll.RedundantTest(false)
		expect (scop.IsNilTest) (op, "Can't use this operator on nil. Use != or ==.")

		|| side = (rr, ll)(lnil)
		.jump(side, test) // can handle !(a == nil)
		return NilState.real


	|| andor = scop.IsAndOr
	if !andor		// bit ops or math		// (ptr+1) or (1+ptr) still needs nilness check
		return .Jump(ll).Worst(.Jump(rr))


	// needs to take into account whether test is positive or negative!
	if (andor == SCOperator.AND) or msg.IsNilSafe // isnilsafe will speed things up a lot for ints/bools and stuff
		.Jump(ll, NilCheckMode.positive)
		.Jump(rr, NilCheckMode.positive)
		return NilState.real
	

	|| First = t.DeclCount // if (!a or a.length)
	.Jump(ll, NilCheckMode.positive)
	t.Restore(First)
	.Jump(ll, NilCheckMode.negative)
	
	|| second = t.DeclCount
	.Jump(rr, NilCheckMode.positive)
	return NilState.real
	//.merge(first, second) // we want to ignore the negative state... just merge the two values
	// so we'll need 3 ranges. A-Positive, A-negative, B-positive...
	// then we merge the two positives


function Brel (Niltrackerfn)
	opt norefcounts
	|| b = *msg.name
	|| f = *msg
	if b == '*'
		return t.UseChildAsReal(msg)										// *abc
	if b == '!'
		return .Jump(f, test.Negate)
	if b == '&'
		Jump(f, test)
		return NilState.Real // its obviously real


function Declaration (niltrackerfn)
	opt norefcounts
	|| rel = msg.last
	if rel == @rel
		setrel(rel)
	// the decl-checker is done in variableset    // checks if we are setting a ? into a ! :)
	

function SetRel (niltrackerfn)
	opt norefcounts
	|| l = msg.first
	|| B = .JumpDecl(msg.last) // c++ runs B first...
	|| A = .JumpDecl(l)
	.VariableSet(A, B, l, 0)


function JumpDecl (|message| msg, |scdecl|)
	.Jump(msg)
	return msg.NilDecl


function Jump (NilTrackerFn)
	pragma inline
	opt norefcounts
	return (NilTable[msg.func])(msg, test)


function RunAll (NilTrackerFn)
	opt norefcounts
	for s.fast in msg
		if s.IsLast
			return .jump(s, test)
		.Jump(s)


function NilMsg (|message| err, |scdecl| d, |bool| PointerInferred, |string|)
	if PointerInferred
		return "Nil Error: Pointed-to can't be nil."
	if d isnt param
		if err == @thg
			return "Nil Access: Needs 'if' wrapping."
		return "Nil Access here."
	return "Nil Error: Don't declare with '?'... or test for nil."


function VariableSet (|scdecl| Recv, |scdecl| Sent, |message| ErrPlace, |uint| IsParam) // setrel, relset
	opt norefcounts
	require recv.suffersnil

	if recv.NilDeclared isnt nilish
		require .FailIfNotReal(errplace, sent, (isparam>>1)!=0)
	  
	  elseif isparam										// a param that can accept nil
		|| recnil = recv.nildeclared
		check ((recnil is stated) or (sent.NilUsed isnt Nilish)) (errplace, "Unknown if this parameter accepts nil.")
		if IsParam == 2
			T.SetNilness(sent, recnil)
			debugger 										// its too hard to imagine. just figure this out later
			// if (a and func(&a))
	  else
		T.SetNilness(recv, sent.nilused)
		
	
	// so what if we are sending the address of a thing? to a function param...
	// sigh.
	// shouldn't the function param caller deal with that?
	// makes more sense! 
	if recv.PointerCount == 1	// |!&!&struct| abc = f
	// for pointers to pointers? use the declared type!
		return .VariableSet(recv.internal, sent.internal, errplace, IsParam<<1)



function FailIfNotReal (|message| err, |scdecl| d, |bool| PointerInferred=false,  |bool|)
	opt norefcounts
	if d.NilUsed isnt Nilish
		return true

	if !PointerInferred  and  d is param  and  d.NilDeclared is Stated
		d.NilDeclared = NilState.real
		d.nilused = NilState.Realish
		return true

	error (err, NilMsg(err, d, PointerInferred))
}


function message.IsNilSafe (|bool|)
	// just a speed optimisation...  can check if all values are datatypes or whatever :) then just ignore those nodes
	return false


// !(a and b) --> (!a or !b)
// !(a or  b) --> (!a and !b)

