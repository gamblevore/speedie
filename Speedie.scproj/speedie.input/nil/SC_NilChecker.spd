


// We need to probably combine "merge" and "restore" and "negate"
// we are always merging two branches... one just might happen to be nil
// and one might happen to return.
// for example:
// 
// if !x
//    x = realobject()
// how to merge the states here? If we combine the previous state of "maybe" with the new state of "real"
// we get still "maybe". So we need to combine both branches instead of the parent branch.
// what about returns?

// if !x
// 		return

// hmmm... perhaps we can treat this differently. I mean... just apply the negative and be done with it.
// I think we are gonna calculate both states/approaches at once.
// we only have "StateA" and "StateB"... then we can swap between them or choose one.
// many cases to solve!!

prototype NilTrackerFn (|&Niltracker| self, |message| msg, |branchstate| Y=branchstate.always, |bool| AllowRedundant=false)
	


function scfunction.canNil (|bool|)
	return !(.IsMacro and !.IsWrapper and .isOK)


function scfunction.LimitTests (|bool|)
	|| c = .Lookup #require
	require c.name contains "NilTest"

	require .SourceArg contains "nilcheck"

	
function NilTracker.UseChildAsReal (|message| wrapper, |bool|) // a.b, *a, a[0], (a)()
	opt norefcounts
	|| ch = wrapper.first
		RunInner(self, ch) // (fn * 0.5[])(a,b) // how do I know if this is real? run the child first (a tern here)
		return .FailIfNotReal(ch, ch.NilDecl)	
	


extend_module NilTracker {
	dispatch NilTable (NilTrackerFn)
		@thg: ProcessCondThg

function Function (NilTrackerFn)
	opt norefcounts
	|| fp = msg.first
	|| prms = fp.next
	|| fn = prms.obj|scfunction|
	if msg.tmptype == ASMtmp.kTern
		return tern(self, prms)

	if (fp.func == @bra)
		require .UseChildAsReal(fp.first)						// (abc)()
	
	|| ret = fn.ReturnType
		check (!ret.SuffersNil or ret.IsStated) (msg, "Unknown if this function returns nil.")

	|| p = prms.first
	if fn.IsNilChecker and (y is always)
		ProcessCondThg(self, p, y, true)		// if (!x.length) // x can be nil
	
	
	for a in fn.args
		.VariableSet(a, p.NilDecl, p, 1)
		if p.HasAny
			RunInner(self, p)
		p++
	
	debugat // so what do we return if it is a nilchecker??
		


function Return (NilTrackerFn)
	opt norefcounts

	|| value = msg.first				#require
	|| vd = value.NilDecl
	if vd.suffersnil
		|| vn = vd.nilused
		|| rd = .fn.ReturnType
		|| r  = rd.NilDeclared
		if r is real  and vn is Nilish
			error (msg, "Nil returned, against function declaration!")
		rd.nilused |= vn // find the answer at the end


function If (NilTrackerFn)
	opt norefcounts	
	|| BeginState = .DeclCount
	|| cond = msg.first
	|| arg1 = cond.next
	|| Else = arg1.next
	|| arg2 = else.Last

	.IfDepth++
	ProcessCond(self, cond, BranchState.Always) // SetVars during conds actually should go into the parent branch... not undoable.
	.IfDepth++
	RunNormal(self, arg1)
	
	if arg2												// IF X {y=y1} ELSE {y=y2}
		|| Arg1Only = .DeclCount
		.Restore(BeginState)							// (undo y=y1 but keep track of it)
		.IfDepth--
		ProcessCond(self, cond, BranchState.Never)
		if arg2.IsFirst									// ELSE {y=y2}
			.IfDepth++
			RunNormal(self, arg2)
			.IfDepth -= 2
		  else											// ELSEIF (Y) {y=y2}
			.IfDepth--
			if(self, else)
		
		if arg1.Blocks
			0
		  elseif arg2.blocks							// (use arg1's state, <2% likelyhood)
			.Undo(BeginState)							// IF X {y=y1} ELSE {return}
		  else
			.DeclCount = Arg1Only						// (skip arg2, its already current)
			.merge(BeginState)							// (merges y=y1, y=y2)
		
	  else
		.IfDepth -= 2
		if arg1.Blocks
			.Undo(BeginState)							// IF X {y=y1, return}
			ProcessCond(self, cond, branchstate.never)
		  else
			.merge(BeginState)							// IF X {y=y1}

// 1 y: false
// if
// 2 x: True
// 3 y: true
// else
// 4 x: false
// 5 y: true



function Tern (Niltrackerfn)
	opt norefcounts
	|| cond = msg.first
	|| A = cond.next
	|| B = A.next

	debugat
	.IfDepth++
	ProcessCond(self, cond, branchstate.always)
	.IfDepth++
	|| BeginState = .DeclCount
	RunNormal(self, A)
	.Restore(BeginState)
	ProcessCond(self, cond, branchstate.never)
	RunNormal(self, B)
	.merge(BeginState)								// IF X {y=y1}
	.IfDepth -= 2
	// needs to propagate through bras and typescasts into a setrel



function ProcessCondThg (NilTrackerFn)
	opt norefcounts
	if Y >= nilstate.Either			// if a or b
	|| dest = Y|NilState|
	|| dcl = msg.nildecl			#debug_require
	|| u = dcl.NilUsed
	
	if u == NilState.Either
		if (dcl is param) and (dcl.NilDeclared isnt stated)
			dcl.NilDeclared = NilState.optional
		return .TestedNilness(dcl, dest)

	if !AllowRedundant and dcl.NilDeclared is Either
		msg.RedundantBranch(y.syntaxcast)


function ProcessCondDot (Niltrackerfn)
	opt norefcounts
	|| exp = msg.first
	RunInner(self, exp)
	|| dcl = msg.nildecl			#debug_require
	if dcl.NilDeclared isnt Either // perhaps allowing redundant checks sometimes is nice?
		msg.RedundantBranch(y.syntaxcast)


function RunBra (Niltrackerfn)
	opt norefcounts
	|| c = *msg
	|| d = (.IfDepth&1) and (c == @arg)
	.IfDepth += d	// shouldn't be doing this here.
	Runinner(self, c, y) // || x = a > b
	.IfDepth -= d   // || x = (a > b)
					// both are good!
					// we long as we know "Where we are... we don't need to fool around with an ifdepth"



function Brel (Niltrackerfn)
	// MERRGEEEEE
	opt norefcounts
	|| b = *msg.name
	|| f = msg.first
	if b == '!'
		|| old = .NeedCond()
		RunInner(self, f, branchstate.always)
		.NegateCond(old)
		// x = !a // optimise away?

		// hmmm... interesting... 
		// x = !(a and a.length)
		// this one has an interesting problem...
		// when we send y.not... what does that do?
		// it makes condthing set it to nil? lets see.
		// if (!(a and a.length))
		// woah. We need to first verify that a exists... before making it not exist???
		// the thing is... if !(a and b)
		// that gets turned into a perhaps...
		// perhaps... we need to actually...  just do everything in the positive, and not it after?
	  elseif b == '*'
		.UseChildAsReal(msg)										// *abc
		|| pd = f.nildecl
			.FailIfNotReal(f, pd)
		return ProcessCond(self, f, y)
	  else
		RunInner(self, f, y)
	

function ProcessCondRel (Niltrackerfn)
	opt norefcounts
	|| ll = msg.first
	|| op = ll.next
	|| rr = op.next
	|| scop = op.obj|SCOperator|

	if scop.IsCompare
		|| LNil = (ll.obj as scdecl).IsNowNil
		|| RNil = (rr.obj as scdecl).IsNowNil
		if lnil or rnil
			expect (scop.IsNilTest) (op, "Can't use this operator on nil. Use != or ==.")
			if (lnil and rnil)
				return msg.RedundantBranch(true)
			if scop.HasEquals // if (a==nil or b==nil) return else a.a(b.b)
				y = y.not
			|| side = (rr, ll)(lnil)
			return ProcessCond(self, side, Y)
		return
	
	
	if scop.IsAndOr
		if scop.IsAndOr == 3 // x = (a and b)
			if y == BranchState.Never
				y = BranchState.Perhaps
		  else // x = !(a or b)
			if y == BranchState.always
				y = BranchState.Perhaps
		
		ProcessCond(self, ll, Y)
		ProcessCond(self, rr, Y)
		return

		// what about the cond?
		// if (a and b)			// a yes,   b yes		... after a may, b may
		// if (!a and !b)		// a no,    b no    	... after a may, b may
		// if (!(a and b))		// a may,	b may   	... after a yes, b yes
		// if (!(!a and !b)		// a may,	b may   	... after a no,  b no
		// if (a or b)			// a may,	b may		... after a no,  b no		
		// if (!(a or b))		// a no,	b no		... after a may, b may
		// if (!(!a or !b))		// a may,	b may		... after a no,  b no 
		// if !msg or *msg
		// if (abc and m) or (*m == 1)

// its a bit ops by now. all others would have gone.
	if ll.hasany
		RunNormal(self, ll)
	if rr.hasany
		RunNormal(self, rr)


function Decl (niltrackerfn)
	opt norefcounts
	|| exp = msg.last
	if exp == @rel
		exp = exp.last
		|| d = exp.AsDecl
		|| r = msg.AsDecl
		r.NilTake(d)	
	

function SetRel (niltrackerfn)
	opt norefcounts
	|| l = msg.first
	|| r = msg.last
	if l.hasany
		RunNormal(self, l)
	if r.hasany // x = func() // we wanna actually call .func! not loop over .funcs insides!
		RunNormal(self, r)
	.VariableSet(l.nildecl, r.nildecl, r, 0)



function ProcessCond (Niltrackerfn)
	opt norefcounts
	|| fn = msg.func
	if fn == @thg
		return ProcessCondThg(self, msg, y, false)
	if fn == @dot
		return ProcessCondDot(self, msg, y)
	if fn == @bra or @type
		return ProcessCond(self, msg.first, Y)
	if fn == @rel
		return ProcessCondRel(self, msg, y)
	if fn == @func
		return function(self, msg, y)
	if fn == @brel
		return brel(self, msg, y)
	debugger 
	RunNormal(self, msg)


function RunInner (NilTrackerFn)
	opt norefcounts
	|| f = msg.func
//	|| fn = NilTable[f]
//		(fn)()
	
	if (f == @dot)
		if msg.NilPropAccess
			.UseChildAsReal(msg)					// abc.var
	  elseif (f == @acc) 
		.UseChildAsReal(msg)						// abc[0]
	  elseif (f == @brel) 
		Brel(self, msg, y)
	  elseif (f == @rel)
		if msg.tmptype is kSetVar					// x = y
			SetRel(self, msg)
		  else
			ProcessCondRel(self, msg)
	  elseif (f == @func)
		Function(self, msg, y)						// || x = y.length,  if x
													// should this be a CondChecker?
	  elseif (f == @tmp)
		|| type = msg.TmpType
		if Type is kif
			If(self, msg)
		  elseif type is kReturn
			Return(self, msg)
	  elseif (f == @decl)
		Decl(self, msg)
	  elseif (f == @bra)
		RunBra(self, msg, y) // surely this should be the same as the cond-bra? or not? its not within a cond really...
		
	  elseif (f == @arg)
		debugger // hmm?
			
	  elseif msg.HasAny
		if msg.IsLast
			return RunNormal(self, msg)				// tail-call opt
		  else
			RunNormal(self, msg)		  


function RunNormal (NilTrackerFn)
	opt norefcounts
	for s.fast in msg
		RunInner(self, msg)


function NilMsg (|message| err, |scdecl| d, |uint| PointerInferred, |string|)
	if PointerInferred
		return "Nil Error: Pointed-to can't be nil."
	if d isnt param
		if err == @thg
			return "Nil Access: Needs 'if' wrapping."
		return "Nil Access here."
	return "Nil Error: Don't declare with '?'... or test for nil."



}



function niltracker.VariableSet (|scdecl| recv, |scdecl| sent, |message| errplace, |uint| IsParam) // setrel, relset
	opt norefcounts
	require recv.suffersnil

	if recv.NilDeclared isnt nilish
		require .FailIfNotReal(errplace, sent, isparam>>1)
	  
	  elseif isparam										// a param that can accept nil
		|| recnil = recv.nildeclared
		check ((recnil is stated) or (sent.NilUsed isnt Nilish)) (errplace, "Unknown if this parameter accepts nil.")
		if IsParam == 2
			.SetNilness(sent, recnil)
			debugger 										// its too hard to imagine. just figure this out later
			// if (a and func(&a))
	  else
		.SetNilness(recv, sent.nilused)
		
			
	if recv.PointerCount == 1	// |!&!&struct| abc = f
	// what about pointers to pointers to something? // just give up? i think so...
		return .VariableSet(recv.internal, sent.internal, errplace, IsParam<<1)


function niltracker.FailIfNotReal (|message| err, |scdecl| d, |uint| PointerInferred=0,  |bool|)
	opt norefcounts
	if d.NilUsed isnt Nilish
		return true

	if !pointerinferred  and  d is param  and  d.NilDeclared is Stated
		d.NilDeclared = NilState.real
		d.nilused = NilState.Realish
		return true

	error (err, nilmsg(err, d, PointerInferred) )




