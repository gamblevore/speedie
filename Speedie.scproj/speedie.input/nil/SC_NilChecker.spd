


prototype NilTrackerFn (|message| msg, |NilCheckMode| Test=0, |nilstate|)

	
function NilTracker.UseChildAsReal (|message| wrapper) // a.b, *a, a[0], (a)()
	opt norefcounts
	|| ch = wrapper.first
		Jump(ch) // (fn * 0.5[])(a,b) // how do I know if this is real? run the child first (a tern here)
		FailIfNotReal(ch, ch.NilDecl)	
	


extend_module NilTracker {
	dispatch NilTable (NilTrackerFn)
		@thg:	Thing
		@bra:	Bracket
		@type:	Bracket // pretty much
		@func:	Function
		@tmp:   Statement
		@dot:	Property
		@acc:	Access
		@brel:	brel
		@rel:	Rel
		@decl:	Declaration
		@arg:	Argument
		63:     // for the size
	
	TrackerDummies()


function TrackerDummies
	for i in 64
		NilTable[i] := Dummy
					

function Dummy (NilTrackerFn)
	debugger // do we get this ever?


function Access (NiLTrackerFn)
	opt norefcounts
	T.UseChildAsReal(msg)						// abc[0]

	
function Rel (NilTrackerFn)
	opt norefcounts
	if msg.tmptype is kSetVar					// x = y
		SetRel(msg, test)
	  else
		ProcessCondRel(msg, test)


function Property (niltrackerfn)
	opt norefcounts

	if !msg.NilPropAccess // remove test
	|| ch = msg.first
	Jump(ch)
	FailIfNotReal(ch, ch.NilDecl)	
	T.UseChildAsReal(msg)						// abc.var
	|| dcl = msg.nildecl			#debug_require
	if dcl.NilDeclared isnt Either // perhaps allowing redundant checks sometimes is nice?
		msg.RedundantBranch(dcl.nilused is realish)

	//// version two?
	// so what if we are dong this:
	// x = a.b
	// or this?
	// if (a.b)
	// perhaps the redundant check isn't needed at this point, but some other point?
	// either way... we need to know "Where we are in the code". in some cond, or not?


function Statement (NilTrackerFn)
	opt norefcounts
	|| type = msg.TmpType
	if Type is kif
		return If(msg)
	if type is kReturn
		return Return(msg)
	if type is kWhile
		return While(msg)
	debugger 
		
	
function Function (NilTrackerFn)
	opt norefcounts
	|| fp = msg.first
	|| prms = fp.next
	|| fn = prms.obj|scfunction|
	if msg.tmptype == ASMtmp.kTern
		return tern(prms)

	if (fp.func == @bra)
		T.UseChildAsReal(fp.first)						// (abc)()

	|| p = prms.first
	if fn.IsNilChecker and (test is Active)
		Thing(p, NilCheckMode.AllowRedundant)		// if (!x.length) // x can be nil
	
	for a in fn.args
		VariableSet(a, p.NilDecl, p, 1)
		JumpAny(p)
		p++

	|| ret = fn.ReturnType				#require
	check (ret.IsStated or !ret.SuffersNil) (msg, "Unknown if this function returns nil.")
	return ret.NilDeclared
	


function Return (NilTrackerFn)
	opt norefcounts

	|| value = msg.first				#require
	|| vd = value.NilDecl
	if vd.suffersnil
		|| vn = vd.nilused
		|| rd = T.fn.ReturnType
		|| r  = rd.NilDeclared
		if r is real  and vn is Nilish
			error (msg, "Nil returned, against function declaration!")
		rd.nilused |= vn // find the answer at the end


function While (NilTrackerFn)
	opt norefcounts

	|| Cond = msg.first
	|| Arg = cond.next				#require
	// i guess its different cos of exits/continues working differently
	// and loops and stuff.


function If (NilTrackerFn)
	opt norefcounts	
	|| BeginState = T.DeclCount
	|| cond = msg.first
	|| arg1 = cond.next
	|| Else = arg1.next
	|| arg2 = else.Last

	T.IfDepth++
	jump(cond, BranchState.Always) // SetVars during conds actually should go into the parent branch... not undoable.
	T.IfDepth++
	RunAll(arg1)
	
	if arg2												// IF X {y=y1} ELSE {y=y2}
		|| Arg1Only = T.DeclCount
		Restore(BeginState)								// (undo y=y1 but keep track of it)
		T.IfDepth--
		jump(cond, BranchState.Never)
		if arg2.IsFirst									// ELSE {y=y2}
			T.IfDepth++
			RunAll(arg2)
			T.IfDepth -= 2
		  else											// ELSEIF (Y) {y=y2}
			T.IfDepth--
			if(else)
		
		if arg1.Blocks
			0
		  elseif arg2.blocks							// (use arg1's state, <2% likelyhood)
			Undo(BeginState)							// IF X {y=y1} ELSE {return}
		  else
			T.DeclCount = Arg1Only						// (skip arg2, its already current)
			merge(BeginState)							// (merges y=y1, y=y2)
		
	  else
		T.IfDepth -= 2
		if arg1.Blocks
			Undo(BeginState)							// IF X {y=y1, return}
			jump(cond, branchstate.never)
		  else
			merge(BeginState)							// IF X {y=y1}


function Tern (Niltrackerfn)
	opt norefcounts
	|| cond = msg.first
	|| A = cond.next
	|| B = A.next

	debugat
	T.IfDepth++
	jump(cond, branchstate.always)
	T.IfDepth++
	|| BeginState = T.DeclCount
	rz  = jumpany(A)
	Restore(BeginState)
	jump(cond, branchstate.never)
	rz |= jumpany(B)
	merge(BeginState)								// IF X {y=y1}
	T.IfDepth -= 2

	// needs to propagate through bras and typescasts into a setrel


		
function Thing (NilTrackerFn)
	opt norefcounts
	if test {
//	|| dest = Y|NilState|
	|| dcl = msg.nildecl			#debug_require
	
	if dcl.NilUsed is Either
		dcl.ParamUpgrade
		return T.TestedNilness(dcl, nilstate.realish)

	if dcl.NilDeclared is Either
		msg.RedundantBranch(dcl.nilused is realish)
}


function Argument (Niltrackerfn)
	opt norefcounts
	ifn msg in @bra
	|| d = t.IfDepth&1
	
	t.IfDepth += d
	RunAll(msg, test)
	t.IfDepth -= d   // || x = (a > b)
					// both are good!
					// we long as we know "Where we are... we don't need to fool around with an ifdepth"
	
function Bracket (Niltrackerfn)
	opt norefcounts
	return Jump(*msg, test)


function Brel (Niltrackerfn)
	opt norefcounts
	|| b = *msg.name
	|| f = *msg
	if b == '*'
		t.UseChildAsReal(msg)										// *abc
		|| pd = f.nildecl
			.FailIfNotReal(f, pd)
	if b != '&'
		return Jump(f, test)
	|| old = t.NeedCond()
	rz = Jump(f, nilcheckmode.active)
	t.NegateCond(old)

	

function ProcessCondRel (Niltrackerfn)
	opt norefcounts
	|| ll = msg.first
	|| op = ll.next
	|| rr = op.next
	|| scop = op.obj|SCOperator|

	if scop.IsCompare
		|| LNil = (ll.obj as scdecl).IsNowNil
		|| RNil = (rr.obj as scdecl).IsNowNil
		if lnil or rnil
			expect (scop.IsNilTest) (op, "Can't use this operator on nil. Use != or ==.")
			if (lnil and rnil)
				return msg.RedundantBranch(true)
			|| side = (rr, ll)(lnil)
			return jump(side, scop.HasEquals|int|)
		return 0
	
	
	if scop.IsAndOr
//		if scop.IsAndOr == 3 // x = (a and b)
//			if y == BranchState.Never
//				y = BranchState.Perhaps
//		  else // x = !(a or b)
//			if y == BranchState.always
//				y = BranchState.Perhaps
		
		jump(ll, NilCheckMode.Active)
		jump(rr, NilCheckMode.Active)
		return 0

// its a bit ops by now. all others would have gone.
	JumpAny(ll)
	JumpAny(rr)


function Declaration (niltrackerfn)
	opt norefcounts
	|| exp = msg.last
	if exp == @rel
		setrel(exp)
	

function SetRel (niltrackerfn)
	opt norefcounts
	|| l = msg.first
	|| r = msg.last
	JumpAny(l)
	JumpAny(r)

	// || x = &b // OK... x is not nil
	// but how do we know this? &abc does not return anything, not via our current code.
	// it has a decl... but like... what kind? a shared one? in this case... no?
	// i think getting a pointer will never share the decl.

	.VariableSet(l.nildecl, r.nildecl, r, 0)


function JumpAny (NilTrackerFn)
	pragma inline
	if msg.HasAny
		return .Jump(msg, test)

function Jump (NilTrackerFn)
	pragma inline
	opt norefcounts
	return (NilTable[msg.func])(msg, test)


function RunAll (NilTrackerFn)
	opt norefcounts
	for s.fast in msg
		if s.IsLast
			return jump(msg, test)
		Jump(msg)


function NilMsg (|message| err, |scdecl| d, |uint| PointerInferred, |string|)
	if PointerInferred
		return "Nil Error: Pointed-to can't be nil."
	if d isnt param
		if err == @thg
			return "Nil Access: Needs 'if' wrapping."
		return "Nil Access here."
	return "Nil Error: Don't declare with '?'... or test for nil."


function VariableSet (|scdecl| recv, |scdecl| sent, |message| errplace, |uint| IsParam) // setrel, relset
	opt norefcounts
	require recv.suffersnil

	if recv.NilDeclared isnt nilish
		require .FailIfNotReal(errplace, sent, isparam>>1)
	  
	  elseif isparam										// a param that can accept nil
		|| recnil = recv.nildeclared
		check ((recnil is stated) or (sent.NilUsed isnt Nilish)) (errplace, "Unknown if this parameter accepts nil.")
		if IsParam == 2
			T.SetNilness(sent, recnil)
			debugger 										// its too hard to imagine. just figure this out later
			// if (a and func(&a))
	  else
		T.SetNilness(recv, sent.nilused)
		
			
	if recv.PointerCount == 1	// |!&!&struct| abc = f
	// what about pointers to pointers to something? // just give up? i think so...
		return .VariableSet(recv.internal, sent.internal, errplace, IsParam<<1)



function FailIfNotReal (|message| err, |scdecl| d, |uint| PointerInferred=0,  |bool|)
	opt norefcounts
	if d.NilUsed isnt Nilish
		return true

	if !pointerinferred  and  d is param  and  d.NilDeclared is Stated
		d.NilDeclared = NilState.real
		d.nilused = NilState.Realish
		return true

	error (err, nilmsg(err, d, PointerInferred))


}




