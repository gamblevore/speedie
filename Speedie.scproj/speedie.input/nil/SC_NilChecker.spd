

// !(a and b) --> (!a or !b)
// !(a or  b) --> (!a and !b)
// well thats simplififes everything



prototype NilTrackerFn (|message| msg, |NilCheckMode| Test=0,  |nilstate|)

	
function NilTracker.UseChildAsReal (|message| wrapper, |nilstate|) // a.b, *a, a[0], (a)()
	opt norefcounts
	|| ch = wrapper.first
		Jump(ch) // (fn * 0.5[])(a,b) // how do I know if this is real? run the child first (a tern here)
		|| d = ch.NilDecl
		FailIfNotReal(ch, d)
		return d.NilUsed


extend_module NilTracker {
	dispatch NilTable (NilTrackerFn)
		@thg:	Thing
		@bra:	Bracket
		@type:	Bracket // pretty much
		@func:	Function
		@tmp:   Statement
		@dot:	Property
		@acc:	Access
		@brel:	brel
		@rel:	Rel
		@decl:	Declaration
		@arg:	Argument
		63:     // for the size
	
	TrackerDummies()


function TrackerDummies
	for i in 64
		NilTable[i] := Dummy
					

function Dummy (NilTrackerFn)
	debugger // do we get this ever?


function Access (NilTrackerFn)
	opt norefcounts
	return T.UseChildAsReal(msg)						// abc[0]

	
function Rel (NilTrackerFn)
	opt norefcounts
	if msg.tmptype is kSetVar					// x = y
		return SetRel(msg, test)

	return ProcessCondRel(msg, test)


function Property (niltrackerfn)
	opt norefcounts

	|| ch = msg.first
	.Jump(ch, test)
	.FailIfNotReal(ch, ch.NilDecl)
	|| dcl = msg.nildecl			#debug_require
	if test is Active
		if dcl.NilDeclared isnt Either // perhaps allowing redundant checks sometimes is nice?
			msg.RedundantTest(dcl.nilused is realish)
	return dcl.NilDeclared


function Statement (NilTrackerFn)
	opt norefcounts
	|| type = msg.TmpType
	test = NilCheckMode.positive
	if Type is kif
		return If(msg, test)
	if type is kReturn
		return Return(msg, test)
	if type is kWhile
		return While(msg, test)
	debugger 
		
	
function Function (NilTrackerFn)
	opt norefcounts
	|| fp = msg.first
	|| prms = fp.next
	|| fn = prms.obj|scfunction|

	if msg.tmptype == ASMtmp.kTern
		return tern(prms, test)

	if (fp.func == @bra)
		T.UseChildAsReal(fp.first)						// (abc)()

	|| p = prms.first
	if fn.IsNilChecker and (test is Positive)
		.Thing(p, NilCheckMode.AllowRedundant)		// if (!x.length) // x can be nil
	
	for a in fn.args
		.VariableSet(a, p.NilDecl, p, 1)
		.Jump(p)
		p++

	|| ret = fn.ReturnType				#require
	check (ret.IsStated or !ret.SuffersNil) (msg, "Unknown if this function returns nil.")
	return ret.NilDeclared
	


function Return (NilTrackerFn)
	opt norefcounts

	|| value = msg.first				#require
	|| vd = value.NilDecl
	if vd.suffersnil
		|| vn = vd.nilused
		|| rd = T.fn.ReturnType
		|| r  = rd.NilDeclared
		if r is real  and vn is Nilish
			error (msg, "Nil returned, against function declaration!")
		rd.nilused |= vn // find the answer at the end


function While (NilTrackerFn)
	opt norefcounts

	|| beginning = t.DeclCount
	.jump(msg.first, NilCheckMode.positive)
	.RunAll(msg.second)
	t.Merge(Beginning) // while seems very simple?


function Else (niltrackerfn)
	opt norefcounts
	if msg.isfirst									// ELSE {y=y2}
		.RunAll(msg)
	  elseif msg
		.if(msg.Parent, test)


function If (NilTrackerFn)
	opt norefcounts
	|| Beginning = T.DeclCount
	|| cond = msg.first,  || arg1 = cond.next,  || Else = arg1.next,  || arg2 = else.last

	.jump(cond, test)
	.RunAll(arg1)
	|| FirstHalf = T.DeclCount

													// IF X {y=y1} ELSE {y=y2}
	t.Restore(Beginning)							// (undo y=y1 but keep track of it)
	.jump(cond, test.negate)
	.else(arg2)
	
	if arg1.blocks
		if !arg2.Blocks
			t.Clear(Beginning, FirstHalf)
		  else
			t.undo(Beginning)						// clear for owners
		
	  elseif arg2.blocks
		t.Undo(FirstHalf)							// IF X {y=y1} ELSE {return}
		
	  else
		T.DeclCount = FirstHalf						// (skip arg2, its already current)
		t.Merge(Beginning)							// (merges y=y1, y=y2)


function Tern (Niltrackerfn)
	opt norefcounts
	|| C = msg.first
	|| A = C.next
	|| B = A.next

	debugat
	|| BeginState = T.DeclCount

	.jump(C, nilcheckmode.positive)
	rz = .Jump(A, test)
	t.Restore(BeginState)

	.jump(C, nilcheckmode.negative)
	rz |= .Jump(B, test)
	t.merge(BeginState)								// IF X {y=y1}


		
function Thing (NilTrackerFn)
	opt norefcounts
	|| dcl = msg.nildecl			#debug_require
	if test is Active
		if dcl.NilUsed is Either
			dcl.ParamUpgrade
			return T.TestedNilness(dcl, nilstate.realish)
	
		if dcl.NilDeclared is Either
			msg.RedundantTest(dcl.nilused is realish)
	return dcl.NilUsed


function Argument (Niltrackerfn)
	opt norefcounts
	ifn msg in @bra
	.RunAll(msg, test)

	
function Bracket (Niltrackerfn)
	opt norefcounts
	return .Jump(*msg, test)
	

function ProcessCondRel (Niltrackerfn)
	opt norefcounts
	|| ll = msg.first
	|| op = ll.next
	|| rr = op.next
	|| scop = op.obj|SCOperator|

	if scop.IsCompare
		|| LNil = ll.IsNowNil
		|| RNil = rr.IsNowNil
		ifn lnil or rnil			// if (a > b)
			.jump(ll, test)
			.jump(rr, test)
			return NilState.Real
		
		if (lnil and rnil)
			return ll.RedundantTest(false)
		expect (scop.IsNilTest) (op, "Can't use this operator on nil. Use != or ==.")

		|| side = (rr, ll)(lnil)
		.jump(side, test) // can handle !(a == nil)
		return NilState.real


	|| andor = scop.IsAndOr
	if !andor		// bit ops or math		// (ptr+1) or (1+ptr) still needs nilness check
		return .Jump(ll).Worst(.Jump(rr))


	// needs to take into account whether test is positive or negative!
	if (andor == SCOperator.AND) or msg.IsNilSafe // isnilsafe will speed things up a lot for ints/bools and stuff
		.Jump(ll, NilCheckMode.positive)
		.Jump(rr, NilCheckMode.positive)
		return NilState.real
	

	|| First = t.DeclCount // if (!a or a.length)
	.Jump(ll, NilCheckMode.positive)
	t.Restore(First)
	.Jump(ll, NilCheckMode.negative)
	
	|| second = t.DeclCount
	.Jump(rr, NilCheckMode.positive)
	return NilState.real
	//.merge(first, second) // we want to ignore the negative state... just merge the two values
	// so we'll need 3 ranges. A-Positive, A-negative, B-positive...
	// then we merge the two positives


function Brel (Niltrackerfn)
	opt norefcounts
	|| b = *msg.name
	|| f = *msg
	if b == '*'
		return t.UseChildAsReal(msg)										// *abc
	if b == '!'
		return .Jump(f, test.Negate)
	if b == '&'
		Jump(f, test)
		return NilState.Real // its obviously real


function Declaration (niltrackerfn)
	opt norefcounts
	|| exp = msg.last
	if exp == @rel
		setrel(exp)
	

function SetRel (niltrackerfn)
	opt norefcounts
	|| l = msg.first
	|| r = msg.last
	.VariableSet(.JumpDecl(l), .JumpDecl(r), l, 0)


function JumpDecl (|message| msg, |scdecl|)
	if msg.hasany // just for speed?
		.Jump(msg)
	return msg.NilDecl


function Jump (NilTrackerFn)
	pragma inline
	opt norefcounts
	return (NilTable[msg.func])(msg, test)


function RunAll (NilTrackerFn)
	opt norefcounts
	for s.fast in msg
		if s.IsLast
			return .jump(msg, test)
		.Jump(msg)


function NilMsg (|message| err, |scdecl| d, |uint| PointerInferred, |string|)
	if PointerInferred
		return "Nil Error: Pointed-to can't be nil."
	if d isnt param
		if err == @thg
			return "Nil Access: Needs 'if' wrapping."
		return "Nil Access here."
	return "Nil Error: Don't declare with '?'... or test for nil."


function VariableSet (|scdecl| Recv, |scdecl| Sent, |message| ErrPlace, |uint| IsParam) // setrel, relset
	opt norefcounts
	require recv.suffersnil

	if recv.NilDeclared isnt nilish
		require .FailIfNotReal(errplace, sent, isparam>>1)
	  
	  elseif isparam										// a param that can accept nil
		|| recnil = recv.nildeclared
		check ((recnil is stated) or (sent.NilUsed isnt Nilish)) (errplace, "Unknown if this parameter accepts nil.")
		if IsParam == 2
			T.SetNilness(sent, recnil)
			debugger 										// its too hard to imagine. just figure this out later
			// if (a and func(&a))
	  else
		T.SetNilness(recv, sent.nilused)
		
			
	if recv.PointerCount == 1	// |!&!&struct| abc = f
	// what about pointers to pointers to something? // just give up? i think so...
		return .VariableSet(recv.internal, sent.internal, errplace, IsParam<<1)



function FailIfNotReal (|message| err, |scdecl| d, |uint| PointerInferred=0,  |bool|)
	opt norefcounts
	if d.NilUsed isnt Nilish
		return true

	if !PointerInferred  and  d is param  and  d.NilDeclared is Stated
		d.NilDeclared = NilState.real
		d.nilused = NilState.Realish
		return true

	error (err, NilMsg(err, d, PointerInferred))


}


	
/*
	OK... so whats the problem? the problem is how negation works...
	
	if !(a and a.prop)
	
	OK... so if we run everything negatively... then... IDK?
	
	running negatively is for: a=nil instead of a=real
	
	but if we set negative mode... well I guess the "and cond" will take care of it
	it becomes a "perhaps?"
	the thing is... it isnt a perhaps. its a real thing... just during the cond itself.
	we need to run it Positively inside, then negate the result.
	but how?
	
	could we simplify the problem? what exactly hapens in this case?
	
		if !(a and a.prop) { // (a is real in "( )")  +    (a is maybe after "!")
			// a is ?
		} else {
			// a is real
		}
	
	Perhaps the "and" should handle the negation?
	Even if so... that means EVERYTHING has to do the negation! i suppose there aren't that many though.
	
	seems simpler to do negation in the "!"
	
	the thing is... how do we negate. negating something simple... is simple. negating a bunch of stuff when
	we don't know what to do wit them isnt.
	
		if !(a and b and a.prop and b.prop)
		
	how can we negate this?
	
	Within the @bra, it must be positive, so that we can test the properties
	
	outside the branch?
	
	we could run it twice? One in "actual execution mode" and one in "conditions only mode"
	
	I think it works?			
*/

function message.IsNilSafe (|bool|)
	return false