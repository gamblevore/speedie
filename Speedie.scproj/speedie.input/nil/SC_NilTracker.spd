

struct NilItem
	|scdecl--|	Decl
	|nilstate|	Nil
	|byte|		IfDepth


/*
	OK... so... how does the ifdepth work?
	Each decl has a depth at which it is declared?
	Or are we talking about the current state of the decl within the branch??
	
	Not sure? for a start lets increase the depth.
*/

struct NilTracker
	linkage:cpp_part nil
	|uint| 				DeclCount
	|uint| 				IfDepth
	|scfunction--|		fn
	|NilItem[1536]|		Items

	function Undo (|uint| s)
		.Restore(s)
		.DeclCount = s
	
	function Restore (|uint| s)
		.merge(s, false)

	function Merge (|uint| s, |bool| Merge=true)
		|| c = .DeclCount
		|| id = .IfDepth
		.DeclCount = s
		while s >= --c
			|| i = &.items[c]
			|| d = i.decl
			|| v = i.nil
			if Merge
				v |= d.nilused
			d.nilused = v
			if d.IfDepth >= id
				debugger // bad
		
	
	function NeedCond (|int|)
	function NegateCond (|int| old)
	function CloseCond (|int| old)
		
	function SetNilness (|scdecl| d, |nilstate| s)
		|| dd = d.ifDepth
		if dd < .ifdepth
			.items[dd].nil = s
		  else
			.TestedNilness(d, s)
	

// we need to redesign this so we always know "Where we are"
// if we are in a cond... what cond
// or in a branch, what branch?
// or in a func... is it in a func or a branch?
// what about a rel in a func?

/*
	What are we doing with the ifdepth?
	
	ifdepth.... hmmm
	
	so we only wanna change the value within the same branch
	So when we declare a decl... we set it with the current value
	
	then within the branch its set again... but now the ifdepth has to increase
	
	OK... so why do we need this? what were we doing before. 

	we set the decl.... we got an ifbranch, no ifdepth
	we store any changes, then undo them. do we need an ifdepth?
	no! i dont think so... because we keep the current depth via DeclCount
	
	what about multiple sets so that we don't merge invalid values. only the last state.
	
	x = nil
	x = realobj()
	// merge both? NO!
	
	OK... so its for multiple sets within a branch.
	
	OK... so if we set something during the cond... where is it set?
	not into the cond... righht? in fact not during any of the else ifs...!
	
	Perhaps we don't need such an extreme design? Perhaps all setvars during the ifcond... can...
	go back into the parent ifdepth thing? and also set the "restore" value at the same time?

	It would be simpler than "going up by 2".
	
	OK... so how would that deal with this?
	
	if (x and alter(&x) and x)
		x.y = 1
		x = maybenil()
		if (x and alter(&x) and x)
			x.y = 1
		  else
			x = real()
		// x = real
	  else
		x = nil
	// x = maybe
				

	// just alter the state 1 up... if altered within a branch :)

	// what about booltests?
	
	|| y = (x and alter(&x) and x)
	
*/
	
	function TestedNilness (|scdecl| d, |nilstate| s)
		opt norefcounts
		if d.nilused > 3 // what?
		|| c = .DeclCount
		|| id = .IfDepth
		if (c < 1536) and (id < 250)
			|| i = &.Items[c]
			i.nil = d.NilUsed
			i.decl = d
			.DeclCount = c + 1
			d.nilused = s
			d.ifDepth = id
			i.ifDepth = id
			return
		
		check (id < 250) (.fn, "Too much nested if")
		error (.fn, "Too many variables for nilchecker")


	function Start (|scfunction| f)
		opt norefcounts
		scfunction.currfunc = f
		.DeclCount = 1 // because of scdecl.NilDepth
		.fn = f
		|| r = f.returntype
			r.NilUsed = 0 // :)
		for d in .fn.args
			d.RestoreNil


	function Finish (|scfunction| f)
		opt norefcounts
		f.ReturnType.DeclareAsUsed?
		.fn = nil
		
	
	function Check (|scfunction| f)
		opt norefcounts
		require f.cannil and f.limittests
		return 
		.Start(f)
		.RunNormal(f.SourceArg)
		.Finish(f)
	
	

function SCDecl.RestoreNil
	if .nilused != .NilDeclared // is this ever used?
	.nilused = .nildeclared

function SCDecl.NilTake (|scdecl| d)
	opt norefcounts
	|| n = d.NilDeclared
	.NilUsed = n
	.NilDeclared = n

function SCDecl.IsNowNil (|bool|)
	return (self == TypeNil) or (.nilused isnt real)

function SCDecl.DeclareAsUsed
	opt norefcounts
	.nildeclared = .NilUsed (|) nilstate.stated

function scdecl.SuffersNil (|bool|)
	return .IsObject or .PointerCount

function scdecl.IsStated (|bool|)
	return .NilDeclared is Stated

