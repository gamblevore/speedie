

struct NilItem
	|scdecl--|	Decl
	|nilstate|	Nil


struct NilTracker
	linkage:cpp_part nil
	|uint| 				DeclCount
	|scfunction--|		fn
	|NilItem[1536]|		Items


	function Merge (|uint| s, |bool| Merge=true)
		|| c = .DeclCount
		.DeclCount = s
		while s >= --c
			|| i = .items[c]
			|| d = i.decl
			|| v = i.nil
			if Merge
				v |= d.nilused
			d.nilused = v
		
	
	function StartCond (|int|)
	function NeedCond (|int|)
	function CloseCond (|int| old)
		
	function SetNilness (|scdecl| d, |nilstate| s)
		.TestedNilness(d, s)
	
	
	function TestedNilness (|scdecl| d, |nilstate| s, |nilstate|)
		opt norefcounts
		if d.nilused > 3 // what?
		|| c = .DeclCount
		if (c < 1536)
			|| i = .items[c]
			i.nil = d.NilUsed
			i.decl = d
			.DeclCount = c + 1
			d.nilused = s
			return s
		
		error (.fn, "Too many variables for nilchecker")
		return s


	function Start (|scfunction| f)
		opt norefcounts
		scfunction.currfunc = f
		.DeclCount = 1 // because of scdecl.NilDepth
		.fn = f
		|| r = f.returntype
			r.NilUsed = 0 // :)
		for d in .fn.args
			d.RestoreNil


	function Finish (|scfunction| f)
		opt norefcounts
		f.ReturnType.DeclareAsUsed?
		.fn = nil
		
	
	function Check (|scfunction| f)
		opt norefcounts
		require f.cannil and f.limittests
		return 
		.Start(f)
		.RunNormal(f.SourceArg)
		.Finish(f)


	function scfunction.canNil (|bool|)
		return !(.IsMacro and !.IsWrapper and .isOK)	
	
	
	function scfunction.LimitTests (|bool|)
		|| c = .Lookup #require
		require c.name contains "NilTest"
		require .SourceArg contains "nilcheck"
		return true
	
		
	module {
		|NilTracker| T
		function SaveLives
			opt norefcounts
			require StdErr.ok
			using options.NilStrength
				for f in compiler.funclist
					T.Check(f)
				
			scfunction.currfunc = nil
			.SweepInits
			StdErr.PrintErrors
			StdErr.Clear
	
		
		function SweepInits
			// || init = compiler.getfunc("init_")
			// what about "init_"?


		function Undo (|uint| s)
			T.merge(s, false)
			t.DeclCount = s
		
		function Restore (|uint| s)
			t.merge(s, false)
	
		function Merge (|uint| s)
			t.merge(s, true)
}
	
	

function SCDecl.RestoreNil
	if .nilused != .NilDeclared // is this ever used?
	.nilused = .nildeclared

function SCDecl.NilTake (|scdecl| d)
	opt norefcounts
	|| n = d.NilDeclared
	.NilUsed = n
	.NilDeclared = n


function message.IsNowNil (|bool|)
	opt norefcounts
	|| d = .obj as scdecl
		return (d == TypeNil) or (d.nilused isnt real)


function SCDecl.DeclareAsUsed
	opt norefcounts
	.nildeclared = .NilUsed (|) nilstate.stated

function scdecl.SuffersNil (|bool|)
	return .IsObject or .PointerCount

function scdecl.IsStated (|bool|)
	return .NilDeclared is Stated

