
BOOLEAN LOGICS:
* || x = (a and b), if x: a.a(b.b) // only next ifbranch tho


DONE?

nil-checker funcs:

can't tell what happened:
	if (a or b) {nochangetoboth()} else {botharenil()}


refills and relsetters:
	if (!a) a = b(), a = &e

multiple branches:
	if !a { if b {return 1} else {return 2} }
	a.b = 1

return affecting future code:
	if (!msg)
		return
	msg.prop

ternaries:
	|| x = (a.b, nil)(a)

rel-sets to internal pointers:
	|| obj = nil
	|!&!object| x = &obj // error: Pointed-to can't be nil

function calls:
	function gg (|object|)
		|| a = maybenil
		|| x = ff(a) // error: ff does not take nil.
		|| y = gg()  // error: unknown at this time if gg returns nil.

update the params:
	function abc (|message| o)
		o.position // o is now "!"

return values:
	if x
		return message()
	  else
		return nil // now this func returns optional values. 

using ptrs:
	if (*msg)

nilstrength:
	--nil=3

can access prop:
	if (msg)
		msg.prop

multiple tests:
	if (a and b)

redundant "m":
	if (m and m.length)
	if (!m or !m.length)

pointless:
	if nil == nil

fail:
	if msg >= nil, if msg <= nil

nil within branch:
	if msg == nil



Init Vars Sweep?
	We need to go through the entire program, and give each item found, a "timecode". That
	is... it has an "earliest time" that it COULD occur.
perhaps just do it on a per-module basis... If a module makes no sense in terms of itself thats the programmers fault.

recursive funcs?
	I think for them... we let the user simply specify their nilness!! makes sense, right?
	I think, just assume NOT NIL unless we can prove that it is tested. It is implicit and we can't be that smart.



// DISTURBANCE CHECKER WILL HELP
// for global vars
	// global.x = obj
	// func()
	// global.x.func2 // allowed or not? func() might have altered global.x


.....


// we need to redesign this so we always know "Where we are"
// if we are in a cond... what cond
// or in a branch, what branch?
// or in a func... is it in a func or a branch?
// what about a rel in a func?

/*
	What are we doing with the ifdepth?
	
	ifdepth.... hmmm
	
	so we only wanna change the value within the same branch
	So when we declare a decl... we set it with the current value
	
	then within the branch its set again... but now the ifdepth has to increase
	
	OK... so why do we need this? what were we doing before. 

	we set the decl.... we got an ifbranch, no ifdepth
	we store any changes, then undo them. do we need an ifdepth?
	no! i dont think so... because we keep the current depth via DeclCount
	
	what about multiple sets so that we don't merge invalid values. only the last state.
	
	x = nil
	x = realobj()
	// merge both? NO!
	
	OK... so its for multiple sets within a branch.
	
	OK... so if we set something during the cond... where is it set?
	not into the cond... righht? in fact not during any of the else ifs...!
	
	Perhaps we don't need such an extreme design? Perhaps all setvars during the ifcond... can...
	go back into the parent ifdepth thing? and also set the "restore" value at the same time?

	It would be simpler than "going up by 2".
	
	OK... so how would that deal with this?
	
	if (x and alter(&x) and x)
		x.y = 1
		x = maybenil()
		if (x and alter(&x) and x)
			x.y = 1
		  else
			x = real()
		// x = real
	  else
		x = nil
	// x = maybe
				

	// just alter the state 1 up... if altered within a branch :)

	// what about booltests?
	
	|| y = (x and alter(&x) and x)
	
*/




// if !x
//    x = realobject()
// If we merge the previous state with new state, we get "maybe"
// So we need to merge both branches instead of the parent branch.

// I think we are gonna calculate both states/approaches at once.
// we only have "StateA" and "StateB"... then we can swap between them or choose one.

