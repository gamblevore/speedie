

// Later, the disturbance checker will mesh nicely! for global vars
	// global.x = obj
	// func()
	// global.x.func2 // allowed or not? func() might have altered global.x



module NilChecker
	function SaveLives
		opt norefcounts
		using options.NilStrength
	
		|NilTracker| T
		for f in compiler.funclist
			if f.CanNilCheck
				T.Check(f)
		
		scfunction.currfunc = nil
		.SweepInits

	
	function SweepInits
		// || init = compiler.getfunc("init_")
		// what about "init_"?


function SCFunction.CanNilCheck (|bool|)
	return  false
	require !.IsMacro and !.IsWrapper and .isOK
	|| c = .Lookup
		return c.name contains "NilTest"


function NilTracker.Check (|scfunction| f)
	debugat
	opt norefcounts
	.Start(f)
	.RunNormal(f.SourceArg)
//	.TightenNilness(f) // no need... will already be tightened


function message.NilPropAccess (|scdecl|)
	opt norefcounts
	|| m = .DotMustBeProperty
	if m and m isnt onmodule
		return m


function NilTracker.ChildMustExist (|message| wrapper)
	// a.b, *a, a[0], (a)()
	opt norefcounts
	|| msg = wrapper.first
		.MustBeReal(msg, msg.NeedDecl)


function NilTracker.IfWhileOne (|message| test, |message| root, |message|)
	opt norefcounts
	|| arg = test.first
	if arg == @arg
		.RunNormal(arg)
	  else
		|| Br = .ProcessCond(arg, true)
		arg++
		.RunNormal(arg)
	// So... now what do I do?

	return arg.next
	

function NilTracker.IfOrWhile (|message| msg)
	opt norefcounts
	|| old = .Using
	|| test = msg
	while test
		test = .IfWhileOne(test, msg)
	.used(old)


// the tran_else thing could loopback to do the if removal?

function NilTracker.If (|message| Tmp)
	opt norefcounts
	|| oldif = .IfMsg
	Tmp.Obj = oldif
	.ifmsg = Tmp
	.IfOrWhile(Tmp)
	.IfMsg = oldif


function Message.RedundantBranch (|bool| Value, |branchstate|)
	if Value
		return .RedundantTrue
	return .RedundantFalse


function Message.RedundantTrue (|branchstate|)
	if StdErr.CanAddMore(errorseverity.problem)
		StdErr.NewProblem(self, "nil check is always true")
	return BranchState.Always


function Message.RedundantFalse (|branchstate|)
	if StdErr.CanAddMore(errorseverity.problem)
		StdErr.NewProblem(self, "nil check is always false")
	return BranchState.Never


function SCDecl.IsNowNil (|bool|)
	return (self == TypeNil) or (.nilused isnt real)


function niltracker.MustBeReal (|message| msg, |scdecl| d)
	opt norefcounts
	|| u = d.NilUsed
	require u is Nilish
	expect (u is realish) (msg, "Possible NilObject Access.")

	if d is param
		d = .ReDeclare(msg, d, nilstate.real)

	.SetNilness(msg, d, NilState.Realish)



function niltracker.Redeclare (|message| msg, |scdecl| d, |nilstate| used, |scdecl|)
	opt norefcounts
	if d.NilDeclared is stated
		if d.nildeclared.syntaxis(used)
			return d
		if used is real
			error (msg, "something")
		  else
			error (msg, "something else")
		return d

	
	|| d2 = d.copy
	SCFunction.CurrFunc[d.NilParamPos] = d2
	d2.NilDeclared = used
	return d2
	
// if we are testing a cond to be true (or false)... it must be optional.
// right?

function NilTracker.ProcessCondThg (|message| msg, |bool| Y, |branchstate|)
	opt norefcounts
	|| dest = NilState.Nilish + Y	
	|| d = msg.NeedDecl			#debug_require
	|| u = d.NilUsed
	if u == dest
		return msg.RedundantTrue

	.SetNilness(msg, d, dest)
	if u == NilState.Either					// typical state
		if d is param
			.ReDeclare(msg, d, u)
		return BranchState.Perhaps
	if d.NilDeclared is either
		return BranchState.Never
	return msg.RedundantFalse


function NilTracker.ProcessCond (|message| m, |bool| Y, |branchstate|)
	opt norefcounts
	|| fn = m.func
	if fn == @thg
		return .ProcessCondThg(m, y)
	if fn == @bra or @type
		return .ProcessCond(m.first, Y)
	if fn == @rel
		return .ProcessCondRel(m, y)
	if fn == @func
		return .ProcessCondFunc(m,y)
	if fn == @brel
		return .ProcessCondBrel(m, y)
	debugat
	.RunNormal(m)
	return branchstate.Perhaps


function NilTracker.ProcessCondPtr (|message| m, |bool| Y, |branchstate|)
	opt norefcounts
	|| f = m.first
	|| d = f.NeedDecl
		.MustBeReal(f, d)
		return .ProcessCond(f, y)


function NilTracker.ProcessCondBrel (|message| m, |bool| Y, |branchstate|)
	opt norefcounts
	if (m == "!")
		return .ProcessCond(m.first, !Y)
	if m == "*"
		return .ProcessCondPtr(m, Y)
	if m == "&"			// objects always have an address
		return NilState.Real.Always(Y)
	debugat
	.RunNormal(m)
	return branchstate.Perhaps


function NilTracker.ProcessCondFunc (|message| m, |bool| Y, |branchstate|)
	opt norefcounts
	|| prms = m.last
	|| fn = prms.obj|SCFunction|
	if !fn.IsNilChecker
		return branchstate.Perhaps
	|| p1 = prms.first
	if p1 == @thg
		return .ProcessCondThg(m, y)
	
		
// now what?
function NilTracker.ProcessCondRelSimple (|message| m, |bool| Y, |message|)
	
	

function NilTracker.ProcessCondRel (|message| m, |bool| Y, |branchstate|)
	opt norefcounts
	|| ll = m.first
	|| op = ll.next
	|| rr = op.next$
	|| scop = op.obj|SCOperator|				#debug_require
	if scop.IsCompare
		|| LNil = (ll.obj as scdecl).IsNowNil
		|| RNil = (rr.obj as scdecl).IsNowNil
		if lnil or rnil
			expect (scop.IsNilTest) (op, "Can't use this operator on nil. Use != or ==.")
			if (lnil and rnil)
				return m.RedundantBranch(scop.hasequals)
			if lnil
				return .ProcessCond(rr, Y != scop.hasequals)
			  else
				return .ProcessCond(ll, Y != scop.hasequals)
		return BranchState.Perhaps
	
	if scop.IsAndOr
		if scop == "and"
			return .ProcessCond(ll, Y) & .ProcessCond(rr, Y)
	
		if scop == "or"
			|| where = .MsgCount
			|| SimpleLeft = .ProcessCond(ll, y)
			|| SimpleRight = .ProcessCondRelSimple(rr, y)
			if .msgCount > where
		// this will require .count to go up... so basically condthg will add it
		// but what removes it? we have to... right?
		
		// what about the cond?
		// if (a and b)			// a yes,   b yes		... after a may, b may
		// if (!a and !b)		// a no,    b no    	... after a may, b may
		// if (!(a and b))		// a may,	b may   	... after a yes, b yes
		// if (!(!a and !b)		// a may,	b may   	... after a no,  b no
		// if (a or b)			// a may,	b may		... after a no,  b no		
		// if (!(a or b))		// a no,	b no		... after a may, b may
		// if (!(!a or !b))		// a may,	b may		... after a no,  b no 
		
		
		// if !msg or *msg
		// if (abc and m) or (*m == 1)
	return branchstate.Perhaps


function NilTracker.RunNormal (|message| msg, |branchstate|)
	opt norefcounts
	
	for s.fast in msg
		|| f = s.func
		if (f == @dot)
			|| Prop = s.NilPropAccess
				.ChildMustExist(s)								// abc.var
		  elseif (f == @acc) 
			.ChildMustExist(s)									// abc[0]
		  elseif (f == @brel) 
			if s != "*"
			.ChildMustExist(s)									// *abc
		  elseif (f == @func and s.first == @bra)
			.ChildMustExist(s.first)							//  (abc)()
		  elseif (f == @tmp)
			|| type = S.TmpType
			if Type is kif
				.If(s)
			  elseif type is kwhile
				.IfOrWhile(s)
				
		  elseif !s.IsLast
			.RunNormal(s)
		  else
			return .RunNormal(s) // tail-call opt
	return BranchState.Always
	

	


/*
TODO:
* fix " = .internal" all over!!!! DO IT FIRST
* update the params properly
* pop the msgs out and restore nilused
* ternaries
* freeze bug
* if .lookuponly isa scdecl... we need to update that... and also its a chain


* return values
* .ifmsg is needed?
* modifications of objects via func pointer param... during a cond
* fn abc (|object| x)
	x = haha() // x is nil or not? haha? its literally been replaced so the original decl is unused.  unused decls default to optional



BOOLEAN LOGICS:
	refills and relsetters:
		if (!a) a = b(), a = &e
	
	multiple branches:
		if !a { if b {return 1} else {return 2} }
		a.b = 1
	
	return affecting future code:
		if (!msg)
			return
		msg.prop
	
	changes nothing:
		if (a or b)


DONE?
using ptrs:
	if (*msg)

nilstrength:
	--nil=3

can access prop:
	if (msg)
		msg.prop

multiple tests:
	if (a and b)

redundant "m":
	if (m and m.length)
	if (!m or !m.length)

pointless:
	if nil == nil

fail:
	if msg >= nil, if msg <= nil

nil within branch:
	if msg == nil
*/


/*
* Init Vars Sweep?
	We need to go through the entire program, and give each item found, a "timecode". That
	is... it has an "earliest time" that it COULD occur.
perhaps just do it on a per-module basis... If a module makes no sense in terms of itself thats the programmers fault.
*/

/*
Issues:
What about the fact that a function's param nilness can rely on other funcs??
like:

	x = msg[0] // OK... so we don't rely on msg existing? but only cos it doesn't rely on self existing.
what if msg[n] is recursive and complicated? then how do we check if a decl... is nil or not?

The fact that we have ordered this... leaf first... helps. dependancies help... but that only reduces the problem
not eliminiates it. There will be cases that we can't eliminate.

* Make it nestable? That is... we actually can check functions?
	* this would only be needed for actual recursive functions... non-recursives would have a strict chain...
* what if two funcs with the same depth... and one is called before the other but the wrong one is called first?
	* then making it nestable helps!

* what about actually recursive funcs? I think for them... we let the user simply specify their nilness!! makes sense, right?
	* I think, just assume NOT NIL unless we can prove that it is tested. It is implicit and we can't be that smart.
*/

