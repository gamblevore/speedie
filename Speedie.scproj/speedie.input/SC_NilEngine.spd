

// fix " = .internal" all over

module VoidSweeper
	function SuperUberChecker
		opt norefcounts
		using options.NilStrength
	
		|NilTracker| T
		for f in compiler.funclist
			if f.CanNilCheck
				T.Check(f)
		
		scfunction.currfunc = nil
		.Sweep

	
	function Sweep
		// || init = compiler.getfunc("init_")
		// what about "init_"?


function SCFunction.CanNilCheck (|bool|)
	return  false
	require !.IsMacro and !.IsWrapper and .isOK
	|| c = .Lookup
		return c.name contains "NilTest"


function NilTracker.Check (|scfunction| f)
	debugat
	opt norefcounts
	.Start(f)
	.RunNormal(f.SourceArg)
	.Tighten(f)					// then we alter the function's nilness
	.Restore


function message.NilPropAccess (|scdecl|)
	opt norefcounts
	|| m = .DotMustBeProperty
	if m and m isnt onmodule
		return m


function NilTracker.ChildMustExist (|message| wrapper)
	// a.b, *a, a[0], (a)()
	opt norefcounts
	|| msg = wrapper.first
		.MustBeReal(msg, msg.needdecl)


function niltracker.MustBeReal (|message| msg, |scdecl| d, |scdecl|)
	opt norefcounts
	|| u = d.NilUsed
	if u isnt nil
		return d
	expect (u is realish) (msg, nilerr)

	if  d is param  and  d.nildeclared isnt stated // fn name: msg.prop
		// what about self-param, and lookup via "isa class"
		d.NilDeclared = NilState.Real
	
	return .SetNil(msg, d, NilState.Realish)


function message.IfNextTest (|message| arg, |message|)
	opt norefcounts
	if arg in self
		return arg.next
	  else
		return .next


function NilTracker.IfWhileOne (|message| test, |message| root, |message|)
	opt norefcounts
	|| cond = test.first
	|| Br = .ProcessCond(cond, true)
	|| arg = test.last
	if cond != arg
		.RunNormal(arg)
	
	// blocking can be always, perhaps or never
	// I mean like "if (Abc): return", blocks... within... but it doesnt block everything
	// I think blocking everyhting doesnt matter anyhow? cos theres no future code?
	// the transform stage should keep track of that, then??
	// probably.
	
	|| ret = arg.last
		ifn ret.flags & kEndsblock
			root.flags &=~ kEndsblock // bubble up
	
	if test == "else" // well... this is the last one... it affects the boolean logic somehow?
		
	if 1 == 2
		if 1==1
			return nil
		  else
			return nil

	return (arg.next, test.next)(test == root)
	

function NilTracker.IfWhile (|message| msg)
	opt norefcounts
	|| Depth = .Count
	.if = msg
	msg.flags |= kEndsblock // children can clear it

	|| test = .IfWhileOne(msg, msg)
	while test
		test = .IfWhileOne(test, msg)

	if msg == "while" // while can't block
		msg.flags &=~ kEndsblock
	.Count = Depth


function Message.RedundantBranch (|bool| Value, |branchstate|)
	if Value
		return .RedundantTrue
	return .RedundantFalse


function Message.RedundantTrue (|branchstate|)
	if StdErr.CanAddMore(errorseverity.problem)
		StdErr.NewProblem(self, "nil check is always true")
	return BranchState.Always


function Message.RedundantFalse (|branchstate|)
	if StdErr.CanAddMore(errorseverity.problem)
		StdErr.NewProblem(self, "nil check is always false")
	return BranchState.Never


function SCDecl.IsNowNil (|bool|)
	return (self == TypeNil) or (.nilused isnt real)


function NilTracker.ProcessCondThg (|message| m, |bool| Y, |branchstate|)
	opt norefcounts
	|| dest = NilState.nil + Y	
	|| d = m.NeedDecl			#debug_require
	|| u = d.NilUsed
	if u == dest
		return m.RedundantTrue

	.setnil(m, d, dest)
	if u == NilState.Either					// typical state
		return BranchState.Perhaps
	if d.NilDeclared is either
		return BranchState.Never
	return m.RedundantFalse


function NilTracker.ProcessCond (|message| m, |bool| Y, |branchstate|)
	opt norefcounts
	|| fn = m.func
	if fn == @arg // "else" 
		return .RunNormal(m)
	if fn == @thg
		return .ProcessCondThg(m, y)
	if fn == @bra or @type
		return .ProcessCond(m.first, Y)
	if fn == @rel
		return .ProcessCondRel(m, y)
	if fn == @func
		return .ProcessCondFunc(m,y)
	if fn == @brel
		return .ProcessCondBrel(m, y)
	debugat
	.RunNormal(m)
	return branchstate.Perhaps


function NilTracker.ProcessCondPtr (|message| m, |bool| Y, |branchstate|)
	opt norefcounts
	|| f = m.first
	|| d = f.NeedDecl
	if d and .MustBeReal(f, d)
		return .ProcessCond(f, y)


function NilTracker.ProcessCondBrel (|message| m, |bool| Y, |branchstate|)
	opt norefcounts
	if (m == "!")
		return .ProcessCond(m.first, !Y)
	if m == "*"
		return .ProcessCondPtr(m, Y)
	if m == "&"			// objects always have an address
		return NilState.Real.Always(Y)
	debugat
	.RunNormal(m)
	return branchstate.Perhaps


function NilTracker.ProcessCondFunc (|message| m, |bool| Y, |branchstate|)
	opt norefcounts
	|| prms = m.last
	|| fn = prms.obj|SCFunction|
	if !fn.IsNilChecker
		return branchstate.Perhaps
	|| p1 = prms.first
	if p1 == @thg
		return .ProcessCondThg(m, y)
	
		
// now what?
function NilTracker.ProcessCondRelSimple (|message| m, |bool| Y, |message|)
	
	

function NilTracker.ProcessCondRel (|message| m, |bool| Y, |branchstate|)
	opt norefcounts
	|| ll = m.first
	|| op = ll.next
	|| rr = op.next$
	|| scop = op.obj|SCOperator|				#debug_require
	if scop.IsCompare
		|| LNil = (ll.obj as scdecl).IsNowNil
		|| RNil = (rr.obj as scdecl).IsNowNil
		if lnil or rnil
			expect (scop.IsNilTest) (op, "Can't use this operator on nil. Use != or ==.")
			if (lnil and rnil)
				return m.RedundantBranch(scop.hasequals)
			if lnil
				return .ProcessCond(rr, Y != scop.hasequals)
			  else
				return .ProcessCond(ll, Y != scop.hasequals)
		return BranchState.Perhaps
	
	if scop.IsAndOr
		if scop == "and"
			return .ProcessCond(ll, Y) & .ProcessCond(rr, Y)
	
		if scop == "or"
			|| where = .Count
			|| SimpleLeft = .ProcessCond(ll, y)
			|| SimpleRight = .ProcessCondRelSimple(rr, y)
			if .Count > where
		// this will require .count to go up... so basically condthg will add it
		// but what removes it? we have to... right?
		
		// what about the cond?
		// if (a and b)			// a yes,   b yes		... after a may, b may
		// if (!a and !b)		// a no,    b no    	... after a may, b may
		// if (!(a and b))		// a may,	b may   	... after a yes, b yes
		// if (!(!a and !b)		// a may,	b may   	... after a no,  b no
		// if (a or b)			// a may,	b may		... after a no,  b no		
		// if (!(a or b))		// a no,	b no		... after a may, b may
		// if (!(!a or !b))		// a may,	b may		... after a no,  b no 
		
		
		// if !msg or *msg
		// if (abc and m) or (*m == 1)
		
	return branchstate.Perhaps


function NilTracker.RunNormal (|message| msg, |branchstate|)
	opt norefcounts
	
	for s.fast in msg
		|| f = s.func
		if (f == @dot)
			|| Prop = s.NilPropAccess
				.ChildMustExist(s)								// abc.var
		  elseif (f == @acc) 
			.ChildMustExist(s)									// abc[0]
		  elseif (f == @brel) 
			if s != "*"
			.ChildMustExist(s)									// *abc
		  elseif (f == @func and s.first == @bra)
			.ChildMustExist(s.first)							//  (abc)()
		  elseif (f == @tmp) and (s == "if" or "while")
			.IfWhile(s)
		  elseif !s.IsLast
			.RunNormal(s)
		  else
			return .RunNormal(s) // tail-call opt
	return BranchState.Always
	

	


/*
TODO:
* tran_if should handle "if" being a blocker if both paths block
	* process app.quit
* pop the msgs out.
* ternaries
* freeze bug

* return values
* .if is needed?
* modifications of objects via func pointer param... during a cond
* fn abc (|object| x)
	x = haha() // x is nil or not? haha? its literally been replaced so the original decl is unused.  unused decls default to optional



BOOLEAN LOGICS:
	refills and relsetters:
		if (!a) a = b(), a = &e
	
	multiple branches:
		if !a { if b {return 1} else {return 2} }
		a.b = 1
	
	return affecting future code:
		if (!msg)
			return
		msg.prop
	
	changes nothing:
		if (a or b)


DONE?
using ptrs:
	if (*msg)

nilstrength:
	--nil=3

can access prop:
	if (msg)
		msg.prop

multiple tests:
	if (a and b)

redundant "m":
	if (m and m.length)
	if (!m or !m.length)

pointless:
	if nil == nil

fail:
	if msg >= nil, if msg <= nil

nil within branch:
	if msg == nil
*/


/*
* Init Vars Sweep?
	We need to go through the entire program, and give each item found, a "timecode". That
	is... it has an "earliest time" that it COULD occur.
perhaps just do it on a per-module basis... If a module makes no sense in terms of itself thats the programmers fault.
*/

/*
Issues:
What about the fact that a function's param nilness can rely on other funcs??
like:

	x = msg[0] // OK... so we don't rely on msg existing? but only cos it doesn't rely on self existing.
what if msg[n] is recursive and complicated? then how do we check if a decl... is nil or not?

The fact that we have ordered this... leaf first... helps. dependancies help... but that only reduces the problem
not eliminiates it. There will be cases that we can't eliminate.

* Make it nestable? That is... we actually can check functions?
	* this would only be needed for actual recursive functions... non-recursives would have a strict chain...
* what if two funcs with the same depth... and one is called before the other but the wrong one is called first?
	* then making it nestable helps!

* what about actually recursive funcs? I think for them... we let the user simply specify their nilness!! makes sense, right?
	* I think, just assume NOT NIL unless we can prove that it is tested. It is implicit and we can't be that smart.
*/

