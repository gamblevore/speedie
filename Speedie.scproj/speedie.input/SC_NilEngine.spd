
// DISTURBANCE CHECKER WILL HELP
// for global vars
	// global.x = obj
	// func()
	// global.x.func2 // allowed or not? func() might have altered global.x



module NilChecker
	function SaveLives
		opt norefcounts
		using options.NilStrength
	
		|NilTracker| T
		for f in compiler.funclist
			T.Check(f)
		
		scfunction.currfunc = nil
		.SweepInits

	
	function SweepInits
		// || init = compiler.getfunc("init_")
		// what about "init_"?


function NilTracker.Check (|scfunction| f)
	debugat
	opt norefcounts
	require false
	require !f.IsMacro and !f.IsWrapper and f.isOK
	|| c = f.Lookup
		require c.name contains "NilTest"

	.Start(f)
	.RunNormal(.fn.SourceArg)
	|| r = .fn.ReturnType
		r.nildeclared = r.NilUsed (|) NilState.Stated


function message.NilPropAccess (|scdecl|)
	opt norefcounts
	|| m = .DotMustBeProperty
	if m and m isnt onmodule
		return m


function message.NilDecl (|scdecl|)
	opt norefcounts
	|| obj = .obj
	if (obj isa scdecl)
		|| l = obj.IsLookupOnly
		if l isa scdecl
			return l
		return obj
	
	
function NilTracker.UseChildAsReal (|message| wrapper)
	// a.b, *a, a[0], (a)()
	opt norefcounts
	|| ch = wrapper.first
		.UseAsReal(ch, ch.NilDecl)


function NilTracker.CheckFunction (|message| msg)
	opt norefcounts
	// check all the function params. and return too. The return must be stated
	// print(a, b, c)
	|| prms = msg.last
	|| fn = prms.obj|scfunction|
	|| ret = fn.ReturnType
		check (!ret.SuffersNil or ret.IsStated) (msg, "Unknown if this function returns nil.")

	|| p = prms.first
	for d in fn.args
		|| pnd = p.NilDecl
		while 
			if (pnd.NilUsed is Nilish) and d.SuffersNil
				if !d.IsStated
					error (p, "Unknown if this parameter accepts nil.")
				  elseif d.NilDeclared isnt Nilish
					error (p, "Passing possible nil")
		// what if we get the address of an obj? or the address of an address?
		// we'd need to follow the chain all the way up :( oooofff
		// same issue with .return
		p++


function NilTracker.Return (|message| msg)
	opt norefcounts

	|| value = msg.first				#require
	|| vd = value.NilDecl
	if vd.suffersnil
		|| vn = vd.nilused
		|| rd = .fn.ReturnType
		|| r  = rd.NilDeclared
		if r is real  and vn is Nilish
			error (msg, "NilObject returned!")
		rd.nilused |= vn // find the answer at the end


function NilTracker.IfWhileOne (|message| test, |message| root, |message|)
	opt norefcounts
	|| arg = test.first
	if arg == @arg
		.RunNormal(arg)
	  else
		|| Br = .ProcessCond(arg, branchstate.always)
		arg++
		.RunNormal(arg)

	return arg.next
	

function NilTracker.IfOrWhile (|message| msg)
	opt norefcounts
	|| old = .enter
	|| test = msg
	while test
		test = .IfWhileOne(test, msg)
	.leave(old)


function NilTracker.If (|message| Tmp)
	opt norefcounts
	|| oldif = .IfMsg
	Tmp.Obj = oldif
	.ifmsg = Tmp
	.IfOrWhile(Tmp)
	.IfMsg = oldif


function Message.RedundantBranch (|branchstate|)
	if StdErr.CanAddMore(errorseverity.problem)
		StdErr.NewProblem(self, "nil check is constant (always true or false)")
	return BranchState.Perhaps


function SCDecl.IsNowNil (|bool|)
	return (self == TypeNil) or (.nilused isnt real)


function niltracker.UseAsReal (|message| msg, |scdecl| d)
	opt norefcounts
	|| u = d.NilUsed
	if u is Nilish
		expect (d is param) (msg, msg.nilmsg)
		expect (d.NilDeclared isnt Stated) (msg, `NilObjectAccess: Add '!' to param type, or wrap with "if".`)
		d.NilDeclared = NilState.real
		d.nilused = NilState.Realish


function NilTracker.ProcessCondThg (|message| msg, |branchstate| Y, |branchstate|)
	opt norefcounts
	|| dest = NilState.Nilish + Y	
	|| dcl = msg.nildecl			#debug_require
	|| u = dcl.NilUsed
	// we need to have actually 3 states set.
	// one for this branch, one for the other branch...
	// and one for the after branch... in case one or other branch returns.
	// where do we store this info? id rather figure it out at this point in time...
	// but the if/else thingy needs to restore it?
	// seem slike the if/else needs to set it, then...
	
	if u == NilState.Either
		if (dcl is param) and (dcl.NilDeclared isnt stated)
			dcl.NilDeclared = NilState.optional
		return .SetNilness(msg, dcl, dest)

	if dcl.NilDeclared is Either
		return msg.RedundantBranch
	return BranchState.Never + (u == dest) // checking for nil-obj allocations


function NilTracker.ProcessCond (|message| m, |branchstate| Y, |branchstate|)
	opt norefcounts
	|| fn = m.func
	if fn == @thg
		return .ProcessCondThg(m, y)
	if fn == @bra or @type
		return .ProcessCond(m.first, Y)
	if fn == @rel
		return .ProcessCondRel(m, y)
	if fn == @func
		return .ProcessCondFunc(m, y)
	if fn == @brel
		return .ProcessCondBrel(m, y)
	debugat
	.RunNormal(m)
	return branchstate.Perhaps


function NilTracker.ProcessCondPtr (|message| m, |branchstate| Y, |branchstate|)
	opt norefcounts
	|| PointedTo = m.first
	|| pd = PointedTo.nildecl
		.UseAsReal(PointedTo, pd)
		return .ProcessCond(PointedTo, y)


function NilTracker.ProcessCondBrel (|message| m, |branchstate| Y, |branchstate|)
	opt norefcounts
	|| b = m.name[0]
	if b == '!'
		return .ProcessCond(m.first, Y.not)
	if b == '*'
		return .ProcessCondPtr(m, Y)
	if b == '&'			// objects always have an address
		return Y
	debugat
	.RunNormal(m)
	return branchstate.Perhaps


function NilTracker.ProcessCondFunc (|message| m, |branchstate| Y, |branchstate|)
	opt norefcounts
	|| prms = m.last
	|| fn = prms.obj|SCFunction|
	if !fn.IsNilChecker
		return branchstate.Perhaps
	|| p1 = prms.first
	if p1 == @thg
		return .ProcessCondThg(m, y)	
	

function NilTracker.ProcessCondRel (|message| m, |branchstate| Y, |branchstate|)
	opt norefcounts
	|| ll = m.first
	|| op = ll.next
	|| rr = op.next
	|| scop = op.obj|SCOperator|
	require scop and rr

	if scop.IsCompare
		|| LNil = (ll.obj as scdecl).IsNowNil
		|| RNil = (rr.obj as scdecl).IsNowNil
		if lnil or rnil
			expect (scop.IsNilTest) (op, "Can't use this operator on nil. Use != or ==.")
			if (lnil and rnil)
				return m.RedundantBranch
			if scop.HasEquals // if (a==nil or b==nil) return else a.a(b.b)
				y = y.not
			|| side = (rr, ll)(lnil)
			return .ProcessCond(side, Y)
		return BranchState.Perhaps
	
	if scop.IsAndOr
		if scop.IsAndOr == 3 // and
			// x = (a and b)
			if y == BranchState.Never
				y = BranchState.Perhaps
		  else
			// x = !(a or b)
			if y == BranchState.always
				y = BranchState.Perhaps
		
		.ProcessCond(ll, Y)
		.ProcessCond(rr, Y)
		return BranchState.Perhaps
			
		
		// what about the cond?
		// if (a and b)			// a yes,   b yes		... after a may, b may
		// if (!a and !b)		// a no,    b no    	... after a may, b may
		// if (!(a and b))		// a may,	b may   	... after a yes, b yes
		// if (!(!a and !b)		// a may,	b may   	... after a no,  b no
		// if (a or b)			// a may,	b may		... after a no,  b no		
		// if (!(a or b))		// a no,	b no		... after a may, b may
		// if (!(!a or !b))		// a may,	b may		... after a no,  b no 
		
		
		// if !msg or *msg
		// if (abc and m) or (*m == 1)
	return branchstate.Perhaps


function Niltracker.Decl (|message| declmsg)
	opt norefcounts
	|| exp = declmsg.last
	if exp == @rel
		exp = exp.last
	|| d = exp.AsDecl
	|| r = declmsg.AsDecl
	r.NilTake(d)	
	

function NilTracker.RunNormal (|message| msg, |branchstate|)
	opt norefcounts
	
	for s.fast in msg
		|| f = s.func
		if (f == @dot)
			|| Prop = s.NilPropAccess
				.UseChildAsReal(s)								// abc.var
		  elseif (f == @acc) 
			.UseChildAsReal(s)									// abc[0]
		  elseif (f == @brel) 
			if s != "*"
			.UseChildAsReal(s)									// *abc
		  elseif (f == @func)
			|| ch = s.first
			if ch == @bra
				.UseChildAsReal(ch)								//  (abc)()
			.CheckFunction(s)
		  elseif (f == @tmp)
			|| type = S.TmpType
			if Type is kif
				.If(s)
			  elseif type is kwhile
				.IfOrWhile(s)
			  elseif type is kReturn
				.Return(s)
		  elseif (f == @decl)
			.Decl(s)
				
		  elseif !s.IsLast
			.RunNormal(s)
		  else
			return .RunNormal(s) // tail-call opt
	return BranchState.Always



function message.nilmsg (|string|)
	if self == @thg
		return `NilObjectAccess: Needs "if" wrapping.`
	return "Possible NilObjectAccess"




/*
TODO:
* cpp-wrappers and prototypes default to not nil unless stated.
* pop the msgs out and restore nilused
* ternaries
* freeze bug

* modifications of objects via func pointer param... during a cond
* fn abc (|object| x)
	x = haha() // x is nil or not? haha? its literally been replaced so the original decl is unused.  unused decls default to optional
* msg.last/first etc will have to accept nil :O. The C++ compiler will opt it.



BOOLEAN LOGICS:
	refills and relsetters:
		if (!a) a = b(), a = &e
	
	multiple branches:
		if !a { if b {return 1} else {return 2} }
		a.b = 1
	
	return affecting future code:
		if (!msg)
			return
		msg.prop
	
	changes nothing:
		if (a or b)

	nil-checker funcs:
		can still be realish if returns false.


DONE?

function calls:
function gg (|object|)
	|| a = maybenil
	|| x = ff(a) // error: ff does not take nil.
	|| y = gg()  // error: unknown at this time if gg returns nil.

update the params:
	function abc (|message| o)
		o.position // o is now "!"

return values:
	if x
		return message()
	  else
		return nil // now this func returns optional values. 

using ptrs:
	if (*msg)

nilstrength:
	--nil=3

can access prop:
	if (msg)
		msg.prop

multiple tests:
	if (a and b)

redundant "m":
	if (m and m.length)
	if (!m or !m.length)

pointless:
	if nil == nil

fail:
	if msg >= nil, if msg <= nil

nil within branch:
	if msg == nil
*/


/*
* Init Vars Sweep?
	We need to go through the entire program, and give each item found, a "timecode". That
	is... it has an "earliest time" that it COULD occur.
perhaps just do it on a per-module basis... If a module makes no sense in terms of itself thats the programmers fault.
*/

/*
Issues:
What about the fact that a function's param nilness can rely on other funcs??
like:

	x = msg[0] // OK... so we don't rely on msg existing? but only cos it doesn't rely on self existing.
what if msg[n] is recursive and complicated? then how do we check if a decl... is nil or not?

The fact that we have ordered this... leaf first... helps. dependancies help... but that only reduces the problem
not eliminiates it. There will be cases that we can't eliminate.

* Make it nestable? That is... we actually can check functions?
	* this would only be needed for actual recursive functions... non-recursives would have a strict chain...
* what if two funcs with the same depth... and one is called before the other but the wrong one is called first?
	* then making it nestable helps!

* what about actually recursive funcs? I think for them... we let the user simply specify their nilness!! makes sense, right?
	* I think, just assume NOT NIL unless we can prove that it is tested. It is implicit and we can't be that smart.
*/

