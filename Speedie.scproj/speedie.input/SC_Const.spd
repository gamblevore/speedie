
/*
	Jeebox internals. By Theodore H. Smith...
*/


function SCNode.CollectOneConstants (|Message| ch)
	constantsloadingoverride = true
	.project.use
	using ch
	.CollectConstantsSub( ch )
	ConstantsLoadingOverride = false

	

function SCNode.CalculateConstRel (|message!| value, |&datatypecode| Ty, |uint64|)
	opt norefcounts
	|| A = value.first!
	|| L = .CalculateConst(A, Ty)
	require ty[] isnt failed
	
	|| B = A.next!
	|| C = b.next!
	if value == @brel
		expect (ty[] is int) (value, "Not an integer")
		return ~L
		
	|| op = scoperator.lookup(B)
	#!SSSSS
	|| R = .CalculateConst(C, Ty)
	expect (op is MathLike) (B)
	|| N = B.name.first
	|| Lg = b.name.length
	|| Ints = (ty[]).isint
	if n == '+'
		if Ints
			return L + R
		  else
			return (L|int64|.asfloat + R|int64|.asfloat).asint
	if n == '-'
		if Ints
			return L - R
		  else
			return (L|int64|.asfloat - R|int64|.asfloat).asint
	if n == '/'
		if Ints
			return L / R
		  else
			return (L|int64|.asfloat / R|int64|.asfloat).asint
	if n == 'm' // mod
		if Ints
			return L mod R
		  else
			return (L|int64|.asfloat mod R|int64|.asfloat).asint
	if n == '*'
		if Ints
			return L * R
		  else
			return (L|int64|.asfloat * R|int64|.asfloat).asint
	
	expect (ints) (value, "Not an integer")
	if n == '&'
		return L & R
	if n == '|' or '('
		return L ||| R
	if lg == 2
		if n == '<'
			|| T = L << R
			expect ((T >> R) == L) (value, "Loses numeric info.")
			return T
		if n == '>'
			|| T = L >> R
			expect ((T << R) == L) (value, "Loses numeric info.")
			return T
	
	error (value)
	
	

function SCNode.CalculateConst (|message!| value, |uint64|)
	|datatypecode| Ty = 0
	return .CalculateConst(value, ty)


function message.TypeExpect (|&datatypecode| Ty, |datatypecode| In)
	|| v = ty[]
		if  v != in  and  v isnt failed
			ty[] = datatypecode.failed
			error (self, "Can't mix floats/ints here.")
	  else
		ty[] = In


function SCNode.CalculateConst (|message!| value, |&datatypecode| Ty, |uint64|)
	opt norefcounts
	|| f = value.func
	if f == @num
		if value.name contains '.'
			value.TypeExpect(ty, datatypecode.float)
			return value.float.asint
		value.TypeExpect(ty, datatypecode.int)
		return value.int

	if f == @bra
		return .calculateconst(Value.first!, ty)
	
	if f == @thg
		if value ~= "true"
			value.TypeExpect(ty, datatypecode.bool)
			return 1
		if value ~= "false"
			value.TypeExpect(ty, datatypecode.bool)
			return 0
		|| d = self[value]
		if d isa scdecl 
			expect (d is const) (value, "Not a constant")
			if d.isfloat
				value.typeexpect(ty, datatypecode.float)
			  elseif d.isint
				value.typeexpect(ty, datatypecode.int)
			  else
				error (value, "Not a number")
				
			return d.exportposition
		  else
			error (value)
		return 0
	
	if f == @rel
		return .CalculateConstRel(value, ty)
		
	if f == @char
		return value.name.codepoint
	
	if value isbrel "~"
		return .CalculateConstRel(value, ty)
	
	error value
	return 0
	
	
		
	
	


function SCNode.CollectConstantsSub (|Message| ch)
	|| FuncName = ch.first									#require
	|| arg = ch[-1]
	|| vs = funcname

	if funcname == @thg
		vs = funcname.next
	  else
		funcname = nil

	expect (arg == vs) (vs)
	expect (arg == @arg or arg == @list) (arg)
	
	|uint64| NextNum = 0 + (ch == "flags")
	|uint64| StartNum = NextNum
	|uint64| LastFlag = 0
	
	|[SCDecl]|	FixLater
	|[message]|	NameList
	|SCDecl|	CurrType

	for (line in arg)
		|| LF = line.first.func
		|| LL = line.Last.func
		if (line == @rel) and (LF == @arr) or (LL == @arr)
			.ConstantExpand( line )
		  elseif (line == @tmp)
			expect !line.hasany (line)
			line.Func = @thg


	for (Line in arg)
		if (line == @decl)
			CurrType = ExtractDecl( line.first!, self, declmode.Globals )		#expect line
			line.remove
			continue
		if (line == "...")
			NextNum = StartNum
			Continue
		
		|scdecl| NewItem
			
		if (line == @Thg) // default numeric constant
			using (line)
			NewItem = SCDecl(typeint!)
			|| NewNum = NewDeclNum( NewItem, NextNum, line.name )
			newitem.source = line
			if (ch == "flags")
				LastFlag++
				NextNum <<= 1
			  else
				NextNum++

			if currtype
				currtype.AssignabilityCheck(nil, newnum, currtype)
				currtype.copytypeinfoto(newitem)
			
		  elseif line == @bra
			nextnum = .CalculateConst(line.first!)
		
		  else
			|| ValueNode = Line.last
			|| thg = line[ @Thg ]
			require  line.expect(@rel)  and  line[@opp, 1].expect(@opp, "=")  and  valuenode  and  thg
			|| OMGType = TypeOfExpr( ValueNode, self )		#require // can’t seem to remove this.
			|| NewType = CurrType
			if !NewType
				newtype = OMGType
			NewItem = SCDecl(newtype.type)

			if (ValueNode == @Str or @sstr)
				SCFunction.ObjectifyString(ValueNode)
				ValueNode.obj = TypeString!.typenormal
				
			  elseif (valuenode.isint) or (valuenode == @unit)
				NewType.AssignabilityCheck(nil, ValueNode, OMGType)  
				nextnum = valuenode.int
				newitem.numberconst = nextnum
				nextnum++
			  else
				newitem.numberconst = .CalculateConst(Valuenode)
			
			FixLater <~ NewItem
			
			NewType.CopyTypeInfoTo( NewItem )
			NewItem.name = thg.name
			NewItem.Default = ValueNode
			newitem.source = thg

		if newitem
			compiler.newconst(newitem)
			NameList <~ NewItem.source!
			.TryAdd( line, NewItem, NewItem.Name )
	
	
//	if (ch == "flags")
//		|| s = (FuncName.Name, "Flag")(FuncName)
//		.AddNumericConst("Largest" + s, lastflag|int|.bits, ch)
	
	for (D in FixLater)
		.Tran_Const( D, self )

	if (FuncName)
		.CreateNameDict( FuncName, NameList )



function SCNode.Tran_Const (|SCDecl| D, |SCNode| base)
	|| root = D.default!
	|| Using = root.SyntaxUsing

	for curr.flat in root
		if curr == @thg
			require TypeOfExpr(curr, base)
			|| actual = base[curr.name]
			if actual isa SCDecl
				|| BetterVersion = actual.Default!.Copy(curr)
				curr.ReplaceWith( BetterVersion )				
			  else
				expect ((curr.obj == TypeString!.TypeNormal) or (curr ~= "true") or (curr ~= "false")) (curr, "This type isn't allowed for a constant.")
			
		  elseif curr == @unit
			require TypeOfExpr(curr, base)
			
		  elseif (curr == @str) or ((curr==@num) and curr.parent!=@unit)
			require TypeOfExpr(curr, base)




function message.ConstIntValueSub (|SCNode| name_space, |&int64| v, |bool|)
	opt norefcounts
	|| s = self
	while s == @bra
		s = s.first!
	if s == @num
		v[] = s.int
		return true
	if (s == @thg) and s.name[0,"syx"]
		|| find = _syxdict_.valuelower(s.name[3...])
			v[] = find.id|int64|
			s.become(@num, v[].render)
			return true


function message.ConstIntValue (|SCNode| name_space, |&int64| v, |bool|)
	opt norefcounts
	if .ConstIntValueSub(name_space, v)
		return true

	|| t = typeofexpr(self, name_space)
		|| d = t.default
			// error (d is const) (itm, "We need a constant for the index") // not neeeded
			return d.constintvaluesub(name_space, v)


struct ArgArrayCounter
	|int|  i
	|int|  max
	|bool| IsItem
	|bool| IsNotItem
	
	function Check (|message| exp)
		if (.isitem and .isnotitem)
			error (exp, "Mixed indexes found. (Some have ':' and some don't)")

	function Do (|string| name, |message| item, |SCNode| name_space, |message|)
		opt norefcounts
		|| acc = «acc, «thg name » »
		|| arr = acc.msg(@arr)
		|| value = item
		if value == @item
			.IsItem = true
			|| key = item[@nil]
				|int64| v
				if key.ConstIntValue(name_space, v) #check (item, "Can't load constant.")
					(.max max= v)
				arr <~ key
				value = item.first
		  else
			.IsNotItem = true
			arr <~ (.i)++
			.max = .i
		return NeweqRel( acc, value )			// [1:x, 4:y]


function @scmodule.ConstantCollector (collectfunc)
	compiler.ConstantsList <~ node
	if name_space isa SCClass
		node.Obj = name_space.Modul
	  else
		node.Obj = name_space
	return compiler.program


function compiler.CollectConstants
	opt norefcounts
	for ch in .constantslist
		|| b = ch.obj as SCNode
			b.CollectOneConstants(ch)


function datatypecode.NumericCountBoolsToo (|scdecl| D, |int|)
	if (Self & numeric)
		return .count
	if !self
		return 1
	if scnode.ConstantsLoadingOverride and d is const
		return .count
		

