

struct NilTracker
	linkage:cpp_part nil
	|bool| 				NeedsTracking // base does not
	|uint64| 			Count
	|message|			If
	|message--[1024]|	Items
	
	
	function SetNil (|message| m, |scdecl| d, |nilstate| s, |scdecl|)
		opt norefcounts

		if (.count < 1024) 
			if d.nilused > 3 // what?
			m.Indent = d.NilUsed
			.items[.count++] = m
			return d

		error (m, "Too many variables")
		return d

		// what if d is a lookup for something else?
		// like:    if (a isa b): a.bfunc

	function Start (|scfunction| f)
		opt norefcounts
		scfunction.currfunc = f
		.if = nil
		.Count = 0
		for d in f.args				// no need add prms.... only log changes
			d.RestoreNil
	
	function Tighten (|scfunction| f)
		opt norefcounts
		for (d in f.args) (i)
			if d.NeedsNilTighten
				f.args[i] = d.NilTighten
		if f.ReturnType.NeedsNilTighten
			f.ReturnType = f.ReturnType.NilTighten

	function SCDecl.NilTighten (|scdecl|)
		if .NilUsed isnt Nil
			return .MakeReal
		return .MakeOptional

	
	function Restore
		opt norefcounts
		for i in .count
			|| m = .items[i]
				m.AsDecl.RestoreNil
	
	iterator
		|| n = 0
		while (n < .count++)
			yield self[n]
	module
		|| nilerr = "Possible NilObject Access."
	


function SCDecl.RestoreNil
	.nilused = .nildeclared


function SCdecl.NeedsNilTighten (|bool|)
	if self
		if (.NilDeclared isnt stated) and (.nilused is stated)
			return true
		return false
		if .nilused is Stated
			if !options.perry
				debugat
