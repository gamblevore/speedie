

struct NilTracker
	linkage:cpp_part nil
	|uint| 				IfDepth
	|uint| 				MsgCount
	|scfunction--|		fn
	|message--[2048]|	Items


	function Enter (|uint|)
		.ifdepth++
		return .MsgCount


	function Leave (|uint| s)
		.MsgCount = s
		.IfDepth--


	function SetNilness (|message| m, |scdecl| d, |nilstate| s, |branchstate|)
		opt norefcounts
		if d.nilused > 3 // what?
		m.Indent = d.NilUsed
		d.nilused = s
		|| c = .MsgCount
		if (c >= 2048) 
			error (m, "Too many variables")
		  elseif c
			m.Indent = d.NilUsed
			.items[c] = m
			.MsgCount = c + 1
		return BranchState.Perhaps


	function Start (|scfunction| f)
		opt norefcounts
		scfunction.currfunc = f
		.MsgCount = 0
		.fn = f
		|| r = f.returntype
			r.NilUsed = 0 // :)
		for (d in .fn.args) (i)				// no need add prms.... only log changes
			d.NilParamPos = i
			d.RestoreNil


	function Finish (|scfunction| f)
		opt norefcounts
		f.ReturnType.State
		.fn = nil
	
	iterator
		|| n = 0
		while (n < .MsgCount++)
			yield self[n]
	


function SCDecl.RestoreNil
	if .nilused != .NilDeclared // is this ever used?
	.nilused = .nildeclared


function SCDecl.NilTake (|scdecl| d)
	opt norefcounts
	|| n = d.NilDeclared
	.NilUsed = n
	.NilDeclared = n


function SCDecl.IsNowNil (|bool|)
	return (self == TypeNil) or (.nilused isnt real)

function SCDecl.State
	opt norefcounts
	.nildeclared = .NilUsed (|) nilstate.stated


function scdecl.SuffersNil (|bool|)
	return .IsObject or .PointerCount


function scdecl.IsStated (|bool|)
	return .NilDeclared is Stated
