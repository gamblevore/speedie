

struct NilItem
	|scdecl--|	Decl
	|nilstate|	Nil
	|byte|		IfDepth


/*
	OK... so... how does the ifdepth work?
	Each decl has a depth at which it is declared?
	Or are we talking about the current state of the decl within the branch??
	
	Not sure? for a start lets increase the depth.
*/

struct NilTracker
	linkage:cpp_part nil
	|uint| 				DeclCount
	|uint| 				IfDepth
	|scfunction--|		fn
	|NilItem[1536]|		Items

	function Undo (|uint| s)
		.Restore(s)
		.DeclCount = s
	
	function Restore (|uint| s)
		.merge(s, false)

	function Merge (|uint| s, |bool| Merge=true)
		|| c = .DeclCount
		|| id = .IfDepth
		.DeclCount = s
		while s >= --c
			|| i = &.items[c]
			|| d = i.decl
			|| v = i.nil
			if Merge
				v |= d.nilused
			d.nilused = v
			if d.IfDepth >= id
				debugger // bad
			

	function SetNilness (|scdecl| d, |nilstate| s)
		|| dd = d.ifDepth
			debug_require dd < .ifdepth // what?
			.items[dd].nil = s
		  else
			.TestedNilness(d, s)
	
	
/*
	What are we doing with the ifdepth?
	
	ifdepth.... hmmm
	
	so we only wanna change the value within the same branch
	So when we declare a decl... we set it with the current value
	
	then within the branch its set again... but now the ifdepth has to increase
	
	OK... so why do we need this? what were we doing before. 

	we set the decl.... we got an ifbranch, no ifdepth
	we store any changes, then undo them. do we need an ifdepth?
	no! i dont think so... because we keep the current depth via DeclCount
	
	what about multiple sets so that we don't merge invalid values. only the last state.
	
	x = nil
	x = realobj()
	// merge both? NO!
	
	OK... so its for multiple sets within a branch.
	
	OK... so if we set something during the cond... where is it set?
	not into the cond... righht? in fact not during any of the else ifs...!
*/
	
	function TestedNilness (|scdecl| d, |nilstate| s)
		opt norefcounts
		if d.nilused > 3 // what?
		|| c = .DeclCount
		if (c < 1536) 
			|| i = &.Items[c]
			|| id = .IfDepth
			i.nil = d.NilUsed
			i.decl = d
			.DeclCount = c + 1
			d.nilused = s
			d.ifDepth = id
			i.ifDepth = id
			return
		
		error (.fn, "Too many variables for nilchecker")


	function Start (|scfunction| f)
		opt norefcounts
		scfunction.currfunc = f
		.DeclCount = 1 // because of scdecl.NilDepth
		.fn = f
		|| r = f.returntype
			r.NilUsed = 0 // :)
		for d in .fn.args
			d.RestoreNil


	function Finish (|scfunction| f)
		opt norefcounts
		f.ReturnType.DeclareAsUsed?
		.fn = nil
		


function SCDecl.RestoreNil
	if .nilused != .NilDeclared // is this ever used?
	.nilused = .nildeclared

function SCDecl.NilTake (|scdecl| d)
	opt norefcounts
	|| n = d.NilDeclared
	.NilUsed = n
	.NilDeclared = n

function SCDecl.IsNowNil (|bool|)
	return (self == TypeNil) or (.nilused isnt real)

function SCDecl.DeclareAsUsed
	opt norefcounts
	.nildeclared = .NilUsed (|) nilstate.stated

function scdecl.SuffersNil (|bool|)
	return .IsObject or .PointerCount

function scdecl.IsStated (|bool|)
	return .NilDeclared is Stated

