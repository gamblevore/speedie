

struct NilTracker
	linkage:cpp_part nil
//	|uint| 				IfDepth
	|uint| 				MsgCount
	|scfunction--|		fn
	|scdecl--[1750]|	Decls
	|nilstate[1750]|	Values


	function Save (|uint|)
		return .MsgCount


	function Restore (|uint| s)
		|| c = .MsgCount
		while --s >= c
			.decls[s].nilused = .Values[s]
		.MsgCount = s

	function Merge (|uint| s)
		|| c = .MsgCount
		while --s >= c
			.decls[s].nilused |= .Values[s]
		.MsgCount = s


	function SetNilness (|scdecl| d, |nilstate| s)
		opt norefcounts
		if d.nilused > 3 // what?
		|| c = .MsgCount
		if (c < 1750) 
			.values[c] = d.NilUsed
			.Decls[c] = d
			.MsgCount = c + 1
			d.nilused = s
			return
			
		error (.fn, "Too many variables for nilchecker")


	function Start (|scfunction| f)
		opt norefcounts
		scfunction.currfunc = f
		.MsgCount = 0
		.fn = f
		|| r = f.returntype
			r.NilUsed = 0 // :)
		for (d in .fn.args) (i)				// no need add prms.... only log changes
			d.NilParamPos = i // unused?
			d.RestoreNil


	function Finish (|scfunction| f)
		opt norefcounts
		f.ReturnType.DeclareAsUsed?
		.fn = nil
	
	iterator
		|| n = 0
		while (n < .MsgCount++)
			yield self[n]
	


function SCDecl.RestoreNil
	if .nilused != .NilDeclared // is this ever used?
	.nilused = .nildeclared


function SCDecl.NilTake (|scdecl| d)
	opt norefcounts
	|| n = d.NilDeclared
	.NilUsed = n
	.NilDeclared = n


function SCDecl.IsNowNil (|bool|)
	return (self == TypeNil) or (.nilused isnt real)

function SCDecl.DeclareAsUsed
	opt norefcounts
	.nildeclared = .NilUsed (|) nilstate.stated


function scdecl.SuffersNil (|bool|)
	return .IsObject or .PointerCount


function scdecl.IsStated (|bool|)
	return .NilDeclared is Stated
