

struct NilTracker
	linkage:cpp_part nil
	|uint64| 			Count
	|message|			If
	|message--[1024]|	Items
	

	syntax Append (|scdecl| d)
		opt norefcounts
		|| m = d.source
			// what if d is a lookup for something else?
			// like:    if (a isa b): a.bfunc
			self <~ (m, d)
		  else
			debugger 
	
	syntax Append (|message| m, |scdecl| d)
		expect (.count < 1024) (m, "Too many variables")
		m.Indent = d.NilUsed & 3
		.items[.count++] = m

	function Start (|scfunction| f)
		opt norefcounts
		scfunction.currfunc = f
		.if = nil
		.Count = 0
		for d in f.args				// no need add prms.... only log changes
			d.NilUsed = d.NilDeclared
	
	function Tighten (|scfunction| f)
		opt norefcounts
		for (d in f.args) (i)
			if d.NeedsNilTighten
				f.args[i] = d.NilTighten
		if f.ReturnType.NeedsNilTighten
			f.ReturnType = f.ReturnType.NilTighten

	function SCDecl.NilTighten (|scdecl|)
		if .NilUsed isnt Nil
			return .MakeReal
		return .MakeOptional

							
//	function Pop (|scdecl|)
//		if .count
//			return .items[--.count]
	
	function Restore
		opt norefcounts
		for i in .count
			|| m = .items[i]
				m.AsDecl.RestoreNil
	
	iterator
		|| n = 0
		while (n < .count++)
			yield self[n]


function SCDecl.RestoreNil
	.nilused = .nildeclared


function SCdecl.NeedsNilTighten (|bool|)
	if self
		if (.NilDeclared isnt stated) and (.nilused is stated)
			return true
		return false
		if .nilused is Stated
			if !options.perry
				debugat
