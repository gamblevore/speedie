#!/usr/local/bin/speedie


datatype Type (int)
	flags // compressed should be an action?
		ReadOK, Compressed, Plain, XML, actions=(Box, Jbin, Report), StdOut, SelfReplace, TestComp
	
	syntax is (|Type| test, |bool|)
		return self & test 
	syntax isnt (|Type| test, |bool|)
		return !(self & test)
	function Format (|Type|) 
		return self & (Box (|) jbin (|) xml)
	
	render
		if self is Compressed
			fs <~ "compressed "
		if self is jbin
			fs <~ "jbin"
		  elseif self is box
			fs <~ "jeebox"
		  elseif self is xml
			fs <~ "xml"
		  else // speedie can't put this on a single line. C++ compile-error!
			fs <~ "plain"


function app.UseOne (|file| f)
	conv.in = f
	conv.out = conv.OutPath
	if conv.in.IsDir
		if app.args == 1
			"${conv.in} is a folder"
	  elseif (conv.dest is TestComp)
		conv.TestOne
	  else 
		conv.Process
	conv.End


function app.UseAll (|file| start)
	for c.files in start
		if !c.isdir
			.UseOne(c)
		  elseif c.IsLink
			printline "Can't recursively enter link: " + c
		  elseif c.visible
			.useall(c)
	
main {
	if !app.args
		print .usage
		return 0

	conv.Dest = .GetActions$
	expect (conv.Dest.Format.CountBits <= 1) ("Error: Multiple formats specified.")
	
	|| GotAll = false
	for r in app.args
		if r == "**"
			expect (!GotAll) ("Can't use '**' twice.")
			.useall(app.cwd.file)
			GotAll = true
		  else
			.useone(r.file)
	
	if (stderr.ok) and (!conv.done) and (conv.dest isnt report)
		"Nothing to do. All files already in destination format."
}

function App.Singlefile (|string| sw)
	check (app.args == 1) ("Can't write multiple files with switch: " + sw)


function App.GetActions (|Type|)
	for s in app.Switches
		|| name = s.ArgName
		|| v = s.ArgValue
		if name ~= "r"
			rz |= type.report
		  elseif name ~= "j"
			rz |= type.box
		  elseif name ~= "b"
			rz |= type.jbin
		  elseif name ~= "s"
			rz |= type.selfreplace
		  elseif name ~= "p"
			rz |= type.stdout
			.SingleFile(name)
		  elseif name ~= "o"
			|| x = type.compressed * (v contains 'm')
			x |= type.xml  * (v contains 'x')
			x |= type.jbin * (v contains 'b')
			x |= type.box  * (v contains 'j')
			conv.DetectOnly = x
		  elseif name ~= "test"
			rz |= type.TestComp
			rz |= type.compressed
		  elseif name ~= "c"
			rz |= type.compressed
			if v!="true"
				conv.DefaultStrength = v.int|int| max MZLab.Fastest
		  elseif name ~= "f"
			Conv.destpath = v
			.SingleFile(name)
			check (v) "Add a value, eg: --f=value"
		  else
			error "Unknown switch $s"

	rz |= type.plain
	check ((rz & type.actions).CountBits <= 1) ("Too many actions.")


function app.usage (|string|)
	return "Usage: ${.filename} File1 [File2...]
Convert files between jbin, box, xml formats. Additionally can compress or decompress.

    -j              Convert to jeebox
    -b              Convert to jbin
    -c              Compress
    -c=0            Compress for very-fast decompress
    -s              Replace file in-place
    -p              Print to stdout
    -r              Just report types, otherwise do nothing
    -f=name         Sets the filename of output
    -o=j/b/m/x/h    Detect only specified type.
                    j = jeebox, b = jbin, m = compressed, x = xml

examples:
    jz -j A.xml   					// xml to jeebox
    jz -c A.xml   					// compress A.xml into A.xml.mz
    jz    A.txt.mz   				// decompress A.txt.mz to A.txt
    jz -b A.box   					// jeebox to jbin
    jz -b A.xml   					// xml to jbin
"


module Conv
	|string|		Data
	|file|			In
	|file| 			Out
	|date|			Start
	|type| 			DetectOnly = -1
	|type| 			Dest
	|type| 			Detected
	|float| 		Size
	|message| 		AST
	|int| 			MaxNodeLength = 128 //int.max
	|int|			Done
	|string|		DestPath
	|bool| 			FileIsCompressed
	||				DefaultStrength = mzlab.strong
	|| 				Speed = faststring()
	

	function End
		|| s = .speed.GetResult
			printline s
		.in = nil
		.data = nil
		.start = nil
		.ast = nil
		.Detected = nil
		CompressionStats.all.Clear
	

	function TestOne
		require .in.MustExist("test compression")
		.done++
		|| OrigIn = .in
		|| OrigOut = .out
		.DefaultStrength = MZLab.Fast

		.TestSub(origIn)

		.in = origin
		.out = OrigOut
		.DefaultStrength = MZLab.Strong
		.TestSub(origIn)

		.del(.out, origin)		
		.del(origout, origin)

	
	function del (|file| f, |file| o)
		if f.exists and f.path != o.path	
			"deleting ${f.name}"
			f.delete
		
		
	function TestSub (|file| orig)
		require StdErr.ok
		expect (!.DestPath) ("Can't specify a dest-path!")

		.CompressOnly(false)
		require stderr.ok

		.in = .out
		.out = (.in + ".back").file

		.CompressOnly(true)
		require stderr.ok
		
		.out.CompareFile(Orig, Orig)
		
	
	function Time (|string| Name, |bool| compress=false)
		require .dest isnt stdout // would ruin output
		if !compress
			|| ago = .Start.ago
			|float| scale = 1MB
			if .data
				size = .data.Length
			|| speed = ""
			|| s    = ago.seconds
			|| s2   = (s*1000, s)(s < 0.01)
			|| unit = ("ms", "s")(s < 0.01) 
			conv.speed <~ "    $Name: ${s2}$unit" 
			if s
				conv.speed <~ "  (${Size/(scale*s)}MB/s)"
			conv.speed <~ '\n'
			// why not fill up the stats.all thing and reuse it?
		  else
			conv.speed <~ (' ', 4)
			CompressionStats.all.Render(conv.speed)
			CompressionStats.all.Clear
			conv.speed <~ '\n'

		
	function CompressOnly (|bool| Decomp)
		printline .out|string|
		|| d = .out.out
		|| src = .in.in
		require src and d
		.start = date() 
		if Decomp
			.size = d.File.size
			src.DecompressInto(d)
			.time("Decompress(streamed )", true)
		  else 
			|| typ = ("µz", "ro")(.defaultstrength < mzlab.strong)
			.size = .in.size
			src.CompressInto(d, DefaultStrength) 
			.time("Compress(streamed $typ)", true)
	

	function Read (|bool|)
		|| OrigSize = 0
		|| CmpFormat = .in.FormatInfo(OrigSize)
		|| IsJbin = CmpFormat == "jbin"
			CmpFormat = ""
			.Detected |= type.jbin
		
		.FileIsCompressed = CmpFormat!=""
		if .FileIsCompressed
			.Detected |= type.compressed // only read compressed at first
		
		if .DetectOnly != -1 
			require .Detected & .detectonly
			printline "Found: ${.in.path}"

		if !(Dest&type.Actions)
			if (FileIsCompressed != (dest is compressed))
				.done++
				.CompressOnly(FileIsCompressed)
			return 0
		.done++
		if (Dest is report) and CmpFormat
			"$.in is: ${OrigSize.strsize} compressed to ${.in.size.strsize} ($CmpFormat)"
			return 0
				
		.start = date()
		.data = .in.ReadAll(int.max, false)
		if .data != string.error
			.Detected |= type.ReadOK
		if (Dest is report) and (.data == "")
			if StdErr.OK
				"$.in is empty"
			return 0
		.Time("Read ")
		
		if .FileIsCompressed
			.start = date()
			.data = .data.Decompress(int.max)
			.time("Decompress", true)
		
		if Dest is report
			"$.in is: ${.Detected.render}"
			return 0
		return true

	
	function Detect (|bool|)
		require .detected

		.start = date.now
		.AST = .data.Parse // no errors actually :)
		if !.AST
			stderr.pop
		  else
			.time("Parse")
		.done++
		
		if !.AST
			.detected |= type.plain
		  elseif .data.IsJbin
			.detected |= type.jbin
		  elseif .AST.Find(@xml)
			.detected |= type.xml
			if dest isnt report
				.start = date.now
				require .AST.XMLToJeebox
				.time("Convert XML")
		  else
			.detected |= type.box

		return true


	function Transform (|bool|) 
		|faststring| fs
		if dest isnt compressed
			fs = .out.Out							#require

		if .AST and (Detected.format != Dest.format)
			.Start = date.now
			if dest is jbin
				.data = .AST.render_jbin(fs)
			  else
				.data = .AST.Render(fs)
			.time("Render")

		if .dest is compressed 
			.start = date.now
			fs = .out.out							#require
			.data.Compressinto(fs, .DefaultStrength)
			.time("Compress")

		fs.Flush
		if !fs
			"Nothing to do for: $.out"
		if .dest isnt stdout
			printline .out.path


	function Process
		if .in.MustExist and .Read and .Detect
			.Transform


	function Ext (|string|)
		if dest is box
			return "box"
		if dest is jbin
			return "jbin"
	
	
	function OutPath (|file|)
		if dest is stdout
			return app.StdOut
		if DestPath
			return destpath.file
		if dest is selfreplace
			return .in
		|| str = .in.path
		if str isa "mz"
			str = .in.trimext
			
		if str isa "box" or "jbin" or "xml"
			str = str.SetExt(.ext)
		  else
			str = str.AddExt(.ext) 
		if dest is compressed
			str = str.AddExt("mz")
		  elseif ((.in isa "mz") and str.FileExists) or (str == .in)
			str += ".back"
		return str.file
	
	
function file.FormatInfo (|&int| Size=0, |string|)
	|| str = .Section(0, 32)
		if str == string.error
			return str
	if str.IsJbin
		rz = "jbin"
		|| mz = str.parse_jbin
		if mz == @tmp and "µz"
			|| arg = mz.last
			if arg != @arg
				rz = string.error
			  else
				|| s = arg.prev.int
				if size
					*size = s
				if !s
					rz = string.Error
				  elseif arg ~= "ro"
					rz = "ro"
				  else
					rz = "µz"
					
