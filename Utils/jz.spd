#!/usr/local/bin/speedie


datatype Type (int)
	flags // compressed should be an action?
		ReadOK, Compressed, Plain, XML, actions=(Box, Jbin, Report), StdOut, SelfReplace, TestComp
	
	syntax is (|Type| test, |bool|)
		return self & test
	syntax isnt (|Type| test, |bool|)
		return !(self & test)
	function Format (|Type|) 
		return self & (Box (|) jbin (|) xml)
	
	render
		if self is Compressed
			fs <~ "compressed "
		if self is jbin
			fs <~ "jbin"
		  elseif self is box
			fs <~ "jeebox"
		  elseif self is xml
			fs <~ "xml"
		  else // speedie can't put this on a single line. C++ compile-error!
			fs <~ "plain"


function app.UseOne (|file| f)
	conv.in = f
	conv.Out = conv.OutPath.file
	if conv.in.IsDir
		if app.args == 1
			"${conv.in} is a folder"
	  elseif (conv.dest is TestComp)
		conv.TestOne
	  else
		conv.Process
	conv.End


function app.UseAll (|file| start)
	for c.files in start
		if !c.isdir
			.UseOne(c)
		  elseif c.IsLink
			printline "Can't recursively enter link: " + c
		  elseif c.visible
			.useall(c)
	
main {
	if !app.args
		print .usage
		return 0

	conv.dest = .GetActions$
	
	|| GotAll = false
	for r in app.args
		if r == "**"
			expect (!GotAll) ("Can't do this twice: '**'.")
			.useall(app.cwd.file)
			GotAll = true
		  else
			.useone(r.file)
	
	if (stderr.ok) and (!conv.done) and (conv.dest isnt report)
		"Nothing to do. All files already in destination format."
}

function App.Singlefile (|string| sw)
	check (app.args == 1) ("Can't write multiple files with switch: " + sw)


function App.GetActions (|Type|)
	for s in app.Switches
		|| name = s.ArgName
		|| v = s.ArgValue
		if name ~= "r"
			rz |= type.report
		  elseif name ~= "j"
			rz |= type.box
		  elseif name ~= "b"
			rz |= type.jbin
		  elseif name ~= "s"
			rz |= type.selfreplace
		  elseif name ~= "p"
			rz |= type.stdout
			.SingleFile(name)
		  elseif name ~= "o"
			|| x = type.compressed * (v contains 'm')
			x |= type.xml  * (v contains 'x')
			x |= type.jbin * (v contains 'b')
			x |= type.box  * (v contains 'j')
			conv.DetectOnly = x
		  elseif name ~= "test"
			rz |= type.TestComp
			rz |= type.compressed
		  elseif name ~= "c"
			rz |= type.compressed
			if v!="true"
				conv.DefaultStrength = v.int|int|.clamp(MZLab.Fastest, MZLab.Strongest)
		  elseif name ~= "f"
			Conv.destpath = v
			.SingleFile(name)
			check (v) "Add a value, eg: --f=value"
		  else
			error "Unknown switch $s"

	rz |= type.plain
	check ((rz & type.actions).CountBits <= 1) ("Too many actions.")


function app.usage (|string|)
	return "Usage: ${.filename} File1 [File2...]
    options:
        -j          Convert to jeebox
        -b          Convert to jbin
        -c          Compress
        -c=0        Compress for very-fast decompress
        -s          Replace file in-place
        -p          Print to stdout
        -r          Just report types, otherwise do nothing
        -f=name     Sets the filename of output
        -o=j/b/m/x  Detect only specified type.
                    j = jeebox, b = jbin, m = compressed, x = xml

    examples:
        jz -j A.xml   					// xml to jeebox
        jz -c A.xml   					// compress A.xml into A.xml.mz
        jz    A.txt.mz   				// decompress A.txt.mz to A.txt
        jz -b A.box   					// jeebox to jbin
        jz -b A.xml   					// xml to jbin
"


module Conv
	|string|		Data
	|file|			In
	|file| 			Out
	|date|			Start
	|type| 			DetectOnly = -1
	|type| 			Dest
	|type| 			Detected
	|float| 		Size
	|message| 		AST
	|int| 			MaxNodeLength = 128 //int.max
	|int|			Done
	|string|		DestPath
	|bool| 			FileIsCompressed
	||				DefaultStrength = mzlab.strong
	|| 				Speed = faststring()
	

	function End
		|| s = .speed.GetResult
			printline s
		.in = nil
		.data = nil
		.start = nil
		.ast = nil
		.Detected = nil
		CompressionStats.all.Clear
	
	
	function TestOne
		require .in.MustExist("test compression")
		|| OrigIn = .in
		|| OrigOut = .out
		.DefaultStrength = MZLab.Fast
		.TestSub(origIn)

		.in = origin
		.out = OrigOut
		.DefaultStrength = MZLab.Strong
		.TestSub(origIn)

		.del(.out, origin)		
		.del(origout, origin)
		.done++
	
	
	function del (|file| f, |file| o)
		if f.exists and f.path != o.path	
			"deleting ${f.name}"
			f.delete
		
		
	function TestSub (|file| orig)
		require StdErr.ok
		expect (!.DestPath) ("Can't specify a dest-path!")

		.CompressOnly(false)
		require stderr.ok

		.in = .out
		.out = (.in + ".back").file

		.CompressOnly(true)
		require stderr.ok
		
		.out.CompareFile(Orig, Orig)
		
	
	function Time (|string| Name, |bool| compress=false)
		require .dest isnt stdout // would ruin output
		if !compress
			|| ago = .Start.ago
			|float| scale = 1MB
			if .data
				size = .data.Length
			|| speed = ""
			|| s    = ago.seconds
			|| s2   = (s*1000, s)(s < 0.01)
			|| unit = ("ms", "s")(s < 0.01) 
			conv.speed <~ "    $Name: ${s2}$unit" 
			if s
				conv.speed <~ "  (${Size/(scale*s)}MB/s)\n"
			// why not fill up the stats.all thing and reuse it?
		  else
			conv.speed <~ (' ', 4)
			CompressionStats.all.Render(conv.speed)
			conv.speed <~ '\n'

		
	function CompressOnly (|bool| Decomp)
		printline .out|string|
		|| dest = .out.out
		|| src = .in.in
		require src and dest
		.start = date() 
		if Decomp
			src.DecompressInto(dest)
			.size = dest.File.size
			.time("Decompress(streamed )", true)
		  else 
			.size = .in.size
			|| type = ("µz", "ro")(.defaultstrength < mzlab.strong)
			src.CompressInto(dest, DefaultStrength) 
			.time("Compress(streamed $type)", true)
	

	function Read (|bool|)
		|| OrigSize = 0
		|| CmpFormat = .in.FormatInfo(OrigSize)
		|| IsJbin = CmpFormat == "jbin"
			CmpFormat = ""
			.Detected |= type.jbin
		
		.FileIsCompressed = CmpFormat!=""
		if .FileIsCompressed
			.Detected |= type.compressed // only read compressed at first
		
		if .DetectOnly != -1 
			require .Detected & .detectonly
			printline "Found: ${.in.path}"

		ifn Dest&type.Actions
			if FileIsCompressed != (dest is compressed)
				.done++
				.CompressOnly(FileIsCompressed)
			return 0
		
		.done++
		if (Dest is report) and CmpFormat
			"$.in is: ${OrigSize.strsize} compressed to ${.in.size.strsize} ($CmpFormat)"
			return 0
				
		.start = date()
		.data = .in.ReadAll(int.max, false)
		if .data != string.error
			.Detected |= type.ReadOK
		if (Dest is report) and (.data == "")
			if StdErr.OK
				"$.in is empty"
			return 0
		.Time("Read ")
		
		if .FileIsCompressed
			.start = date()
			.data = .data.Decompress(int.max)
			.time("Decompress", true)
		
		if Dest is report
			"$.in is: ${.Detected.render}"
			return 0
		return true

	
	function Detect (|bool|)
		require .detected

		.start = date.now
		.AST = .data.Parse // no errors actually :)
		if !.AST
			stderr.pop
		  else
			.time("Parse")
		.done++
		
		if !.AST
			.detected |= type.plain
		  elseif .data.IsJbin
			.detected |= type.jbin
		  elseif .AST.Find(@xml)
			.detected |= type.xml
			if dest isnt report
				.start = date.now
				require .AST.XMLToJeebox
				.time("Convert XML")
		  else
			.detected |= type.box

		return true


	function Transform (|bool|)
		if !.AST
			0
		  elseif (Detected.format != Dest.format)
			.Start = date.now
			if dest is box
				.data = .AST.Render
			  else
				.data = .AST.render_jbin
			.time("Render")

		if .dest is compressed
			.start = date.now
			.data = .data.Compress(DefaultStrength)
			.time("Compress")
		return true


	function Process
		require .in.MustExist and .Read and .Detect and .Transform
			
		if dest is stdout
			print .data
		  elseif .Out.data(.data)
			printline .out.path


	function OutPath (|string|)
		if destpath
			return destpath.file
		
		if dest is selfreplace
			return .in
		|| ext = ""
		if dest is box
			ext = "box"
		  elseif dest is jbin
			ext = "jbin"
		rz = .in.RemoveExt("mz")
		if ext
			if rz isa "box" or "jbin" or "xml"
				rz = rz.SetExt(ext)
			  else
				rz = rz.AddExt(ext)
		if dest is compressed
			rz = rz.AddExt("mz")
		  elseif ((.in isa "mz") and rz.FileExists) or (rz == .in)
			rz += ".back"
	
	
function file.FormatInfo (|&int| Size=0, |string|)
	|| str = .Section(0, 32)
		if str == string.error
			return str
	if str.IsJbin
		rz = "jbin"
		|| mz = str.parse_jbin
		if mz == @tmp and "µz"
			|| arg = mz.last
			if arg != @arg
				rz = string.error
			  else
				|| s = arg.prev.int
				if size
					*size = s
				if !s
					rz = string.Error
				  elseif arg ~= "ro"
					rz = "ro"
				  else
					rz = "µz"
