#!/usr/local/bin/speedie

// balz decomp still fails! on big files or all?
datatype Type (int)
	flags // compressed should be an action?
		Compressed, Plain, XML, actions=(Box, Jbin, Report), StdOut, SelfReplace, TestThem
	
	syntax is (|Type| test, |bool|)
		return self & test
	syntax isnt (|Type| test, |bool|)
		return !(self & test)
	
	function Format (|Type|)
		return Box (|) jbin (|) xml
	
	render
		if self is Compressed
			fs <~ "compressed "
		if self is jbin
			fs <~ "jbin"
		  elseif self is box
			fs <~ "jeebox"
		  elseif self is xml
			fs <~ "xml"
		  else // speedie can't put this on a single line. C++ compile-error!
			fs <~ "plain"



function App.Singlefile (|string| sw)
	check (app.args == 1) ("Can't write multiple files with switch: " + sw)
	
function App.GetActions (|Type|)
	for s in app.Switches
		|| name = s.ArgName
		if name ~= "r"
			rz |= type.report
		  elseif name ~= "j"
			rz |= type.box
		  elseif name ~= "b"
			rz |= type.jbin
		  elseif name ~= "s"
			rz |= type.selfreplace
		  elseif name ~= "p"
			rz |= type.stdout
			.SingleFile(name)
		  elseif name ~= "test"
			rz |= type.TestThem
		  else
			|| v = s.ArgValue
			if name ~= "c"
				rz |= type.compressed
				if v
					conv.DefaultStrength = v.int max 0
			  elseif name ~= "f"
				Conv.destpath = v
				.SingleFile(name)
				check (v) "Add a value, eg: --f=value"
			  else
				error "Unknown switch $s"

	rz |= type.plain
	check ((rz & type.actions).CountBits <= 1) ("Too many actions.")



function app.usage (|string|)
	return "Usage: ${.filename} File1 [File2...]
	options:
		-j			Convert to jeebox
		-b			Convert to jbin
		-c			Compress
		-c=0		Compress for very-fast decompress
		-s			Replace file in-place
		-p			Print to stdout
		-r			Just report types, otherwise do nothing
		-f=name 	Sets the filename of output
	
	debugging:
		-test		Tests if compression works on every file asked for!

	examples:
		jz -j A.xml						// xml to jeebox
		jz -c A.xml						// compress A.xml into A.xml.mz
		jz    A.txt.mz					// decompress A.txt.mz to A.txt
		jz -b A.box						// jeebox to jbin
		jz -b A.xml						// xml to jbin
"


main		
	|| action = .GetActions$
	if !app.args
		print .usage
		return 0
	
	for r in app.args
		|| f = r.file
		if f.IsDir
			"$f is a folder"
		  else
			conv.in = f
			if action is TestThem
				conv.TestOne()
			  else
				conv.Process(action)
			conv.End
	
	if (stderr.ok) and (!conv.done) and (action isnt report)
		"Nothing to do. All files already in destination format."



module Conv
	|string|		Data
	|file|			In
	|file| 			Out
	|date|			Start
	|float| 		Size
	|int|			Done
	|string|		DestPath
	||				DefaultStrength = mzlab.strong
	|| 				Speed = faststring()
	

	function End
		.in = nil
		.data = nil
		.start = nil
		printline .Speed.GetResult
	
	
	function TestOne // to test many
		require StdErr.ok
		expect (!.DestPath) ("Can't specify a dest-path!")
		|| Orig = .in
		.CompressOnly(false)
		require stderr.ok
		.in = .out
		.out = (.in + ".decomp").file
		.CompressOnly(true)
		require stderr.ok
		
		orig.CompareFile(Orig,Orig)
		Orig.delete
		.in.Delete
		.out.delete
		
	
	function Time (|string| Name)
		|| ago = .Start.ago
		|float| scale = 1MB
		if .data
			size = .data.Length
		|| speed = ""
		|| s    = ago.seconds
		|| s2   = (s*1000, s)(s < 0.01)
		|| unit = ("ms", "s")(s < 0.01)
		conv.speed <~ "    $Name: ${s2}$unit"
		if s
			conv.speed <~ "  (${Size/(scale*s)}MB/s)\n"
		
		
	function CompressOnly (|bool| Decomp)
		printline .out|string|
		|| dest = .out.out
		|| src = .in.in
		require src and dest
		.start = date() 
		if Decomp
			src.DecompressInto(dest)
			.size = dest.File.size
			.time("Decompress(streamed)")
		  else 
			.size = .in.size
			src.CompressInto(dest, DefaultStrength) 
			.time("Compress(streamed)")
	

	function Process (|Type| Dest)
		require .in.MustExist
		|| OrigSize = 0
		|| CmpFormat = .in.CompressionInfo(OrigSize)
		|| FileIsCompressed = CmpFormat!=""
		|type| Detected = FileIsCompressed * type.compressed // only read compressed at first
		if Dest&type.Actions
			++done			
			if (Dest is report) and CmpFormat
				"$.in is: ${OrigSize.strsize} compressed to ${.in.size.strsize} ($CmpFormat)"
				return
					
			.start = date()
			.data = .in.ReadAll(int.max, false)
			if (Dest is report) and .data == ""
				if StdErr.OK
					"$.in is empty"
				return
			.Time("Read ")
			if FileIsCompressed
				.start = date()
				.data = .data.Decompress(int.max)
				.time("Decompress")
		  else
			require FileIsCompressed == (dest isnt compressed)
			++ done
		.Out = .OutPath(dest).file
		
		ifn Dest&type.Actions
			.CompressOnly(FileIsCompressed)
			return
			
		.start = date.now
		|error| err
		|| parse = .data.ParseWithError(err) // no errors actually :)
		expect (parse  or  dest is report) ("File isn't parseable.")
		if parse
			.time("Parse")
		if !parse
			detected |= type.plain
		  elseif .data.IsJbin
			detected |= type.jbin
		  elseif parse.Find(@xml)
			detected |= type.xml
			if dest isnt report
				require parse.XMLToJeebox
		  else
			detected |= type.box

		if Dest is report
			"$.in is: ${detected.render}"
			return

		if (Detected.format != Dest.format)
			.Start = date.now
			if dest is box
				.data = parse.Render
			  else
				.data = parse.render_jbin
			.time("Render")

		if dest is compressed
			.start = date.now
			.data = .data.Compress(DefaultStrength)
			.time("Compress")
			
		if dest is stdout
			print .data
		  elseif .Out.data(.data)
			printline .out.path


	function OutPath (|type| dest,  |string|)
		if destpath
			return destpath
		
		if dest is selfreplace
			return .in
		|| ext = ""
		if dest is box
			ext = "box"
		  elseif dest is jbin
			ext = "jbin"
		rz = .in.RemoveExt("mz")
		if ext  and  rz isa "box" or "jbin"
			rz = rz.SetExt(ext)
		if dest is compressed
			rz = rz.AddExt("mz")
		  elseif (.in isa "mz") and rz.FileExists
			//"    (Adding '.back' to avoid file-overwrite.)"
			rz += ".back"
	
	
function file.CompressionInfo (|&int| Size=0, |string|)
	|| str = .Section(0, 32)
	if str == string.error
		return str
	|| mz = str.parse_jbin
	if mz == @tmp and "µz"
		|| arg = mz.last
		if arg != @arg
			rz = string.error
		  else
			|| s = arg.prev.int
			if size
				*size = s
			if !s
				rz = string.Error
			  elseif arg ~= "ro"
				rz = "ro"
			  else
				rz = "µz"
