#!/usr/local/bin/spd

app.usage = "Compress many files into one archive. Or decompress.

Pass just the archive and no files, to decompress.

Pass the archive and some files, to compress."


// todo:
	// why does it start with '/' when using 1 file?
	// corrupt mz files when decomp from my large test
	// chunk files
	// why are some errors created on large test
		// errors in large test should come with a file-path
	// large jbin viewer would be nice. Read from part of a file? Don't load entire thing.


main (|file| archive, |[file]| files)
	if files
		require archive.OpenEmpty
		using "Archiving `$archive`"
			archive.Archive(files, app.excludes)
	  else
		using "Unarchiving `$archive`"
			|| dir = app.cwd
			archive.Unarchive
			app.cwd = dir

function app.excludes (|[string]|)
	for s in .Switches
		if s.ArgName ~= "x"
			rz <~ s.ArgValue

module µzArchiver
	task Decompressor (stringreader.ParserCallBack)
		|compressionstats| Stats
		run
			require msg == @bin
			|| p = msg.parent
			|| path = p.name
			"	$path"
			msg.name.decompressinto(path.out, .stats)
			msg.name = "" // save RAM
			p.prev.remove

	helper FindTop (|[string]| self, |int|)
		|| a = self[0] #require
		for s in self
			rz ?= a.Length
			|| d = a.DiffAt(s)
			if d >= 0
				rz = rz min d

	helper AddFile (|jbin| j, |file| f, |int| n, |CompressionStats| stats)
		|| name = f[n...]
		"	$name"
		j.Enter(@tmp, name)
		j.AddComp(f.in, stats)
		j.exit(1)


	helper ArchiveSub (|jbin| self, |file| f, |int| n, |[string]| x,  |compressionstats| stats)
		require f.Visible
		if f globs x or f.name globs x
			"// Excluding: $f"
			return 
		if f.IsDir
			if f.IsLink
				"// Skipping link: $f"
				return 
			for c.files in f
				archivesub(self, c, n, x, stats)
		  else
			addfile(self, f, n, Stats)

	
function file.Unarchive
	|| in = .in$
	|| fol = (.TrimExt + ".decomp").file
	require fol.MakeDir and fol.DeleteAll(true) and app.cwd(fol)
	|| d = µzArchiver.Decompressor(in)
	in.CallBack = d
	in.ParseJbin
	d.Stats.Print(true) // why is it true both ways? is it always true?


function file.Archive (|[file]| files, |[string]| x)
	|jbin| j = jbin(@tmp, "jarc")
	|compressionstats| Stats
	j.File = self
	
	j.add(@str, "v1")
	j.Enter
	
	|| n = µzArchiver.FindTop(files)
	j.Tmp("files")
	
	for f in files
		µzArchiver.archivesub(j,f,n,x,stats)
	j.exit
	
	stats.print(True)

