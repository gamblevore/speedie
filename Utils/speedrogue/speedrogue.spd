#!/usr/local/bin/spd

// todo
	// fix room connection...no need connect to the same room
	// also delete rooms that can't connect
	// also some rooms should connect but aren't
	// fill genplayer and genmonster

module roguetype	// i could use a selector? i guess?
	|dictionary of message| all
	syntax access (|string| name, |message|)
		return .all[name]
	function door		(|message|): return .all["door"]
	function wall		(|message|): return .all["wall"]
	function floor		(|message|): return .all["floor"]
	function rock		(|message|): return .all["rock"]
	function corriwall	(|message|): return .all["corriwall"]
	function corridor	(|message|): return .all["corridor"]


role RogueObject (message)
class RogueCreature (RogueObject)
    render
		fs <~ "${.name} has ${..strength} STR and ${..health} HP. "


class RogueRoom
	|ivec4|   Size


datatype RogueCellState (byte)
	flags
		Visited
		Seen
		Glimpsed


role RogueCell	(message)
	contains RogueObject
	
	constructor (|message| parent, |int| x,  |message| Type)
		super.Constructor(parent, @tmp, x, type.name)
		.msg(@arg)
	
	function TermColor (|int|)
		return .first.Indent
	function Type (|message|)
		return roguetype.all[.name]	// The compiler can opt this? An ideal compiler would
	setter Type (|message|)
		.Name = Value.name	
	function Pos (|ivec2|)
		return (.position, .parent.position)
	function Draw 
		opt norefcounts
		|| t = .type.first
		Terminal <~ (t.name, .pos, t.indent)


module Info
	|message| 		Creatures
	|Message| 		RoomTypes
	|Message| 		CellTypes

module Map {
|[RogueCell]|	Data
|ivec2|			Size
|int64| 		Seed
|message|		MapState
|message| 		Level
|message|		Player

		

syntax access (|ivec2| s, |RogueCell|)
	if s inrange .size
		return .data[s.y * .size.x  +  s.x]

function Init (|ivec2| size)
	|| rock = roguetype.rock
	.size = size
	.MapState = Message()
	|| maplist = .MapState.msg(@tmp, "maps").msg(@arg)
	for i in 6
		|| map = maplist.msg(@tmp, "map")
		map <~ i+1
		for y in size.y
			|| row = map.GiveArg.msg(@tmp, "row").msg(@arg)
			row.Position = y
			for x in size.x
				RogueCell(row, x, rock)
	.LoadLevel(1)


function LoadLevel (|int| i)
	.Level = (.mapstate..maps)[i-1]
	.data.clear
	for row in .level.arg
		for cell in row.arg
			.data <~ cell
	// thats the level. Now what?
	

function IsRoomOK (|ivec4| i, |bool|)
	for p.rect in i
		require self[p].Type != roguetype.Floor
	return true

function OKSize (|ivec4|)
	for attempt in 1000
		|| RoomSize = .rndsize
		if .IsRoomOK(RoomSize)
			return RoomSize

function RndSize (|ivec4|)
	|| c1 = .size.rnd
	|int| w = random[5, 25, 1]+2
	|int| h = random[4, 15, 1]+2
	|| c2 = c1 + (w,h)
	if c2.x >= .size.x // reflect room size back inwards if too far
		c2.x = c1.x
		c1.x -= w
	if c2.y >= .size.y
		c2.y = c1.y
		c1.y -= h
	return (c1, c2)

function ivec4.EdgeLength (|int|)
	return .area - (self Â± 2).area

function ivec4.Edge (|int| where, |ivec4|)
	// no corners!
	|| W = .Width-2
	|| H = .Height-2
	while where >= 0 and w > 0 and h > 0
		if (where < W)		// bottom
			return (.x + where+1, .Y, 0, -1)
		where -= w

		if (where < H)		// right
			return (.X2-1, .y+where+1, 1, 0)
		where -= h

		if (where < W)		// top
			return (.x + where+1, .Y2-1, 0, -1)
		where -= w

		if (where < H)		// left
			return (.X, .y + where+1, 1, 0)
		where -= h
		
	
function Connect (|ivec2| p, |ivec2| d)
	|| first = self[p] #require
	|| Length = 1
	|roguecell| last
	|| d2 = d.yx
	|| door = roguetype.door, || floor = roguetype.floor, || cw = roguetype.corriwall
	|| rock = roguetype.rock, || corridor = roguetype.corridor, || wall = roguetype.wall
	while Length < 30
		p += d
		|| c = self[p] #require
		|| ctype = c.type
		ifn cType == rock or wall or Corridor
			exit
		last = c
		Length++
		c.Type = roguetype.Corridor
		with self[p+d2]
			if .type == Rock
				.type = cw
		with self[p-d2]
			if .type == Rock
				.type = cw
	
	if Length >= 2
		first.Type = door
	if length > 2
		last.Type = door
	  elseif length == 2
		last.Type = Floor


function CanConnect (|rogueroom| r, |ivec2| p, |ivec2| d, |bool| Coridoors=false,  |bool|)
	|| s = r.size
	|| hitwall = 1
	|| wall = roguetype.wall,   || rock = roguetype.rock,   || corr = roguetype.corridor
	
	for length in 30
		p += d
		|| c = self[p]$
		|| r2 = c.obj
		|| ct = c.type
		if ct == wall
			require hitwall++ <= 1
		if r2 and (r2 != r) and (ct == roguetype.Floor)
			return true
		require (ct == rock or wall) or (coridoors and ct == corr)


function ConnectRoom (|rogueroom| r)
	|| n = 5 * r.size.area/(25*15)
	|| needed = random[1, n, 1]|int|
	|| ToTest = r.size.EdgeLength
	for 1000
		|| Cell = r.size.Edge(Random[0, ToTest])
		if .CanConnect(r, cell.xy, cell.x2y2)
			.Connect(cell.xy, cell.x2y2)
			needed--
			require needed > 0
//		else // seems that some good positiosn ARE being tested, but are failing. Can't see why?
// everything seems OK?'
//			self[cell.xy].Type = roguetype.gate


function ivec2.isCornerOf (|ivec4| R, |bool|)
	r-=(0,0,1,1)
	return self == R.x1y1 or R.x1y2 or R.x2y1 or R.x2y2 // fix later

function GenRoom (|[rogueroom]| rooms)
	|| RoomSize = .oksize #require
	|| room = RogueRoom(roomsize)
	rooms <~ room
	for P.rect in RoomSize
		|| cell = self[p]
		cell.obj = room
		|| type = RogueType.Floor
		if !RoomSize.contains(P, 1)
			if cell.type != RogueType.wall
				Type = RogueType.wall
			  elseif p.IsCornerOf(Roomsize)
				0
			  else
					type = RogueType.floor
		cell.Type = type
	
	
function GenMap
	|[rogueroom]| 	Rooms
	for i in 10
		.GenRoom(rooms)
	for r in Rooms
		.ConnectRoom(r)


function GenPlayer
	|| P = info.Creatures..classes$.rand$
	.player = p.Copy

	
function GenMonster
	|| CanGen = 18th
	|| lim = 32
	for c in .data // all cells
		|| t = c.type
		if t..walkable and CanGen[]
			c.GenMonster
			require --lim > 0

function Roguecell.AllowedMonsters (|[roguecreature]|)
	|| L = map.level
	|| level_num = L[0].int
	
	
function Roguecell.GenMonster
	// OK so... So we wanna gen a monster
	// We wanna gen a monster. but I don't know how? howwww??????
	// so... how? lets get a random monster?
	|| Allowed = .AllowedMonsters()


function info.Load (|int64| Seed, |bool|)
	seed := date.now & 0xffff
	Random.shared.seed = seed
	map.seed = seed
	app.CWD = app.Path.parent
	.Creatures = "Creatures.txt".file.parse
	.roomtypes = "Rooms.txt".file.parse
	.CellTypes = "Cells.txt".file.parse
	roguetype.all = .CellTypes.Dict

	for s in .CellTypes
		|| col = s..color
		|| f = s.first
		if col ~= "white"
			f.Indent = Terminal.white
		if col ~= "red"
			f.Indent = Terminal.red
	
	return StdErr.ok


function Run (|bool| Splash)
	.init(terminal.size)
	.GenMap
	.GenPlayer
	.GenMonster
	if Splash
		.splash
	while .Running
		.DetectVisibility
		.DrawMap
		Terminal.Display


function Running (|bool|)
	return true


function DetectVisibility
	
	
function DrawMap
	for i in .size
		self[i].draw
	terminal <~ ("Map: " + .Seed.Render, 30, 0)


function Splash
	|| scale = Terminal.w|float| / Terminal.h|float|
	|| h = 24

	for secs in 10s
		Terminal.DrawRect((0, 0, terminal.w, h))
		for i in 5.0
			|| Title = " Mini Rogue ".Rotate(i + secs*3)
			|| f = i*1.234 + secs*(0.33+i*0.05)
			|| x = 1+((1.5*f/scale).bounce*(Terminal.w-(title.length+2)))
			|| y = 1+f.bounce*(h-2)
			Terminal <~ (Title, x, y, terminal.Red+i)

		|| title2 = "<Mini-Rogue>"
		|| x2 = (terminal.w - title2.length) / 2
		Terminal <~ (title2, x2, 0, Terminal.Red)
		Terminal <~ (file://HeartLogo.txt , 32, 10, terminal.red)
		Terminal.Display
}
	
main
	|| a = app[0]
	if info.load(a.int)
		map.run(!a)

