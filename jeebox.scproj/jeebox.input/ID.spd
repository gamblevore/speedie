

class StringShared (string)
	linkage
		wrapper
		cpp_class JB_StringShared
		cpp_part Str

	cpp_refs
		Disturbs		nil
	
	constructor (|string| data)
		cpp_wrapper JB_Str_Clone

	default			""
	false			""


class MessageID (stringshared)				// now is usefully used! :D
	linkage
		cpp_part ID
	
	default NIL
	false	NIL
	contains object
	||					Obj
	|uint64| 			ID
	|Syntax|			Func
	|MessageID?| 		Next
	
	render
		fs <~ .func.name
		fs <~ "@"
		if .length
			fs.AppendQuotedEscape(self)
			
	syntax cast (|bool|)
		disabled "Do you mean .length > 0  or  self != nil"
	
	constructor (|string| Name, |Syntax| Fn, |uint64| ID=0)
		super.constructor(name)
		.Func = fn
		.obj = nil               // c++ generator fails otherwise
		.ID = ID

	constructor
		cpp_part Empty
		super.constructor("")
		.Func = @arg
		.ID = 0
		
		
	function Msg (|message| parent, |message|)
		return Message(parent, .func, -1, .name, .name.length)

	module
		function IDSorter (SorterComparer)
			opt norefcounts
			|| aa = a|MessageID|,   || bb = b|MessageID| 
			
			|| diff = aa.ID  -  bb.ID
				return diff > 0							// more frequent should have lower lengths
				
			return aa|uint64| < bb|uint64|
			// Now what?



struct MessageIDList
	|messageID?| First
	|messageID?| Last
	|int| 		 Count

	iterator
		|| curr = .first
		while curr != nil
			yield curr
			curr++
			if curr == .first
				debugger
				exit

	function NewID (|string| name, |syntax| func=@str, |messageid|)
		rz = MessageID(name, func, ++.count)
		self <~ rz
		
		
	syntax append (|messageid| i)
		|| l = .last
		if l != nil
			l.next = i
		  else
			.first = i
		.last = i


/*function Message.Identify (|&Messagecompressor| d,  |[messageid]| table, |uint|)
	opt NoRefCounts
	|| s = self
	|| Count = 0
	while s
		|| name = s.name
		|| Found = d.makeplace(s)|&messageID|
		|| ID = *found
		if ID != nil
			ID.mTag++
		  else
			rz += name.Length				// a direct result within self
			id = MessageID(name, s.func, 0)
//			id.Position = Count++
			*found = id
			if table != nil
				table <~ id
		s.Name = id
		s = s.flatnext


struct MessageDecompressor
	linkage:cpp_part Mxpd
	|(&Message--)?|					End
	|(&Message--)?|					Curr
	|(&Message--)?|					Table

	helper Allocate (|bool|)
		require StdErr.ok
		
		|| pos = .Curr - .Table
		|| Amount = (pos*2) max 4K
		|| rz = Memory.realloc(.table, Amount * platform.PointerBytes)|&message|
			
		expect rz ("jbin decompressor can't allocate")
		.Table = rz
		.Curr = rz + pos
		.End = rz + Amount
		return true
	
	syntax append (|Message| New, |bool|)
		|| c = .Curr
		if c >= .End
			require .Allocate
			c = .curr
		*c++ = New
		.Curr = c
		return true
	
	destructor
		memory.Free(.Table)
		.End = nil
		.Table = nil
		.Curr = nil
	


struct MessageCompressor
	linkage:cpp_part MCmp
	|(dictionary of messageID)[64]| D
	|uint|			Position
	
	function MakePlace (|message| m, |&byte|)
		opt norefcounts
		|| fn = m.func
		if fn|int| < 64
			|| pl = &.d[fn]
			|| v = (*pl) init dictionary()
			return v.MakePlace(m.name)|&byte|

	function Find (|message| m, |MessageID|)
		opt norefcounts
		|| where = .MakePlace(m)|&messageID|
			|| f = *where
				return f
			*where = MessageID(m.name, m.func, .Position++)
		return nil
		
	destructor

*/
