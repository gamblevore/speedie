

// use a message... as a dictionary!!



// why would a conf-file be so big?
function file.Config (|int| lim = 1MB,  |config|)
	opt norefcounts
	if .exists
		rz = .parse(lim)|config|
	rz ?= message()
	rz.obj = self


role config (message)
	linkage
		pragma noearlyfree
	iterator
		|| C = .conffirst
		while (C)
			yield C
			C++

	syntax cast (|string|)
		cpp_part AsString
		if self
			return .Value
			
	syntax cast (|int64|)
		cpp_part AsInt
		return .int
			
	syntax cast (|f64|)
		cpp_part AsFloat
		return .float
	
	syntax cast (|MessageTable|)
		cpp_part AsTable
		return .Dict(true)
	
	function Save (|bool|)
		|| f = .path
			|| r = .render
			|| p = r.parse
				return f.smartdata(r)
			StdErr.pop
	
	function Path (|file|)
		return .obj as file
	
	helper ConfFirst (||)
		|| l = .confarg
			return l|message|.first
			
	module
		function ConfigPath (|string| path,  |string|)
			|| f = path[]
			if f == '~'
				return path.pathfix
			if f == '/'
				return path
			if !f
				return app.FileName.lowercase + ".box.pref"	
			return file.Prefs(path)

		function Create (|string| path,  |config|)
			return .ConfigPath(path).file.config


extend message
	function ConfArg (|config|)
		opt norefcounts
		if self == @arg or nil
			return self
		|| w = (.last, .next)(self == @tmp)
		if w == @arg
			return w

	function SyntaxAccess (|string| key, |syntax| Needed, |string| DefaultName="", |config|)
		opt norefcounts
		description "Creates the correct child type if not found" 
		|| found = .SyntaxAccess(key)
		if found == Needed
			return found
		|| arg = .confarg
		if found
			error (found)
		found = arg.msg(@tmp, key)
		return found.msg(Needed, DefaultName)

	function SyntaxAccess (|string| key, |bool| Err=false, |config|)
		cpp_part GetConf
		opt norefcounts
		|| arg = .confarg
		for item in arg
			if item ~= key
				|| f = item.first
					return f
				error (item, "Value missing in config item")
/				item.remove // cleaner to just remove it. Must have a value. Its a key/value system!
							// and the values have types, so we can't just create one, without knowing
							// what type is needed.
				return nil
		if err
			error (self, key + " not found.")
	
	
	function Value (|string|)
		if self
			if self == @tmp and self in @arg
				return .firstname
			if self != @arg
				return .name
			return .FirstName
