
// merging compressor. NOT FINISHED. WORK IN PROGRESS.
// GOAL
// Just... share strings, and IDs, the rest can be chucked.

helper StringReader.HollyPart (|message| root, |stringreader|)
	|| s = .NextMsg(root)
		if s == @bin
			s.name = s.name.Decompress
		rz = s.name.Stream()
		if !rz.HasAny
			rz = nil


function String.HollyDecode (|message|)
	return .Stream.hollydecode

function StringReader.HollyDecode (|message|)
	require .ExpectJbin
	|| root    = .NextMsg(@tmp, "ћ")
	|| Count = .nextmsg(root).int
	|| Strings = .HollyPart(root)
	|| Types   = .HollyPart(root)
	|| lengths = .HollyPart(root)
	|| Tree    = .HollyPart(root)
		|[messageid]| table = []
		table <~ (messageID(), Count)
		rz = .HollyDecodeSub(strings!, types!, lengths!, tree!, table!)



helper StringReader.HollyDecodeSub (|StringReader| Str,  |StringReader| Ty,  |StringReader| Ln,  |StringReader| Tree,  |[messageid]| table,  |message|)
	opt norefcounts

	|| Found = 0
	while Ty.HasAny
		|| fn = Ty.Byte|syntax|						#expect (self, "Bad syntax")
		(Found < table.Length)						#expect	(self, "Too many IDs")
		(ln.HasAny)									#expect	(self, "Not enough lengths")
		table[Found++] = MessageID(Str.str(Ln.Small), fn, found)
	(Found == table.Length)							#expect (self, "Too few IDs")
	
	|message| parent
	Found = 0
	while Tree.HasAny
		|| Raw = Tree.Small - 8
		if Raw < 0
			parent = parent.Upward(9+Raw)
			if !parent
				!(tree.hasany)						#check (self, "Went up too far")
			continue
		|| ID = raw>>1
			ID = found - ID
		  else
			ID = found++
		|| MID = table[ID]							#expect (self, "Bad ID")
		|| Down = mid.msg(parent)
		if Raw & 1
			parent = Down
			rz := down



module ћ     ////  Should keep entire table of every item... and update the IDs to the latest position.
			 ////  Shrinks the offset size!
	
	function Encode (|message!| root, |jbin!| j)
		|(dictionary of messageID)[64]| D
		j <~ _JbinHeader
		j.enter(@tmp, "ћ")
		|| tree = FastString()
		|| lengths = FastString()
		|| types = FastString()
		|| strings = faststring()
		|| Count = .EncodeSub(root, tree, lengths, types, strings, &d[0])
		j.AddInt(count)
		j.addcomp(strings, 1)
		j.addcomp(types,   1)
		j.addcomp(lengths, 0)
		j.addcomp(Tree,    0)
		j.exit
		for i in –count d
			d[i] = nil


	helper MakePlace (|message| m, |&(dictionary of messageID)| D, |&messageID|)
		opt norefcounts
		|| pl = &d[(m.func)|int| & 63]
		|| v = (*pl) init dictionary()
		return v.MakePlace(m.name)|&messageID|


	helper EncodeSub (|Message| s, |FastString| tree, |FastString| lengths, |FastString| types, |FastString!| strings, |&(dictionary of messageID)| D, |int|)
		opt NoRefCounts
		while s
			|| Where = .MakePlace(s, d)
			|| depth = 0
			|| Next = s.FlatNextDepth(depth)
			
			|| Back = 0
			|| Found = Where[0]
				Back = rz - found.id
			  else
				|| id = MessageID(s, rz++),  *where = id				// (internal)
				types <~ s.func											// TYPES
				strings <~ id											// STRINGS
				lengths.AppendSmall(id.length)							// LENGTHS
		
			|| DOWN = depth max 0										// 1 or 0
			tree.AppendSmall(8 + (Back<<1) + DOWN)						// DOWN TREE
			if depth < 0
				depth = -depth
				while depth												// UP TREE
					|| item = depth min 8
					tree <~ (item-1)|byte|
					depth -= item
			s = next
	
	
	helper message.HollyEncode (|string|)
		|| fs = faststring()
		ћ.encode(self, fs)
		return fs
	
	

	function TestHolly (|file| input)
		require input.MustExist
		|| p = input.path
		if input isa "jbin"
			p = input.trimext
		|| out = p.AddExt("hol").file
		|| pp = input.parse
		|| sout = out.out
		if pp and sout
			ћ.encode(pp, sout)
			sout = nil
			|| back = out.in!.HollyDecode
				message.treecompare(pp, back)
