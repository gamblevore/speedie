
// merging compressor. NOT FINISHED. WORK IN PROGRESS.
// GOAL
// Just... share strings, and IDs, the rest can be chucked.

helper StringReader.HollyPart (|message| root, |stringreader|)
	|| s = .NextMsg(root, @nil)
		if s == @bin
			s.name = s.name.Decompress
		rz = s.name.Stream()
		if !rz.HasAny
			rz = nil


function StringReader.Holly (|message|)
	|| root    = .NextMsg(@tmp, "ћ")
	|| Strings = .HollyPart(root)
	|| Types   = .HollyPart(root)
	|| lengths = .HollyPart(root)
	|| Tree    = .HollyPart(root)
		|[messageid]| table = []
		table <~ (messageID(), Types!.hInt)
		rz = .HollyDecode(strings!, types, lengths!, tree!, table!)



helper StringReader.HollyDecode (|StringReader| Str,  |StringReader| Ty,  |StringReader| Ln,  |StringReader| Tree,  |[messageid]| table,  |message|)
	opt norefcounts

	|| Found = 0
	while Ty.HasAny
		|| fn = Ty.Byte|syntax|						#expect (self, "Bad syntax")
		(Found < table.Length)						#expect	(self, "Too many IDs")
		(ln.HasAny)									#expect	(self, "Not enough lengths")
		table[Found++] = MessageID(Str.str(Ln.Small), fn, found)
	(Found == table.Length)							#expect (self, "Too few IDs")
	
	Tree.Small
	|| TM = table[0]								#expect (self, "No nodes found")
	|| parent = TM.msg
	Found = 0
	rz = parent
	while Tree.HasAny
		|| Raw = Tree.Small - 8
		if Raw < 0
			parent = parent.Upward(-Raw)			#expect (self, "Went up too far")
			continue
		|| ID = raw>>1
		if ID
			ID = found - ID
		  else
			ID = found++
		|| MID = table[ID]							#expect (self, "Bad ID")
		|| Down = mid.msg(parent)
		if Raw & 1
			parent = Down



struct ћ
	|(dictionary of messageID)[64]| D
	
	function Compress (|message!| root, |int| mode, |jbin| fs)
		fs <~ _JbinHeader
		fs.enter(@tmp, "ћ")
		|| tree = FastString()
		|| lengths = FastString()
		|| types = FastString()
		|| Strings = .Encode(root, tree, lengths, types)		
		fs.addcomp(strings, mode&1)
		fs.addcomp(types,   mode&2)
		fs.addcomp(lengths, mode&4)
		fs.addcomp(Tree,    mode&8)
		fs.exit
		for i in –count .d
			.d[i] = nil


	function MakePlace (|message| m, |&messageID|)
		opt norefcounts
		|| pl = &.d[(m.func)|int| & 63]
		|| v = (*pl) init dictionary()
		return v.MakePlace(m.name)|&messageID|


	function Encode (|Message| s,  |faststring| tree, |faststring| lengths, |faststring| types,  |faststring!|)
		opt NoRefCounts
		rz = FastString()
		|| Table = 0
		while s
			|| depth = 0
			|| next = s.FlatNextDepth(depth)
			while depth < 0												// GO UP TREE
				|| item = -depth min 8
				tree <~ (item-1)|byte|
				depth += item
			
			|| Found = .MakePlace(s)
			|| Back = 0
			ifn found[0]
				|| id = MessageID(s, table++),  *found = id				// (internal)
				types <~ s.func											// TYPES
				rz <~ id												// STRINGS
				lengths.AppendSmall(id.length)							// LENGTHS
			  else
				Back = table - found.id
		
			tree.AppendSmall(Back<<1 + depth)							// TREE
			s = next
	
	
	helper message.Holly (|int| Mode=-1, |string|)
		|ћ| Hol
		|| fs = jbin()
		Hol.Compress(self, Mode, fs)
		return fs
	
	
	module
		function TestHolly (|file| input)
			return 
			require input.MustExist
			|| p = input.path
			if input isa "jbin"
				p = input.trimext
			|| out = p.addext("hol").file 
			|| back = p.addext("back").file
			input.file.parse.Holly(out)
			"${input.size.strsize} compressed to ${out.size.strsize}"
			|| msg = out.in.holly()				#require
			msg.renderjbin(back.out)
			if back.CompareFile(input, input)
				printline "Holly Tested OK: " + input

